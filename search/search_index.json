{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Keck Planet Finder (KPF) Instrument Status KPF has been commissioned on sky, and is available for use. Many aspects of the instrument are still being optimized and the long term stability is still under evaluation. Short term stability looks excellent (exceeding the 50 cm/s target spec within a night) and we expect measures of the long term RV precision to become available as the DRP evolves. See KPF Status Summary and Blog for the latest details on the instrument's operational status broken down by subsystem. A detailed summary of the instrument status was presented at the September 2023 Keck Science Meeting. The slides from that presentation are available in PDF format . Instrument Description The Keck Planet Finder (KPF) is a \ufb01ber-fed, high-resolution, high-stability cross dispersed, spectrometer designed to characterize exoplanets via Doppler spectroscopy with a goal of a single measurement precision of 0.3 m/s or better. KPF covers a wavelength range of 445 nm to 870 nm over green and red channels. KPF consists of 3 independant spectrographs: The primary science spectrograph described above which is designed to be highly stable and has both a green and red arm. The spectrograph optical bench is made from low expansion Zerodur and is kept is a temperature stabilized environment. A Calcium H&K spectrograph which gets the light blueward of the main science spectrograph and is used to simultaneously measure stellar activity using the Ca H&K lines. The exposure meter spectrograph which gets a portion of the science light and is used to measure the flux level during long exposures of the primary science detectors. The exposure meter both measures the time weighted flux midpoint of each exposure, and can also be used to terminate an exposure at a specified flux level. All three spectrographs are fed by optical fiber from the Fiber Injection Unit (FIU) which sits on the Keck I AO bench. The light entering the FIU is not AO corrected, but is fed off a fast tip tilt mirror which is used to maintain the target star's position on the science fiber within 50 mas rms of the fiber center. Performance of the tip tilt loop is to be confirmed during commissioning. During observations, the spectrograph can be fed with light from a simultaneous calibration fiber. This places calibration light alongside science and sky spectra in the pseudo-slit. The calibration light is fed from the calibration bench which contains several calibration sources. In addition to the simultaneous calibration light, the calibration bench can be configured to feed light up to the FIU and through the science and sky fibers in order to bring cal light in to the science and sky portions of the pseudo-slit. The system overview diagram showing the relationships between the different subsystems of the instrument. KPF's Zerodur optical bench during integration at the Space Sciences Lab at UC Berkeley. The echelle grating can be seen at the upper right.","title":"KPF Home"},{"location":"#keck-planet-finder-kpf","text":"","title":"Keck Planet Finder (KPF)"},{"location":"#instrument-status","text":"KPF has been commissioned on sky, and is available for use. Many aspects of the instrument are still being optimized and the long term stability is still under evaluation. Short term stability looks excellent (exceeding the 50 cm/s target spec within a night) and we expect measures of the long term RV precision to become available as the DRP evolves. See KPF Status Summary and Blog for the latest details on the instrument's operational status broken down by subsystem. A detailed summary of the instrument status was presented at the September 2023 Keck Science Meeting. The slides from that presentation are available in PDF format .","title":"Instrument Status"},{"location":"#instrument-description","text":"The Keck Planet Finder (KPF) is a \ufb01ber-fed, high-resolution, high-stability cross dispersed, spectrometer designed to characterize exoplanets via Doppler spectroscopy with a goal of a single measurement precision of 0.3 m/s or better. KPF covers a wavelength range of 445 nm to 870 nm over green and red channels. KPF consists of 3 independant spectrographs: The primary science spectrograph described above which is designed to be highly stable and has both a green and red arm. The spectrograph optical bench is made from low expansion Zerodur and is kept is a temperature stabilized environment. A Calcium H&K spectrograph which gets the light blueward of the main science spectrograph and is used to simultaneously measure stellar activity using the Ca H&K lines. The exposure meter spectrograph which gets a portion of the science light and is used to measure the flux level during long exposures of the primary science detectors. The exposure meter both measures the time weighted flux midpoint of each exposure, and can also be used to terminate an exposure at a specified flux level. All three spectrographs are fed by optical fiber from the Fiber Injection Unit (FIU) which sits on the Keck I AO bench. The light entering the FIU is not AO corrected, but is fed off a fast tip tilt mirror which is used to maintain the target star's position on the science fiber within 50 mas rms of the fiber center. Performance of the tip tilt loop is to be confirmed during commissioning. During observations, the spectrograph can be fed with light from a simultaneous calibration fiber. This places calibration light alongside science and sky spectra in the pseudo-slit. The calibration light is fed from the calibration bench which contains several calibration sources. In addition to the simultaneous calibration light, the calibration bench can be configured to feed light up to the FIU and through the science and sky fibers in order to bring cal light in to the science and sky portions of the pseudo-slit. The system overview diagram showing the relationships between the different subsystems of the instrument. KPF's Zerodur optical bench during integration at the Space Sciences Lab at UC Berkeley. The echelle grating can be seen at the upper right.","title":"Instrument Description"},{"location":"KPFTranslator/","text":"KPF Translator Most of KPF operations are controlled via the KPF Translator which is composed of Python code, which interacts with the underlying KTL keywords to automate various tasks. Each script is actually a Python class which is invoked by an execute() method which itself calls the pre_condition() , perform() , and post_condition() methods. This three-part structure allows the script to check that the system is ready for the action to be performed, then execute the action, then confirm a successful execution. These scripts can also be invoked via a command line interface to the underlying python and are used for everything from small, atomic actions which might require only a single KTL keyword write to execute, to large scripts which need significant flow control such as executing a science observation at night -- including configuring the instrument, waiting for the telescope and tip-tilt system to acquire the target, executing the specified exposures, and finally performing clean up actions. Detailed documentation on each translator script can be found in the scripts section of this documentation.","title":"Instrument Software"},{"location":"KPFTranslator/#kpf-translator","text":"Most of KPF operations are controlled via the KPF Translator which is composed of Python code, which interacts with the underlying KTL keywords to automate various tasks. Each script is actually a Python class which is invoked by an execute() method which itself calls the pre_condition() , perform() , and post_condition() methods. This three-part structure allows the script to check that the system is ready for the action to be performed, then execute the action, then confirm a successful execution. These scripts can also be invoked via a command line interface to the underlying python and are used for everything from small, atomic actions which might require only a single KTL keyword write to execute, to large scripts which need significant flow control such as executing a science observation at night -- including configuring the instrument, waiting for the telescope and tip-tilt system to acquire the target, executing the specified exposures, and finally performing clean up actions. Detailed documentation on each translator script can be found in the scripts section of this documentation.","title":"KPF Translator"},{"location":"KPFvsHIRES/","text":"Comparing KPF to HIRES This page attempts to compare KPF and HIRES for users who may be wondering which instrument they should propose for. Fundamentally HIRES is a more flexible instrument with selectable grating angles to control the wavelength coverage and selectable slits which allow the user to trade off throughput against spectral resolution while KPF is a fixed format spectrograph with a fixed input fiber. HIRES also has a wider spectral coverage than KPF and even includes the option to change the internal optics to optimize either blue or red sensitivity. Though KPF has the Calcium H&K spectrograph, a dedicated arm to examine the 382-402 nm wavelength range around the Ca H&K lines. KPF, on the other hand, has higher spectral resolution even though it has a larger entrance aperture on sky and so it may be more sensitive for use cases which need that combination. Of course, KPF is also highly stabilized and is optimized for precision radial velocity measurements. Summary Table Comparison KPF HIRES Optical Input 1.14 arcsec octagonal fibers for science and sky (fixed format) Selectable deckers and slits for different sky projections (e.g., B5 = 0.87 x 3.5 arcsec) Wavelength Coverage Fixed format: 445-870 nm (high-res) 382-402 nm (med-res) ~300-1000 nm in an adjustable format (moving the spectral format across detector) Resolving Power R=98k (445-870 nm) depends on slit e.g. R=49k for 0.86 arcsec-wide slit R=80k for 0.40 arcsec-wide slit Throughput (sky to CCD) ~8-10% peak-of-blaze (measured) 5-6% peak-of-blaze for B5-B1 deckers (measured) Doppler Precision 0.5 m/s noise floor (req.) 0.3 m/s (goal) ~2 m/s systematic noise floor Doppler Speed ~8-10x faster than HIRES Limited by need for high SNR to model iodine spectrum","title":"KPF vs. HIRES"},{"location":"KPFvsHIRES/#comparing-kpf-to-hires","text":"This page attempts to compare KPF and HIRES for users who may be wondering which instrument they should propose for. Fundamentally HIRES is a more flexible instrument with selectable grating angles to control the wavelength coverage and selectable slits which allow the user to trade off throughput against spectral resolution while KPF is a fixed format spectrograph with a fixed input fiber. HIRES also has a wider spectral coverage than KPF and even includes the option to change the internal optics to optimize either blue or red sensitivity. Though KPF has the Calcium H&K spectrograph, a dedicated arm to examine the 382-402 nm wavelength range around the Ca H&K lines. KPF, on the other hand, has higher spectral resolution even though it has a larger entrance aperture on sky and so it may be more sensitive for use cases which need that combination. Of course, KPF is also highly stabilized and is optimized for precision radial velocity measurements.","title":"Comparing KPF to HIRES"},{"location":"KPFvsHIRES/#summary-table","text":"Comparison KPF HIRES Optical Input 1.14 arcsec octagonal fibers for science and sky (fixed format) Selectable deckers and slits for different sky projections (e.g., B5 = 0.87 x 3.5 arcsec) Wavelength Coverage Fixed format: 445-870 nm (high-res) 382-402 nm (med-res) ~300-1000 nm in an adjustable format (moving the spectral format across detector) Resolving Power R=98k (445-870 nm) depends on slit e.g. R=49k for 0.86 arcsec-wide slit R=80k for 0.40 arcsec-wide slit Throughput (sky to CCD) ~8-10% peak-of-blaze (measured) 5-6% peak-of-blaze for B5-B1 deckers (measured) Doppler Precision 0.5 m/s noise floor (req.) 0.3 m/s (goal) ~2 m/s systematic noise floor Doppler Speed ~8-10x faster than HIRES Limited by need for high SNR to model iodine spectrum","title":"Summary Table"},{"location":"afternoonsetup/","text":"Afternoon Setup The afternoon setup process for the instrument itself is minimal. Calibrations are automated, so unless you have very special requirements for your observation (if so please contact the Staff Astronomer supporting your night in advance), then observers will not need to execute any calibrations. Prior to starting observing, observers should run: KPF Control Menu --> Start KPF GUIs from the background menu (or kpfStartUp from the command line on any KPF machine). This will: Configure the output directories Set the observer names based on the telescope schedule Start the KPF GUIs This can be run at any time prior to observing. If automated calibrations are in progress, this may take several minutes as certain operations can only be done while the detectors are not exposing. Observers should use the afternoon to prepare Observing Blocks (OBs) and their star list if they have not done so already. Start of Night KPF does, however, need to be configured properly at the start of the night. There is a procedure which should be run only after the Observing Assistant (OA) has selected KPF as the instrument and after automated afternoon calibrations are complete. It is important that this not be run while other instruments are observing. To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will: Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Confgure the tip tilt loop gain to its default setting","title":"Afternoon Setup"},{"location":"afternoonsetup/#afternoon-setup","text":"The afternoon setup process for the instrument itself is minimal. Calibrations are automated, so unless you have very special requirements for your observation (if so please contact the Staff Astronomer supporting your night in advance), then observers will not need to execute any calibrations. Prior to starting observing, observers should run: KPF Control Menu --> Start KPF GUIs from the background menu (or kpfStartUp from the command line on any KPF machine). This will: Configure the output directories Set the observer names based on the telescope schedule Start the KPF GUIs This can be run at any time prior to observing. If automated calibrations are in progress, this may take several minutes as certain operations can only be done while the detectors are not exposing. Observers should use the afternoon to prepare Observing Blocks (OBs) and their star list if they have not done so already.","title":"Afternoon Setup"},{"location":"afternoonsetup/#start-of-night","text":"KPF does, however, need to be configured properly at the start of the night. There is a procedure which should be run only after the Observing Assistant (OA) has selected KPF as the instrument and after automated afternoon calibrations are complete. It is important that this not be run while other instruments are observing. To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will: Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Confgure the tip tilt loop gain to its default setting","title":"Start of Night"},{"location":"agitator/","text":"","title":"Agitator"},{"location":"cahk/","text":"Calcium H&K Spectrometer A separate small spectrometer is used to monitor the Ca H & K lines for stellar activity that could mimic Doppler shifts. A major advantage of this approach is that the KPF spectrometer does not need to cover an increased bandpass blueward to 390 nm, and can stop at 443 nm (the Doppler information is reduced for G and K stars at bluer wavelengths owing to the significantly lower flux). This approach has important advantages with respect to optical coating bandpasses and efficiency, as well as the required detector size. The Calcium H & K spectrometer is a simple system (VPH-based with doublet lenses for collimator and camera), and is fiber fed via a UV-enhanced fiber (such as CeramOptec UVNS). Light will be injected into this fiber by the FIU, to captrue this light before major UV absorption losses occur within the long fiber run.","title":"Ca H&K Spectrograph"},{"location":"cahk/#calcium-hk-spectrometer","text":"A separate small spectrometer is used to monitor the Ca H & K lines for stellar activity that could mimic Doppler shifts. A major advantage of this approach is that the KPF spectrometer does not need to cover an increased bandpass blueward to 390 nm, and can stop at 443 nm (the Doppler information is reduced for G and K stars at bluer wavelengths owing to the significantly lower flux). This approach has important advantages with respect to optical coating bandpasses and efficiency, as well as the required detector size. The Calcium H & K spectrometer is a simple system (VPH-based with doublet lenses for collimator and camera), and is fiber fed via a UV-enhanced fiber (such as CeramOptec UVNS). Light will be injected into this fiber by the FIU, to captrue this light before major UV absorption losses occur within the long fiber run.","title":"Calcium H&amp;K Spectrometer"},{"location":"calbench/","text":"","title":"Calibration Bench"},{"location":"dataformat/","text":"Because KPF contains many detectors, but they are all synchronized in time, the raw data is immediately combined in to a \"Level 0\" (L0) multi-extension FITS file by the kpfassemble dispatcher. Most users will want to use that L0 data for analysis or inspection. Raw Data Each detector writes data to a separate output directory and kpfassemble will collect them from these to generate the L0 file. This is a relatively quick process, typically the L0 file is written a few seconds after the component raw data are available on disk. As mentioned on the detectors page, the Green and Red detectors have 32 bit ADCs and thus the pixel data do not fall on the usual 0-65535 range you may be used to. L0 Data The L0 data is a multi extension FITS file consisting of the following HDUs: HDU # HDU Name Notes 0 PRIMARY Header only, no image data 1 GREEN_AMP1 Green image data 2 GREEN_AMP2 Green image data 3 RED_AMP1 Red image data 4 RED_AMP2 Red image data 5 CA_HK Ca H&K image data 6 EXPMETER_SCI Table of processed exposure meter spectra 7 EXPMETER_SKY Table of processed exposure meter spectra 8 GUIDER_AVG The average guider image over the duration of the exposure 9 GUIDER_CUBE_ORIGINS Table of telemetry from the tip tilt system 10 TELEMETRY Table of instrument telemetry This can change depending on the composition of the science observation. For example, if the Ca H&K detector was not triggered, that extension would not be used.","title":"Data Format"},{"location":"dataformat/#raw-data","text":"Each detector writes data to a separate output directory and kpfassemble will collect them from these to generate the L0 file. This is a relatively quick process, typically the L0 file is written a few seconds after the component raw data are available on disk. As mentioned on the detectors page, the Green and Red detectors have 32 bit ADCs and thus the pixel data do not fall on the usual 0-65535 range you may be used to.","title":"Raw Data"},{"location":"dataformat/#l0-data","text":"The L0 data is a multi extension FITS file consisting of the following HDUs: HDU # HDU Name Notes 0 PRIMARY Header only, no image data 1 GREEN_AMP1 Green image data 2 GREEN_AMP2 Green image data 3 RED_AMP1 Red image data 4 RED_AMP2 Red image data 5 CA_HK Ca H&K image data 6 EXPMETER_SCI Table of processed exposure meter spectra 7 EXPMETER_SKY Table of processed exposure meter spectra 8 GUIDER_AVG The average guider image over the duration of the exposure 9 GUIDER_CUBE_ORIGINS Table of telemetry from the tip tilt system 10 TELEMETRY Table of instrument telemetry This can change depending on the composition of the science observation. For example, if the Ca H&K detector was not triggered, that extension would not be used.","title":"L0 Data"},{"location":"detectors/","text":"Overview and Exposure Timing KPF utilizes 5 detectors during normal science operations. Two science detectors (green and red) sit on the main spectrograph bench in the facility basement and record the science spectrum which is used to calculate radial velocities. The Ca H&K Spectrograph is an independant optical system fed by a short fiber which runs from the FIU to a nearby echelle spectrograph which contains the third science detector. The exposure meter is another independent spectrograph which sits in the basement and contains the forth science detector. The fifth detector used during science operations is the CRED2 in the FIU and obtains fast frame rate images used to run the tip tilt system. Because precision radial velocity measurements require exquisite timing, the red and green detectors must have their exposures synced up. To do this, KPF uses a timed shutter on their common light path (before the dichroic splits the light). This is the \"Scrambler Timed Shutter\". As a result, the red and green cameras are not triggered independently. Instead the KPF software takes a single set of exposure parameters and triggers each camera to begin an exposure, then opens and closes timed shutters to ensure simultaneity where needed. In addition, the Scrambler Timed Shutter, also gates the light going to the exposure meter to ensure that its sensitivity to light is simultaneous to the red and green detectors. The Ca H&K spectrograph has its own, separate timed shutter as it is on a completely independent light path to the other detectors. Science Detector Specifications Parameter Green CCD Red CCD Ca H&K CCD Readout Time 47 s 47 s 1 s Read Noise AMP1: 4.0 e- AMP2: 4.9 e- AMP1: 4.1 e- AMP2: 4.2 e- Format 4080x4080 4080x4080 Gain Data Format 32 bit 32 bit 16 bit Note that the Green and Red science detectors have 32 bit readouts instead of the more common 16 bit (which the Ca H&K detector uses). This means that the values of the raw image pixels are not in the usual 0-65535 range for CCDs, but are instead much larger. To convert to the more usual range we are used to, divide by 2^16 (65536) to get ADU values in that range. Fast Read Mode Summary The Green and Red science detectors can operate in a fast readout mode. This reduces the readout time to 16 seconds (and significantly increases the read noise), however changing the readout modes induces a temperature change at the detectors which can impact PRV measurements. As a result, fast read mode observations should be limited to those instances where it is critical to the science (e.g. seismology or other high cadence observations of a single target) and which are scheduled such that the mode change will not have overly negative impact on other science that night. Fast read mode is not appropriate for long term cadenced RV measurements as the two read modes have different systematic offsets and so RV measurements of the same target taken in different modes can not be easily combined. Details The KPF main spectrometer CCDs can be operated in two read modes: normal and fast. The main difference is the time to read the CCDs, which is 47 sec in normal-read mode and 16 sec in fast-read mode. In general, KPF observations should be taken in normal-read mode unless there is a highly compelling reason to operate in fast-read mode. The fast-read mode is only offered for KPF observations where the speed will aid in resolving fast astrophysical phenomena (e.g., seismology) or for cases where short exposure times are required to avoid saturation and the efficiency is significantly improved by also reading the CCDs quickly (e.g., observing a very bright star during a planetary transit). This applies to sequences of exposures ranging from 1 hour to 1 night in duration. The fast-read mode should not be used to improve the efficiency of individual exposure or short sequences of exposures, which comprise the vast majority of KPF observations. The motivation for this strategy is that changing between the two modes imparts a ~10 mK temperature transient to the CCDs, which shift and stretch at the nanometer level in response. These perturbations violate the operating requirements of maintaining 1 mK rms temperature stability of the CCDs and lead to systematic errors in Doppler measurements on short timescales (< 20-30 min). On longer timescales, the CCDs appear to relax back to their original state, but this has not been measured at the sub-30 cm/s level. Out of conservatism, KPF is toggled between read modes as infrequently as possible. Automated daily calibration sequences are taken in the normal-read mode and are used in the KPF Data Reduction Pipeline (DRP) to process spectra taken with both read modes. Radial velocities measured from KPF spectra in the two modes are offset; users cannot combine RVs from the two modes in a time series. On the other hand, RVs measured from spectra taken in the fast-read mode during a single night (which are processed with a common set of calibrations) have high Doppler stability over that night-long timescale; this is the main use case for the fast-read mode. Some additional tradeoffs to consider are the increased read noise and the charge transfer inefficiency (CTI) in fast-read mode. As listed in the table below, the read noise (measured in rms noise per CCD pixel) is 1.5-2X higher in fast-read mode. This limits the utility of this mode for faint sources, which have higher Poisson noise per CCD pixel in the source spectrum. In fast-read mode, the CCDs are read out using four amplifiers at a higher clock speed (instead of two amplifiers at a slower speed). This strategy brings one amplifier on the Green CCD into play that has ~100x higher CTI than the others. CTI smears the spectrum along the direction of the CCD rows (leaving a trail of charge along pixels as they are clocked). As a result, stellar lines in the affected quadrant are smeared in the dispersion direction. The intensity of the effect depends on the number of electrons in each pixel (i.e., the SNR of the spectrum), making this effect very difficult to calibrate for precise RV measurements. When computing RVs for fast-read mode spectra, the KPF DRP ignores portions of the spectrum in the affected quadrant. This increases the RV uncertainties in the fast-read mode and adds an additional RV zero-point offset between measurements in the two modes. Fast spectroscopy to measure changes in line intensity (not line shape or center) can still be accomplished using spectra from the affected quadrant. Parameter Normal Read Mode Fast Read Mode Readout Time 47 s 16 s Read Noise Green: 4.0, 4.9 e- Red: 4.1, 4.2 e- Green: 8.2, 9.7, 8.6, 6.9 e- Red: 6.0, 5.8, 8.2, 6.6 e- Charge Transfer One green amp has ~100x higher CTI Use Cases Most KPF observations, including cadence RPV measurements and general spectroscopy Sequences of short exposures whose duration is 1 hour to 1 night. If you have questions about utilizing fast read mode, please contact kpf_info well ahead of your run.","title":"Detectors"},{"location":"detectors/#overview-and-exposure-timing","text":"KPF utilizes 5 detectors during normal science operations. Two science detectors (green and red) sit on the main spectrograph bench in the facility basement and record the science spectrum which is used to calculate radial velocities. The Ca H&K Spectrograph is an independant optical system fed by a short fiber which runs from the FIU to a nearby echelle spectrograph which contains the third science detector. The exposure meter is another independent spectrograph which sits in the basement and contains the forth science detector. The fifth detector used during science operations is the CRED2 in the FIU and obtains fast frame rate images used to run the tip tilt system. Because precision radial velocity measurements require exquisite timing, the red and green detectors must have their exposures synced up. To do this, KPF uses a timed shutter on their common light path (before the dichroic splits the light). This is the \"Scrambler Timed Shutter\". As a result, the red and green cameras are not triggered independently. Instead the KPF software takes a single set of exposure parameters and triggers each camera to begin an exposure, then opens and closes timed shutters to ensure simultaneity where needed. In addition, the Scrambler Timed Shutter, also gates the light going to the exposure meter to ensure that its sensitivity to light is simultaneous to the red and green detectors. The Ca H&K spectrograph has its own, separate timed shutter as it is on a completely independent light path to the other detectors.","title":"Overview and Exposure Timing"},{"location":"detectors/#science-detector-specifications","text":"Parameter Green CCD Red CCD Ca H&K CCD Readout Time 47 s 47 s 1 s Read Noise AMP1: 4.0 e- AMP2: 4.9 e- AMP1: 4.1 e- AMP2: 4.2 e- Format 4080x4080 4080x4080 Gain Data Format 32 bit 32 bit 16 bit Note that the Green and Red science detectors have 32 bit readouts instead of the more common 16 bit (which the Ca H&K detector uses). This means that the values of the raw image pixels are not in the usual 0-65535 range for CCDs, but are instead much larger. To convert to the more usual range we are used to, divide by 2^16 (65536) to get ADU values in that range.","title":"Science Detector Specifications"},{"location":"detectors/#fast-read-mode","text":"","title":"Fast Read Mode"},{"location":"detectors/#summary","text":"The Green and Red science detectors can operate in a fast readout mode. This reduces the readout time to 16 seconds (and significantly increases the read noise), however changing the readout modes induces a temperature change at the detectors which can impact PRV measurements. As a result, fast read mode observations should be limited to those instances where it is critical to the science (e.g. seismology or other high cadence observations of a single target) and which are scheduled such that the mode change will not have overly negative impact on other science that night. Fast read mode is not appropriate for long term cadenced RV measurements as the two read modes have different systematic offsets and so RV measurements of the same target taken in different modes can not be easily combined.","title":"Summary"},{"location":"detectors/#details","text":"The KPF main spectrometer CCDs can be operated in two read modes: normal and fast. The main difference is the time to read the CCDs, which is 47 sec in normal-read mode and 16 sec in fast-read mode. In general, KPF observations should be taken in normal-read mode unless there is a highly compelling reason to operate in fast-read mode. The fast-read mode is only offered for KPF observations where the speed will aid in resolving fast astrophysical phenomena (e.g., seismology) or for cases where short exposure times are required to avoid saturation and the efficiency is significantly improved by also reading the CCDs quickly (e.g., observing a very bright star during a planetary transit). This applies to sequences of exposures ranging from 1 hour to 1 night in duration. The fast-read mode should not be used to improve the efficiency of individual exposure or short sequences of exposures, which comprise the vast majority of KPF observations. The motivation for this strategy is that changing between the two modes imparts a ~10 mK temperature transient to the CCDs, which shift and stretch at the nanometer level in response. These perturbations violate the operating requirements of maintaining 1 mK rms temperature stability of the CCDs and lead to systematic errors in Doppler measurements on short timescales (< 20-30 min). On longer timescales, the CCDs appear to relax back to their original state, but this has not been measured at the sub-30 cm/s level. Out of conservatism, KPF is toggled between read modes as infrequently as possible. Automated daily calibration sequences are taken in the normal-read mode and are used in the KPF Data Reduction Pipeline (DRP) to process spectra taken with both read modes. Radial velocities measured from KPF spectra in the two modes are offset; users cannot combine RVs from the two modes in a time series. On the other hand, RVs measured from spectra taken in the fast-read mode during a single night (which are processed with a common set of calibrations) have high Doppler stability over that night-long timescale; this is the main use case for the fast-read mode. Some additional tradeoffs to consider are the increased read noise and the charge transfer inefficiency (CTI) in fast-read mode. As listed in the table below, the read noise (measured in rms noise per CCD pixel) is 1.5-2X higher in fast-read mode. This limits the utility of this mode for faint sources, which have higher Poisson noise per CCD pixel in the source spectrum. In fast-read mode, the CCDs are read out using four amplifiers at a higher clock speed (instead of two amplifiers at a slower speed). This strategy brings one amplifier on the Green CCD into play that has ~100x higher CTI than the others. CTI smears the spectrum along the direction of the CCD rows (leaving a trail of charge along pixels as they are clocked). As a result, stellar lines in the affected quadrant are smeared in the dispersion direction. The intensity of the effect depends on the number of electrons in each pixel (i.e., the SNR of the spectrum), making this effect very difficult to calibrate for precise RV measurements. When computing RVs for fast-read mode spectra, the KPF DRP ignores portions of the spectrum in the affected quadrant. This increases the RV uncertainties in the fast-read mode and adds an additional RV zero-point offset between measurements in the two modes. Fast spectroscopy to measure changes in line intensity (not line shape or center) can still be accomplished using spectra from the affected quadrant. Parameter Normal Read Mode Fast Read Mode Readout Time 47 s 16 s Read Noise Green: 4.0, 4.9 e- Red: 4.1, 4.2 e- Green: 8.2, 9.7, 8.6, 6.9 e- Red: 6.0, 5.8, 8.2, 6.6 e- Charge Transfer One green amp has ~100x higher CTI Use Cases Most KPF observations, including cadence RPV measurements and general spectroscopy Sequences of short exposures whose duration is 1 hour to 1 night. If you have questions about utilizing fast read mode, please contact kpf_info well ahead of your run.","title":"Details"},{"location":"exposuremeter/","text":"Exposure Meter An accurate measurement of the time of the flux-weighted midpoint of each exposure is essential to correct for the barycentric velocity of the Earth. During an exposure, a small fraction of the light within the spectrometer is diverted to a separate, low-resolution spectrometer that records the flux time series for all wavelengths across the main spectrometer bandpass. This system accurately tracks the photon arrival times in the parent spectrometer, allowing for precise determination of flux-weighted exposure mid-points as a function of wavelength. The optical design of the exposure meter is a prism-based spectrometer with a resolving power of approximately 100. The exposure meter accepts light from two fibers; one collecting light from the otherwise unused outboard slices of the science fiber at the spectrometer reformatter entrance, and a sky fiber from the fiber injection unit on the telescope. The optical design is shown in the following figure. Optical design of the KPF Exposure Meter","title":"Exposure Meter"},{"location":"exposuremeter/#exposure-meter","text":"An accurate measurement of the time of the flux-weighted midpoint of each exposure is essential to correct for the barycentric velocity of the Earth. During an exposure, a small fraction of the light within the spectrometer is diverted to a separate, low-resolution spectrometer that records the flux time series for all wavelengths across the main spectrometer bandpass. This system accurately tracks the photon arrival times in the parent spectrometer, allowing for precise determination of flux-weighted exposure mid-points as a function of wavelength. The optical design of the exposure meter is a prism-based spectrometer with a resolving power of approximately 100. The exposure meter accepts light from two fibers; one collecting light from the otherwise unused outboard slices of the science fiber at the spectrometer reformatter entrance, and a sky fiber from the fiber injection unit on the telescope. The optical design is shown in the following figure. Optical design of the KPF Exposure Meter","title":"Exposure Meter"},{"location":"fiu/","text":"Fiber Injection Unit (FIU) The Fiber Injection Unit (FIU) sits on the Keck I AO bench ahead of AO correction. The unit's primary role is to feed telescope light to the science, sky, and Ca H&K fibers. The unit utilizes a pair of dichroics to send light to the relevant subsystems: Wavelength Range Subsystem Notes 382-402 nm Ca H&K Spectrograph Includes two fibers (science and sky) 445-870 nm Science Spectrograph Includes two fibers (science and sky) 950-1200 nm Guide Camera Used for acquisition and fast tip tilt correction The FIU can also be configured in a mode which takes light from the calibration bench in the basement and injects it in to the science and sky fibers. Atmospheric Dispersion Correctors In addition, the FIU contains atmospheric dispersion correction (ADC) systems for both the science and Ca H&K wavelengths. Science ADC For the science arm, a pair of prisms are rotated to provide dispersion correction based on the telescope position. The ADCs are designed to keep all the science wavelengths within 50 mas. The ADC corrects atmospheric dispersion at that full 50 mas specification down to an elevation of 30 degrees. The prisms reach their maximum correction power at an elevation of 25 degrees, beyond that, their correction power is fixed and no longer increases as the elevation decreases. Ca H&K ADC For the Ca H&K arm, the fiber is on a two axis stage and is translated in such as way as to place the fiber under the correct wavelengths of light. The total wavelength range in this arm is small enough that only the differential position between this arm and the science and guide arms is corrected, there is no correction of the dispersion over the narrow wavelength range of the Ca H&K arm. FIU Layout The FIU layout when in science mode. Light from the telescope is directed to the FIU off of a tip tilt mirror located on the PCU stage. The FIU layout when in calibration mode. The calibration fibers are illuminated and a fold mirror is moved in to place to direct their light on to the science fiber. Fiber Viewing Cameras Both the science arm and the Ca H&K arm have fiber viewing cameras (FVCs) for imaging the fiber tip. These are only useful in an engineering context as it takes a very bright (roughly 1st magnitude) star to be visible because the FVCs are looking through the dichroics (and the ADC prisms in the science arm). This drastically reduced the amount of light to the FVCs and makes the images hard to interpret due to reflections and ghost images.","title":"FIU"},{"location":"fiu/#fiber-injection-unit-fiu","text":"The Fiber Injection Unit (FIU) sits on the Keck I AO bench ahead of AO correction. The unit's primary role is to feed telescope light to the science, sky, and Ca H&K fibers. The unit utilizes a pair of dichroics to send light to the relevant subsystems: Wavelength Range Subsystem Notes 382-402 nm Ca H&K Spectrograph Includes two fibers (science and sky) 445-870 nm Science Spectrograph Includes two fibers (science and sky) 950-1200 nm Guide Camera Used for acquisition and fast tip tilt correction The FIU can also be configured in a mode which takes light from the calibration bench in the basement and injects it in to the science and sky fibers.","title":"Fiber Injection Unit (FIU)"},{"location":"fiu/#atmospheric-dispersion-correctors","text":"In addition, the FIU contains atmospheric dispersion correction (ADC) systems for both the science and Ca H&K wavelengths.","title":"Atmospheric Dispersion Correctors"},{"location":"fiu/#science-adc","text":"For the science arm, a pair of prisms are rotated to provide dispersion correction based on the telescope position. The ADCs are designed to keep all the science wavelengths within 50 mas. The ADC corrects atmospheric dispersion at that full 50 mas specification down to an elevation of 30 degrees. The prisms reach their maximum correction power at an elevation of 25 degrees, beyond that, their correction power is fixed and no longer increases as the elevation decreases.","title":"Science ADC"},{"location":"fiu/#ca-hk-adc","text":"For the Ca H&K arm, the fiber is on a two axis stage and is translated in such as way as to place the fiber under the correct wavelengths of light. The total wavelength range in this arm is small enough that only the differential position between this arm and the science and guide arms is corrected, there is no correction of the dispersion over the narrow wavelength range of the Ca H&K arm.","title":"Ca H&amp;K ADC"},{"location":"fiu/#fiu-layout","text":"The FIU layout when in science mode. Light from the telescope is directed to the FIU off of a tip tilt mirror located on the PCU stage. The FIU layout when in calibration mode. The calibration fibers are illuminated and a fold mirror is moved in to place to direct their light on to the science fiber.","title":"FIU Layout"},{"location":"fiu/#fiber-viewing-cameras","text":"Both the science arm and the Ca H&K arm have fiber viewing cameras (FVCs) for imaging the fiber tip. These are only useful in an engineering context as it takes a very bright (roughly 1st magnitude) star to be visible because the FVCs are looking through the dichroics (and the ADC prisms in the science arm). This drastically reduced the amount of light to the FVCs and makes the images hard to interpret due to reflections and ghost images.","title":"Fiber Viewing Cameras"},{"location":"guider/","text":"Guider The KPF guide camera views the science field, but behind a long pass dichroic which sends light blueward of about 950nm to the science and Ca H&K fibers. As a result, the guide camera was chosen to be a \"short wave IR\" camera utilizing an InGaS detector. Camera Model First Light CRED2 Pixel Scale 0.056 arcsec/pix Field of View 35 x 28 arcseconds Frame Rate up to 400 Hz (100 Hz recommended) Passband 950-1200 nm (0.95-1.2 microns) Gain Settings high, medium, low Note that while the camera can operate at 400 Hz, the practical limit for operations is around 100-150 Hz due to tip tilt system limitations. Rather than using traditional telescope guiding, the guide camera takes images at high frame rates and sends corrections to a fast tip tilt mirror situated just outside the FIU. We recommend running the system at 100 Hz for optimum performance. The system will offload corrections from the tip tilt mirror to the telescope drive system periodically as needed to keep the tip tilt mirror within its optimum range of travel. The OAs use a separate GUI for controlling the KPF tip tilt system (not the usual Magiq interface used on other instruments). The OAs can run Magiq in \"centroid only\" mode which will provide FWHM and flux feedback to the observer in the normal Magiq display.","title":"Guider"},{"location":"guider/#guider","text":"The KPF guide camera views the science field, but behind a long pass dichroic which sends light blueward of about 950nm to the science and Ca H&K fibers. As a result, the guide camera was chosen to be a \"short wave IR\" camera utilizing an InGaS detector. Camera Model First Light CRED2 Pixel Scale 0.056 arcsec/pix Field of View 35 x 28 arcseconds Frame Rate up to 400 Hz (100 Hz recommended) Passband 950-1200 nm (0.95-1.2 microns) Gain Settings high, medium, low Note that while the camera can operate at 400 Hz, the practical limit for operations is around 100-150 Hz due to tip tilt system limitations. Rather than using traditional telescope guiding, the guide camera takes images at high frame rates and sends corrections to a fast tip tilt mirror situated just outside the FIU. We recommend running the system at 100 Hz for optimum performance. The system will offload corrections from the tip tilt mirror to the telescope drive system periodically as needed to keep the tip tilt mirror within its optimum range of travel. The OAs use a separate GUI for controlling the KPF tip tilt system (not the usual Magiq interface used on other instruments). The OAs can run Magiq in \"centroid only\" mode which will provide FWHM and flux feedback to the observer in the normal Magiq display.","title":"Guider"},{"location":"kpfdrp/","text":"Data Reduction Pipeline WMKO automatically delivers KPF L0 data products to the Keck Observatory Archive (KOA) for distribution to observers. We plan to distribute L1 and L2 data products as well, but the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. Observers not affiliated with the KPF build team or with the California Planet Search (CPS) should contact their Staff Astronomer about access to reduced data products. Advanced users who would like to run the DRP locally can find the KPF DRP on GitHub . Level Definitions Level Description L0 Raw spectra packaged with other instrument data (see Data Format for details) L1 1-d, wavelength calibrated spectra L2 RVs, multiple activity indicators","title":"Data Reduction"},{"location":"kpfdrp/#data-reduction-pipeline","text":"WMKO automatically delivers KPF L0 data products to the Keck Observatory Archive (KOA) for distribution to observers. We plan to distribute L1 and L2 data products as well, but the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. Observers not affiliated with the KPF build team or with the California Planet Search (CPS) should contact their Staff Astronomer about access to reduced data products. Advanced users who would like to run the DRP locally can find the KPF DRP on GitHub .","title":"Data Reduction Pipeline"},{"location":"kpfdrp/#level-definitions","text":"Level Description L0 Raw spectra packaged with other instrument data (see Data Format for details) L1 1-d, wavelength calibrated spectra L2 RVs, multiple activity indicators","title":"Level Definitions"},{"location":"observingprocedures/","text":"Quick Reference Wait for Dome to Open Run Start of Night Slew to the Vicinity of Your First Target Focus the Telescope Execute OBs Switching Programs on a Split Night Wait for Dome to Open The Observing Assistant (OA) is not permitted to open the dome until after sunset. Please be patient while the shutter opens and the OA checks the initial telescope pointing. Run Start of Night To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Confgure the tip tilt loop gain to its default setting Set data output directory Set observers from telescope schedule Slew to the Vicinity of Your First Target When ready to move the telescope, the OA will ask you for your first target and load the coordinates from your starlist file. They will select a bright star near your target and will attempt to acquire that in the guider, then will double-check the accuracy of pointing by acquiring one or two additional stars from the SAO or GSC catalogs. To monitor the guider images, run Telescope GUIs --> MAGIQ Guider UI from the background menu. Focus the Telescope The OA will run the telescope focus procedure (Autofoc) near your science field. On some nights, they will opt for the Mira focus procedure which takes slightly longer but is needed to calibrate the secondary mirror tilt. Execute OBs Observers can load previously saved OBs or create them on the fly for KPF observing. To load and execute a saved OB: Click Load OB from File Select a desired OB from the file list Click Execute This OB or Execute OB with Slew Cal The GUI will first prompt the observers to conform the OB execution. Once confirmed, an xterm will launch and prompt the observers with addtional information if needed. The log lines which show up in the xterm with the running OB contain useful information. In general, lines with INFO are attempting to explain what the instrument is doing. Lines with WARNING are indicating that a minor problem has occurred, but the system is handling it. The WARNING lines are purely informational, no action is needed on the part of the observer in response. Lines with ERROR indicate a serious problems which may require user intervention. Stopping Scripts or Exposures Important : If you wish to halt an OB durin execution, do NOT hit Control-c in the terminal. Use the \"Request Script STOP\" button instead. The KPF scripts have checkpoints in them which are places where the script can cleanly exit and perform important cleanup operations. The \"STOP Exposure and Script\" button does the same thing, but it will also terminate an exposure in progress. Switching Programs on a Split Night On a KPF/KPF split night, before starting the second KPF program, run KPF Control Menu --> Set Program ID and Observers from the background menu (or kpfSetObserverFromSchedule from the command line on any KPF machine). Enter the program ID at the terminal prompt. The script will then set program ID and observers for the second KPF program, based on the telescope schedule.","title":"Observing Procedures"},{"location":"observingprocedures/#quick-reference","text":"Wait for Dome to Open Run Start of Night Slew to the Vicinity of Your First Target Focus the Telescope Execute OBs Switching Programs on a Split Night","title":"Quick Reference"},{"location":"observingprocedures/#wait-for-dome-to-open","text":"The Observing Assistant (OA) is not permitted to open the dome until after sunset. Please be patient while the shutter opens and the OA checks the initial telescope pointing.","title":"Wait for Dome to Open"},{"location":"observingprocedures/#run-start-of-night","text":"To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Confgure the tip tilt loop gain to its default setting Set data output directory Set observers from telescope schedule","title":"Run Start of Night"},{"location":"observingprocedures/#slew-to-the-vicinity-of-your-first-target","text":"When ready to move the telescope, the OA will ask you for your first target and load the coordinates from your starlist file. They will select a bright star near your target and will attempt to acquire that in the guider, then will double-check the accuracy of pointing by acquiring one or two additional stars from the SAO or GSC catalogs. To monitor the guider images, run Telescope GUIs --> MAGIQ Guider UI from the background menu.","title":"Slew to the Vicinity of Your First Target"},{"location":"observingprocedures/#focus-the-telescope","text":"The OA will run the telescope focus procedure (Autofoc) near your science field. On some nights, they will opt for the Mira focus procedure which takes slightly longer but is needed to calibrate the secondary mirror tilt.","title":"Focus the Telescope"},{"location":"observingprocedures/#execute-obs","text":"Observers can load previously saved OBs or create them on the fly for KPF observing. To load and execute a saved OB: Click Load OB from File Select a desired OB from the file list Click Execute This OB or Execute OB with Slew Cal The GUI will first prompt the observers to conform the OB execution. Once confirmed, an xterm will launch and prompt the observers with addtional information if needed. The log lines which show up in the xterm with the running OB contain useful information. In general, lines with INFO are attempting to explain what the instrument is doing. Lines with WARNING are indicating that a minor problem has occurred, but the system is handling it. The WARNING lines are purely informational, no action is needed on the part of the observer in response. Lines with ERROR indicate a serious problems which may require user intervention.","title":"Execute OBs"},{"location":"observingprocedures/#stopping-scripts-or-exposures","text":"Important : If you wish to halt an OB durin execution, do NOT hit Control-c in the terminal. Use the \"Request Script STOP\" button instead. The KPF scripts have checkpoints in them which are places where the script can cleanly exit and perform important cleanup operations. The \"STOP Exposure and Script\" button does the same thing, but it will also terminate an exposure in progress.","title":"Stopping Scripts or Exposures"},{"location":"observingprocedures/#switching-programs-on-a-split-night","text":"On a KPF/KPF split night, before starting the second KPF program, run KPF Control Menu --> Set Program ID and Observers from the background menu (or kpfSetObserverFromSchedule from the command line on any KPF machine). Enter the program ID at the terminal prompt. The script will then set program ID and observers for the second KPF program, based on the telescope schedule.","title":"Switching Programs on a Split Night"},{"location":"preparingOBs/","text":"Observing Blocks (OBs) The basic unit of KPF nighttime operations is the Observing Block (OB). An OB describes a single visit to a science target and the observations made there. The data in an OB can be divided in to 4 rough categories: Target information : The OB will contain information about the target beyond what is in a typical Keck Star List entry in order to flow that information to the FITS header and the data reduction pipeline (DRP). Guide camera configuration : The OB will also contain information about how to configure the guide camera and tip tilt system for this target. Instrument Setup : The OB will also contain information about how to configure the instrument for this set of observations. Observations : Finally, the OB will contain a list of \"observations\" to be made of the target. For typical KPF observers, this will only have one entry, but multiple entries are supported. Each entry describes a set of exposures on the target and contains the information on how those exposures should be executed. The data contained in the OB is a set of keyword-value pairs. Observers can prepare OBs as text files which can be read in by the KPF software and executed or (once logged in to the KPF VNCs) they can use tools there to build the OBs and save them as files. Science OB Contents Here is an example science OB formatted as a text file (this is the YAML data format). The comments (preceded by a # symbol) are not needed, but are present to help the reader. Template_Name : kpf_sci Template_Version : 1.0 # Target Info TargetName : 10700 # Name GaiaID : DR3 2452378776434276992 # Gaia ID 2 MASSID : 01440402 - 1556141 # 2 MASS ID Parallax : 273.81 # Parallax in arcsec RadialVelocity : - 16.597 # Radial Velocity in km / s Gmag : 3.3 # G band magnitude ( eventualy used by exposure meter ) Jmag : 2.14 # J band magnitude ( eventualy used by guider ) Teff : 5266 # Effective temperature # Guider Setup GuideMode : manual # \"manual\" , \"auto\" , \"off\" , or \"telescope\" GuideCamGain : low # Guide camera gain ; values = low | medium | high GuideFPS : 100 # Frames per second for guide camera ( for tip - tilt ) # Spectrograph Setup TriggerCaHK : False # Include CaHK in exposure ( True / False ) TriggerGreen : True # Include Green CCD in exposure ( True / False ) TriggerRed : True # Include Red CCD in exposure ( True / False ) BlockSky : False # Close the sky fiber shutter during observations ( True / False ) # Observations SEQ_Observations : # - Object : 10700 # User settable comment nExp : 4 # Number of exoposures in the OB ExpTime : 30 # Exposure time of the main spectrometer and CaH & K . See Exposure Meter section below . ExpMeterMode : control # \"monitor\" or \"control\" ( to terminate exposure based on flux ) AutoExpMeter : False # Set the exposure meter exposure time automatically ExpMeterExpTime : 0.5 # Exposure time of the Exposure Meter subframes ExpMeterBin : 3 # Exposure meter wavelength bin to use for stopping exposure ExpMeterThreshold : 1 e5 # Target science flux in e -/ nm TakeSimulCal : True # Take simultaneous calibrations ? ( True / False ) AutoNDFilters : False # Automatically set ND filters -- Not available at this time ! CalND1 : OD 4.0 # OD = Optical Density . Throughput = 10 ^- OD CalND2 : OD 0.1 # Each value in the OB is described in more detail below. Template_Name and Template_Version : These values indicate to the software what sort of observation this is and what script to execute. For a science observation, always use \"kpf_sci\" as the template name. TargetName : This is a name chosen by the observer. GaiaID and 2MASSID : These values are used by the DRP to identify the star and determine its properties. Parallax and RadialVelocity : These values are used by the DRP. Gmag : This is used by the DRP and by the algorithm which automatically sets the exposure meter exposure time. Jmag : This is used by the algorithm which automatically sets the guider gain and frame rate. Teff : The effective temperature of the star is used by the DRP. GuideMode : The options are \"manual\", \"auto\", or \"off\". If \"manual\" is selected, the values for the gain and FPS below are used. If \"auto\" is selected, the camera gain and FPS values in the OB are ignored and the software will choose values based on the Jmag value. GuideCamGain and GuideFPS : The gain (high, medium, or low) and the frame rate (frames per second) at which to operate the guide camera. These are ignored if the GuideMode is set to \"auto\". TriggerCaHK, TriggerGreen, and TriggerRed : These values indicate whether to trigger the respective camera during the science exposures. All of these cameras will be synced up and will get the same exposure time. SEQ_Observations : This line is required. The following block of lines represent one entry in a list. If more than one set of exposures on a target is desired, this block of text can be repeated to build a second \"observation\" on the target with different parameters. Object : This value will go in to the FITS header as the OBJECT keyword value. This is can be used as a notes field for the observer to explain how this set of exposures differs from any following observations of this target. This field can be left blank or set to the target name, it is entirely up to the observer. nExp and ExpTime : The number of exposures and exposure time. Note that if the exposure meter is controlling the exposure duration, this exposure time is the maximum value which will be allowed (the exposure meter may cut the exposure short if the desired flux level is reached). ExpMeterMode : For now, only the \"monitor\" mode is available. In \"monitor\" the exposure meter will take exposure during the science exposure and record fluxes. This data will be stored in the resulting FITS file can be used to determine the flux weighted exposure midpoint in time for accurate barycentric correction. AutoExpMeter : If this is True, the software will use the Gmag value to estimate a good exposure time for the individual exposure meter exposures and use that instead of the ExpMeterExpTime value below. ExpMeterExpTime : The exposure time for individual exposure meter exposures. This is ignored if AutoExpMeter is True. TakeSimulCal : Should the instrument be configured to illuminate the simultaneous calibration fiber during the science exposure? AutoNDFilters : Should the software automatically set the ND filters based on the target and exposure information? This is not currently implemented and will be ignored! CalND1 : Which neutral density filter should be used in the ND1 filter wheel to cut down the brightness of the simultaneous calibration light source? This is only needed if TakeSimulCal is True. Allowed values are \"OD 0.1\", \"OD 1.0\", \"OD 1.3\", \"OD 2.0\", \"OD 3.0\", and \"OD 4.0\" CalND2 : Which neutral density filter should be used in the ND2 filter wheel to cut down the brightness of the simultaneous calibration light source? This is only needed if TakeSimulCal is True. Allowed values are \"OD 0.1\", \"OD 0.3\", \"OD 0.5\", \"OD 0.8\", \"OD 1.0\", and \"OD 4.0\" KPF OB GUI A graphical tool has been built to help observers build their KPF OBs, it is launched automatically as part of the script to start all GUIs. A screenshot of the KPF OB GUI. This tool is still under development and may change. The top section of the GUI, \"Instrument Status\" shows whether an instrument script (e.g. an observation or calibration set) is being run and allows users to request that script stop. The middle section can be used to load an OB from a file, build an OB from scratch using a Gaia DR3 catalog query, save the OB to a file, or execute the OB. The lower section is where a user can fill out the OB parameters as described in the \"KPF Science OB Contents\" section above.","title":"Preparing OBs"},{"location":"preparingOBs/#observing-blocks-obs","text":"The basic unit of KPF nighttime operations is the Observing Block (OB). An OB describes a single visit to a science target and the observations made there. The data in an OB can be divided in to 4 rough categories: Target information : The OB will contain information about the target beyond what is in a typical Keck Star List entry in order to flow that information to the FITS header and the data reduction pipeline (DRP). Guide camera configuration : The OB will also contain information about how to configure the guide camera and tip tilt system for this target. Instrument Setup : The OB will also contain information about how to configure the instrument for this set of observations. Observations : Finally, the OB will contain a list of \"observations\" to be made of the target. For typical KPF observers, this will only have one entry, but multiple entries are supported. Each entry describes a set of exposures on the target and contains the information on how those exposures should be executed. The data contained in the OB is a set of keyword-value pairs. Observers can prepare OBs as text files which can be read in by the KPF software and executed or (once logged in to the KPF VNCs) they can use tools there to build the OBs and save them as files.","title":"Observing Blocks (OBs)"},{"location":"preparingOBs/#science-ob-contents","text":"Here is an example science OB formatted as a text file (this is the YAML data format). The comments (preceded by a # symbol) are not needed, but are present to help the reader. Template_Name : kpf_sci Template_Version : 1.0 # Target Info TargetName : 10700 # Name GaiaID : DR3 2452378776434276992 # Gaia ID 2 MASSID : 01440402 - 1556141 # 2 MASS ID Parallax : 273.81 # Parallax in arcsec RadialVelocity : - 16.597 # Radial Velocity in km / s Gmag : 3.3 # G band magnitude ( eventualy used by exposure meter ) Jmag : 2.14 # J band magnitude ( eventualy used by guider ) Teff : 5266 # Effective temperature # Guider Setup GuideMode : manual # \"manual\" , \"auto\" , \"off\" , or \"telescope\" GuideCamGain : low # Guide camera gain ; values = low | medium | high GuideFPS : 100 # Frames per second for guide camera ( for tip - tilt ) # Spectrograph Setup TriggerCaHK : False # Include CaHK in exposure ( True / False ) TriggerGreen : True # Include Green CCD in exposure ( True / False ) TriggerRed : True # Include Red CCD in exposure ( True / False ) BlockSky : False # Close the sky fiber shutter during observations ( True / False ) # Observations SEQ_Observations : # - Object : 10700 # User settable comment nExp : 4 # Number of exoposures in the OB ExpTime : 30 # Exposure time of the main spectrometer and CaH & K . See Exposure Meter section below . ExpMeterMode : control # \"monitor\" or \"control\" ( to terminate exposure based on flux ) AutoExpMeter : False # Set the exposure meter exposure time automatically ExpMeterExpTime : 0.5 # Exposure time of the Exposure Meter subframes ExpMeterBin : 3 # Exposure meter wavelength bin to use for stopping exposure ExpMeterThreshold : 1 e5 # Target science flux in e -/ nm TakeSimulCal : True # Take simultaneous calibrations ? ( True / False ) AutoNDFilters : False # Automatically set ND filters -- Not available at this time ! CalND1 : OD 4.0 # OD = Optical Density . Throughput = 10 ^- OD CalND2 : OD 0.1 # Each value in the OB is described in more detail below. Template_Name and Template_Version : These values indicate to the software what sort of observation this is and what script to execute. For a science observation, always use \"kpf_sci\" as the template name. TargetName : This is a name chosen by the observer. GaiaID and 2MASSID : These values are used by the DRP to identify the star and determine its properties. Parallax and RadialVelocity : These values are used by the DRP. Gmag : This is used by the DRP and by the algorithm which automatically sets the exposure meter exposure time. Jmag : This is used by the algorithm which automatically sets the guider gain and frame rate. Teff : The effective temperature of the star is used by the DRP. GuideMode : The options are \"manual\", \"auto\", or \"off\". If \"manual\" is selected, the values for the gain and FPS below are used. If \"auto\" is selected, the camera gain and FPS values in the OB are ignored and the software will choose values based on the Jmag value. GuideCamGain and GuideFPS : The gain (high, medium, or low) and the frame rate (frames per second) at which to operate the guide camera. These are ignored if the GuideMode is set to \"auto\". TriggerCaHK, TriggerGreen, and TriggerRed : These values indicate whether to trigger the respective camera during the science exposures. All of these cameras will be synced up and will get the same exposure time. SEQ_Observations : This line is required. The following block of lines represent one entry in a list. If more than one set of exposures on a target is desired, this block of text can be repeated to build a second \"observation\" on the target with different parameters. Object : This value will go in to the FITS header as the OBJECT keyword value. This is can be used as a notes field for the observer to explain how this set of exposures differs from any following observations of this target. This field can be left blank or set to the target name, it is entirely up to the observer. nExp and ExpTime : The number of exposures and exposure time. Note that if the exposure meter is controlling the exposure duration, this exposure time is the maximum value which will be allowed (the exposure meter may cut the exposure short if the desired flux level is reached). ExpMeterMode : For now, only the \"monitor\" mode is available. In \"monitor\" the exposure meter will take exposure during the science exposure and record fluxes. This data will be stored in the resulting FITS file can be used to determine the flux weighted exposure midpoint in time for accurate barycentric correction. AutoExpMeter : If this is True, the software will use the Gmag value to estimate a good exposure time for the individual exposure meter exposures and use that instead of the ExpMeterExpTime value below. ExpMeterExpTime : The exposure time for individual exposure meter exposures. This is ignored if AutoExpMeter is True. TakeSimulCal : Should the instrument be configured to illuminate the simultaneous calibration fiber during the science exposure? AutoNDFilters : Should the software automatically set the ND filters based on the target and exposure information? This is not currently implemented and will be ignored! CalND1 : Which neutral density filter should be used in the ND1 filter wheel to cut down the brightness of the simultaneous calibration light source? This is only needed if TakeSimulCal is True. Allowed values are \"OD 0.1\", \"OD 1.0\", \"OD 1.3\", \"OD 2.0\", \"OD 3.0\", and \"OD 4.0\" CalND2 : Which neutral density filter should be used in the ND2 filter wheel to cut down the brightness of the simultaneous calibration light source? This is only needed if TakeSimulCal is True. Allowed values are \"OD 0.1\", \"OD 0.3\", \"OD 0.5\", \"OD 0.8\", \"OD 1.0\", and \"OD 4.0\"","title":"Science OB Contents"},{"location":"preparingOBs/#kpf-ob-gui","text":"A graphical tool has been built to help observers build their KPF OBs, it is launched automatically as part of the script to start all GUIs. A screenshot of the KPF OB GUI. This tool is still under development and may change. The top section of the GUI, \"Instrument Status\" shows whether an instrument script (e.g. an observation or calibration set) is being run and allows users to request that script stop. The middle section can be used to load an OB from a file, build an OB from scratch using a Gaia DR3 catalog query, save the OB to a file, or execute the OB. The lower section is where a user can fill out the OB parameters as described in the \"KPF Science OB Contents\" section above.","title":"KPF OB GUI"},{"location":"references/","text":"Referencing KPF The suggested instrument paper to use when referencing KPF is currently Gibson et al. (2024) in prep. Additional KPF Instrument Papers \"System Design of the Keck Planet Finder\" Gibson et al. (2024) in prep. \"A fiber injection unit for the Keck Planet Finder: opto-mechanical design\" Lilley et al. (2022) \"Keck Planet Finder: design updates\" Ginson et al. (2020) \"A optical fiber double scrambler and mechanical agitator system for the Keck planet finder spectrograph\" Sirk et al (2018) \"Keck Planet Finder: preliminary design\" Gibson et al. (2018) \"Keck Planet Finder: Zerodur optical bench mechanical design\" Smith et al. (2018) \"A comprehensive radial velocity error budget for next generation Doppler spectrometers\" Halverson et al. 2016 \"KPF: Keck Planet Finder\" Gibson et al. 2016","title":"Acknowledging KPF"},{"location":"references/#referencing-kpf","text":"The suggested instrument paper to use when referencing KPF is currently Gibson et al. (2024) in prep.","title":"Referencing KPF"},{"location":"references/#additional-kpf-instrument-papers","text":"\"System Design of the Keck Planet Finder\" Gibson et al. (2024) in prep. \"A fiber injection unit for the Keck Planet Finder: opto-mechanical design\" Lilley et al. (2022) \"Keck Planet Finder: design updates\" Ginson et al. (2020) \"A optical fiber double scrambler and mechanical agitator system for the Keck planet finder spectrograph\" Sirk et al (2018) \"Keck Planet Finder: preliminary design\" Gibson et al. (2018) \"Keck Planet Finder: Zerodur optical bench mechanical design\" Smith et al. (2018) \"A comprehensive radial velocity error budget for next generation Doppler spectrometers\" Halverson et al. 2016 \"KPF: Keck Planet Finder\" Gibson et al. 2016","title":"Additional KPF Instrument Papers"},{"location":"sensitivity/","text":"For sensitivity estimates, please see the KPF exposure time calculator written by the instrument team. More information is available on the KPF Exposure Time (and RV Precision) Calculator page or go directly to GitHub to download the exposure time calculator software .","title":"Sensitivity"},{"location":"spectrograph/","text":"Spectrometer Optical Design The baseline KPF spectrometer design is shown in the following figure. Light enters the core spectrometer following the fiber image reformatter, at the focal point of the primary collimator mirror (traditionally this would be the location of the spectrometer slit). The f/8 beam diverges past this point and then strikes the primary collimator mirror (an off-axis paraboloid). Upon reflection, the now collimated 200 mm diameter light beam travels to the echelle grating, located one primary collimator focal length away from the primary collimator. After diffraction by the echelle, the diverging monochromatic beams reflect from the primary collimator a second time. Because the echelle grating is rotated slightly out of plane (the echelle gamma angle), the dispersed light does not return along the same path, and the pre- and post-diffraction beams are separated. Therefore, after reflecting from the collimator the second time, the dispersed light does not return to the entrance slit, but forms an intermediate focus to the side of the echelle. Just before the intermediate focus, a flat mirror is employed to fold the beam, to make the spectrometer footprint more compact. Layout of the spectrograph on the optical bench. After the fold mirror reflection, the light rays go through the intermediate focus, and then the diverging monochromatic beams are collimated by the secondary collimator mirror (an off-axis paraboloid). The monochromatic beam diameter here is 160 mm, owing to the secondary collimator having a focal length 0.8x that of the primary collimator. The converging monochromatic beams next encounter a dichroic beamsplitter, where wavelengths blueward of 593 nm are reflected, and wavelengths redward of 593 nm are transmitted. After reflection, the green channel monochromatic beams continue to converge towards the white pupil, where the cross-dispersion grism (grating prism) is located. This disperser consists of a shallow apex angle prism bonded to a volume phase holographic (VPH) grating. Following the grism, the light enters the camera, which then focuses the spectrum onto the CCD detector. A summary of various spectrometer parameters is given the the following table. A brief summary table of KPF instrument properties. VPH Grating Overview As described above, the main spectrometer employs VPH-based grisms for cross-dispersion. In order to provide sufficient cross dispersion, the green channel VPH grating was produced with a line density of 800 lines per mm and the red channel VPH with 450 lines per mm. A summary of the KPF VPH grating specifications are shown in the table below. Both gratings were produced by Kaiser Optical Systems (KOSI). A brief summary table of KPF's VPH grating properties. A preliminary set of diffraction efficiency measurements was conducted by KOSI at a few locations across the clear aperture for each KPF grating. These data were re-measured and confirmed at SSL using the measurement test equipment and procedures developed by the DESI project. Overall, we were able to confirm KOSI's measurements and saw a slight (2-4%) increase in diffraction efficiency. The optimum angle of incidence (AOI) for each grating were both chosen away from their design AOI due to gains in diffraction efficiency at the \"blue\" end (green grating) and \"red\" end (red grating) of the KPF passband. For the green grating, we chose an AOI of -29.5 degree which incrased the overall band average efficiency from 86.4 degree to 87.7 degree. This increased the blue end efficiency from 77.6% to 84.6%. For the red grating, we chose an AOI of -25.4 degree which slightly increased the overall band average efficiency from 87.7% to 88.6%. This increased the red end efficiency from 82.7% to 89.6%. The following figure shows the SSL measured efficiency of the two KPF VPH gratings over the spectrometer's passband. With the changing of the AOI in each grating, we have seen significant gains (approximately 25%) in diffraction efficiency vs. the production minimum specification at both ends of the spectrometer passband. Overall these grating exceeded our production minimum specification by >5% across at all wavelengths with the noted gains at the \"blue\" and \"red\" ends of the KPF spectrometer passband. Plot of the VPH grating efficiency as a function of wavelength.","title":"Spectrograph"},{"location":"spectrograph/#spectrometer-optical-design","text":"The baseline KPF spectrometer design is shown in the following figure. Light enters the core spectrometer following the fiber image reformatter, at the focal point of the primary collimator mirror (traditionally this would be the location of the spectrometer slit). The f/8 beam diverges past this point and then strikes the primary collimator mirror (an off-axis paraboloid). Upon reflection, the now collimated 200 mm diameter light beam travels to the echelle grating, located one primary collimator focal length away from the primary collimator. After diffraction by the echelle, the diverging monochromatic beams reflect from the primary collimator a second time. Because the echelle grating is rotated slightly out of plane (the echelle gamma angle), the dispersed light does not return along the same path, and the pre- and post-diffraction beams are separated. Therefore, after reflecting from the collimator the second time, the dispersed light does not return to the entrance slit, but forms an intermediate focus to the side of the echelle. Just before the intermediate focus, a flat mirror is employed to fold the beam, to make the spectrometer footprint more compact. Layout of the spectrograph on the optical bench. After the fold mirror reflection, the light rays go through the intermediate focus, and then the diverging monochromatic beams are collimated by the secondary collimator mirror (an off-axis paraboloid). The monochromatic beam diameter here is 160 mm, owing to the secondary collimator having a focal length 0.8x that of the primary collimator. The converging monochromatic beams next encounter a dichroic beamsplitter, where wavelengths blueward of 593 nm are reflected, and wavelengths redward of 593 nm are transmitted. After reflection, the green channel monochromatic beams continue to converge towards the white pupil, where the cross-dispersion grism (grating prism) is located. This disperser consists of a shallow apex angle prism bonded to a volume phase holographic (VPH) grating. Following the grism, the light enters the camera, which then focuses the spectrum onto the CCD detector. A summary of various spectrometer parameters is given the the following table. A brief summary table of KPF instrument properties.","title":"Spectrometer Optical Design"},{"location":"spectrograph/#vph-grating-overview","text":"As described above, the main spectrometer employs VPH-based grisms for cross-dispersion. In order to provide sufficient cross dispersion, the green channel VPH grating was produced with a line density of 800 lines per mm and the red channel VPH with 450 lines per mm. A summary of the KPF VPH grating specifications are shown in the table below. Both gratings were produced by Kaiser Optical Systems (KOSI). A brief summary table of KPF's VPH grating properties. A preliminary set of diffraction efficiency measurements was conducted by KOSI at a few locations across the clear aperture for each KPF grating. These data were re-measured and confirmed at SSL using the measurement test equipment and procedures developed by the DESI project. Overall, we were able to confirm KOSI's measurements and saw a slight (2-4%) increase in diffraction efficiency. The optimum angle of incidence (AOI) for each grating were both chosen away from their design AOI due to gains in diffraction efficiency at the \"blue\" end (green grating) and \"red\" end (red grating) of the KPF passband. For the green grating, we chose an AOI of -29.5 degree which incrased the overall band average efficiency from 86.4 degree to 87.7 degree. This increased the blue end efficiency from 77.6% to 84.6%. For the red grating, we chose an AOI of -25.4 degree which slightly increased the overall band average efficiency from 87.7% to 88.6%. This increased the red end efficiency from 82.7% to 89.6%. The following figure shows the SSL measured efficiency of the two KPF VPH gratings over the spectrometer's passband. With the changing of the AOI in each grating, we have seen significant gains (approximately 25%) in diffraction efficiency vs. the production minimum specification at both ends of the spectrometer passband. Overall these grating exceeded our production minimum specification by >5% across at all wavelengths with the noted gains at the \"blue\" and \"red\" ends of the KPF spectrometer passband. Plot of the VPH grating efficiency as a function of wavelength.","title":"VPH Grating Overview"},{"location":"scripts/","text":"Scripts analysis AnalyzeGridSearch AnalyzeTipTiltPerformance Fit2DGridSearch CountCameraErrors ao ControlAOHatch SendPCUtoHome SendPCUtoKPF SetAFMtoMirror SetAFStoNGS SetAODCStoSIM SetAORotator SetAORotatorManual SetupAOforACAM SetupAOforKPF TurnHepaOff TurnHepaOn TurnLightSourceOff cahk PowerCycleCaHK calbench CalLampPower IsCalSourceEnabled SetCalSource SetFlatFieldFiberPos SetLFCtoAstroComb SetLFCtoStandbyHigh SetND SetND1 SetND2 TakeIntensityReading WaitForCalSource WaitForFlatFieldFiberPos WaitForLampWarm WaitForLFCReady WaitForND WaitForND1 WaitForND2 engineering GridSearch ImageBackIlluminatedFibers Run2DGridSearch TakeADCGridData TakeADCOffsetGridData TakeGuiderSensitivityData TriggerGreenMiniFill TriggerRedMiniFill expmeter BuildMasterBias SetExpMeterExpTime SetExpMeterTerminationParameters PredictExpMeterParameters SetMasterBiasToDefault SetupExpMeter TakeExpMeterBiases fiu ConfigureFIU ControlFoldMirror ControlHatch InitializeTipTilt LockFIU UnlockFIU MeasureTipTiltMirrorRange SetADCAngles SetADCOffsets SetTipTiltCalculations SetTipTiltControl SetTipTiltGain SetTipTiltPosition SetTipTiltTargetPixel ShutdownTipTilt StartTipTilt StopTipTilt TestTipTiltMirrorRange VerifyCurrentBase WaitForConfigureFIU WaitForTipTilt fvc FVCPower PredictFVCParameters TakeFVCContinuous TakeFVCExposure SetFVCExpTime guider DisplayGuiderContinuous GetGaiaStars GuiderLastfile GuiderOutdir OptimizeGuiderExposure PredictGuiderParameters SetGuiderExpTime SetGuiderFPS SetGuiderGain SetGuiderOutdir StartGuiderContinuous StartTriggerFile StopGuiderContinuous StopTriggerFile TakeGuiderCube TakeGuiderExposure WaitForTriggerFile scripts CleanupAfterCalibrations CleanupAfterScience CollectGuiderDarkCubes ConfigureForAcquisition ConfigureForCalibrations ConfigureForScience EndOfNight ExecuteSlewCal RunCalOB RunSciOB RunSoCalObservingLoop RunTwilightRVStandard StartOfNight StartUp WaitForConfigureCalibrations socal DisableSoCal EnableSoCal IsSoCalClosed IsSoCalOpen IsSoCalShutDown ParkSoCal SoCalStartAutonomous SoCalStopAutonomous WaitForSoCalOnTarget spectrograph QueryFastReadMode RecoverDetectors ResetCaHKDetector ResetExpMeterDetector ResetGreenDetector ResetRedDetector ResetDetectors SetExpTime SetObject SetObserver SetProgram SetReadModeFast SetReadModeNormal SetSourceSelectShutters SetTimedShutters SetTriggeredDetectors StartAgitator StartExposure StopAgitator WaitForReadout WaitForReady utils BuildOBfromQuery CalculateDAR CheckDewarWeights CorrectDAR EstimateOBDuration SetObserverFromSchedule SetOutdirs SetSimulCalSource SetTargetInfo StartGUIs StopGUIs ZeroOutSlewCalTime","title":"Scripts"},{"location":"scripts/#scripts","text":"","title":"Scripts"},{"location":"scripts/#analysis","text":"AnalyzeGridSearch AnalyzeTipTiltPerformance Fit2DGridSearch CountCameraErrors","title":"analysis"},{"location":"scripts/#ao","text":"ControlAOHatch SendPCUtoHome SendPCUtoKPF SetAFMtoMirror SetAFStoNGS SetAODCStoSIM SetAORotator SetAORotatorManual SetupAOforACAM SetupAOforKPF TurnHepaOff TurnHepaOn TurnLightSourceOff","title":"ao"},{"location":"scripts/#cahk","text":"PowerCycleCaHK","title":"cahk"},{"location":"scripts/#calbench","text":"CalLampPower IsCalSourceEnabled SetCalSource SetFlatFieldFiberPos SetLFCtoAstroComb SetLFCtoStandbyHigh SetND SetND1 SetND2 TakeIntensityReading WaitForCalSource WaitForFlatFieldFiberPos WaitForLampWarm WaitForLFCReady WaitForND WaitForND1 WaitForND2","title":"calbench"},{"location":"scripts/#engineering","text":"GridSearch ImageBackIlluminatedFibers Run2DGridSearch TakeADCGridData TakeADCOffsetGridData TakeGuiderSensitivityData TriggerGreenMiniFill TriggerRedMiniFill","title":"engineering"},{"location":"scripts/#expmeter","text":"BuildMasterBias SetExpMeterExpTime SetExpMeterTerminationParameters PredictExpMeterParameters SetMasterBiasToDefault SetupExpMeter TakeExpMeterBiases","title":"expmeter"},{"location":"scripts/#fiu","text":"ConfigureFIU ControlFoldMirror ControlHatch InitializeTipTilt LockFIU UnlockFIU MeasureTipTiltMirrorRange SetADCAngles SetADCOffsets SetTipTiltCalculations SetTipTiltControl SetTipTiltGain SetTipTiltPosition SetTipTiltTargetPixel ShutdownTipTilt StartTipTilt StopTipTilt TestTipTiltMirrorRange VerifyCurrentBase WaitForConfigureFIU WaitForTipTilt","title":"fiu"},{"location":"scripts/#fvc","text":"FVCPower PredictFVCParameters TakeFVCContinuous TakeFVCExposure SetFVCExpTime","title":"fvc"},{"location":"scripts/#guider","text":"DisplayGuiderContinuous GetGaiaStars GuiderLastfile GuiderOutdir OptimizeGuiderExposure PredictGuiderParameters SetGuiderExpTime SetGuiderFPS SetGuiderGain SetGuiderOutdir StartGuiderContinuous StartTriggerFile StopGuiderContinuous StopTriggerFile TakeGuiderCube TakeGuiderExposure WaitForTriggerFile","title":"guider"},{"location":"scripts/#scripts_1","text":"CleanupAfterCalibrations CleanupAfterScience CollectGuiderDarkCubes ConfigureForAcquisition ConfigureForCalibrations ConfigureForScience EndOfNight ExecuteSlewCal RunCalOB RunSciOB RunSoCalObservingLoop RunTwilightRVStandard StartOfNight StartUp WaitForConfigureCalibrations","title":"scripts"},{"location":"scripts/#socal","text":"DisableSoCal EnableSoCal IsSoCalClosed IsSoCalOpen IsSoCalShutDown ParkSoCal SoCalStartAutonomous SoCalStopAutonomous WaitForSoCalOnTarget","title":"socal"},{"location":"scripts/#spectrograph","text":"QueryFastReadMode RecoverDetectors ResetCaHKDetector ResetExpMeterDetector ResetGreenDetector ResetRedDetector ResetDetectors SetExpTime SetObject SetObserver SetProgram SetReadModeFast SetReadModeNormal SetSourceSelectShutters SetTimedShutters SetTriggeredDetectors StartAgitator StartExposure StopAgitator WaitForReadout WaitForReady","title":"spectrograph"},{"location":"scripts/#utils","text":"BuildOBfromQuery CalculateDAR CheckDewarWeights CorrectDAR EstimateOBDuration SetObserverFromSchedule SetOutdirs SetSimulCalSource SetTargetInfo StartGUIs StopGUIs ZeroOutSlewCalTime","title":"utils"},{"location":"scripts/AnalyzeGridSearch/","text":"AnalyzeGridSearch Bases: KPFTranslatorFunction Description Tool to analyze engineering data taken by the engineering.GridSearch or engineering.Run2DGridSearch scripts. Parameters None Source code in kpf/analysis/AnalyzeGridSearch.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 class AnalyzeGridSearch ( KPFTranslatorFunction ): '''# Description Tool to analyze engineering data taken by the `engineering.GridSearch` or `engineering.Run2DGridSearch` scripts. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for logfile in args . get ( 'logfile' ): analyze_grid_search ( logfile , fiber = args . get ( 'fiber' ), model_seeing = args . get ( 'seeing' ), xfit = args . get ( 'xfit' ), yfit = args . get ( 'yfit' ), generate_cred2 = args . get ( 'cred2' ), ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfile' , type = str , nargs = '*' , help = \"The logfile or files of the grid search runs to analyze\" ) ## add flags parser . add_argument ( \"--cred2\" , dest = \"cred2\" , default = False , action = \"store_true\" , help = \"Generate CRED2 plots? (default = False)\" ) ## add options parser . add_argument ( \"--fiber\" , dest = \"fiber\" , type = str , default = 'Science' , help = \"The fiber being examined (Science, Sky, or EMSky).\" ) parser . add_argument ( \"--seeing\" , dest = \"seeing\" , type = str , choices = [ '0.5' , '0.7' , '0.9' ], default = '0.7' , help = \"The seeing model to overlay on the fiber coupling plot.\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"AnalyzeGridSearch"},{"location":"scripts/AnalyzeGridSearch/#analyzegridsearch","text":"Bases: KPFTranslatorFunction","title":"AnalyzeGridSearch"},{"location":"scripts/AnalyzeGridSearch/#kpf.analysis.AnalyzeGridSearch.AnalyzeGridSearch--description","text":"Tool to analyze engineering data taken by the engineering.GridSearch or engineering.Run2DGridSearch scripts.","title":"Description"},{"location":"scripts/AnalyzeGridSearch/#kpf.analysis.AnalyzeGridSearch.AnalyzeGridSearch--parameters","text":"None Source code in kpf/analysis/AnalyzeGridSearch.py 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 class AnalyzeGridSearch ( KPFTranslatorFunction ): '''# Description Tool to analyze engineering data taken by the `engineering.GridSearch` or `engineering.Run2DGridSearch` scripts. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for logfile in args . get ( 'logfile' ): analyze_grid_search ( logfile , fiber = args . get ( 'fiber' ), model_seeing = args . get ( 'seeing' ), xfit = args . get ( 'xfit' ), yfit = args . get ( 'yfit' ), generate_cred2 = args . get ( 'cred2' ), ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfile' , type = str , nargs = '*' , help = \"The logfile or files of the grid search runs to analyze\" ) ## add flags parser . add_argument ( \"--cred2\" , dest = \"cred2\" , default = False , action = \"store_true\" , help = \"Generate CRED2 plots? (default = False)\" ) ## add options parser . add_argument ( \"--fiber\" , dest = \"fiber\" , type = str , default = 'Science' , help = \"The fiber being examined (Science, Sky, or EMSky).\" ) parser . add_argument ( \"--seeing\" , dest = \"seeing\" , type = str , choices = [ '0.5' , '0.7' , '0.9' ], default = '0.7' , help = \"The seeing model to overlay on the fiber coupling plot.\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/AnalyzeTipTiltPerformance/","text":"AnalyzeTipTiltPerformance Bases: KPFTranslatorFunction Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. Parameters None Source code in kpf/analysis/AnalyzeTipTiltPerformance.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 class AnalyzeTipTiltPerformance ( KPFTranslatorFunction ): '''# Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): viewer_command = find_viewer_command ( args ) for file in args . get ( 'files' ): file = Path ( file ) . expanduser () if file . exists () is False : log . error ( f \"Could not find file { args . get ( 'file' ) } \" ) plotfile = Path ( str ( file . name ) . replace ( '.fits' , '.png' )) plot_tiptilt_stats ( file , plotfile = plotfile , start = args . get ( 'start' , None ), end = args . get ( 'end' , None ), snr = args . get ( 'snr' , None ), minarea = args . get ( 'minarea' , None ), deblend_nthresh = args . get ( 'deblend_nthresh' , None ), deblend_cont = args . get ( 'deblend_cont' , None ), ) if viewer_command is not None : log . info ( f \"Opening { plotfile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { plotfile } \" ]) if args . get ( 'gif' ) is True : giffile = Path ( str ( file . name ) . replace ( '.fits' , '.gif' )) generate_cube_gif ( file , giffile ) if viewer_command is not None : log . info ( f \"Opening { giffile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { giffile } \" ]) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , type = str , nargs = '*' , help = \"The FITS files to analyze\" ) parser . add_argument ( \"-g\" , \"--gif\" , dest = \"gif\" , default = False , action = \"store_true\" , help = \"Generate the animated GIF of frames (computationally expensive)\" ) parser . add_argument ( \"--view\" , dest = \"view\" , default = False , action = \"store_true\" , help = \"Open a viewer once the file is generated\" ) parser . add_argument ( \"--start\" , dest = \"start\" , type = float , help = \"Zoom the plot in to this start time (in seconds).\" ) parser . add_argument ( \"--end\" , dest = \"end\" , type = float , help = \"Zoom the plot in to this end time (in seconds).\" ) parser . add_argument ( \"--snr\" , dest = \"snr\" , type = float , help = \"Run source extractor again with this SNR threshold\" ) parser . add_argument ( \"--minarea\" , dest = \"minarea\" , type = float , help = \"Run source extractor again with this minarea parameter\" ) parser . add_argument ( \"--deblend_nthresh\" , dest = \"deblend_nthresh\" , type = float , help = \"Run source extractor again with this deblend_nthresh\" ) parser . add_argument ( \"--deblend_cont\" , dest = \"deblend_cont\" , type = float , help = \"Run source extractor again with this deblend_cont parameter\" ) return super () . add_cmdline_args ( parser , cfg )","title":"AnalyzeTipTiltPerformance"},{"location":"scripts/AnalyzeTipTiltPerformance/#analyzetiptiltperformance","text":"Bases: KPFTranslatorFunction","title":"AnalyzeTipTiltPerformance"},{"location":"scripts/AnalyzeTipTiltPerformance/#kpf.analysis.AnalyzeTipTiltPerformance.AnalyzeTipTiltPerformance--description","text":"Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file.","title":"Description"},{"location":"scripts/AnalyzeTipTiltPerformance/#kpf.analysis.AnalyzeTipTiltPerformance.AnalyzeTipTiltPerformance--parameters","text":"None Source code in kpf/analysis/AnalyzeTipTiltPerformance.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 class AnalyzeTipTiltPerformance ( KPFTranslatorFunction ): '''# Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): viewer_command = find_viewer_command ( args ) for file in args . get ( 'files' ): file = Path ( file ) . expanduser () if file . exists () is False : log . error ( f \"Could not find file { args . get ( 'file' ) } \" ) plotfile = Path ( str ( file . name ) . replace ( '.fits' , '.png' )) plot_tiptilt_stats ( file , plotfile = plotfile , start = args . get ( 'start' , None ), end = args . get ( 'end' , None ), snr = args . get ( 'snr' , None ), minarea = args . get ( 'minarea' , None ), deblend_nthresh = args . get ( 'deblend_nthresh' , None ), deblend_cont = args . get ( 'deblend_cont' , None ), ) if viewer_command is not None : log . info ( f \"Opening { plotfile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { plotfile } \" ]) if args . get ( 'gif' ) is True : giffile = Path ( str ( file . name ) . replace ( '.fits' , '.gif' )) generate_cube_gif ( file , giffile ) if viewer_command is not None : log . info ( f \"Opening { giffile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { giffile } \" ]) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , type = str , nargs = '*' , help = \"The FITS files to analyze\" ) parser . add_argument ( \"-g\" , \"--gif\" , dest = \"gif\" , default = False , action = \"store_true\" , help = \"Generate the animated GIF of frames (computationally expensive)\" ) parser . add_argument ( \"--view\" , dest = \"view\" , default = False , action = \"store_true\" , help = \"Open a viewer once the file is generated\" ) parser . add_argument ( \"--start\" , dest = \"start\" , type = float , help = \"Zoom the plot in to this start time (in seconds).\" ) parser . add_argument ( \"--end\" , dest = \"end\" , type = float , help = \"Zoom the plot in to this end time (in seconds).\" ) parser . add_argument ( \"--snr\" , dest = \"snr\" , type = float , help = \"Run source extractor again with this SNR threshold\" ) parser . add_argument ( \"--minarea\" , dest = \"minarea\" , type = float , help = \"Run source extractor again with this minarea parameter\" ) parser . add_argument ( \"--deblend_nthresh\" , dest = \"deblend_nthresh\" , type = float , help = \"Run source extractor again with this deblend_nthresh\" ) parser . add_argument ( \"--deblend_cont\" , dest = \"deblend_cont\" , type = float , help = \"Run source extractor again with this deblend_cont parameter\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/BuildMasterBias/","text":"BuildMasterBias Bases: KPFTranslatorFunction Description Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate. KTL Keywords Used kpf_expmeter.BIAS_FILE Scripts Called None Parameters files ( list ) A list of files to combine. output ( str ) The output combined filename to write. Source code in kpf/expmeter/BuildMasterBias.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class BuildMasterBias ( KPFTranslatorFunction ): '''# Description Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. ## KTL Keywords Used - `kpf_expmeter.BIAS_FILE` ## Scripts Called None ## Parameters **files** (`list`) > A list of files to combine. **output** (`str`) > The output combined filename to write. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'files' , allowed_types = [ list ]) @classmethod def perform ( cls , args , logger , cfg ): biasfiles = [ Path ( biasfile ) for biasfile in args . get ( 'files' )] log . debug ( f \"Combining { len ( biasfiles ) } bias frames:\" ) biases = [] timestamps = [] for biasfile in biasfiles : log . debug ( f \" { biasfile . name } \" ) this_bias = CCDData . read ( biasfile , unit = \"adu\" ) biases . append ( this_bias ) timestamps . append ( this_bias [ 0 ] . header . get ( 'DATE-BEG' )) combiner = ccdproc . Combiner ( biases ) combiner . sigma_clipping ( low_thresh = 5 , high_thresh = 5 ) combined_average = combiner . average_combine () for i , timestamp in enumerate ( timestamps ): combined_average [ 0 ] . header [ f 'DATEBEG { i : 02d } ' ] = ( timestamp , 'DATE-BEG of file {i:02d} ' ) utnow = datetime . utcnow () combined_average [ 0 ] . header [ 'DATEMADE' ] = ( utnow . isoformat (), 'UT timestamp of file creation' ) if args . get ( 'output' , None ) not in [ None , '' ]: outputfile = Path ( args . get ( 'output' )) . expanduser () else : match_fn = re . match ( '([\\w\\d_]+)(\\d {6} )\\.(\\d {3} )\\.fits' , biasfiles [ 0 ] . name ) if match_fn is not None : frameno = match_fn . group ( 2 ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { frameno } .fits' ) else : now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { now_str } .fits' ) log . info ( f \"Writing { outputfile } \" ) combined_average . write ( outputfile , overwrite = True ) if args . get ( 'update' , False ) is True : bias_file = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) bias_file . write ( f \" { outputfile } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , nargs = '*' , help = \"The files to combine\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"BuildMasterBias"},{"location":"scripts/BuildMasterBias/#buildmasterbias","text":"Bases: KPFTranslatorFunction","title":"BuildMasterBias"},{"location":"scripts/BuildMasterBias/#kpf.expmeter.BuildMasterBias.BuildMasterBias--description","text":"Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate.","title":"Description"},{"location":"scripts/BuildMasterBias/#kpf.expmeter.BuildMasterBias.BuildMasterBias--ktl-keywords-used","text":"kpf_expmeter.BIAS_FILE","title":"KTL Keywords Used"},{"location":"scripts/BuildMasterBias/#kpf.expmeter.BuildMasterBias.BuildMasterBias--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/BuildMasterBias/#kpf.expmeter.BuildMasterBias.BuildMasterBias--parameters","text":"files ( list ) A list of files to combine. output ( str ) The output combined filename to write. Source code in kpf/expmeter/BuildMasterBias.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class BuildMasterBias ( KPFTranslatorFunction ): '''# Description Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. ## KTL Keywords Used - `kpf_expmeter.BIAS_FILE` ## Scripts Called None ## Parameters **files** (`list`) > A list of files to combine. **output** (`str`) > The output combined filename to write. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'files' , allowed_types = [ list ]) @classmethod def perform ( cls , args , logger , cfg ): biasfiles = [ Path ( biasfile ) for biasfile in args . get ( 'files' )] log . debug ( f \"Combining { len ( biasfiles ) } bias frames:\" ) biases = [] timestamps = [] for biasfile in biasfiles : log . debug ( f \" { biasfile . name } \" ) this_bias = CCDData . read ( biasfile , unit = \"adu\" ) biases . append ( this_bias ) timestamps . append ( this_bias [ 0 ] . header . get ( 'DATE-BEG' )) combiner = ccdproc . Combiner ( biases ) combiner . sigma_clipping ( low_thresh = 5 , high_thresh = 5 ) combined_average = combiner . average_combine () for i , timestamp in enumerate ( timestamps ): combined_average [ 0 ] . header [ f 'DATEBEG { i : 02d } ' ] = ( timestamp , 'DATE-BEG of file {i:02d} ' ) utnow = datetime . utcnow () combined_average [ 0 ] . header [ 'DATEMADE' ] = ( utnow . isoformat (), 'UT timestamp of file creation' ) if args . get ( 'output' , None ) not in [ None , '' ]: outputfile = Path ( args . get ( 'output' )) . expanduser () else : match_fn = re . match ( '([\\w\\d_]+)(\\d {6} )\\.(\\d {3} )\\.fits' , biasfiles [ 0 ] . name ) if match_fn is not None : frameno = match_fn . group ( 2 ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { frameno } .fits' ) else : now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { now_str } .fits' ) log . info ( f \"Writing { outputfile } \" ) combined_average . write ( outputfile , overwrite = True ) if args . get ( 'update' , False ) is True : bias_file = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) bias_file . write ( f \" { outputfile } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , nargs = '*' , help = \"The files to combine\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/BuildOBfromQuery/","text":"BuildOBfromQuery Bases: KPFTranslatorFunction Source code in kpf/utils/BuildOBfromQuery.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class BuildOBfromQuery ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GaiaID' ) @classmethod def perform ( cls , args , logger , cfg ): gaiaid = args . get ( 'GaiaID' ) observation = { 'ExpMeterMode' : \"monitor\" , 'AutoExpMeter' : \"False\" , 'TakeSimulCal' : \"True\" } OB = ScienceOB ({ 'GaiaID' : f \"DR3 { gaiaid } \" , 'SEQ_Observations' : [ observation ]}) # Get target name and 2MASS ID from Gaia ID names = get_names_from_gaiaid ( gaiaid ) if names is None : log . warning ( f \"Query for { gaiaid } failed to return names\" ) return OB . set ( 'TargetName' , f \" { names [ 'TargetName' ] } \" ) OB . set ( '2MASSID' , f \" { names [ '2MASSID' ] } \" ) # Using 2MASS ID query for Jmag twomass_params = get_Jmag ( names [ '2MASSID' ]) OB . set ( 'Jmag' , f \" { twomass_params [ 'Jmag' ] } \" ) # Using Gaia ID, query for Gaia parameters gaia_params = get_gaia_parameters ( gaiaid ) OB . set ( 'Parallax' , f \" { gaia_params [ 'Parallax' ] } \" ) OB . set ( 'RadialVelocity' , f \" { gaia_params [ 'RadialVelocity' ] } \" ) OB . set ( 'Gmag' , f \" { gaia_params [ 'Gmag' ] } \" ) OB . set ( 'Teff' , f \" { gaia_params [ 'Teff' ] } \" ) # Defaults OB . set ( 'GuideMode' , \"auto\" ) OB . set ( 'TriggerCaHK' , \"True\" ) OB . set ( 'TriggerGreen' , \"True\" ) OB . set ( 'TriggerRed' , \"True\" ) # Build Starlist line OB . star_list_line = form_starlist_line ( names [ 'TargetName' ], gaia_params [ 'RA_ICRS' ], gaia_params [ 'DE_ICRS' ], vmag = gaia_params [ 'Gmag' ]) print ( OB ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GaiaID' , type = str , help = 'Gaia DR3 ID to query for (e.g. \"35227046884571776\")' ) return super () . add_cmdline_args ( parser , cfg )","title":"BuildOBfromQuery"},{"location":"scripts/BuildOBfromQuery/#buildobfromquery","text":"Bases: KPFTranslatorFunction Source code in kpf/utils/BuildOBfromQuery.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class BuildOBfromQuery ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GaiaID' ) @classmethod def perform ( cls , args , logger , cfg ): gaiaid = args . get ( 'GaiaID' ) observation = { 'ExpMeterMode' : \"monitor\" , 'AutoExpMeter' : \"False\" , 'TakeSimulCal' : \"True\" } OB = ScienceOB ({ 'GaiaID' : f \"DR3 { gaiaid } \" , 'SEQ_Observations' : [ observation ]}) # Get target name and 2MASS ID from Gaia ID names = get_names_from_gaiaid ( gaiaid ) if names is None : log . warning ( f \"Query for { gaiaid } failed to return names\" ) return OB . set ( 'TargetName' , f \" { names [ 'TargetName' ] } \" ) OB . set ( '2MASSID' , f \" { names [ '2MASSID' ] } \" ) # Using 2MASS ID query for Jmag twomass_params = get_Jmag ( names [ '2MASSID' ]) OB . set ( 'Jmag' , f \" { twomass_params [ 'Jmag' ] } \" ) # Using Gaia ID, query for Gaia parameters gaia_params = get_gaia_parameters ( gaiaid ) OB . set ( 'Parallax' , f \" { gaia_params [ 'Parallax' ] } \" ) OB . set ( 'RadialVelocity' , f \" { gaia_params [ 'RadialVelocity' ] } \" ) OB . set ( 'Gmag' , f \" { gaia_params [ 'Gmag' ] } \" ) OB . set ( 'Teff' , f \" { gaia_params [ 'Teff' ] } \" ) # Defaults OB . set ( 'GuideMode' , \"auto\" ) OB . set ( 'TriggerCaHK' , \"True\" ) OB . set ( 'TriggerGreen' , \"True\" ) OB . set ( 'TriggerRed' , \"True\" ) # Build Starlist line OB . star_list_line = form_starlist_line ( names [ 'TargetName' ], gaia_params [ 'RA_ICRS' ], gaia_params [ 'DE_ICRS' ], vmag = gaia_params [ 'Gmag' ]) print ( OB ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GaiaID' , type = str , help = 'Gaia DR3 ID to query for (e.g. \"35227046884571776\")' ) return super () . add_cmdline_args ( parser , cfg )","title":"BuildOBfromQuery"},{"location":"scripts/CalLampPower/","text":"CalLampPower Bases: KPFTranslatorFunction Description Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate. KTL Keywords Used kpflamps.BRDBANDFIBER kpflamps.U_GOLD kpflamps.U_DAILY kpflamps.TH_DAILY kpflamps.TH_GOLD kpflamps.FF_FIBER kpflamps.EXPMLED kpflamps.HKLED kpflamps.SCILED kpflamps.SKYLED Scripts Called None Parameters lamp ( str ) Name of the lamp to control Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power ( str ) Destination state for lamp power Allowed Values: \"on\" or \"off\" Source code in kpf/calbench/CalLampPower.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class CalLampPower ( KPFTranslatorFunction ): '''# Description Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. ## KTL Keywords Used - `kpflamps.BRDBANDFIBER` - `kpflamps.U_GOLD` - `kpflamps.U_DAILY` - `kpflamps.TH_DAILY` - `kpflamps.TH_GOLD` - `kpflamps.FF_FIBER` - `kpflamps.EXPMLED` - `kpflamps.HKLED` - `kpflamps.SCILED` - `kpflamps.SKYLED` ## Scripts Called None ## Parameters **lamp** (`str`) > Name of the lamp to control <br>Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED **power** (`str`) > Destination state for lamp power <br>Allowed Values: \"on\" or \"off\" ''' @classmethod def pre_condition ( cls , args , logger , cfg ): # Check lamp name lamp = standardize_lamp_name ( args . get ( 'lamp' , None )) if lamp is None : msg = f \"Could not standardize lamp name { args . get ( 'lamp' ) } \" raise FailedPreCondition ( msg ) # Check power check_input ( args , 'power' , allowed_values = [ 'on' , 'off' ]) @classmethod def perform ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) log . debug ( f \"Turning { pwr } { lamp } \" ) kpflamps = ktl . cache ( 'kpflamps' ) kpflamps [ lamp ] . write ( pwr ) @classmethod def post_condition ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) timeout = cfg . getfloat ( 'times' , 'lamp_timeout' , fallback = 1 ) success = ktl . waitFor ( f \"($kpflamps. { lamp } == { pwr } )\" , timeout = timeout ) if success is not True : kpflamps = ktl . cache ( 'kpflamps' ) raise FailedPostCondition ( kpflamps [ lamp ], pwr ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' , 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ], help = 'Which lamp to control?' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"CalLampPower"},{"location":"scripts/CalLampPower/#callamppower","text":"Bases: KPFTranslatorFunction","title":"CalLampPower"},{"location":"scripts/CalLampPower/#kpf.calbench.CalLampPower.CalLampPower--description","text":"Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate.","title":"Description"},{"location":"scripts/CalLampPower/#kpf.calbench.CalLampPower.CalLampPower--ktl-keywords-used","text":"kpflamps.BRDBANDFIBER kpflamps.U_GOLD kpflamps.U_DAILY kpflamps.TH_DAILY kpflamps.TH_GOLD kpflamps.FF_FIBER kpflamps.EXPMLED kpflamps.HKLED kpflamps.SCILED kpflamps.SKYLED","title":"KTL Keywords Used"},{"location":"scripts/CalLampPower/#kpf.calbench.CalLampPower.CalLampPower--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/CalLampPower/#kpf.calbench.CalLampPower.CalLampPower--parameters","text":"lamp ( str ) Name of the lamp to control Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power ( str ) Destination state for lamp power Allowed Values: \"on\" or \"off\" Source code in kpf/calbench/CalLampPower.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class CalLampPower ( KPFTranslatorFunction ): '''# Description Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. ## KTL Keywords Used - `kpflamps.BRDBANDFIBER` - `kpflamps.U_GOLD` - `kpflamps.U_DAILY` - `kpflamps.TH_DAILY` - `kpflamps.TH_GOLD` - `kpflamps.FF_FIBER` - `kpflamps.EXPMLED` - `kpflamps.HKLED` - `kpflamps.SCILED` - `kpflamps.SKYLED` ## Scripts Called None ## Parameters **lamp** (`str`) > Name of the lamp to control <br>Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED **power** (`str`) > Destination state for lamp power <br>Allowed Values: \"on\" or \"off\" ''' @classmethod def pre_condition ( cls , args , logger , cfg ): # Check lamp name lamp = standardize_lamp_name ( args . get ( 'lamp' , None )) if lamp is None : msg = f \"Could not standardize lamp name { args . get ( 'lamp' ) } \" raise FailedPreCondition ( msg ) # Check power check_input ( args , 'power' , allowed_values = [ 'on' , 'off' ]) @classmethod def perform ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) log . debug ( f \"Turning { pwr } { lamp } \" ) kpflamps = ktl . cache ( 'kpflamps' ) kpflamps [ lamp ] . write ( pwr ) @classmethod def post_condition ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) timeout = cfg . getfloat ( 'times' , 'lamp_timeout' , fallback = 1 ) success = ktl . waitFor ( f \"($kpflamps. { lamp } == { pwr } )\" , timeout = timeout ) if success is not True : kpflamps = ktl . cache ( 'kpflamps' ) raise FailedPostCondition ( kpflamps [ lamp ], pwr ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' , 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ], help = 'Which lamp to control?' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/CalculateDAR/","text":"CalculateDAR Bases: KPFTranslatorFunction Return the DAR correction in arcseconds between the CRED2 wavelength and the science wavelength. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: :EL: float Elevation of the telescope. Source code in kpf/utils/CalculateDAR.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class CalculateDAR ( KPFTranslatorFunction ): '''Return the DAR correction in arcseconds between the CRED2 wavelength and the science wavelength. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: ===== :EL: `float` Elevation of the telescope. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): dcs = ktl . cache ( 'dcs1' ) EL = dcs [ 'EL' ] . read ( binary = True ) * 180 / np . pi DARarcsec = calculate_DAR_arcsec ( EL ) log . info ( f \"Calculated DAR for { EL : .1f } EL = { DARarcsec : .3f } arcsec\" ) dx , dy = calculate_DAR_pix ( DARarcsec ) log . info ( f \"Pixel shift is { dx : .1f } , { dy : .1f } = { ( dx ** 2 + dy ** 2 ) ** 0.5 : .1f } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"CalculateDAR"},{"location":"scripts/CalculateDAR/#calculatedar","text":"Bases: KPFTranslatorFunction Return the DAR correction in arcseconds between the CRED2 wavelength and the science wavelength. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982)","title":"CalculateDAR"},{"location":"scripts/CalculateDAR/#kpf.utils.CalculateDAR.CalculateDAR--args","text":":EL: float Elevation of the telescope. Source code in kpf/utils/CalculateDAR.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class CalculateDAR ( KPFTranslatorFunction ): '''Return the DAR correction in arcseconds between the CRED2 wavelength and the science wavelength. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: ===== :EL: `float` Elevation of the telescope. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): dcs = ktl . cache ( 'dcs1' ) EL = dcs [ 'EL' ] . read ( binary = True ) * 180 / np . pi DARarcsec = calculate_DAR_arcsec ( EL ) log . info ( f \"Calculated DAR for { EL : .1f } EL = { DARarcsec : .3f } arcsec\" ) dx , dy = calculate_DAR_pix ( DARarcsec ) log . info ( f \"Pixel shift is { dx : .1f } , { dy : .1f } = { ( dx ** 2 + dy ** 2 ) ** 0.5 : .1f } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/CheckDewarWeights/","text":"CheckDewarWeights Bases: KPFTranslatorFunction Check the weight of the red and green dewars and send email if they are lower than expected. ARGS: :dewar: str Which dewar to check? red or green :email: bool If True, send email if dewar weight is low Source code in kpf/utils/CheckDewarWeights.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class CheckDewarWeights ( KPFTranslatorFunction ): '''Check the weight of the red and green dewars and send email if they are lower than expected. ARGS: ===== :dewar: `str` Which dewar to check? red or green :email: `bool` If True, send email if dewar weight is low ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): dewar = args . get ( 'dewar' , 'green' ) fill_time = cfg . getint ( 'LN2' , 'fill_time' , fallback = 21 ) low_weight = cfg . getint ( 'LN2' , f 'low_weight_ { dewar } ' , fallback = 90 ) use_rate = cfg . getint ( 'LN2' , f 'use_rate_ { dewar } ' , fallback = 40 ) utcnow = datetime . utcnow () if utcnow . hour < fill_time : time_until_fill = fill_time - ( utcnow . hour + utcnow . minute / 60 ) else : time_until_fill = fill_time + 24 - ( utcnow . hour + utcnow . minute / 60 ) kpffill = ktl . cache ( 'kpffill' ) weight = kpffill [ f ' { dewar } WEIGHT' ] . read ( binary = True ) weight_at_fill = weight - ( time_until_fill / 24 ) * use_rate if weight_at_fill > low_weight : # Dewar fill level is ok print ( 'Dewar weight is OK' ) else : # Dewar fill level is not ok print ( 'Dewar weight is low!' ) if args . get ( 'email' , False ) is True : try : msg = [ f 'KPF { dewar } dewar weight is low' , f '' , f 'Current dewar weight: { weight : .1f } ' , f 'Estimated weight at 11am fill: { weight_at_fill : .1f } ' , ] SendEmail . execute ({ 'Subject' : f 'KPF { dewar } dewar weight is low' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'dewar' , type = str , choices = [ 'green' , 'red' ], default = 'green' , help = 'Which dewar to check? red or green' ) parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if dewar weight is low' ) return super () . add_cmdline_args ( parser , cfg )","title":"CheckDewarWeights"},{"location":"scripts/CheckDewarWeights/#checkdewarweights","text":"Bases: KPFTranslatorFunction Check the weight of the red and green dewars and send email if they are lower than expected.","title":"CheckDewarWeights"},{"location":"scripts/CheckDewarWeights/#kpf.utils.CheckDewarWeights.CheckDewarWeights--args","text":":dewar: str Which dewar to check? red or green :email: bool If True, send email if dewar weight is low Source code in kpf/utils/CheckDewarWeights.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class CheckDewarWeights ( KPFTranslatorFunction ): '''Check the weight of the red and green dewars and send email if they are lower than expected. ARGS: ===== :dewar: `str` Which dewar to check? red or green :email: `bool` If True, send email if dewar weight is low ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): dewar = args . get ( 'dewar' , 'green' ) fill_time = cfg . getint ( 'LN2' , 'fill_time' , fallback = 21 ) low_weight = cfg . getint ( 'LN2' , f 'low_weight_ { dewar } ' , fallback = 90 ) use_rate = cfg . getint ( 'LN2' , f 'use_rate_ { dewar } ' , fallback = 40 ) utcnow = datetime . utcnow () if utcnow . hour < fill_time : time_until_fill = fill_time - ( utcnow . hour + utcnow . minute / 60 ) else : time_until_fill = fill_time + 24 - ( utcnow . hour + utcnow . minute / 60 ) kpffill = ktl . cache ( 'kpffill' ) weight = kpffill [ f ' { dewar } WEIGHT' ] . read ( binary = True ) weight_at_fill = weight - ( time_until_fill / 24 ) * use_rate if weight_at_fill > low_weight : # Dewar fill level is ok print ( 'Dewar weight is OK' ) else : # Dewar fill level is not ok print ( 'Dewar weight is low!' ) if args . get ( 'email' , False ) is True : try : msg = [ f 'KPF { dewar } dewar weight is low' , f '' , f 'Current dewar weight: { weight : .1f } ' , f 'Estimated weight at 11am fill: { weight_at_fill : .1f } ' , ] SendEmail . execute ({ 'Subject' : f 'KPF { dewar } dewar weight is low' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'dewar' , type = str , choices = [ 'green' , 'red' ], default = 'green' , help = 'Which dewar to check? red or green' ) parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if dewar weight is low' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/CleanupAfterCalibrations/","text":"CleanupAfterCalibrations Bases: KPFTranslatorFunction Script which cleans up after Cal OBs. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.post_observation_cleanup . ARGS: :OB: dict A fully specified calibration observing block (OB). Source code in kpf/scripts/CleanupAfterCalibrations.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class CleanupAfterCalibrations ( KPFTranslatorFunction ): '''Script which cleans up after Cal OBs. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.post_observation_cleanup`. ARGS: ===== :OB: `dict` A fully specified calibration observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) # Power off lamps if OB . get ( 'leave_lamps_on' , False ) == True : log . info ( 'Not turning lamps off because command line option was invoked' ) else : sequence = OB . get ( 'SEQ_Calibrations' , None ) lamps = set ([ x [ 'CalSource' ] for x in sequence if x [ 'CalSource' ] != 'Home' ]) \\ if sequence is not None else [] for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'off' }) if lamp == 'LFCFiber' : SetLFCtoStandbyHigh . execute ({}) kpfconfig = ktl . cache ( 'kpfconfig' ) runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) log . info ( f \"Stowing FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Set OBJECT back to empty string log . info ( 'Waiting for readout to finish' ) WaitForReady . execute ({}) SetObject . execute ({ 'Object' : '' }) # Clear target info SetTargetInfo . execute ({}) clear_script_keywords () @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) return super () . add_cmdline_args ( parser , cfg )","title":"CleanupAfterCalibrations"},{"location":"scripts/CleanupAfterCalibrations/#cleanupaftercalibrations","text":"Bases: KPFTranslatorFunction Script which cleans up after Cal OBs. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.post_observation_cleanup .","title":"CleanupAfterCalibrations"},{"location":"scripts/CleanupAfterCalibrations/#kpf.scripts.CleanupAfterCalibrations.CleanupAfterCalibrations--args","text":":OB: dict A fully specified calibration observing block (OB). Source code in kpf/scripts/CleanupAfterCalibrations.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class CleanupAfterCalibrations ( KPFTranslatorFunction ): '''Script which cleans up after Cal OBs. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.post_observation_cleanup`. ARGS: ===== :OB: `dict` A fully specified calibration observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) # Power off lamps if OB . get ( 'leave_lamps_on' , False ) == True : log . info ( 'Not turning lamps off because command line option was invoked' ) else : sequence = OB . get ( 'SEQ_Calibrations' , None ) lamps = set ([ x [ 'CalSource' ] for x in sequence if x [ 'CalSource' ] != 'Home' ]) \\ if sequence is not None else [] for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'off' }) if lamp == 'LFCFiber' : SetLFCtoStandbyHigh . execute ({}) kpfconfig = ktl . cache ( 'kpfconfig' ) runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) log . info ( f \"Stowing FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Set OBJECT back to empty string log . info ( 'Waiting for readout to finish' ) WaitForReady . execute ({}) SetObject . execute ({ 'Object' : '' }) # Clear target info SetTargetInfo . execute ({}) clear_script_keywords () @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/CleanupAfterScience/","text":"CleanupAfterScience Bases: KPFTranslatorFunction Script which cleans up at the end of Science OBs. Can be called by ddoi_script_functions.post_observation_cleanup . ARGS: :OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/CleanupAfterScience.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class CleanupAfterScience ( KPFTranslatorFunction ): '''Script which cleans up at the end of Science OBs. Can be called by `ddoi_script_functions.post_observation_cleanup`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) if OB . get ( 'GuideMode' , 'off' ) != 'off' : StopTipTilt . execute ({}) kpfconfig = ktl . cache ( 'kpfconfig' ) runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) # Clear target info log . debug ( 'Clearing target info' ) SetTargetInfo . execute ({}) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Set SKY_OFFSET back to 0 0 log . debug ( 'Clearing kpfguide.SKY_OFFSET' ) sky_offset = ktl . cache ( 'kpfguide' , 'SKY_OFFSET' ) sky_offset . write ( '0 0' ) clear_script_keywords () @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"CleanupAfterScience"},{"location":"scripts/CleanupAfterScience/#cleanupafterscience","text":"Bases: KPFTranslatorFunction Script which cleans up at the end of Science OBs. Can be called by ddoi_script_functions.post_observation_cleanup .","title":"CleanupAfterScience"},{"location":"scripts/CleanupAfterScience/#kpf.scripts.CleanupAfterScience.CleanupAfterScience--args","text":":OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/CleanupAfterScience.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class CleanupAfterScience ( KPFTranslatorFunction ): '''Script which cleans up at the end of Science OBs. Can be called by `ddoi_script_functions.post_observation_cleanup`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) if OB . get ( 'GuideMode' , 'off' ) != 'off' : StopTipTilt . execute ({}) kpfconfig = ktl . cache ( 'kpfconfig' ) runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) # Clear target info log . debug ( 'Clearing target info' ) SetTargetInfo . execute ({}) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Set SKY_OFFSET back to 0 0 log . debug ( 'Clearing kpfguide.SKY_OFFSET' ) sky_offset = ktl . cache ( 'kpfguide' , 'SKY_OFFSET' ) sky_offset . write ( '0 0' ) clear_script_keywords () @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/CollectGuiderDarkCubes/","text":"CollectGuiderDarkCubes Bases: KPFTranslatorFunction Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 ARGS: None Source code in kpf/scripts/CollectGuiderDarkCubes.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class CollectGuiderDarkCubes ( KPFTranslatorFunction ): '''Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 ARGS: ===== None ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/CRED2DarkCubes/CRED2_dark_cubes.txt' ) OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) original_OUTDIR = OUTDIR . read () new_OUTDIR = str ( output_file . parent ) log . debug ( f 'Setting OUTDIR to { new_OUTDIR } ' ) OUTDIR . write ( new_OUTDIR ) SENSORSETP = ktl . cache ( 'kpfguide' , 'SENSORSETP' ) SENSORTEMP = ktl . cache ( 'kpfguide' , 'SENSORTEMP' ) CONTINUOUS = ktl . cache ( 'kpfguide' , 'CONTINUOUS' ) kpfguide = ktl . cache ( 'kpfguide' ) try : log . info ( 'Taking CRED2 dark cubes' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) log . info ( 'Cooling CRED2' ) SENSORSETP . write ( - 40 ) log . info ( 'Waiting up to 10 minutes for detector to reach set point' ) reached_temp = SENSORTEMP . waitFor ( \"<-39.9\" , timeout = 600 ) if reached_temp == False : log . error ( 'CRED2 failed to reach set point. Exiting.' ) SENSORSETP . write ( 0 ) return check_scriptstop () log . debug ( 'Waiting additional time for temperature to stabilize' ) time . sleep ( 60 ) # shim to give time to stabilize check_scriptstop () log . debug ( 'Closing source shutters' ) SetSourceSelectShutters . execute ({}) CONTINUOUS . write ( 'Active' ) SetGuiderFPS . execute ({ 'GuideFPS' : 100 }) for gain in [ 'high' , 'medium' , 'low' ]: log . info ( f 'Collecting { gain } gain cube' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : f . write ( f \" { gain : 12s } , { cube_file } \\n \" ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () for gain in [ 'high' , 'medium' , 'low' ]: sub_file = kpfguide [ f 'SUB_ { gain . upper () } ' ] . read () kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( '' ) log . info ( f 'Collecting { gain } gain cube without bias subtraction' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : gain_string = f ' { gain } _nosub' f . write ( f \" { gain_string : 12s } , { cube_file } \\n \" ) kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( sub_file ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () except Exception as e : log . error ( 'Error running CollectGuiderDarkCubes' ) log . debug ( e ) log . info ( 'Resetting CRED2 temperature set point to 0' ) SENSORSETP . write ( 0 ) log . debug ( f 'Setting OUTDIR to { original_OUTDIR } ' ) OUTDIR . write ( original_OUTDIR ) clear_script_keywords () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"CollectGuiderDarkCubes"},{"location":"scripts/CollectGuiderDarkCubes/#collectguiderdarkcubes","text":"Bases: KPFTranslatorFunction Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0","title":"CollectGuiderDarkCubes"},{"location":"scripts/CollectGuiderDarkCubes/#kpf.scripts.CollectGuiderDarkCubes.CollectGuiderDarkCubes--args","text":"None Source code in kpf/scripts/CollectGuiderDarkCubes.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class CollectGuiderDarkCubes ( KPFTranslatorFunction ): '''Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 ARGS: ===== None ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/CRED2DarkCubes/CRED2_dark_cubes.txt' ) OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) original_OUTDIR = OUTDIR . read () new_OUTDIR = str ( output_file . parent ) log . debug ( f 'Setting OUTDIR to { new_OUTDIR } ' ) OUTDIR . write ( new_OUTDIR ) SENSORSETP = ktl . cache ( 'kpfguide' , 'SENSORSETP' ) SENSORTEMP = ktl . cache ( 'kpfguide' , 'SENSORTEMP' ) CONTINUOUS = ktl . cache ( 'kpfguide' , 'CONTINUOUS' ) kpfguide = ktl . cache ( 'kpfguide' ) try : log . info ( 'Taking CRED2 dark cubes' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) log . info ( 'Cooling CRED2' ) SENSORSETP . write ( - 40 ) log . info ( 'Waiting up to 10 minutes for detector to reach set point' ) reached_temp = SENSORTEMP . waitFor ( \"<-39.9\" , timeout = 600 ) if reached_temp == False : log . error ( 'CRED2 failed to reach set point. Exiting.' ) SENSORSETP . write ( 0 ) return check_scriptstop () log . debug ( 'Waiting additional time for temperature to stabilize' ) time . sleep ( 60 ) # shim to give time to stabilize check_scriptstop () log . debug ( 'Closing source shutters' ) SetSourceSelectShutters . execute ({}) CONTINUOUS . write ( 'Active' ) SetGuiderFPS . execute ({ 'GuideFPS' : 100 }) for gain in [ 'high' , 'medium' , 'low' ]: log . info ( f 'Collecting { gain } gain cube' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : f . write ( f \" { gain : 12s } , { cube_file } \\n \" ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () for gain in [ 'high' , 'medium' , 'low' ]: sub_file = kpfguide [ f 'SUB_ { gain . upper () } ' ] . read () kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( '' ) log . info ( f 'Collecting { gain } gain cube without bias subtraction' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : gain_string = f ' { gain } _nosub' f . write ( f \" { gain_string : 12s } , { cube_file } \\n \" ) kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( sub_file ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () except Exception as e : log . error ( 'Error running CollectGuiderDarkCubes' ) log . debug ( e ) log . info ( 'Resetting CRED2 temperature set point to 0' ) SENSORSETP . write ( 0 ) log . debug ( f 'Setting OUTDIR to { original_OUTDIR } ' ) OUTDIR . write ( original_OUTDIR ) clear_script_keywords () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ConfigureFIU/","text":"ConfigureFIU Bases: KPFTranslatorFunction Set the FIU mode (kpffiu.MODE). IF the wait option is fale this will retry the move if it fails with a configurable number of retries. ARGS: :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration :wait: (bool) Wait for move to complete before returning? (default: True) Source code in kpf/fiu/ConfigureFIU.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ConfigureFIU ( KPFTranslatorFunction ): '''Set the FIU mode (kpffiu.MODE). IF the wait option is fale this will retry the move if it fails with a configurable number of retries. ARGS: ===== :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration :wait: (bool) Wait for move to complete before returning? (default: True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) wait = args . get ( 'wait' , True ) log . info ( f \"Configuring FIU for { dest } \" ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : wait }) if wait == True : WaitForConfigureFIU . execute ({ 'mode' : dest }) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ConfigureFIU"},{"location":"scripts/ConfigureFIU/#configurefiu","text":"Bases: KPFTranslatorFunction Set the FIU mode (kpffiu.MODE). IF the wait option is fale this will retry the move if it fails with a configurable number of retries.","title":"ConfigureFIU"},{"location":"scripts/ConfigureFIU/#kpf.fiu.ConfigureFIU.ConfigureFIU--args","text":":mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration :wait: (bool) Wait for move to complete before returning? (default: True) Source code in kpf/fiu/ConfigureFIU.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ConfigureFIU ( KPFTranslatorFunction ): '''Set the FIU mode (kpffiu.MODE). IF the wait option is fale this will retry the move if it fails with a configurable number of retries. ARGS: ===== :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration :wait: (bool) Wait for move to complete before returning? (default: True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) wait = args . get ( 'wait' , True ) log . info ( f \"Configuring FIU for { dest } \" ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : wait }) if wait == True : WaitForConfigureFIU . execute ({ 'mode' : dest }) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/ConfigureForAcquisition/","text":"ConfigureForAcquisition Bases: KPFTranslatorFunction Script which configures the instrument for Acquisition step. Sets target parameters Sets guide camera parameters Sets FIU mode Executes Slew Cal This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_acquisition . ARGS: :OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/ConfigureForAcquisition.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class ConfigureForAcquisition ( KPFTranslatorFunction ): '''Script which configures the instrument for Acquisition step. - Sets target parameters - Sets guide camera parameters - Sets FIU mode - Executes Slew Cal This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_acquisition`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) # Check guider parameters guide_mode = OB . get ( 'GuideMode' , 'off' ) if guide_mode == 'auto' : check_input ( OB , 'Jmag' , allowed_types = [ float , int ]) # Check Slewcals kpfconfig = ktl . cache ( 'kpfconfig' ) if kpfconfig [ 'SLEWCALREQ' ] . read ( binary = True ) is True : slewcal_argsfile = Path ( kpfconfig [ 'SLEWCALFILE' ] . read ()) if slewcal_argsfile . exists () is False : raise FailedPreCondition ( f \"Slew cal file { slewcal_argsfile } does not exist\" ) @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Observations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set Octagon kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) ## Execute Slew Cal if Requested if kpfconfig [ 'SLEWCALREQ' ] . read ( binary = True ) is True : slewcal_argsfile = Path ( kpfconfig [ 'SLEWCALFILE' ] . read ()) log . info ( f \"Beginning Slew Cal\" ) log . debug ( f \"Using: { slewcal_argsfile } \" ) with open ( slewcal_argsfile , 'r' ) as file : slewcal_OB = yaml . safe_load ( file ) slewcal_args = slewcal_OB . get ( 'SEQ_Calibrations' )[ 0 ] slewcal_args [ 'Template_Name' ] = 'kpf_slewcal' slewcal_args [ 'Template_Version' ] = '0.5' slewcal_args [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] slewcal_args [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] slewcal_args [ 'TriggerRed' ] = OB [ 'TriggerRed' ] ExecuteSlewCal . execute ( slewcal_args ) log . info ( 'Slew cal complete. Resetting SLEWCALREQ' ) kpfconfig [ 'SLEWCALREQ' ] . write ( 'No' ) # Set FIU Mode log . info ( 'Setting FIU mode to Observing' ) ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set Target Parameters from OB SetTargetInfo . execute ( OB ) # Set guide camera parameters guide_mode = OB . get ( 'GuideMode' , 'off' ) if guide_mode == 'manual' : if OB . get ( 'GuideCamGain' , None ) is not None : SetGuiderGain . execute ( OB ) if OB . get ( 'GuideFPS' , None ) is not None : SetGuiderFPS . execute ( OB ) elif guide_mode == 'auto' : guider_parameters = PredictGuiderParameters . execute ( OB ) SetGuiderGain . execute ( guider_parameters ) SetGuiderFPS . execute ( guider_parameters ) elif guide_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both log . info ( f \"GuideMode is off, no guider parameters set\" ) else : log . error ( f \"Guide mode ' { guide_mode } ' is not supported.\" ) log . error ( f \"Not setting guider parameters.\" ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ConfigureForAcquisition"},{"location":"scripts/ConfigureForAcquisition/#configureforacquisition","text":"Bases: KPFTranslatorFunction Script which configures the instrument for Acquisition step. Sets target parameters Sets guide camera parameters Sets FIU mode Executes Slew Cal This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_acquisition .","title":"ConfigureForAcquisition"},{"location":"scripts/ConfigureForAcquisition/#kpf.scripts.ConfigureForAcquisition.ConfigureForAcquisition--args","text":":OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/ConfigureForAcquisition.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class ConfigureForAcquisition ( KPFTranslatorFunction ): '''Script which configures the instrument for Acquisition step. - Sets target parameters - Sets guide camera parameters - Sets FIU mode - Executes Slew Cal This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_acquisition`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) # Check guider parameters guide_mode = OB . get ( 'GuideMode' , 'off' ) if guide_mode == 'auto' : check_input ( OB , 'Jmag' , allowed_types = [ float , int ]) # Check Slewcals kpfconfig = ktl . cache ( 'kpfconfig' ) if kpfconfig [ 'SLEWCALREQ' ] . read ( binary = True ) is True : slewcal_argsfile = Path ( kpfconfig [ 'SLEWCALFILE' ] . read ()) if slewcal_argsfile . exists () is False : raise FailedPreCondition ( f \"Slew cal file { slewcal_argsfile } does not exist\" ) @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Observations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set Octagon kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) ## Execute Slew Cal if Requested if kpfconfig [ 'SLEWCALREQ' ] . read ( binary = True ) is True : slewcal_argsfile = Path ( kpfconfig [ 'SLEWCALFILE' ] . read ()) log . info ( f \"Beginning Slew Cal\" ) log . debug ( f \"Using: { slewcal_argsfile } \" ) with open ( slewcal_argsfile , 'r' ) as file : slewcal_OB = yaml . safe_load ( file ) slewcal_args = slewcal_OB . get ( 'SEQ_Calibrations' )[ 0 ] slewcal_args [ 'Template_Name' ] = 'kpf_slewcal' slewcal_args [ 'Template_Version' ] = '0.5' slewcal_args [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] slewcal_args [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] slewcal_args [ 'TriggerRed' ] = OB [ 'TriggerRed' ] ExecuteSlewCal . execute ( slewcal_args ) log . info ( 'Slew cal complete. Resetting SLEWCALREQ' ) kpfconfig [ 'SLEWCALREQ' ] . write ( 'No' ) # Set FIU Mode log . info ( 'Setting FIU mode to Observing' ) ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set Target Parameters from OB SetTargetInfo . execute ( OB ) # Set guide camera parameters guide_mode = OB . get ( 'GuideMode' , 'off' ) if guide_mode == 'manual' : if OB . get ( 'GuideCamGain' , None ) is not None : SetGuiderGain . execute ( OB ) if OB . get ( 'GuideFPS' , None ) is not None : SetGuiderFPS . execute ( OB ) elif guide_mode == 'auto' : guider_parameters = PredictGuiderParameters . execute ( OB ) SetGuiderGain . execute ( guider_parameters ) SetGuiderFPS . execute ( guider_parameters ) elif guide_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both log . info ( f \"GuideMode is off, no guider parameters set\" ) else : log . error ( f \"Guide mode ' { guide_mode } ' is not supported.\" ) log . error ( f \"Not setting guider parameters.\" ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ConfigureForCalibrations/","text":"ConfigureForCalibrations Bases: KPFTranslatorFunction Script which configures the instrument for Cal OBs. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_science . ARGS: :OB: dict A fully specified calibration observing block (OB). Source code in kpf/scripts/ConfigureForCalibrations.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class ConfigureForCalibrations ( KPFTranslatorFunction ): '''Script which configures the instrument for Cal OBs. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_science`. ARGS: ===== :OB: `dict` A fully specified calibration observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) check_scriptstop () # Power up needed lamps sequence = OB . get ( 'SEQ_Calibrations' , None ) lamps = set ([ x [ 'CalSource' ] for x in sequence if x [ 'CalSource' ] != 'Home' ]) \\ if sequence is not None else [] for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'on' }) log . debug ( f \"Ensuring back illumination LEDs are off\" ) CalLampPower . execute ({ 'lamp' : 'ExpMeterLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'CaHKLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SciLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SkyLED' , 'power' : 'off' }) log . info ( f \"Configuring FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Calibration' }) log . info ( f \"Set Detector List\" ) WaitForReady . execute ({}) SetTriggeredDetectors . execute ( OB ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ConfigureForCalibrations"},{"location":"scripts/ConfigureForCalibrations/#configureforcalibrations","text":"Bases: KPFTranslatorFunction Script which configures the instrument for Cal OBs. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_science .","title":"ConfigureForCalibrations"},{"location":"scripts/ConfigureForCalibrations/#kpf.scripts.ConfigureForCalibrations.ConfigureForCalibrations--args","text":":OB: dict A fully specified calibration observing block (OB). Source code in kpf/scripts/ConfigureForCalibrations.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class ConfigureForCalibrations ( KPFTranslatorFunction ): '''Script which configures the instrument for Cal OBs. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_science`. ARGS: ===== :OB: `dict` A fully specified calibration observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) check_scriptstop () # Power up needed lamps sequence = OB . get ( 'SEQ_Calibrations' , None ) lamps = set ([ x [ 'CalSource' ] for x in sequence if x [ 'CalSource' ] != 'Home' ]) \\ if sequence is not None else [] for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'on' }) log . debug ( f \"Ensuring back illumination LEDs are off\" ) CalLampPower . execute ({ 'lamp' : 'ExpMeterLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'CaHKLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SciLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SkyLED' , 'power' : 'off' }) log . info ( f \"Configuring FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Calibration' }) log . info ( f \"Set Detector List\" ) WaitForReady . execute ({}) SetTriggeredDetectors . execute ( OB ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ConfigureForScience/","text":"ConfigureForScience Bases: KPFTranslatorFunction Script which configures the instrument for Science observations. If needed, start tip tilt loops Sets octagon / simulcal source Sets source select shutters Set triggered detectors This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_science . ARGS: :OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/ConfigureForScience.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class ConfigureForScience ( KPFTranslatorFunction ): '''Script which configures the instrument for Science observations. - If needed, start tip tilt loops - Sets octagon / simulcal source - Sets source select shutters - Set triggered detectors This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_science`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) return True @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Observations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) check_scriptstop () # Check tip tilt loops requested_mode = OB . get ( 'GuideMode' , 'off' ) kpfguide = ktl . cache ( 'kpfguide' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read () tt_control = kpfguide [ 'TIPTILT_CONTROL' ] . read () if ( requested_mode in [ 'manual' , 'auto' ] and all_loops in [ 'Inactive' , 'Mixed' ]) \\ or ( requested_mode in [ 'off' , 'telescope' , False ] and tt_control == 'Active' ): log . error ( f 'OB requesting { requested_mode } , but guide loops ' f 'are: { all_loops } ( { tt_control } )' ) # Check with user log . debug ( 'Asking for user input' ) print () print ( \"#####################################################\" ) print ( \"The tip tilt loops are not in the expected state based\" ) print ( \"on the information in the OB.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () if requested_mode in [ 'manual' , 'auto' ]: matched_PO = VerifyCurrentBase . execute ({}) if matched_PO == False : # Check with user log . debug ( 'Asking for user input' ) print () print ( \"#####################################################\" ) print ( \"The dcs.PONAME value is incosistent with CURRENT_BASE\" ) print ( \"Please double check that the target object is where you\" ) print ( \"want it to be before proceeding.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () # Set Octagon kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) check_scriptstop () exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . debug ( f \"kpfexpose is Ready\" ) # Set source select shutters log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'SSS_Science' : True , 'SSS_Sky' : not OB . get ( 'BlockSky' , False ), 'SSS_SoCalSci' : False , 'SSS_SoCalCal' : False , 'SSS_CalSciSky' : False }) # Set Triggered Detectors OB [ 'TriggerGuide' ] = ( OB . get ( 'GuideMode' , 'off' ) != 'off' ) SetTriggeredDetectors . execute ( OB ) check_scriptstop () @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ConfigureForScience"},{"location":"scripts/ConfigureForScience/#configureforscience","text":"Bases: KPFTranslatorFunction Script which configures the instrument for Science observations. If needed, start tip tilt loops Sets octagon / simulcal source Sets source select shutters Set triggered detectors This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. Can be called by ddoi_script_functions.configure_for_science .","title":"ConfigureForScience"},{"location":"scripts/ConfigureForScience/#kpf.scripts.ConfigureForScience.ConfigureForScience--args","text":":OB: dict A fully specified science observing block (OB). Source code in kpf/scripts/ConfigureForScience.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 class ConfigureForScience ( KPFTranslatorFunction ): '''Script which configures the instrument for Science observations. - If needed, start tip tilt loops - Sets octagon / simulcal source - Sets source select shutters - Set triggered detectors This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. Can be called by `ddoi_script_functions.configure_for_science`. ARGS: ===== :OB: `dict` A fully specified science observing block (OB). ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) return True @classmethod def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Observations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) check_scriptstop () # Check tip tilt loops requested_mode = OB . get ( 'GuideMode' , 'off' ) kpfguide = ktl . cache ( 'kpfguide' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read () tt_control = kpfguide [ 'TIPTILT_CONTROL' ] . read () if ( requested_mode in [ 'manual' , 'auto' ] and all_loops in [ 'Inactive' , 'Mixed' ]) \\ or ( requested_mode in [ 'off' , 'telescope' , False ] and tt_control == 'Active' ): log . error ( f 'OB requesting { requested_mode } , but guide loops ' f 'are: { all_loops } ( { tt_control } )' ) # Check with user log . debug ( 'Asking for user input' ) print () print ( \"#####################################################\" ) print ( \"The tip tilt loops are not in the expected state based\" ) print ( \"on the information in the OB.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () if requested_mode in [ 'manual' , 'auto' ]: matched_PO = VerifyCurrentBase . execute ({}) if matched_PO == False : # Check with user log . debug ( 'Asking for user input' ) print () print ( \"#####################################################\" ) print ( \"The dcs.PONAME value is incosistent with CURRENT_BASE\" ) print ( \"Please double check that the target object is where you\" ) print ( \"want it to be before proceeding.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () # Set Octagon kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) check_scriptstop () exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . debug ( f \"kpfexpose is Ready\" ) # Set source select shutters log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'SSS_Science' : True , 'SSS_Sky' : not OB . get ( 'BlockSky' , False ), 'SSS_SoCalSci' : False , 'SSS_SoCalCal' : False , 'SSS_CalSciSky' : False }) # Set Triggered Detectors OB [ 'TriggerGuide' ] = ( OB . get ( 'GuideMode' , 'off' ) != 'off' ) SetTriggeredDetectors . execute ( OB ) check_scriptstop () @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ControlAOHatch/","text":"ControlAOHatch Bases: KPFTranslatorFunction Description Command the AO Hatch to open or close. KTL Keywords Used ao.AOHATCHCMD ao.AOHATCHSTS Scripts Called None Parameters destination ( str ) The destination position. Allowed Values: 'open' or 'close' Source code in kpf/ao/ControlAOHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class ControlAOHatch ( KPFTranslatorFunction ): '''# Description Command the AO Hatch to open or close. ## KTL Keywords Used - `ao.AOHATCHCMD` - `ao.AOHATCHSTS` ## Scripts Called None ## Parameters **destination** (`str`) > The destination position. <br>Allowed Values: 'open' or 'close' ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'destination' , allowed_values = [ 'close' , 'closed' , 'open' ]) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AO Hatch to { destination } \" ) cmd = { 'close' : 1 , 'closed' : 1 , 'open' : 0 }[ destination ] ao [ 'aohatchcmd' ] . write ( cmd ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () final_dest = { 'close' : 'closed' , 'closed' : 'closed' , 'open' : 'open' }[ destination ] aohatchsts = ktl . cache ( 'ao' , 'AOHATCHSTS' ) success = aohatchsts . waitfor ( f \"== ' { final_dest } '\" , timeout = 30 ) if success is not True : raise FailedToReachDestination ( aohatchsts . read (), final_dest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'close' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser , cfg )","title":"ControlAOHatch"},{"location":"scripts/ControlAOHatch/#controlaohatch","text":"Bases: KPFTranslatorFunction","title":"ControlAOHatch"},{"location":"scripts/ControlAOHatch/#kpf.ao.ControlAOHatch.ControlAOHatch--description","text":"Command the AO Hatch to open or close.","title":"Description"},{"location":"scripts/ControlAOHatch/#kpf.ao.ControlAOHatch.ControlAOHatch--ktl-keywords-used","text":"ao.AOHATCHCMD ao.AOHATCHSTS","title":"KTL Keywords Used"},{"location":"scripts/ControlAOHatch/#kpf.ao.ControlAOHatch.ControlAOHatch--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/ControlAOHatch/#kpf.ao.ControlAOHatch.ControlAOHatch--parameters","text":"destination ( str ) The destination position. Allowed Values: 'open' or 'close' Source code in kpf/ao/ControlAOHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class ControlAOHatch ( KPFTranslatorFunction ): '''# Description Command the AO Hatch to open or close. ## KTL Keywords Used - `ao.AOHATCHCMD` - `ao.AOHATCHSTS` ## Scripts Called None ## Parameters **destination** (`str`) > The destination position. <br>Allowed Values: 'open' or 'close' ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'destination' , allowed_values = [ 'close' , 'closed' , 'open' ]) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AO Hatch to { destination } \" ) cmd = { 'close' : 1 , 'closed' : 1 , 'open' : 0 }[ destination ] ao [ 'aohatchcmd' ] . write ( cmd ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () final_dest = { 'close' : 'closed' , 'closed' : 'closed' , 'open' : 'open' }[ destination ] aohatchsts = ktl . cache ( 'ao' , 'AOHATCHSTS' ) success = aohatchsts . waitfor ( f \"== ' { final_dest } '\" , timeout = 30 ) if success is not True : raise FailedToReachDestination ( aohatchsts . read (), final_dest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'close' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/ControlFoldMirror/","text":"ControlFoldMirror Bases: KPFTranslatorFunction Insert or remove the FIU Cal Fold Mirror from the beam. ARGS: :destination: The desired FIU fold mirror position name :wait: (bool) Wait for move to complete before returning? (default: True) Source code in kpf/fiu/ControlFoldMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ControlFoldMirror ( KPFTranslatorFunction ): '''Insert or remove the FIU Cal Fold Mirror from the beam. ARGS: ===== :destination: The desired FIU fold mirror position name :wait: (bool) Wait for move to complete before returning? (default: True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () if destination . lower () not in [ 'in' , 'out' ]: raise FailedPreCondition ( f \"Requested state { destination } is invalid\" ) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'FOLDNAM' ] . write ( destination ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_fold_mirror_move_time' , fallback = 5 ) success = ktl . waitFor ( f '($kpffiu.foldnam == { destination } )' , timeout = timeout ) if success is not True : foldnam = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) raise FailedToReachDestination ( foldnam . read (), destination ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'in' , 'out' ], help = 'Desired fold mirror position' ) return super () . add_cmdline_args ( parser , cfg )","title":"ControlFoldMirror"},{"location":"scripts/ControlFoldMirror/#controlfoldmirror","text":"Bases: KPFTranslatorFunction Insert or remove the FIU Cal Fold Mirror from the beam.","title":"ControlFoldMirror"},{"location":"scripts/ControlFoldMirror/#kpf.fiu.ControlFoldMirror.ControlFoldMirror--args","text":":destination: The desired FIU fold mirror position name :wait: (bool) Wait for move to complete before returning? (default: True) Source code in kpf/fiu/ControlFoldMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ControlFoldMirror ( KPFTranslatorFunction ): '''Insert or remove the FIU Cal Fold Mirror from the beam. ARGS: ===== :destination: The desired FIU fold mirror position name :wait: (bool) Wait for move to complete before returning? (default: True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () if destination . lower () not in [ 'in' , 'out' ]: raise FailedPreCondition ( f \"Requested state { destination } is invalid\" ) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'FOLDNAM' ] . write ( destination ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_fold_mirror_move_time' , fallback = 5 ) success = ktl . waitFor ( f '($kpffiu.foldnam == { destination } )' , timeout = timeout ) if success is not True : foldnam = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) raise FailedToReachDestination ( foldnam . read (), destination ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'in' , 'out' ], help = 'Desired fold mirror position' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/ControlHatch/","text":"ControlHatch Bases: KPFTranslatorFunction Open or close the FIU hatch ARGS: :destination: The desired FIU hatch position name Source code in kpf/fiu/ControlHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ControlHatch ( KPFTranslatorFunction ): '''Open or close the FIU hatch ARGS: ===== :destination: The desired FIU hatch position name ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'destination' , allowed_values = [ 'closed' , 'open' ]) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'HATCH' ] . write ( destination ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_hatch_move_time' , fallback = 1 ) success = ktl . waitFor ( f '($kpffiu.hatch == { destination } )' , timeout = timeout ) if success is not True : hatch = ktl . cache ( 'kpffiu' , 'HATCH' ) raise FailedToReachDestination ( hatch . read (), destination ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'closed' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser , cfg )","title":"ControlHatch"},{"location":"scripts/ControlHatch/#controlhatch","text":"Bases: KPFTranslatorFunction Open or close the FIU hatch","title":"ControlHatch"},{"location":"scripts/ControlHatch/#kpf.fiu.ControlHatch.ControlHatch--args","text":":destination: The desired FIU hatch position name Source code in kpf/fiu/ControlHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ControlHatch ( KPFTranslatorFunction ): '''Open or close the FIU hatch ARGS: ===== :destination: The desired FIU hatch position name ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'destination' , allowed_values = [ 'closed' , 'open' ]) @classmethod def perform ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'HATCH' ] . write ( destination ) @classmethod def post_condition ( cls , args , logger , cfg ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_hatch_move_time' , fallback = 1 ) success = ktl . waitFor ( f '($kpffiu.hatch == { destination } )' , timeout = timeout ) if success is not True : hatch = ktl . cache ( 'kpffiu' , 'HATCH' ) raise FailedToReachDestination ( hatch . read (), destination ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'closed' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/CorrectDAR/","text":"CorrectDAR Bases: KPFTranslatorFunction Modify the CURRENT_BASE keyword based upon the calculated differential atmospheric refraction value. This is NOT the recommended method for doing this as it is now done automatically in the kpfguide keyword service. This script predates full functionality of kpfguide and is being left in place only for emergency use. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: :EL: float Elevation of the telescope. Source code in kpf/utils/CorrectDAR.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class CorrectDAR ( KPFTranslatorFunction ): '''Modify the CURRENT_BASE keyword based upon the calculated differential atmospheric refraction value. This is NOT the recommended method for doing this as it is now done automatically in the `kpfguide` keyword service. This script predates full functionality of `kpfguide` and is being left in place only for emergency use. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: ===== :EL: `float` Elevation of the telescope. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) dcs = ktl . cache ( 'dcs1' ) EL = dcs [ 'EL' ] . read ( binary = True ) * 180 / np . pi DARarcsec = calculate_DAR_arcsec ( EL ) log . info ( f \"DAR is { DARarcsec : .3f } arcseconds\" ) dx , dy = calculate_DAR_pix ( DARarcsec ) total_pix = ( dx ** 2 + dy ** 2 ) ** 0.5 log . info ( f \"Pixel shift is { dx : .1f } , { dy : .1f } = { total_pix : .1f } \" ) base_names = { 'KPF' : 'SCIENCE_BASE' , 'SKY' : 'SKY_BASE' } POname = dcs [ 'PONAME' ] . read () base_name = base_names . get ( POname , None ) if base_name is None : log . error ( f \"dcs.PONAME= { POname } is not recognized\" ) log . error ( \"Leaving CURRENT_BASE unmodified\" ) return # log.error(f\"Using SCIENCE_BASE for testing\") # base_name = 'SCIENCE_BASE' # Set CURRENT_BASE log . info ( f \"dcs.PONAME is { POname } , using { base_name } as reference pixel\" ) reference_pix = list ( kpfguide [ base_name ] . read ( binary = True )) log . debug ( f \"Initial CURRENT_BASE = { reference_pix [ 0 ] : .1f } { reference_pix [ 1 ] : .1f } \" ) final_pixel = [ reference_pix [ 0 ] + dx , reference_pix [ 1 ] + dy ] final_pixel_string = f \" { final_pixel [ 0 ] : .2f } { final_pixel [ 1 ] : .2f } \" log . debug ( f \"Final Pixel = { final_pixel_string } \" ) min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) if final_pixel [ 0 ] < min_x_pixel or final_pixel [ 0 ] > max_x_pixel or \\ final_pixel [ 1 ] < min_y_pixel or final_pixel [ 1 ] > max_y_pixel : log . error ( f \"Target pixel ( { final_pixel_string } ) is not on guide camera\" ) log . error ( \"Leaving CURRENT_BASE unmodified\" ) else : log . info ( f \"Writing new CURRENT_BASE = { final_pixel_string } \" ) kpfguide [ 'CURRENT_BASE' ] . write ( final_pixel ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"CorrectDAR"},{"location":"scripts/CorrectDAR/#correctdar","text":"Bases: KPFTranslatorFunction Modify the CURRENT_BASE keyword based upon the calculated differential atmospheric refraction value. This is NOT the recommended method for doing this as it is now done automatically in the kpfguide keyword service. This script predates full functionality of kpfguide and is being left in place only for emergency use. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982)","title":"CorrectDAR"},{"location":"scripts/CorrectDAR/#kpf.utils.CorrectDAR.CorrectDAR--args","text":":EL: float Elevation of the telescope. Source code in kpf/utils/CorrectDAR.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class CorrectDAR ( KPFTranslatorFunction ): '''Modify the CURRENT_BASE keyword based upon the calculated differential atmospheric refraction value. This is NOT the recommended method for doing this as it is now done automatically in the `kpfguide` keyword service. This script predates full functionality of `kpfguide` and is being left in place only for emergency use. Calculation from Filippenko 1982 (PASP, 94:715-721, August 1982) ARGS: ===== :EL: `float` Elevation of the telescope. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) dcs = ktl . cache ( 'dcs1' ) EL = dcs [ 'EL' ] . read ( binary = True ) * 180 / np . pi DARarcsec = calculate_DAR_arcsec ( EL ) log . info ( f \"DAR is { DARarcsec : .3f } arcseconds\" ) dx , dy = calculate_DAR_pix ( DARarcsec ) total_pix = ( dx ** 2 + dy ** 2 ) ** 0.5 log . info ( f \"Pixel shift is { dx : .1f } , { dy : .1f } = { total_pix : .1f } \" ) base_names = { 'KPF' : 'SCIENCE_BASE' , 'SKY' : 'SKY_BASE' } POname = dcs [ 'PONAME' ] . read () base_name = base_names . get ( POname , None ) if base_name is None : log . error ( f \"dcs.PONAME= { POname } is not recognized\" ) log . error ( \"Leaving CURRENT_BASE unmodified\" ) return # log.error(f\"Using SCIENCE_BASE for testing\") # base_name = 'SCIENCE_BASE' # Set CURRENT_BASE log . info ( f \"dcs.PONAME is { POname } , using { base_name } as reference pixel\" ) reference_pix = list ( kpfguide [ base_name ] . read ( binary = True )) log . debug ( f \"Initial CURRENT_BASE = { reference_pix [ 0 ] : .1f } { reference_pix [ 1 ] : .1f } \" ) final_pixel = [ reference_pix [ 0 ] + dx , reference_pix [ 1 ] + dy ] final_pixel_string = f \" { final_pixel [ 0 ] : .2f } { final_pixel [ 1 ] : .2f } \" log . debug ( f \"Final Pixel = { final_pixel_string } \" ) min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) if final_pixel [ 0 ] < min_x_pixel or final_pixel [ 0 ] > max_x_pixel or \\ final_pixel [ 1 ] < min_y_pixel or final_pixel [ 1 ] > max_y_pixel : log . error ( f \"Target pixel ( { final_pixel_string } ) is not on guide camera\" ) log . error ( \"Leaving CURRENT_BASE unmodified\" ) else : log . info ( f \"Writing new CURRENT_BASE = { final_pixel_string } \" ) kpfguide [ 'CURRENT_BASE' ] . write ( final_pixel ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/CountCameraErrors/","text":"CountCameraErrors Bases: KPFTranslatorFunction Description Parameters Source code in kpf/analysis/CountCameraErrors.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class CountCameraErrors ( KPFTranslatorFunction ): '''# Description # Parameters ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/KPFTranslator_logs/camera_errors.txt' ) if output_file . exists (): output_file . unlink () date = datetime . strptime ( '2023-06-01' , '%Y-%m- %d ' ) total_green_errors = 0 total_green_starts = 0 total_red_errors = 0 total_red_starts = 0 print ( f \"From { date . strftime ( '%Y-%m- %d ' ) } \" ) dates = [] green_errs = [] red_errs = [] green_starts = [] red_starts = [] with open ( output_file , 'w' ) as f : while date < datetime . utcnow () - timedelta ( days = 1 ): date_str = date . strftime ( '%Y-%m- %d ' ) ng_starts , nr_starts = count_start_state_instances ( date = date_str ) ng_errs , nr_errs = count_start_state_errors ( date = date_str ) dates . append ( date ) green_errs . append ( ng_errs ) red_errs . append ( nr_errs ) green_starts . append ( ng_starts ) red_starts . append ( nr_starts ) total_green_errors += ng_errs total_green_starts += ng_starts total_red_errors += nr_errs total_red_starts += nr_starts line = f \" { date_str } , { ng_errs } , { ng_starts } , { nr_errs } , { nr_starts } \" # print(line) f . write ( f \" { line } \\n \" ) date += timedelta ( days = 1 ) print ( f \"Through { date . strftime ( '%Y-%m- %d ' ) } \" ) green_error_rate = total_green_errors / total_green_starts print ( f \"Green error rate = { green_error_rate : .2% } ( { total_green_errors } / { total_green_starts } )\" ) red_error_rate = total_red_errors / total_red_starts print ( f \"Red error rate = { red_error_rate : .2% } ( { total_red_errors } / { total_red_starts } )\" ) plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . title ( f \"Number of start errors per day\" ) plt . bar ( dates , green_errs , color = 'g' , alpha = 0.5 , width = 0.4 , align = 'edge' ) plt . bar ( dates , red_errs , color = 'r' , alpha = 0.5 , width =- 0.4 , align = 'edge' ) plt . ylabel ( 'N Errors' ) plt . subplot ( 2 , 1 , 2 ) plt . title ( f \"Rate of start errors per day\" ) plt . plot ( dates , np . array ( green_errs ) / np . array ( green_starts ) * 100 , 'go-' ) plt . plot ( dates , np . array ( red_errs ) / np . array ( red_starts ) * 100 , 'ro-' ) plt . ylabel ( ' % E rrors' ) plt . xlabel ( 'Date' ) plt . grid () plt . show () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"CountCameraErrors"},{"location":"scripts/CountCameraErrors/#countcameraerrors","text":"Bases: KPFTranslatorFunction","title":"CountCameraErrors"},{"location":"scripts/CountCameraErrors/#kpf.analysis.CountCameraErrors.CountCameraErrors--description","text":"","title":"Description"},{"location":"scripts/CountCameraErrors/#kpf.analysis.CountCameraErrors.CountCameraErrors--parameters","text":"Source code in kpf/analysis/CountCameraErrors.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class CountCameraErrors ( KPFTranslatorFunction ): '''# Description # Parameters ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/KPFTranslator_logs/camera_errors.txt' ) if output_file . exists (): output_file . unlink () date = datetime . strptime ( '2023-06-01' , '%Y-%m- %d ' ) total_green_errors = 0 total_green_starts = 0 total_red_errors = 0 total_red_starts = 0 print ( f \"From { date . strftime ( '%Y-%m- %d ' ) } \" ) dates = [] green_errs = [] red_errs = [] green_starts = [] red_starts = [] with open ( output_file , 'w' ) as f : while date < datetime . utcnow () - timedelta ( days = 1 ): date_str = date . strftime ( '%Y-%m- %d ' ) ng_starts , nr_starts = count_start_state_instances ( date = date_str ) ng_errs , nr_errs = count_start_state_errors ( date = date_str ) dates . append ( date ) green_errs . append ( ng_errs ) red_errs . append ( nr_errs ) green_starts . append ( ng_starts ) red_starts . append ( nr_starts ) total_green_errors += ng_errs total_green_starts += ng_starts total_red_errors += nr_errs total_red_starts += nr_starts line = f \" { date_str } , { ng_errs } , { ng_starts } , { nr_errs } , { nr_starts } \" # print(line) f . write ( f \" { line } \\n \" ) date += timedelta ( days = 1 ) print ( f \"Through { date . strftime ( '%Y-%m- %d ' ) } \" ) green_error_rate = total_green_errors / total_green_starts print ( f \"Green error rate = { green_error_rate : .2% } ( { total_green_errors } / { total_green_starts } )\" ) red_error_rate = total_red_errors / total_red_starts print ( f \"Red error rate = { red_error_rate : .2% } ( { total_red_errors } / { total_red_starts } )\" ) plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . title ( f \"Number of start errors per day\" ) plt . bar ( dates , green_errs , color = 'g' , alpha = 0.5 , width = 0.4 , align = 'edge' ) plt . bar ( dates , red_errs , color = 'r' , alpha = 0.5 , width =- 0.4 , align = 'edge' ) plt . ylabel ( 'N Errors' ) plt . subplot ( 2 , 1 , 2 ) plt . title ( f \"Rate of start errors per day\" ) plt . plot ( dates , np . array ( green_errs ) / np . array ( green_starts ) * 100 , 'go-' ) plt . plot ( dates , np . array ( red_errs ) / np . array ( red_starts ) * 100 , 'ro-' ) plt . ylabel ( ' % E rrors' ) plt . xlabel ( 'Date' ) plt . grid () plt . show () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/DisableSoCal/","text":"DisableSoCal Bases: KPFTranslatorFunction Disables SoCal by setting kpfsocal.CAN_OPEN to No. ARGS: None Source code in kpf/socal/DisableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DisableSoCal ( KPFTranslatorFunction ): '''Disables SoCal by setting kpfsocal.CAN_OPEN to No. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 0' ) CAN_OPEN . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 0' )","title":"DisableSoCal"},{"location":"scripts/DisableSoCal/#disablesocal","text":"Bases: KPFTranslatorFunction Disables SoCal by setting kpfsocal.CAN_OPEN to No.","title":"DisableSoCal"},{"location":"scripts/DisableSoCal/#kpf.socal.DisableSoCal.DisableSoCal--args","text":"None Source code in kpf/socal/DisableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DisableSoCal ( KPFTranslatorFunction ): '''Disables SoCal by setting kpfsocal.CAN_OPEN to No. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 0' ) CAN_OPEN . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 0' )","title":"ARGS:"},{"location":"scripts/DisplayGuiderContinuous/","text":"DisplayGuiderContinuous Bases: KPFTranslatorFunction Continuously display latest guider images to ds9. ARGS: None Source code in kpf/guider/DisplayGuiderContinuous.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class DisplayGuiderContinuous ( KPFTranslatorFunction ): '''Continuously display latest guider images to ds9. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): display_name = cfg . get ( 'display' , 'guider_xpa_target' , fallback = 'CRED2' ) lastfile = ktl . cache ( 'kpfguide' , 'LASTFILE' ) initial_lastfile = lastfile . read () while True : expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" is_there_a_newfile = ktl . waitFor ( expr , timeout = 10 ) if is_there_a_newfile is True : initial_lastfile = lastfile . read () print ( f \"Displaying { initial_lastfile } \" ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { initial_lastfile } \" , '<' , f \" { initial_lastfile } \" ] # log.debug(f\"Running: {' '.join(ds9cmd)}\") subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_cred2.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] # log.debug(f\"Running: {' '.join(overlaycmd)}\") subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"DisplayGuiderContinuous"},{"location":"scripts/DisplayGuiderContinuous/#displayguidercontinuous","text":"Bases: KPFTranslatorFunction Continuously display latest guider images to ds9.","title":"DisplayGuiderContinuous"},{"location":"scripts/DisplayGuiderContinuous/#kpf.guider.DisplayGuiderContinuous.DisplayGuiderContinuous--args","text":"None Source code in kpf/guider/DisplayGuiderContinuous.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class DisplayGuiderContinuous ( KPFTranslatorFunction ): '''Continuously display latest guider images to ds9. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): display_name = cfg . get ( 'display' , 'guider_xpa_target' , fallback = 'CRED2' ) lastfile = ktl . cache ( 'kpfguide' , 'LASTFILE' ) initial_lastfile = lastfile . read () while True : expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" is_there_a_newfile = ktl . waitFor ( expr , timeout = 10 ) if is_there_a_newfile is True : initial_lastfile = lastfile . read () print ( f \"Displaying { initial_lastfile } \" ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { initial_lastfile } \" , '<' , f \" { initial_lastfile } \" ] # log.debug(f\"Running: {' '.join(ds9cmd)}\") subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_cred2.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] # log.debug(f\"Running: {' '.join(overlaycmd)}\") subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/EnableSoCal/","text":"EnableSoCal Bases: KPFTranslatorFunction Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. ARGS: None Source code in kpf/socal/EnableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class EnableSoCal ( KPFTranslatorFunction ): '''Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 1' ) CAN_OPEN . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 1' )","title":"EnableSoCal"},{"location":"scripts/EnableSoCal/#enablesocal","text":"Bases: KPFTranslatorFunction Enables SoCal by setting kpfsocal.CAN_OPEN to Yes.","title":"EnableSoCal"},{"location":"scripts/EnableSoCal/#kpf.socal.EnableSoCal.EnableSoCal--args","text":"None Source code in kpf/socal/EnableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class EnableSoCal ( KPFTranslatorFunction ): '''Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 1' ) CAN_OPEN . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 1' )","title":"ARGS:"},{"location":"scripts/EndOfNight/","text":"EndOfNight Bases: KPFTranslatorFunction Send KPF in to an end of night configuration. kpffiu.MODE = Stowed Power off FVCs Power off LED back illuminators close AO hatch HEPA on Send PCU to Home ARGS: :AO: (bool) Close AO hatch, home PCU, and turn on HEPA? (default=True) Source code in kpf/scripts/EndOfNight.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class EndOfNight ( KPFTranslatorFunction ): '''Send KPF in to an end of night configuration. - kpffiu.MODE = Stowed - Power off FVCs - Power off LED back illuminators - close AO hatch - HEPA on - Send PCU to Home ARGS: ===== :AO: (bool) Close AO hatch, home PCU, and turn on HEPA? (default=True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): StopTipTilt . execute ({}) StopAgitator . execute ({}) # Start FIU stow log . info ( 'Setting FIU mode to Stowed' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' , 'wait' : False }) # --------------------------------- # User Verification for AO Shutdown # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"Perform shutdown of AO? This will move the AO hatch and PCU.\" , \"The AO area should be clear of personnel before proceeding.\" , \"\" , \"Do you wish to shutdown AO?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' , '' ]: log . debug ( 'User chose to shut down AO' ) log . info ( 'Closing AO Hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'closed' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) log . info ( 'Sending PCU stage to Home position' ) SendPCUtoHome . execute ({}) # log.info('Turning on AO HEPA Filter System') # TurnHepaOn.execute({}) else : log . warning ( f 'User chose to skip AO shutdown' ) # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Power off FVCs for camera in [ 'SCI' , 'CAHK' , 'CAL' ]: FVCPower . execute ({ 'camera' : camera , 'power' : 'off' }) # Power off LEDs for LED in [ 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ]: CalLampPower . execute ({ 'lamp' : LED , 'power' : 'off' }) # Finish FIU shutdown WaitForConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Set PROGNAME log . info ( 'Clearing values for PROGNAME, OBSERVER, OBJECT' ) WaitForReady . execute ({}) SetProgram . execute ({ 'progname' : '' }) SetObserver . execute ({ 'observer' : '' }) SetObject . execute ({ 'Object' : '' }) # Power off Simulcal lamp kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'off' }) # Allow scheduled cals log . info ( 'Set ALLOWSCHEDULEDCALS to Yes' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"EndOfNight"},{"location":"scripts/EndOfNight/#endofnight","text":"Bases: KPFTranslatorFunction Send KPF in to an end of night configuration. kpffiu.MODE = Stowed Power off FVCs Power off LED back illuminators close AO hatch HEPA on Send PCU to Home","title":"EndOfNight"},{"location":"scripts/EndOfNight/#kpf.scripts.EndOfNight.EndOfNight--args","text":":AO: (bool) Close AO hatch, home PCU, and turn on HEPA? (default=True) Source code in kpf/scripts/EndOfNight.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class EndOfNight ( KPFTranslatorFunction ): '''Send KPF in to an end of night configuration. - kpffiu.MODE = Stowed - Power off FVCs - Power off LED back illuminators - close AO hatch - HEPA on - Send PCU to Home ARGS: ===== :AO: (bool) Close AO hatch, home PCU, and turn on HEPA? (default=True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): StopTipTilt . execute ({}) StopAgitator . execute ({}) # Start FIU stow log . info ( 'Setting FIU mode to Stowed' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' , 'wait' : False }) # --------------------------------- # User Verification for AO Shutdown # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"Perform shutdown of AO? This will move the AO hatch and PCU.\" , \"The AO area should be clear of personnel before proceeding.\" , \"\" , \"Do you wish to shutdown AO?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' , '' ]: log . debug ( 'User chose to shut down AO' ) log . info ( 'Closing AO Hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'closed' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) log . info ( 'Sending PCU stage to Home position' ) SendPCUtoHome . execute ({}) # log.info('Turning on AO HEPA Filter System') # TurnHepaOn.execute({}) else : log . warning ( f 'User chose to skip AO shutdown' ) # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Power off FVCs for camera in [ 'SCI' , 'CAHK' , 'CAL' ]: FVCPower . execute ({ 'camera' : camera , 'power' : 'off' }) # Power off LEDs for LED in [ 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ]: CalLampPower . execute ({ 'lamp' : LED , 'power' : 'off' }) # Finish FIU shutdown WaitForConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Set PROGNAME log . info ( 'Clearing values for PROGNAME, OBSERVER, OBJECT' ) WaitForReady . execute ({}) SetProgram . execute ({ 'progname' : '' }) SetObserver . execute ({ 'observer' : '' }) SetObject . execute ({ 'Object' : '' }) # Power off Simulcal lamp kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'off' }) # Allow scheduled cals log . info ( 'Set ALLOWSCHEDULEDCALS to Yes' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/EstimateOBDuration/","text":"EstimateOBDuration Bases: KPFTranslatorFunction Estimate the duration of the input OB. This script will determine the OB type (science or calibration) and invoke either EstimateCalOBDuration or EstimateSciOBDuration ARGS: :OB: dict A fully specified observing block (OB). Source code in kpf/utils/EstimateOBDuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class EstimateOBDuration ( KPFTranslatorFunction ): '''Estimate the duration of the input OB. This script will determine the OB type (science or calibration) and invoke either `EstimateCalOBDuration` or `EstimateSciOBDuration` ARGS: ===== :OB: `dict` A fully specified observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): if OB [ 'Template_Name' ] == 'kpf_cal' : return EstimateCalOBDuration . execute ( OB ) elif OB [ 'Template_Name' ] == 'kpf_sci' : return EstimateSciOBDuration . execute ( OB ) else : print ( f \"Time estimate not supported for { OB [ 'Template_Name' ] } type\" ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--fast' , '--fastread' , dest = \"fast\" , default = False , action = \"store_true\" , help = 'Use fast readout mode times for estimate?' ) return super () . add_cmdline_args ( parser , cfg )","title":"EstimateOBDuration"},{"location":"scripts/EstimateOBDuration/#estimateobduration","text":"Bases: KPFTranslatorFunction Estimate the duration of the input OB. This script will determine the OB type (science or calibration) and invoke either EstimateCalOBDuration or EstimateSciOBDuration","title":"EstimateOBDuration"},{"location":"scripts/EstimateOBDuration/#kpf.utils.EstimateOBDuration.EstimateOBDuration--args","text":":OB: dict A fully specified observing block (OB). Source code in kpf/utils/EstimateOBDuration.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class EstimateOBDuration ( KPFTranslatorFunction ): '''Estimate the duration of the input OB. This script will determine the OB type (science or calibration) and invoke either `EstimateCalOBDuration` or `EstimateSciOBDuration` ARGS: ===== :OB: `dict` A fully specified observing block (OB). ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): if OB [ 'Template_Name' ] == 'kpf_cal' : return EstimateCalOBDuration . execute ( OB ) elif OB [ 'Template_Name' ] == 'kpf_sci' : return EstimateSciOBDuration . execute ( OB ) else : print ( f \"Time estimate not supported for { OB [ 'Template_Name' ] } type\" ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--fast' , '--fastread' , dest = \"fast\" , default = False , action = \"store_true\" , help = 'Use fast readout mode times for estimate?' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/ExecuteSlewCal/","text":"ExecuteSlewCal Bases: KPFTranslatorFunction Script which executes the observations of a Slew Cal This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. ARGS: :OB: dict A fully specified slew cal observing block (OB). Source code in kpf/scripts/ExecuteSlewCal.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class ExecuteSlewCal ( KPFTranslatorFunction ): '''Script which executes the observations of a Slew Cal This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== :OB: `dict` A fully specified slew cal observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Template_Name' , allowed_values = [ 'kpf_slewcal' ]) check_input ( args , 'Template_Version' , version_check = True , value_min = '0.4' ) @classmethod def perform ( cls , args , logger , cfg ): set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) fast_read_mode = QueryFastReadMode . execute ({}) # Fill in args in case this is not called by configure for acquisition if args . get ( 'TriggerCaHK' , None ) is None : args [ 'TriggerCaHK' ] = False if args . get ( 'TriggerGreen' , None ) is None : args [ 'TriggerGreen' ] = True if args . get ( 'TriggerRed' , None ) is None : args [ 'TriggerRed' ] = True # Skip this lamp if it is not enabled if IsCalSourceEnabled . execute ({ 'CalSource' : calsource }) == False : return # Set Octagon calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) progname = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) original_progname = progname . read () ## ---------------------------------------------------------------- ## First, configure lamps and cal bench (may happen during readout) ## ---------------------------------------------------------------- log . info ( f \"Configuring FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Calibration' , 'wait' : False }) check_scriptstop () # Stop here if requested # Configure Cal Bench nd1 = args . get ( 'CalND1' ) nd2 = args . get ( 'CalND2' ) log . info ( f \"Set ND1, ND2 Filter Wheels: { nd1 } , { nd2 } \" ) SetND1 . execute ({ 'CalND1' : nd1 , 'wait' : False }) SetND2 . execute ({ 'CalND2' : nd2 , 'wait' : False }) log . info ( f \"Waiting for Octagon/CalSource, ND1, ND2, FIU\" ) WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) WaitForCalSource . execute ({ 'CalSource' : calsource }) WaitForConfigureFIU . execute ({ 'mode' : 'Calibration' }) check_scriptstop () # Stop here if requested ## ---------------------------------------------------------------- ## Second, configure kpfexpose (may not happen during readout) ## ---------------------------------------------------------------- # Wait for current exposure to readout exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . info ( f \"Readout complete\" ) check_scriptstop () # Stop here if requested log . info ( f \"Set Detector List\" ) SetTriggeredDetectors . execute ( args ) log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_SoCalSci' : False , 'SSS_SoCalCal' : False , 'SSS_CalSciSky' : True }) log . info ( f \"Set exposure time: { args . get ( 'ExpTime' ) : .3f } \" ) SetExpTime . execute ( args ) # No need to specify TimedShutter_Scrambler args [ 'TimedShutter_Scrambler' ] = True log . debug ( f \"Automatically setting TimedShutter_Scrambler: { args [ 'TimedShutter_Scrambler' ] } \" ) # No need to specify TimedShutter_CaHK args [ 'TimedShutter_CaHK' ] = args . get ( 'TriggerCaHK' , False ) log . debug ( f \"Automatically setting TimedShutter_CaHK: { args [ 'TimedShutter_CaHK' ] } \" ) # No need to specify TimedShutter_FlatField args [ 'TimedShutter_FlatField' ] = False log . debug ( f \"Automatically setting TimedShutter_FlatField: { args [ 'TimedShutter_FlatField' ] } \" ) # Set TimedShutter_SimulCal args [ 'TimedShutter_SimulCal' ] = args [ 'TakeSimulCal' ] log . debug ( f \"Automatically setting TimedShutter_SimulCal: { args [ 'TimedShutter_SimulCal' ] } \" ) log . info ( f \"Setting timed shutters\" ) SetTimedShutters . execute ( args ) log . info ( f \"Setting OBJECT: { args . get ( 'Object' ) } \" ) SetObject . execute ( args ) log . info ( f \"Clearing stellar parameters\" ) SetTargetInfo . execute ({}) SetProgram . execute ({ 'progname' : 'ENG' }) ## ---------------------------------------------------------------- ## Third, take actual exposures ## ---------------------------------------------------------------- nexp = args . get ( 'nExp' , 1 ) # If we are in fast read mode, turn on agitator once if runagitator and fast_read_mode : StartAgitator . execute ({}) for j in range ( nexp ): check_scriptstop () # Stop here if requested # Wait for current exposure to readout if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . info ( f \"Readout complete\" ) check_scriptstop () # Stop here if requested # Start next exposure if runagitator and not fast_read_mode : StartAgitator . execute ({}) log . info ( f \"Starting expoure { j + 1 } / { nexp } ( { args . get ( 'Object' ) } )\" ) StartExposure . execute ({}) WaitForReadout . execute ({}) log . info ( f \"Readout has begun\" ) if runagitator and not fast_read_mode : StopAgitator . execute ({}) ZeroOutSlewCalTime . execute ({}) # If we are in fast read mode, turn off agitator at end if runagitator and fast_read_mode : StopAgitator . execute ({}) # Set FIU Mode log . info ( 'Setting FIU mode to Observing' ) ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set PROGNAME log . info ( f 'Setting PROGNAME back to { original_progname } ' ) SetProgram . execute ({ 'progname' : original_progname }) clear_script_keywords () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ExecuteSlewCal"},{"location":"scripts/ExecuteSlewCal/#executeslewcal","text":"Bases: KPFTranslatorFunction Script which executes the observations of a Slew Cal This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine.","title":"ExecuteSlewCal"},{"location":"scripts/ExecuteSlewCal/#kpf.scripts.ExecuteSlewCal.ExecuteSlewCal--args","text":":OB: dict A fully specified slew cal observing block (OB). Source code in kpf/scripts/ExecuteSlewCal.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class ExecuteSlewCal ( KPFTranslatorFunction ): '''Script which executes the observations of a Slew Cal This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== :OB: `dict` A fully specified slew cal observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Template_Name' , allowed_values = [ 'kpf_slewcal' ]) check_input ( args , 'Template_Version' , version_check = True , value_min = '0.4' ) @classmethod def perform ( cls , args , logger , cfg ): set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) kpfconfig = ktl . cache ( 'kpfconfig' ) calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) fast_read_mode = QueryFastReadMode . execute ({}) # Fill in args in case this is not called by configure for acquisition if args . get ( 'TriggerCaHK' , None ) is None : args [ 'TriggerCaHK' ] = False if args . get ( 'TriggerGreen' , None ) is None : args [ 'TriggerGreen' ] = True if args . get ( 'TriggerRed' , None ) is None : args [ 'TriggerRed' ] = True # Skip this lamp if it is not enabled if IsCalSourceEnabled . execute ({ 'CalSource' : calsource }) == False : return # Set Octagon calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) progname = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) original_progname = progname . read () ## ---------------------------------------------------------------- ## First, configure lamps and cal bench (may happen during readout) ## ---------------------------------------------------------------- log . info ( f \"Configuring FIU\" ) ConfigureFIU . execute ({ 'mode' : 'Calibration' , 'wait' : False }) check_scriptstop () # Stop here if requested # Configure Cal Bench nd1 = args . get ( 'CalND1' ) nd2 = args . get ( 'CalND2' ) log . info ( f \"Set ND1, ND2 Filter Wheels: { nd1 } , { nd2 } \" ) SetND1 . execute ({ 'CalND1' : nd1 , 'wait' : False }) SetND2 . execute ({ 'CalND2' : nd2 , 'wait' : False }) log . info ( f \"Waiting for Octagon/CalSource, ND1, ND2, FIU\" ) WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) WaitForCalSource . execute ({ 'CalSource' : calsource }) WaitForConfigureFIU . execute ({ 'mode' : 'Calibration' }) check_scriptstop () # Stop here if requested ## ---------------------------------------------------------------- ## Second, configure kpfexpose (may not happen during readout) ## ---------------------------------------------------------------- # Wait for current exposure to readout exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . info ( f \"Readout complete\" ) check_scriptstop () # Stop here if requested log . info ( f \"Set Detector List\" ) SetTriggeredDetectors . execute ( args ) log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_SoCalSci' : False , 'SSS_SoCalCal' : False , 'SSS_CalSciSky' : True }) log . info ( f \"Set exposure time: { args . get ( 'ExpTime' ) : .3f } \" ) SetExpTime . execute ( args ) # No need to specify TimedShutter_Scrambler args [ 'TimedShutter_Scrambler' ] = True log . debug ( f \"Automatically setting TimedShutter_Scrambler: { args [ 'TimedShutter_Scrambler' ] } \" ) # No need to specify TimedShutter_CaHK args [ 'TimedShutter_CaHK' ] = args . get ( 'TriggerCaHK' , False ) log . debug ( f \"Automatically setting TimedShutter_CaHK: { args [ 'TimedShutter_CaHK' ] } \" ) # No need to specify TimedShutter_FlatField args [ 'TimedShutter_FlatField' ] = False log . debug ( f \"Automatically setting TimedShutter_FlatField: { args [ 'TimedShutter_FlatField' ] } \" ) # Set TimedShutter_SimulCal args [ 'TimedShutter_SimulCal' ] = args [ 'TakeSimulCal' ] log . debug ( f \"Automatically setting TimedShutter_SimulCal: { args [ 'TimedShutter_SimulCal' ] } \" ) log . info ( f \"Setting timed shutters\" ) SetTimedShutters . execute ( args ) log . info ( f \"Setting OBJECT: { args . get ( 'Object' ) } \" ) SetObject . execute ( args ) log . info ( f \"Clearing stellar parameters\" ) SetTargetInfo . execute ({}) SetProgram . execute ({ 'progname' : 'ENG' }) ## ---------------------------------------------------------------- ## Third, take actual exposures ## ---------------------------------------------------------------- nexp = args . get ( 'nExp' , 1 ) # If we are in fast read mode, turn on agitator once if runagitator and fast_read_mode : StartAgitator . execute ({}) for j in range ( nexp ): check_scriptstop () # Stop here if requested # Wait for current exposure to readout if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . info ( f \"Readout complete\" ) check_scriptstop () # Stop here if requested # Start next exposure if runagitator and not fast_read_mode : StartAgitator . execute ({}) log . info ( f \"Starting expoure { j + 1 } / { nexp } ( { args . get ( 'Object' ) } )\" ) StartExposure . execute ({}) WaitForReadout . execute ({}) log . info ( f \"Readout has begun\" ) if runagitator and not fast_read_mode : StopAgitator . execute ({}) ZeroOutSlewCalTime . execute ({}) # If we are in fast read mode, turn off agitator at end if runagitator and fast_read_mode : StopAgitator . execute ({}) # Set FIU Mode log . info ( 'Setting FIU mode to Observing' ) ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set PROGNAME log . info ( f 'Setting PROGNAME back to { original_progname } ' ) SetProgram . execute ({ 'progname' : original_progname }) clear_script_keywords () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/FVCPower/","text":"FVCPower Bases: KPFTranslatorFunction Turn on or off the power for the specified FVC camera. ARGS: :camera: Which FVC camera (SCI, CAHK, CAL)? :power: Desired state: on or off Source code in kpf/fvc/FVCPower.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class FVCPower ( KPFTranslatorFunction ): '''Turn on or off the power for the specified FVC camera. ARGS: ===== :camera: Which FVC camera (SCI, CAHK, CAL)? :power: Desired state: on or off ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' ]) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) dest = args . get ( 'power' ) if powerkw . read () . lower () != dest . lower (): log . info ( f \"Turning { dest } { camera } FVC\" ) powerkw . write ( args . get ( 'power' )) shim = cfg . getfloat ( 'times' , 'fvc_command_timeshim' , fallback = 2 ) time . sleep ( shim ) @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 1 ) dest = args . get ( 'power' ) success = powerkw . waitFor ( f \"== ' { dest } '\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( powerkw . read (), dest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' ], help = 'The FVC camera' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"FVCPower"},{"location":"scripts/FVCPower/#fvcpower","text":"Bases: KPFTranslatorFunction Turn on or off the power for the specified FVC camera.","title":"FVCPower"},{"location":"scripts/FVCPower/#kpf.fvc.FVCPower.FVCPower--args","text":":camera: Which FVC camera (SCI, CAHK, CAL)? :power: Desired state: on or off Source code in kpf/fvc/FVCPower.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class FVCPower ( KPFTranslatorFunction ): '''Turn on or off the power for the specified FVC camera. ARGS: ===== :camera: Which FVC camera (SCI, CAHK, CAL)? :power: Desired state: on or off ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' ]) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) dest = args . get ( 'power' ) if powerkw . read () . lower () != dest . lower (): log . info ( f \"Turning { dest } { camera } FVC\" ) powerkw . write ( args . get ( 'power' )) shim = cfg . getfloat ( 'times' , 'fvc_command_timeshim' , fallback = 2 ) time . sleep ( shim ) @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 1 ) dest = args . get ( 'power' ) success = powerkw . waitFor ( f \"== ' { dest } '\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( powerkw . read (), dest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' ], help = 'The FVC camera' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/Fit2DGridSearch/","text":"Fit2DGridSearch Bases: KPFTranslatorFunction Description Take two 1D grid search runs (one in X and one in Y) ... Parameters None Source code in kpf/analysis/Fit2DGridSearch.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Fit2DGridSearch ( KPFTranslatorFunction ): '''# Description Take two 1D grid search runs (one in X and one in Y) ... # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): fit_2D_fiber_center ( Path ( args . get ( 'fgs_cube_fileX' )), Path ( args . get ( 'fgs_cube_fileY' )), xcent = args . get ( 'xfit' ), ycent = args . get ( 'yfit' ), targname = args . get ( 'targname' )) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'fgs_cube_fileX' , type = str , help = \"The FGS FITS cube for the X pixel scan\" ) parser . add_argument ( 'fgs_cube_fileY' , type = str , help = \"The FGS FITS cube for the Y pixel scan\" ) parser . add_argument ( 'targname' , type = str , help = \"The target name\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Fit2DGridSearch"},{"location":"scripts/Fit2DGridSearch/#fit2dgridsearch","text":"Bases: KPFTranslatorFunction","title":"Fit2DGridSearch"},{"location":"scripts/Fit2DGridSearch/#kpf.analysis.Fit2DGridSearch.Fit2DGridSearch--description","text":"Take two 1D grid search runs (one in X and one in Y) ...","title":"Description"},{"location":"scripts/Fit2DGridSearch/#kpf.analysis.Fit2DGridSearch.Fit2DGridSearch--parameters","text":"None Source code in kpf/analysis/Fit2DGridSearch.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class Fit2DGridSearch ( KPFTranslatorFunction ): '''# Description Take two 1D grid search runs (one in X and one in Y) ... # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): fit_2D_fiber_center ( Path ( args . get ( 'fgs_cube_fileX' )), Path ( args . get ( 'fgs_cube_fileY' )), xcent = args . get ( 'xfit' ), ycent = args . get ( 'yfit' ), targname = args . get ( 'targname' )) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'fgs_cube_fileX' , type = str , help = \"The FGS FITS cube for the X pixel scan\" ) parser . add_argument ( 'fgs_cube_fileY' , type = str , help = \"The FGS FITS cube for the Y pixel scan\" ) parser . add_argument ( 'targname' , type = str , help = \"The target name\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/GetGaiaStars/","text":"GetGaiaStars Bases: KPFTranslatorFunction Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. ARGS: :file: str The file to retrieve stars for. Source code in kpf/guider/GetGaiaStars.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class GetGaiaStars ( KPFTranslatorFunction ): '''Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. ARGS: ===== :file: `str` The file to retrieve stars for. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): if Vizier is None : raise FailedPreCondition ( 'Unable to import astroquery.vizier' ) file = Path ( args . get ( 'file' , '/tmp/CRED2.fits' )) . expanduser () . absolute () if file . exists () is False : raise FailedPreCondition ( f 'Fould not find input file: { file } ' ) @classmethod def perform ( cls , args , logger , cfg ): catalog_id = cfg . get ( 'stellar_catalog' , 'catalog_id' , fallback = 'I/345/gaia2' ) search_radius = cfg . getfloat ( 'stellar_catalog' , 'search_radius' , fallback = 28 ) ds9_color = cfg . get ( 'stellar_catalog' , 'ds9_color' , fallback = 'cyan' ) ds9_font = cfg . get ( 'stellar_catalog' , 'ds9_font' , fallback = 'helvetica 10 normal roman' ) requery_threshold = cfg . getfloat ( 'stellar_catalog' , 'requery_threshold' , fallback = 5 ) region_file = Path ( '~/.CRED2_auto_regions.reg' ) . expanduser () cntr_file = Path ( '~/.CRED2_auto_regions.cntr' ) . expanduser () file = Path ( args . get ( 'file' , './junk.fits' )) . expanduser () . absolute () # hdul = fits.open(file) header = fits . getheader ( file ) w = WCS ( header ) # cntr = w.pixel_to_world(hdul[0].data.shape[0]/2, hdul[0].data.shape[1]/2) cntr = w . pixel_to_world ( int ( header . get ( 'NAXIS2' )) / 2 , int ( header . get ( 'NAXIS1' )) / 2 ) if cntr_file . exists () is False : with open ( cntr_file , 'w' ) as FO : FO . write ( cntr . to_string ( 'hmsdms' , precision = 2 )) else : with open ( cntr_file , 'r' ) as FO : cntr_file_string = FO . readlines () file_cntr = SkyCoord ( cntr_file_string , unit = ( u . hourangle , u . deg ), frame = 'icrs' ) sep = file_cntr . separation ( cntr ) # If we're in a new position, query for a new catalog of stars and # write a new region file if sep [ 0 ] . to ( u . arcsec ) . value > requery_threshold : print ( f 'Querying for catalog: { cntr . to_string ( \"hmsdms\" , precision = 2 ) } ' ) gaia = Vizier . query_region ( cntr , radius = search_radius * u . arcsec , catalog = catalog_id )[ 0 ] regions = [ f '# Region file format: DS9 version 4.1' , f 'global color= { ds9_color } dashlist=8 3 width=1 font=\" { ds9_font } \"' , ] for star in gaia : sc = SkyCoord ( star [ 'RA_ICRS' ], star [ 'DE_ICRS' ], unit = ( u . deg , u . deg ), frame = 'icrs' ) coord_string = sc . to_string ( 'hmsdms' , sep = ':' , precision = 2 ) . replace ( ' ' , ',' ) newline = f \"circle( { coord_string } ,0.5 \\\" )\" # \\# text=\\{\"#\\}\" newline += \" # text={\" newline += f \" { star [ 'RPmag' ] : .1f } \" newline += \"}\" regions . append ( newline ) if region_file . exists (): region_file . unlink () with open ( region_file , 'w' ) as FO : for line in regions : FO . write ( line + ' \\n ' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'file' , type = str , help = 'The CRED2 file to retrieve stars for' ) return super () . add_cmdline_args ( parser , cfg )","title":"GetGaiaStars"},{"location":"scripts/GetGaiaStars/#getgaiastars","text":"Bases: KPFTranslatorFunction Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image.","title":"GetGaiaStars"},{"location":"scripts/GetGaiaStars/#kpf.guider.GetGaiaStars.GetGaiaStars--args","text":":file: str The file to retrieve stars for. Source code in kpf/guider/GetGaiaStars.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class GetGaiaStars ( KPFTranslatorFunction ): '''Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. ARGS: ===== :file: `str` The file to retrieve stars for. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): if Vizier is None : raise FailedPreCondition ( 'Unable to import astroquery.vizier' ) file = Path ( args . get ( 'file' , '/tmp/CRED2.fits' )) . expanduser () . absolute () if file . exists () is False : raise FailedPreCondition ( f 'Fould not find input file: { file } ' ) @classmethod def perform ( cls , args , logger , cfg ): catalog_id = cfg . get ( 'stellar_catalog' , 'catalog_id' , fallback = 'I/345/gaia2' ) search_radius = cfg . getfloat ( 'stellar_catalog' , 'search_radius' , fallback = 28 ) ds9_color = cfg . get ( 'stellar_catalog' , 'ds9_color' , fallback = 'cyan' ) ds9_font = cfg . get ( 'stellar_catalog' , 'ds9_font' , fallback = 'helvetica 10 normal roman' ) requery_threshold = cfg . getfloat ( 'stellar_catalog' , 'requery_threshold' , fallback = 5 ) region_file = Path ( '~/.CRED2_auto_regions.reg' ) . expanduser () cntr_file = Path ( '~/.CRED2_auto_regions.cntr' ) . expanduser () file = Path ( args . get ( 'file' , './junk.fits' )) . expanduser () . absolute () # hdul = fits.open(file) header = fits . getheader ( file ) w = WCS ( header ) # cntr = w.pixel_to_world(hdul[0].data.shape[0]/2, hdul[0].data.shape[1]/2) cntr = w . pixel_to_world ( int ( header . get ( 'NAXIS2' )) / 2 , int ( header . get ( 'NAXIS1' )) / 2 ) if cntr_file . exists () is False : with open ( cntr_file , 'w' ) as FO : FO . write ( cntr . to_string ( 'hmsdms' , precision = 2 )) else : with open ( cntr_file , 'r' ) as FO : cntr_file_string = FO . readlines () file_cntr = SkyCoord ( cntr_file_string , unit = ( u . hourangle , u . deg ), frame = 'icrs' ) sep = file_cntr . separation ( cntr ) # If we're in a new position, query for a new catalog of stars and # write a new region file if sep [ 0 ] . to ( u . arcsec ) . value > requery_threshold : print ( f 'Querying for catalog: { cntr . to_string ( \"hmsdms\" , precision = 2 ) } ' ) gaia = Vizier . query_region ( cntr , radius = search_radius * u . arcsec , catalog = catalog_id )[ 0 ] regions = [ f '# Region file format: DS9 version 4.1' , f 'global color= { ds9_color } dashlist=8 3 width=1 font=\" { ds9_font } \"' , ] for star in gaia : sc = SkyCoord ( star [ 'RA_ICRS' ], star [ 'DE_ICRS' ], unit = ( u . deg , u . deg ), frame = 'icrs' ) coord_string = sc . to_string ( 'hmsdms' , sep = ':' , precision = 2 ) . replace ( ' ' , ',' ) newline = f \"circle( { coord_string } ,0.5 \\\" )\" # \\# text=\\{\"#\\}\" newline += \" # text={\" newline += f \" { star [ 'RPmag' ] : .1f } \" newline += \"}\" regions . append ( newline ) if region_file . exists (): region_file . unlink () with open ( region_file , 'w' ) as FO : for line in regions : FO . write ( line + ' \\n ' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'file' , type = str , help = 'The CRED2 file to retrieve stars for' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/GridSearch/","text":"GridSearch Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. ARGS: None Source code in kpf/engineering/GridSearch.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class GridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_grid' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.4' ) check_input ( OB , 'Grid' , allowed_values = [ 'TipTilt' , 'SciADC' ]) check_input ( OB , 'nx' ) check_input ( OB , 'ny' ) check_input ( OB , 'dx' ) check_input ( OB , 'dy' ) check_input ( OB , 'ExpMeter_exptime' ) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) for FVC in FVCs : if FVC not in [ 'SCI' , 'CAHK' , 'EXT' , '' ]: raise FailedPreCondition ( f \"FVC { FVC } not supported\" ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) grid = OB . get ( 'Grid' ) this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { grid }{ this_file_name } _images_ { now_str } .txt' ) fluxes_file = log_path / Path ( f ' { grid }{ this_file_name } _fluxes_ { now_str } .txt' ) images = Table ( names = ( 'file' , 'camera' , 'x' , 'y' ), dtype = ( 'a90' , 'a10' , 'f4' , 'f4' )) expmeter_flux = Table ( names = ( 'i' , 'j' , 'x' , 'y' , 'bck1' , 'bck2' , 'bck3' , 'bck4' , 'cur1' , 'cur2' , 'cur3' , 'cur4' , 'raw1' , 'raw2' , 'raw3' , 'raw4' , 'nimages' ), dtype = ( 'i4' , 'i4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'i4' )) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) nx = OB . get ( 'nx' ) ny = OB . get ( 'ny' ) dx = OB . get ( 'dx' ) dy = OB . get ( 'dy' ) xis = [ xi for xi in range ( int ( - nx / 2 ), int (( nx + 1 ) / 2 ), 1 )] yis = [ yi for yi in range ( int ( - ny / 2 ), int (( ny + 1 ) / 2 ), 1 )] xindicies = [ ind for ind in range ( nx )] yindicies = [ ind for ind in range ( ny )] xs = [ xi * dx for xi in xis ] ys = [ yi * dy for yi in yis ] # Set up guider (assume parameters set during acquisition of star) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Setting TRIGCUBE Inactive' ) kpfguide [ 'TRIGCUBE' ] . write ( 'Inactive' ) if grid == 'TipTilt' : current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE = { current_base [ 0 ] : .2f } { current_base [ 1 ] : .2f } \" ) log . info ( f \"DAR_ENABLE = { kpfguide [ 'DAR_ENABLE' ] . read () } \" ) dar_offset = kpfguide [ 'DAR_OFFSET' ] . read ( binary = True ) log . info ( f \"DAR_OFFSET = { dar_offset [ 0 ] : .2f } { dar_offset [ 1 ] : .2f } \" ) xpix0 , ypix0 = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix0 : .2f } , { ypix0 : .2f } \" ) basex , basey = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE is { basex : .2f } , { basey : .2f } \" ) # Pixel targets must be in absolute coordinates xs = [ basex + xpix for xpix in xs ] ys = [ basey + ypix for ypix in ys ] elif grid == 'SciADC' : kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) nominalx , nominaly = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) x0 = OB . get ( 'ADC1Position' ) if str ( x0 ) . lower () == 'nominal' : x0 = nominalx else : x0 = float ( OB . get ( 'ADC1Position' )) y0 = OB . get ( 'ADC2Position' ) if str ( y0 ) . lower () == 'nominal' : y0 = nominaly else : y0 = float ( OB . get ( 'ADC2Position' )) log . info ( f \"ADC starting position: { x0 : .1f } { y0 : .1f } \" ) # Apply reverse rotation if requested if OB . get ( 'ADC1Reverse' , False ) is True : x0 = - x0 if OB . get ( 'ADC2Reverse' , False ) is True : y0 = - y0 log . info ( f \"ADC reverse nominal position: { x0 : .1f } { y0 : .1f } \" ) # Apply flip if requested if OB . get ( 'ADC1Flip' , False ) is True : x0 += 180 if OB . get ( 'ADC2Flip' , False ) is True : y0 += 180 log . info ( f \"ADC flip nominal position: { x0 : .1f } { y0 : .1f } \" ) xs = [ x + x0 for x in xs ] ys = [ y + y0 for y in ys ] # Set up kpfexpose kpfexpose = ktl . cache ( 'kpfexpose' ) SetSourceSelectShutters . execute ( OB ) OB [ 'TimedShutter_Scrambler' ] = True OB [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) SetTimedShutters . execute ( OB ) SetTriggeredDetectors . execute ( OB ) total_exptime = OB . get ( 'TimeOnPosition' ) SetExpTime . execute ({ 'ExpTime' : total_exptime }) # Configure Exposure Meter kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) ExpMeter_exptime = OB . get ( 'ExpMeter_exptime' ) log . info ( f \"Setting kpf_expmeter.EXPOSURE = { ExpMeter_exptime : .2f } s\" ) kpf_expmeter [ 'EXPOSURE' ] . write ( ExpMeter_exptime ) # Set up FVCs kpffvc = ktl . cache ( 'kpffvc' ) for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and OB . get ( f ' { FVC } FVC_exptime' , None ) != None : exptime = OB . get ( f ' { FVC } FVC_exptime' ) log . info ( f \"Setting { FVC } FVC ExpTime = { exptime : .2f } s\" ) SetFVCExpTime . execute ({ 'camera' : FVC , 'exptime' : exptime }) # for i,xi in enumerate(xis): # yis.reverse() # for j,yi in enumerate(yis): for i in xindicies : yindicies . reverse () for j in yindicies : check_scriptstop () if grid == 'TipTilt' : ##------------------------------------------------------ ## Tip Tilt ##------------------------------------------------------ log . info ( f \"Adjusting CURRENT_BASE to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) SetTipTiltTargetPixel . execute ({ 'x' : xs [ i ], 'y' : ys [ j ]}) sleep_time = 5 log . debug ( f \"Sleeping { sleep_time } s to allow tip tilt loop to settle\" ) time . sleep ( sleep_time ) xpix , ypix = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix : .2f } , { ypix : .2f } \" ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) log . info ( f \"Stopping tip tilt\" ) StopTipTilt . execute ({}) time . sleep ( 1 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) subprocess . call ([ 'kpf' , 'restart' , 'kpfguide2' ]) time . sleep ( 5 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) raise KPFError ( 'Lost Star' ) elif grid == 'SciADC' : ##------------------------------------------------------ ## Science ADC ##------------------------------------------------------ log . info ( f \"Offsetting to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) kpffiu [ 'ADC1VAL' ] . write ( xs [ i ]) kpffiu [ 'ADC2VAL' ] . write ( ys [ j ]) log . info ( f \"Absolute position: { xs [ i ] : .1f } { ys [ j ] : .1f } \" ) expr = '($kpffiu.ADC1STA == Ready) and ($kpffiu.ADC2STA == Ready)' success = ktl . waitFor ( expr , timeout = 2 * max ([ dx * nx , dy * ny ]) / 5 ) if success is not True : ADC1STA = kpffiu [ 'ADC1STA' ] . read () ADC2STA = kpffiu [ 'ADC2STA' ] . read () msg = f 'Timed out waiting for ADCs: ADC1STA= { ADC1STA } ADC2STA= { ADC2STA } ' raise KPFException ( msg ) WaitForReady . execute ({}) check_scriptstop () # Stop here if requested # Start Exposure Meter and Science Cameras kpfexpose [ 'OBJECT' ] . write ( f 'Grid search { xs [ i ] } , { ys [ j ] } ' ) log . info ( f \"Starting kpfexpose cameras\" ) StartExposure . execute ({}) # Begin timestamp for history retrieval begin = time . time () # Take CRED2 image if OB . get ( 'UseCRED2' , True ) is True : log . info ( 'Starting guider Trigger file' ) initial_last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () StartTriggerFile . execute ({}) # Start FVC Exposures initial_lastfile = {} failedFVCs = [] for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs : initial_lastfile [ FVC ] = kpffvc [ f \" { FVC } LASTFILE\" ] . read () log . debug ( f \" Initial lastfile for { FVC } = { initial_lastfile [ FVC ] } \" ) log . info ( f \" Starting { FVC } FVC exposure\" ) try : TakeFVCExposure . execute ({ 'camera' : FVC , 'wait' : False }) except : log . error ( 'Starting FVC image failed' ) failedFVCs . append ( FVC ) check_scriptstop () # Collect files for FVC exposures for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and FVC not in failedFVCs : log . info ( f \" Looking for output file for { FVC } \" ) expr = f '($kpffvc. { FVC } LASTFILE != \" { initial_lastfile [ FVC ] } \")' log . debug ( f \" Waiting for: { expr } \" ) if ktl . waitFor ( expr , timeout = 20 ) is False : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . error ( 'No new FVC file found' ) log . error ( f \" kpffvc. { FVC } LASTFILE = { lastfile } \" ) else : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . debug ( f \"Found { lastfile } \" ) row = { 'file' : lastfile , 'camera' : FVC , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) check_scriptstop () # Here's where we wait for the remainder of the TimeOnPosition log . info ( f \" Waiting for kpfexpose to be ready\" ) WaitForReady . execute ({}) # Collect CRED2 File if OB . get ( 'UseCRED2' , True ) is True : StopTriggerFile . execute ({}) WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_last_cube }) last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () row = { 'file' : last_cube , 'camera' : 'CRED2' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Stop Exposure Meter log . info ( f \" Waiting for ExpMeter to be Ready\" ) EMsuccess = ktl . waitFor ( '$kpf_expmeter.EXPSTATE == Ready' , timeout = 5 ) time . sleep ( 0.5 ) # Time shim because paranoia if EMsuccess is True : lastfile = kpf_expmeter [ 'FITSFILE' ] . read () else : lastfile = 'failed' log . debug ( f ' Done. FITSFILE= { lastfile } ' ) row = { 'file' : lastfile , 'camera' : 'ExpMeter' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) if EMsuccess is True : loutfile = kpf_expmeter [ 'LOUTFILE' ] . read () else : loutfile = 'failed' log . debug ( f ' Done. LOUTFILE= { loutfile } ' ) row = { 'file' : loutfile , 'camera' : 'ExpMeter_1Dspec' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Retrieve keyword history end = time . time () expmeter_data = { 'x' : xs [ i ], 'y' : ys [ j ], 'i' : i , 'j' : j , } log . info ( f \" Retrieving keyword history\" ) for counts_kw in [ 'CUR_COUNTS' , 'RAW_COUNTS' , 'BCK_COUNTS' ]: log . debug ( f \" Retrieving keyword history for { counts_kw } \" ) kws = { 'kpf_expmeter' : [ counts_kw ]} counts_history = keygrabber . retrieve ( kws , begin = begin , end = end ) # Extract counts and save to table (initial style output) fluxes = np . zeros (( len ( counts_history ) - 2 , 4 )) for k , entry in enumerate ( counts_history ): if k != 0 and k != len ( counts_history ) - 1 : value_floats = [ float ( v ) for v in entry [ 'ascvalue' ] . split ()] ts = datetime . fromtimestamp ( entry [ 'time' ]) . strftime ( '%Y-%m- %d %H:%M:%S' ) log . debug ( f \" { ts } : { value_floats } \" ) fluxes [ k - 1 ] = value_floats avg_fluxes = np . mean ( fluxes , axis = 0 ) expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 1\" ] = avg_fluxes [ 0 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 2\" ] = avg_fluxes [ 1 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 3\" ] = avg_fluxes [ 2 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 4\" ] = avg_fluxes [ 3 ] expmeter_data [ 'nimages' ] = len ( counts_history ) expmeter_flux . add_row ( expmeter_data ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if grid == 'TipTilt' : SetTipTiltTargetPixel . execute ({ 'x' : xpix0 , 'y' : ypix0 }) StopTipTilt . execute ({}) elif grid == 'SciADC' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) # kpffiu['ADCTRACK'].write('On') @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"GridSearch"},{"location":"scripts/GridSearch/#gridsearch","text":"Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine.","title":"GridSearch"},{"location":"scripts/GridSearch/#kpf.engineering.GridSearch.GridSearch--args","text":"None Source code in kpf/engineering/GridSearch.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class GridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_grid' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.4' ) check_input ( OB , 'Grid' , allowed_values = [ 'TipTilt' , 'SciADC' ]) check_input ( OB , 'nx' ) check_input ( OB , 'ny' ) check_input ( OB , 'dx' ) check_input ( OB , 'dy' ) check_input ( OB , 'ExpMeter_exptime' ) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) for FVC in FVCs : if FVC not in [ 'SCI' , 'CAHK' , 'EXT' , '' ]: raise FailedPreCondition ( f \"FVC { FVC } not supported\" ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) grid = OB . get ( 'Grid' ) this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { grid }{ this_file_name } _images_ { now_str } .txt' ) fluxes_file = log_path / Path ( f ' { grid }{ this_file_name } _fluxes_ { now_str } .txt' ) images = Table ( names = ( 'file' , 'camera' , 'x' , 'y' ), dtype = ( 'a90' , 'a10' , 'f4' , 'f4' )) expmeter_flux = Table ( names = ( 'i' , 'j' , 'x' , 'y' , 'bck1' , 'bck2' , 'bck3' , 'bck4' , 'cur1' , 'cur2' , 'cur3' , 'cur4' , 'raw1' , 'raw2' , 'raw3' , 'raw4' , 'nimages' ), dtype = ( 'i4' , 'i4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'i4' )) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) nx = OB . get ( 'nx' ) ny = OB . get ( 'ny' ) dx = OB . get ( 'dx' ) dy = OB . get ( 'dy' ) xis = [ xi for xi in range ( int ( - nx / 2 ), int (( nx + 1 ) / 2 ), 1 )] yis = [ yi for yi in range ( int ( - ny / 2 ), int (( ny + 1 ) / 2 ), 1 )] xindicies = [ ind for ind in range ( nx )] yindicies = [ ind for ind in range ( ny )] xs = [ xi * dx for xi in xis ] ys = [ yi * dy for yi in yis ] # Set up guider (assume parameters set during acquisition of star) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Setting TRIGCUBE Inactive' ) kpfguide [ 'TRIGCUBE' ] . write ( 'Inactive' ) if grid == 'TipTilt' : current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE = { current_base [ 0 ] : .2f } { current_base [ 1 ] : .2f } \" ) log . info ( f \"DAR_ENABLE = { kpfguide [ 'DAR_ENABLE' ] . read () } \" ) dar_offset = kpfguide [ 'DAR_OFFSET' ] . read ( binary = True ) log . info ( f \"DAR_OFFSET = { dar_offset [ 0 ] : .2f } { dar_offset [ 1 ] : .2f } \" ) xpix0 , ypix0 = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix0 : .2f } , { ypix0 : .2f } \" ) basex , basey = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE is { basex : .2f } , { basey : .2f } \" ) # Pixel targets must be in absolute coordinates xs = [ basex + xpix for xpix in xs ] ys = [ basey + ypix for ypix in ys ] elif grid == 'SciADC' : kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) nominalx , nominaly = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) x0 = OB . get ( 'ADC1Position' ) if str ( x0 ) . lower () == 'nominal' : x0 = nominalx else : x0 = float ( OB . get ( 'ADC1Position' )) y0 = OB . get ( 'ADC2Position' ) if str ( y0 ) . lower () == 'nominal' : y0 = nominaly else : y0 = float ( OB . get ( 'ADC2Position' )) log . info ( f \"ADC starting position: { x0 : .1f } { y0 : .1f } \" ) # Apply reverse rotation if requested if OB . get ( 'ADC1Reverse' , False ) is True : x0 = - x0 if OB . get ( 'ADC2Reverse' , False ) is True : y0 = - y0 log . info ( f \"ADC reverse nominal position: { x0 : .1f } { y0 : .1f } \" ) # Apply flip if requested if OB . get ( 'ADC1Flip' , False ) is True : x0 += 180 if OB . get ( 'ADC2Flip' , False ) is True : y0 += 180 log . info ( f \"ADC flip nominal position: { x0 : .1f } { y0 : .1f } \" ) xs = [ x + x0 for x in xs ] ys = [ y + y0 for y in ys ] # Set up kpfexpose kpfexpose = ktl . cache ( 'kpfexpose' ) SetSourceSelectShutters . execute ( OB ) OB [ 'TimedShutter_Scrambler' ] = True OB [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) SetTimedShutters . execute ( OB ) SetTriggeredDetectors . execute ( OB ) total_exptime = OB . get ( 'TimeOnPosition' ) SetExpTime . execute ({ 'ExpTime' : total_exptime }) # Configure Exposure Meter kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) ExpMeter_exptime = OB . get ( 'ExpMeter_exptime' ) log . info ( f \"Setting kpf_expmeter.EXPOSURE = { ExpMeter_exptime : .2f } s\" ) kpf_expmeter [ 'EXPOSURE' ] . write ( ExpMeter_exptime ) # Set up FVCs kpffvc = ktl . cache ( 'kpffvc' ) for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and OB . get ( f ' { FVC } FVC_exptime' , None ) != None : exptime = OB . get ( f ' { FVC } FVC_exptime' ) log . info ( f \"Setting { FVC } FVC ExpTime = { exptime : .2f } s\" ) SetFVCExpTime . execute ({ 'camera' : FVC , 'exptime' : exptime }) # for i,xi in enumerate(xis): # yis.reverse() # for j,yi in enumerate(yis): for i in xindicies : yindicies . reverse () for j in yindicies : check_scriptstop () if grid == 'TipTilt' : ##------------------------------------------------------ ## Tip Tilt ##------------------------------------------------------ log . info ( f \"Adjusting CURRENT_BASE to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) SetTipTiltTargetPixel . execute ({ 'x' : xs [ i ], 'y' : ys [ j ]}) sleep_time = 5 log . debug ( f \"Sleeping { sleep_time } s to allow tip tilt loop to settle\" ) time . sleep ( sleep_time ) xpix , ypix = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix : .2f } , { ypix : .2f } \" ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) log . info ( f \"Stopping tip tilt\" ) StopTipTilt . execute ({}) time . sleep ( 1 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) subprocess . call ([ 'kpf' , 'restart' , 'kpfguide2' ]) time . sleep ( 5 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) raise KPFError ( 'Lost Star' ) elif grid == 'SciADC' : ##------------------------------------------------------ ## Science ADC ##------------------------------------------------------ log . info ( f \"Offsetting to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) kpffiu [ 'ADC1VAL' ] . write ( xs [ i ]) kpffiu [ 'ADC2VAL' ] . write ( ys [ j ]) log . info ( f \"Absolute position: { xs [ i ] : .1f } { ys [ j ] : .1f } \" ) expr = '($kpffiu.ADC1STA == Ready) and ($kpffiu.ADC2STA == Ready)' success = ktl . waitFor ( expr , timeout = 2 * max ([ dx * nx , dy * ny ]) / 5 ) if success is not True : ADC1STA = kpffiu [ 'ADC1STA' ] . read () ADC2STA = kpffiu [ 'ADC2STA' ] . read () msg = f 'Timed out waiting for ADCs: ADC1STA= { ADC1STA } ADC2STA= { ADC2STA } ' raise KPFException ( msg ) WaitForReady . execute ({}) check_scriptstop () # Stop here if requested # Start Exposure Meter and Science Cameras kpfexpose [ 'OBJECT' ] . write ( f 'Grid search { xs [ i ] } , { ys [ j ] } ' ) log . info ( f \"Starting kpfexpose cameras\" ) StartExposure . execute ({}) # Begin timestamp for history retrieval begin = time . time () # Take CRED2 image if OB . get ( 'UseCRED2' , True ) is True : log . info ( 'Starting guider Trigger file' ) initial_last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () StartTriggerFile . execute ({}) # Start FVC Exposures initial_lastfile = {} failedFVCs = [] for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs : initial_lastfile [ FVC ] = kpffvc [ f \" { FVC } LASTFILE\" ] . read () log . debug ( f \" Initial lastfile for { FVC } = { initial_lastfile [ FVC ] } \" ) log . info ( f \" Starting { FVC } FVC exposure\" ) try : TakeFVCExposure . execute ({ 'camera' : FVC , 'wait' : False }) except : log . error ( 'Starting FVC image failed' ) failedFVCs . append ( FVC ) check_scriptstop () # Collect files for FVC exposures for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and FVC not in failedFVCs : log . info ( f \" Looking for output file for { FVC } \" ) expr = f '($kpffvc. { FVC } LASTFILE != \" { initial_lastfile [ FVC ] } \")' log . debug ( f \" Waiting for: { expr } \" ) if ktl . waitFor ( expr , timeout = 20 ) is False : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . error ( 'No new FVC file found' ) log . error ( f \" kpffvc. { FVC } LASTFILE = { lastfile } \" ) else : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . debug ( f \"Found { lastfile } \" ) row = { 'file' : lastfile , 'camera' : FVC , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) check_scriptstop () # Here's where we wait for the remainder of the TimeOnPosition log . info ( f \" Waiting for kpfexpose to be ready\" ) WaitForReady . execute ({}) # Collect CRED2 File if OB . get ( 'UseCRED2' , True ) is True : StopTriggerFile . execute ({}) WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_last_cube }) last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () row = { 'file' : last_cube , 'camera' : 'CRED2' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Stop Exposure Meter log . info ( f \" Waiting for ExpMeter to be Ready\" ) EMsuccess = ktl . waitFor ( '$kpf_expmeter.EXPSTATE == Ready' , timeout = 5 ) time . sleep ( 0.5 ) # Time shim because paranoia if EMsuccess is True : lastfile = kpf_expmeter [ 'FITSFILE' ] . read () else : lastfile = 'failed' log . debug ( f ' Done. FITSFILE= { lastfile } ' ) row = { 'file' : lastfile , 'camera' : 'ExpMeter' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) if EMsuccess is True : loutfile = kpf_expmeter [ 'LOUTFILE' ] . read () else : loutfile = 'failed' log . debug ( f ' Done. LOUTFILE= { loutfile } ' ) row = { 'file' : loutfile , 'camera' : 'ExpMeter_1Dspec' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Retrieve keyword history end = time . time () expmeter_data = { 'x' : xs [ i ], 'y' : ys [ j ], 'i' : i , 'j' : j , } log . info ( f \" Retrieving keyword history\" ) for counts_kw in [ 'CUR_COUNTS' , 'RAW_COUNTS' , 'BCK_COUNTS' ]: log . debug ( f \" Retrieving keyword history for { counts_kw } \" ) kws = { 'kpf_expmeter' : [ counts_kw ]} counts_history = keygrabber . retrieve ( kws , begin = begin , end = end ) # Extract counts and save to table (initial style output) fluxes = np . zeros (( len ( counts_history ) - 2 , 4 )) for k , entry in enumerate ( counts_history ): if k != 0 and k != len ( counts_history ) - 1 : value_floats = [ float ( v ) for v in entry [ 'ascvalue' ] . split ()] ts = datetime . fromtimestamp ( entry [ 'time' ]) . strftime ( '%Y-%m- %d %H:%M:%S' ) log . debug ( f \" { ts } : { value_floats } \" ) fluxes [ k - 1 ] = value_floats avg_fluxes = np . mean ( fluxes , axis = 0 ) expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 1\" ] = avg_fluxes [ 0 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 2\" ] = avg_fluxes [ 1 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 3\" ] = avg_fluxes [ 2 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 4\" ] = avg_fluxes [ 3 ] expmeter_data [ 'nimages' ] = len ( counts_history ) expmeter_flux . add_row ( expmeter_data ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if grid == 'TipTilt' : SetTipTiltTargetPixel . execute ({ 'x' : xpix0 , 'y' : ypix0 }) StopTipTilt . execute ({}) elif grid == 'SciADC' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) # kpffiu['ADCTRACK'].write('On') @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/GuiderLastfile/","text":"GuiderLastfile Bases: KPFTranslatorFunction Print the value of the kpfguide.LASTFILE keyword to STDOUT ARGS: :wait: bool Return only after lastfile is updated? (default = False) Source code in kpf/guider/GuiderLastfile.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class GuiderLastfile ( KPFTranslatorFunction ): '''Print the value of the kpfguide.LASTFILE keyword to STDOUT ARGS: ===== :wait: `bool` Return only after lastfile is updated? (default = False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) if args . get ( 'wait' , True ) is True : exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) initial_lastfile = kpfguide [ 'LASTFILE' ] . read () timeout = cfg . getfloat ( 'times' , 'kpfguide_shim_time' , fallback = 0.01 ) expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) lastfile = kpfguide [ 'LASTFILE' ] . read () print ( lastfile ) return lastfile @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"GuiderLastfile"},{"location":"scripts/GuiderLastfile/#guiderlastfile","text":"Bases: KPFTranslatorFunction Print the value of the kpfguide.LASTFILE keyword to STDOUT","title":"GuiderLastfile"},{"location":"scripts/GuiderLastfile/#kpf.guider.GuiderLastfile.GuiderLastfile--args","text":":wait: bool Return only after lastfile is updated? (default = False) Source code in kpf/guider/GuiderLastfile.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class GuiderLastfile ( KPFTranslatorFunction ): '''Print the value of the kpfguide.LASTFILE keyword to STDOUT ARGS: ===== :wait: `bool` Return only after lastfile is updated? (default = False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) if args . get ( 'wait' , True ) is True : exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) initial_lastfile = kpfguide [ 'LASTFILE' ] . read () timeout = cfg . getfloat ( 'times' , 'kpfguide_shim_time' , fallback = 0.01 ) expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) lastfile = kpfguide [ 'LASTFILE' ] . read () print ( lastfile ) return lastfile @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/GuiderOutdir/","text":"GuiderOutdir Bases: KPFTranslatorFunction Print the value of the kpfguide.OUTDIR keyword to STDOUT ARGS: None Source code in kpf/guider/GuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class GuiderOutdir ( KPFTranslatorFunction ): '''Print the value of the kpfguide.OUTDIR keyword to STDOUT ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) outdir = kpfguide [ 'OUTDIR' ] . read () print ( outdir ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"GuiderOutdir"},{"location":"scripts/GuiderOutdir/#guideroutdir","text":"Bases: KPFTranslatorFunction Print the value of the kpfguide.OUTDIR keyword to STDOUT","title":"GuiderOutdir"},{"location":"scripts/GuiderOutdir/#kpf.guider.GuiderOutdir.GuiderOutdir--args","text":"None Source code in kpf/guider/GuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class GuiderOutdir ( KPFTranslatorFunction ): '''Print the value of the kpfguide.OUTDIR keyword to STDOUT ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) outdir = kpfguide [ 'OUTDIR' ] . read () print ( outdir ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ImageBackIlluminatedFibers/","text":"ImageBackIlluminatedFibers Bases: KPFTranslatorFunction Take images of the back illuminated fibers using the FVCs Source code in kpf/engineering/ImageBackIlluminatedFibers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ImageBackIlluminatedFibers ( KPFTranslatorFunction ): '''Take images of the back illuminated fibers using the FVCs ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/' ) images_file = log_path / Path ( f ' { this_file_name } _images.txt' ) hstnow = datetime . now () now_str = hstnow . strftime ( '%Y-%m- %d %H:%M:%S' ) LEDoutlets = { 'Science' : 'E7' , 'Sky' : 'E8' , 'CaHK' : 'J7' , 'ExpMeter' : 'H1' } LEDnames = { 'Science' : 'Science Back-Illumination LED' , 'Sky' : 'Sky Back-Illumination LED' , 'CaHK' : 'HK Back-Illumination LED' , 'ExpMeter' : 'Exp Meter Back Illum LED' } exptimes = { 'SCI' : { 'Science' : 0.1 , 'Sky' : 1 , 'ExpMeter' : 2 }, 'CAHK' : { 'CaHK' : 5 } } kpffvc = ktl . cache ( 'kpffvc' ) kpfpower = ktl . cache ( 'kpfpower' ) kpffiu = ktl . cache ( 'kpffiu' ) def take_back_illuminated_image ( camera , LEDname ): log . info ( f \"Taking back illuminated image of { LEDname } fiber with { camera } FVC\" ) camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () == 'Off' : FVCPower . execute ({ 'camera' : camera , 'power' : 'on' }) # Time shim to let FVC service connect to camera after power up time . sleep ( 10 ) # Set ADC to Null if camera == 'SCI' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) success1 = kpffiu [ 'ADC1NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'ADC2NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on science ADC' ) elif camera == 'CAHK' : kpffiu [ 'HKXNAM' ] . write ( 'Null' ) kpffiu [ 'HKYNAM' ] . write ( 'Null' ) success1 = kpffiu [ 'HKXNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'HKYNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on HK ADC' ) # Turn LED on outlet = LEDoutlets [ LEDname ] if LEDnames [ LEDname ] != kpfpower [ f \"OUTLET_ { outlet } _NAME\" ] . read (): raise KPFException ( f \"Expected outlet { outlet } to have name { LEDnames [ LEDname ] } \" ) log . debug ( 'Turning LED on' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'On' ) # Take FVC Image SetFVCExpTime . execute ({ 'camera' : camera , 'exptime' : exptimes [ camera ][ LEDname ]}) lastfile = TakeFVCExposure . execute ({ 'camera' : camera }) log . info ( f ' LASTFILE: { lastfile } ' ) log . debug ( 'Turning LED off' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'Off' ) # Append to images file if images_file . exists () is False : # Write header line header = f \"# HST date, camera, LED, file \\n \" with open ( images_file , 'w' ) as f : f . write ( header ) row = f \" { now_str } , { camera : 4s } , { LEDname : 8s } , { lastfile } \\n \" with open ( images_file , 'a' ) as f : f . write ( row ) if args . get ( 'SCI' , False ) is True : take_back_illuminated_image ( 'SCI' , 'Science' ) take_back_illuminated_image ( 'SCI' , 'Sky' ) take_back_illuminated_image ( 'SCI' , 'ExpMeter' ) if args . get ( 'CAHK' , False ) is True : take_back_illuminated_image ( 'CAHK' , 'CaHK' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , \"--SCI\" , dest = \"SCI\" , default = False , action = \"store_true\" , help = \"Image science and sky fibers with science FVC?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , \"--CAHK\" , dest = \"CAHK\" , default = False , action = \"store_true\" , help = \"Image CaHK fiber with CaHK FVC?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ImageBackIlluminatedFibers"},{"location":"scripts/ImageBackIlluminatedFibers/#imagebackilluminatedfibers","text":"Bases: KPFTranslatorFunction Take images of the back illuminated fibers using the FVCs Source code in kpf/engineering/ImageBackIlluminatedFibers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ImageBackIlluminatedFibers ( KPFTranslatorFunction ): '''Take images of the back illuminated fibers using the FVCs ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/' ) images_file = log_path / Path ( f ' { this_file_name } _images.txt' ) hstnow = datetime . now () now_str = hstnow . strftime ( '%Y-%m- %d %H:%M:%S' ) LEDoutlets = { 'Science' : 'E7' , 'Sky' : 'E8' , 'CaHK' : 'J7' , 'ExpMeter' : 'H1' } LEDnames = { 'Science' : 'Science Back-Illumination LED' , 'Sky' : 'Sky Back-Illumination LED' , 'CaHK' : 'HK Back-Illumination LED' , 'ExpMeter' : 'Exp Meter Back Illum LED' } exptimes = { 'SCI' : { 'Science' : 0.1 , 'Sky' : 1 , 'ExpMeter' : 2 }, 'CAHK' : { 'CaHK' : 5 } } kpffvc = ktl . cache ( 'kpffvc' ) kpfpower = ktl . cache ( 'kpfpower' ) kpffiu = ktl . cache ( 'kpffiu' ) def take_back_illuminated_image ( camera , LEDname ): log . info ( f \"Taking back illuminated image of { LEDname } fiber with { camera } FVC\" ) camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () == 'Off' : FVCPower . execute ({ 'camera' : camera , 'power' : 'on' }) # Time shim to let FVC service connect to camera after power up time . sleep ( 10 ) # Set ADC to Null if camera == 'SCI' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) success1 = kpffiu [ 'ADC1NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'ADC2NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on science ADC' ) elif camera == 'CAHK' : kpffiu [ 'HKXNAM' ] . write ( 'Null' ) kpffiu [ 'HKYNAM' ] . write ( 'Null' ) success1 = kpffiu [ 'HKXNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'HKYNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on HK ADC' ) # Turn LED on outlet = LEDoutlets [ LEDname ] if LEDnames [ LEDname ] != kpfpower [ f \"OUTLET_ { outlet } _NAME\" ] . read (): raise KPFException ( f \"Expected outlet { outlet } to have name { LEDnames [ LEDname ] } \" ) log . debug ( 'Turning LED on' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'On' ) # Take FVC Image SetFVCExpTime . execute ({ 'camera' : camera , 'exptime' : exptimes [ camera ][ LEDname ]}) lastfile = TakeFVCExposure . execute ({ 'camera' : camera }) log . info ( f ' LASTFILE: { lastfile } ' ) log . debug ( 'Turning LED off' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'Off' ) # Append to images file if images_file . exists () is False : # Write header line header = f \"# HST date, camera, LED, file \\n \" with open ( images_file , 'w' ) as f : f . write ( header ) row = f \" { now_str } , { camera : 4s } , { LEDname : 8s } , { lastfile } \\n \" with open ( images_file , 'a' ) as f : f . write ( row ) if args . get ( 'SCI' , False ) is True : take_back_illuminated_image ( 'SCI' , 'Science' ) take_back_illuminated_image ( 'SCI' , 'Sky' ) take_back_illuminated_image ( 'SCI' , 'ExpMeter' ) if args . get ( 'CAHK' , False ) is True : take_back_illuminated_image ( 'CAHK' , 'CaHK' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , \"--SCI\" , dest = \"SCI\" , default = False , action = \"store_true\" , help = \"Image science and sky fibers with science FVC?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , \"--CAHK\" , dest = \"CAHK\" , default = False , action = \"store_true\" , help = \"Image CaHK fiber with CaHK FVC?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ImageBackIlluminatedFibers"},{"location":"scripts/InitializeTipTilt/","text":"InitializeTipTilt Bases: KPFTranslatorFunction Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. ARGS: None Source code in kpf/fiu/InitializeTipTilt.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class InitializeTipTilt ( KPFTranslatorFunction ): '''Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . debug ( f \"Initializing tip tilt mirror\" ) kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) kpffiu [ 'TTXSRV' ] . write ( 'closed' ) kpffiu [ 'TTYSRV' ] . write ( 'closed' ) time . sleep ( 1 ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) timeout = 1000 * movetime tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) if not ktl . waitFor ( '($kpffiu.TTXSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXSRV' ] . read (), 'closed' ) if not ktl . waitFor ( '($kpffiu.TTYSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYSRV' ] . read (), 'closed' ) expr = ( f '($kpffiu.TTXVAX >= { home [ 0 ] - tol } ) and ' \\ f '($kpffiu.TTXVAX <= { home [ 0 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), f \" { home [ 0 ] } \" ) expr = ( f '($kpffiu.TTYVAX >= { home [ 1 ] - tol } ) and ' \\ f '($kpffiu.TTYVAX <= { home [ 1 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), f \" { home [ 1 ] } \" )","title":"InitializeTipTilt"},{"location":"scripts/InitializeTipTilt/#initializetiptilt","text":"Bases: KPFTranslatorFunction Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0.","title":"InitializeTipTilt"},{"location":"scripts/InitializeTipTilt/#kpf.fiu.InitializeTipTilt.InitializeTipTilt--args","text":"None Source code in kpf/fiu/InitializeTipTilt.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class InitializeTipTilt ( KPFTranslatorFunction ): '''Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . debug ( f \"Initializing tip tilt mirror\" ) kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) kpffiu [ 'TTXSRV' ] . write ( 'closed' ) kpffiu [ 'TTYSRV' ] . write ( 'closed' ) time . sleep ( 1 ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) timeout = 1000 * movetime tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) if not ktl . waitFor ( '($kpffiu.TTXSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXSRV' ] . read (), 'closed' ) if not ktl . waitFor ( '($kpffiu.TTYSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYSRV' ] . read (), 'closed' ) expr = ( f '($kpffiu.TTXVAX >= { home [ 0 ] - tol } ) and ' \\ f '($kpffiu.TTXVAX <= { home [ 0 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), f \" { home [ 0 ] } \" ) expr = ( f '($kpffiu.TTYVAX >= { home [ 1 ] - tol } ) and ' \\ f '($kpffiu.TTYVAX <= { home [ 1 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), f \" { home [ 1 ] } \" )","title":"ARGS:"},{"location":"scripts/IsCalSourceEnabled/","text":"IsCalSourceEnabled Bases: KPFTranslatorFunction Description Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. KTL Keywords Used kpfcal.OCTAGON kpfconfig.BRDBANDFIBER_ENABLED kpfconfig.U_GOLD_ENABLED kpfconfig.U_DAILY_ENABLED kpfconfig.TH_DAILY_ENABLED kpfconfig.TH_GOLD_ENABLED kpfconfig.FF_FIBER_ENABLED kpfconfig.EXPMLED_ENABLED kpfconfig.HKLED_ENABLED kpfconfig.SCILED_ENABLED kpfconfig.SKYLED_ENABLED Scripts Called None Parameters CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Source code in kpf/calbench/IsCalSourceEnabled.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class IsCalSourceEnabled ( KPFTranslatorFunction ): '''# Description Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. ## KTL Keywords Used - `kpfcal.OCTAGON` - `kpfconfig.BRDBANDFIBER_ENABLED` - `kpfconfig.U_GOLD_ENABLED` - `kpfconfig.U_DAILY_ENABLED` - `kpfconfig.TH_DAILY_ENABLED` - `kpfconfig.TH_GOLD_ENABLED` - `kpfconfig.FF_FIBER_ENABLED` - `kpfconfig.EXPMLED_ENABLED` - `kpfconfig.HKLED_ENABLED` - `kpfconfig.SCILED_ENABLED` - `kpfconfig.SKYLED_ENABLED` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) allowed_values . append ( 'SoCal-SciSky' ) allowed_values . append ( 'WideFlat' ) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): calsource = args . get ( 'CalSource' ) if calsource in [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' ]: lamp_name = standardize_lamp_name ( calsource ) elif calsource in [ 'LFCFiber' , 'EtalonFiber' ]: lamp_name = calsource . upper () elif calsource in [ 'SoCal-CalFib' , 'SoCal-SciSky' ]: lamp_name = calsource . replace ( '-' , '_' ) . replace ( 'Sky' , 'FIB' ) else : log . warning ( f \"IsCalSourceEnabled does not recognize ' { calsource } '\" ) return True lamp_enabledkw = ktl . cache ( 'kpfconfig' , f ' { lamp_name } _ENABLED' ) lamp_enabled = lamp_enabledkw . read ( binary = True ) if lamp_enabled is True : log . debug ( f \"Cal source { calsource } is enabled\" ) else : log . warning ( f \"Cal source { calsource } is disabled\" ) return lamp_enabled @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'LFCFiber' , 'EtalonFiber' , 'SoCal-CalFib' , 'SoCal-SciSky' ], help = 'Which lamp to check?' ) return super () . add_cmdline_args ( parser , cfg )","title":"IsCalSourceEnabled"},{"location":"scripts/IsCalSourceEnabled/#iscalsourceenabled","text":"Bases: KPFTranslatorFunction","title":"IsCalSourceEnabled"},{"location":"scripts/IsCalSourceEnabled/#kpf.calbench.IsCalSourceEnabled.IsCalSourceEnabled--description","text":"Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords.","title":"Description"},{"location":"scripts/IsCalSourceEnabled/#kpf.calbench.IsCalSourceEnabled.IsCalSourceEnabled--ktl-keywords-used","text":"kpfcal.OCTAGON kpfconfig.BRDBANDFIBER_ENABLED kpfconfig.U_GOLD_ENABLED kpfconfig.U_DAILY_ENABLED kpfconfig.TH_DAILY_ENABLED kpfconfig.TH_GOLD_ENABLED kpfconfig.FF_FIBER_ENABLED kpfconfig.EXPMLED_ENABLED kpfconfig.HKLED_ENABLED kpfconfig.SCILED_ENABLED kpfconfig.SKYLED_ENABLED","title":"KTL Keywords Used"},{"location":"scripts/IsCalSourceEnabled/#kpf.calbench.IsCalSourceEnabled.IsCalSourceEnabled--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/IsCalSourceEnabled/#kpf.calbench.IsCalSourceEnabled.IsCalSourceEnabled--parameters","text":"CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Source code in kpf/calbench/IsCalSourceEnabled.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class IsCalSourceEnabled ( KPFTranslatorFunction ): '''# Description Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. ## KTL Keywords Used - `kpfcal.OCTAGON` - `kpfconfig.BRDBANDFIBER_ENABLED` - `kpfconfig.U_GOLD_ENABLED` - `kpfconfig.U_DAILY_ENABLED` - `kpfconfig.TH_DAILY_ENABLED` - `kpfconfig.TH_GOLD_ENABLED` - `kpfconfig.FF_FIBER_ENABLED` - `kpfconfig.EXPMLED_ENABLED` - `kpfconfig.HKLED_ENABLED` - `kpfconfig.SCILED_ENABLED` - `kpfconfig.SKYLED_ENABLED` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) allowed_values . append ( 'SoCal-SciSky' ) allowed_values . append ( 'WideFlat' ) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): calsource = args . get ( 'CalSource' ) if calsource in [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' ]: lamp_name = standardize_lamp_name ( calsource ) elif calsource in [ 'LFCFiber' , 'EtalonFiber' ]: lamp_name = calsource . upper () elif calsource in [ 'SoCal-CalFib' , 'SoCal-SciSky' ]: lamp_name = calsource . replace ( '-' , '_' ) . replace ( 'Sky' , 'FIB' ) else : log . warning ( f \"IsCalSourceEnabled does not recognize ' { calsource } '\" ) return True lamp_enabledkw = ktl . cache ( 'kpfconfig' , f ' { lamp_name } _ENABLED' ) lamp_enabled = lamp_enabledkw . read ( binary = True ) if lamp_enabled is True : log . debug ( f \"Cal source { calsource } is enabled\" ) else : log . warning ( f \"Cal source { calsource } is disabled\" ) return lamp_enabled @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'LFCFiber' , 'EtalonFiber' , 'SoCal-CalFib' , 'SoCal-SciSky' ], help = 'Which lamp to check?' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/IsSoCalClosed/","text":"IsSoCalClosed Bases: KPFTranslatorFunction Returns True if SoCal enclsoure is closed. ARGS: None Source code in kpf/socal/IsSoCalClosed.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalClosed ( KPFTranslatorFunction ): '''Returns True if SoCal enclsoure is closed. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) msg = { True : 'SoCal is Closed' , False : 'SoCal is NOT Closed' }[ is_closed ] print ( msg ) return is_closed @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"IsSoCalClosed"},{"location":"scripts/IsSoCalClosed/#issocalclosed","text":"Bases: KPFTranslatorFunction Returns True if SoCal enclsoure is closed.","title":"IsSoCalClosed"},{"location":"scripts/IsSoCalClosed/#kpf.socal.IsSoCalClosed.IsSoCalClosed--args","text":"None Source code in kpf/socal/IsSoCalClosed.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalClosed ( KPFTranslatorFunction ): '''Returns True if SoCal enclsoure is closed. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) msg = { True : 'SoCal is Closed' , False : 'SoCal is NOT Closed' }[ is_closed ] print ( msg ) return is_closed @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/IsSoCalOpen/","text":"IsSoCalOpen Bases: KPFTranslatorFunction Returns True if SoCal enclsoure is open. ARGS: None Source code in kpf/socal/IsSoCalOpen.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalOpen ( KPFTranslatorFunction ): '''Returns True if SoCal enclsoure is open. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_open = ENCSTA . waitFor ( \"==0\" , timeout = timeout ) msg = { True : 'SoCal is Open' , False : 'SoCal is NOT Open' }[ is_open ] print ( msg ) return is_open @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"IsSoCalOpen"},{"location":"scripts/IsSoCalOpen/#issocalopen","text":"Bases: KPFTranslatorFunction Returns True if SoCal enclsoure is open.","title":"IsSoCalOpen"},{"location":"scripts/IsSoCalOpen/#kpf.socal.IsSoCalOpen.IsSoCalOpen--args","text":"None Source code in kpf/socal/IsSoCalOpen.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalOpen ( KPFTranslatorFunction ): '''Returns True if SoCal enclsoure is open. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_open = ENCSTA . waitFor ( \"==0\" , timeout = timeout ) msg = { True : 'SoCal is Open' , False : 'SoCal is NOT Open' }[ is_open ] print ( msg ) return is_open @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/IsSoCalShutDown/","text":"IsSoCalShutDown Bases: KPFTranslatorFunction Returns True if SoCal enclosure is closed and tracker is parked. ARGS: None Source code in kpf/socal/IsSoCalShutDown.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class IsSoCalShutDown ( KPFTranslatorFunction ): '''Returns True if SoCal enclosure is closed and tracker is parked. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Enclosure timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) EKOHOME = ktl . cache ( 'kpfsocal' , 'EKOHOME' ) is_home = EKOHOME . waitFor ( \"==1\" , timeout = timeout ) closedstr = { True : '' , False : 'NOT ' }[ is_closed ] parkedstr = { True : '' , False : 'NOT ' }[ is_home ] msg = f 'SoCal is { closedstr } closed and { parkedstr } parked' print ( msg ) shutdown = is_closed and is_home if not shutdown and args . get ( 'email' , False ) is True : try : SendEmail . execute ({ 'Subject' : f 'KPF SoCal is not shut down properly' , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) return shutdown @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if SoCal is not shut down?' ) return super () . add_cmdline_args ( parser , cfg )","title":"IsSoCalShutDown"},{"location":"scripts/IsSoCalShutDown/#issocalshutdown","text":"Bases: KPFTranslatorFunction Returns True if SoCal enclosure is closed and tracker is parked.","title":"IsSoCalShutDown"},{"location":"scripts/IsSoCalShutDown/#kpf.socal.IsSoCalShutDown.IsSoCalShutDown--args","text":"None Source code in kpf/socal/IsSoCalShutDown.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class IsSoCalShutDown ( KPFTranslatorFunction ): '''Returns True if SoCal enclosure is closed and tracker is parked. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Enclosure timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) EKOHOME = ktl . cache ( 'kpfsocal' , 'EKOHOME' ) is_home = EKOHOME . waitFor ( \"==1\" , timeout = timeout ) closedstr = { True : '' , False : 'NOT ' }[ is_closed ] parkedstr = { True : '' , False : 'NOT ' }[ is_home ] msg = f 'SoCal is { closedstr } closed and { parkedstr } parked' print ( msg ) shutdown = is_closed and is_home if not shutdown and args . get ( 'email' , False ) is True : try : SendEmail . execute ({ 'Subject' : f 'KPF SoCal is not shut down properly' , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) return shutdown @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if SoCal is not shut down?' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/LockFIU/","text":"LockFIU Bases: KPFTranslatorFunction Lock the FIU mechanisms ARGS: :comment: - A comment (must not be empty) designating why the mechanisms are locked. Source code in kpf/fiu/LockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class LockFIU ( KPFTranslatorFunction ): '''Lock the FIU mechanisms ARGS: ===== :comment: - A comment (must not be empty) designating why the mechanisms are locked. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): comment = args . get ( 'comment' , 'locked' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( comment ) kpffiu [ 'adc2lck' ] . write ( comment ) kpffiu [ 'foldlck' ] . write ( comment ) kpffiu [ 'hkxlck=' ] . write ( comment ) kpffiu [ 'hkylck=' ] . write ( comment ) kpffiu [ 'ttxlck=' ] . write ( comment ) kpffiu [ 'ttylck=' ] . write ( comment ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'comment' , type = str , help = 'Comment for lock keywords' ) return super () . add_cmdline_args ( parser , cfg )","title":"LockFIU"},{"location":"scripts/LockFIU/#lockfiu","text":"Bases: KPFTranslatorFunction Lock the FIU mechanisms","title":"LockFIU"},{"location":"scripts/LockFIU/#kpf.fiu.LockFIU.LockFIU--args","text":":comment: - A comment (must not be empty) designating why the mechanisms are locked. Source code in kpf/fiu/LockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class LockFIU ( KPFTranslatorFunction ): '''Lock the FIU mechanisms ARGS: ===== :comment: - A comment (must not be empty) designating why the mechanisms are locked. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): comment = args . get ( 'comment' , 'locked' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( comment ) kpffiu [ 'adc2lck' ] . write ( comment ) kpffiu [ 'foldlck' ] . write ( comment ) kpffiu [ 'hkxlck=' ] . write ( comment ) kpffiu [ 'hkylck=' ] . write ( comment ) kpffiu [ 'ttxlck=' ] . write ( comment ) kpffiu [ 'ttylck=' ] . write ( comment ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'comment' , type = str , help = 'Comment for lock keywords' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/MeasureTipTiltMirrorRange/","text":"MeasureTipTiltMirrorRange Bases: KPFTranslatorFunction ARGS: None Source code in kpf/fiu/MeasureTipTiltMirrorRange.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class MeasureTipTiltMirrorRange ( KPFTranslatorFunction ): ''' ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Measure tip tilt ranges log . info ( 'Beginning MeasureTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) sleeptime = 10 # Set by the 5 second time in the %MEX and %MEV keywords # Need to account for worst case tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) n = args . get ( 'repeats' ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) measured_range = {} axis = [ 'X' , 'Y' ] rawvals = {} update_ax = { 'X' : False , 'Y' : False } for i , ax in enumerate ( axis ): nominal_range = { 'X' : 15.9 , 'Y' : 24.6 }[ ax ] home = 0 measured_range [ ax ] = [ - nominal_range , nominal_range ] rawvals [ ax ] = [ None , None ] # Negative side commanded_position = home - nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 0 ] = new_limit # Positive side commanded_position = home + nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 1 ] = new_limit time . sleep ( sleeptime ) InitializeTipTilt . execute ({}) time . sleep ( sleeptime ) log . info ( f \"Measured X range: { measured_range [ 'X' ] } \" ) log . info ( f \"Measured Y range: { measured_range [ 'Y' ] } \" ) new_home = [ np . mean ( measured_range [ 'X' ]), np . mean ( measured_range [ 'Y' ])] current_home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True ) if np . isclose ( current_home [ 0 ], new_home [ 0 ]) and np . isclose ( current_home [ 1 ], new_home [ 1 ]): print ( f 'TIPTILT_HOME OK: gshow -s kpfguide TIPTILT_HOME matches { new_home } ' ) else : print ( f \"modify -s kpfguide TIPTILT_HOME=' { new_home [ 0 ] : .1f } { new_home [ 1 ] : .1f } '\" ) for i , ax in enumerate ( axis ): print () range = ( max ( measured_range [ ax ]) - min ( measured_range [ ax ])) / 2 print ( f \"modify -s kpfguide TIPTILT_ { ax } RANGE= { range : .1f } \" ) print ( f \" Sending { ax } to home\" ) kpffiu [ f 'TT { ax } VAX' ] . write ( new_home [ i ]) time . sleep ( sleeptime ) new_RON = kpffiu [ f 'TT { ax } MED' ] . read () print ( f \"modify -s kpffiu TT { ax } RON='| { new_RON } |0|Home'\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--repeats' , type = int , default = 1 , help = \"The number of iterations to use in the calculation\" ) return super () . add_cmdline_args ( parser , cfg )","title":"MeasureTipTiltMirrorRange"},{"location":"scripts/MeasureTipTiltMirrorRange/#measuretiptiltmirrorrange","text":"Bases: KPFTranslatorFunction","title":"MeasureTipTiltMirrorRange"},{"location":"scripts/MeasureTipTiltMirrorRange/#kpf.fiu.MeasureTipTiltMirrorRange.MeasureTipTiltMirrorRange--args","text":"None Source code in kpf/fiu/MeasureTipTiltMirrorRange.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 class MeasureTipTiltMirrorRange ( KPFTranslatorFunction ): ''' ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Measure tip tilt ranges log . info ( 'Beginning MeasureTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) sleeptime = 10 # Set by the 5 second time in the %MEX and %MEV keywords # Need to account for worst case tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) n = args . get ( 'repeats' ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) measured_range = {} axis = [ 'X' , 'Y' ] rawvals = {} update_ax = { 'X' : False , 'Y' : False } for i , ax in enumerate ( axis ): nominal_range = { 'X' : 15.9 , 'Y' : 24.6 }[ ax ] home = 0 measured_range [ ax ] = [ - nominal_range , nominal_range ] rawvals [ ax ] = [ None , None ] # Negative side commanded_position = home - nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 0 ] = new_limit # Positive side commanded_position = home + nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 1 ] = new_limit time . sleep ( sleeptime ) InitializeTipTilt . execute ({}) time . sleep ( sleeptime ) log . info ( f \"Measured X range: { measured_range [ 'X' ] } \" ) log . info ( f \"Measured Y range: { measured_range [ 'Y' ] } \" ) new_home = [ np . mean ( measured_range [ 'X' ]), np . mean ( measured_range [ 'Y' ])] current_home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True ) if np . isclose ( current_home [ 0 ], new_home [ 0 ]) and np . isclose ( current_home [ 1 ], new_home [ 1 ]): print ( f 'TIPTILT_HOME OK: gshow -s kpfguide TIPTILT_HOME matches { new_home } ' ) else : print ( f \"modify -s kpfguide TIPTILT_HOME=' { new_home [ 0 ] : .1f } { new_home [ 1 ] : .1f } '\" ) for i , ax in enumerate ( axis ): print () range = ( max ( measured_range [ ax ]) - min ( measured_range [ ax ])) / 2 print ( f \"modify -s kpfguide TIPTILT_ { ax } RANGE= { range : .1f } \" ) print ( f \" Sending { ax } to home\" ) kpffiu [ f 'TT { ax } VAX' ] . write ( new_home [ i ]) time . sleep ( sleeptime ) new_RON = kpffiu [ f 'TT { ax } MED' ] . read () print ( f \"modify -s kpffiu TT { ax } RON='| { new_RON } |0|Home'\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--repeats' , type = int , default = 1 , help = \"The number of iterations to use in the calculation\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/OptimizeGuiderExposure/","text":"OptimizeGuiderExposure Bases: KPFTranslatorFunction Target peak = 4000 ADU Reasonable range = 3000-9000 ADU (0.5-1.5x target) Source code in kpf/guider/OptimizeGuiderExposure.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class OptimizeGuiderExposure ( KPFTranslatorFunction ): ''' Target peak = 4000 ADU Reasonable range = 3000-9000 ADU (0.5-1.5x target) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Running OptimizeGuiderExposure' ) setvalues = args . get ( \"set\" , False ) log . debug ( f 'set = { setvalues } ' ) target_peak = 4000 log . debug ( f 'target_peak = { target_peak } ' ) kpfguide = ktl . cache ( 'kpfguide' ) gain = kpfguide [ 'GAIN' ] . read ( binary = True ) # 0 Low 1 Medium 2 High fps = kpfguide [ 'FPS' ] . read ( binary = True ) time_shim = 1 / fps + 0.5 # If TIPTILT_CALC is not on, turn it on if kpfguide [ 'TIPTILT_CALC' ] . read () == 'Inactive' : log . info ( 'Turning TIPTILT_CALC on' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Active' ) time . sleep ( time_shim ) # Check peak value peak = kpfguide [ 'OBJECT_PEAK' ] . read ( binary = True ) peak_ratio = peak / target_peak if peak_ratio > 2 : # Star is dangerously bright, increase FPS new_fps = int ( fps * peak_ratio ) if setvalues is True : log . info ( f 'Setting new FPS = { new_fps } ' ) kpfguide [ 'FPS' ] . write ( new_fps ) else : print ( f 'Recommend new FPS: { new_fps } ' ) elif peak_ratio > 0.5 : # Star is in reasonable brightness range pass elif peak_ratio > 0.1 : # Star is somewhat faint, decrease FPS new_fps = int ( fps * peak_ratio ) if setvalues is True : log . info ( f 'Setting new FPS = { new_fps } ' ) kpfguide [ 'FPS' ] . write ( new_fps ) else : print ( f 'Recommend new FPS: { new_fps } ' ) else : # Star is very faint, possibly undetected log . info ( 'Star is very faint or undetected' ) if gain < 2 : newgain = gain + 1 if setvalues is True : gain_string = { 0 : 'low' , 1 : 'medium' , 2 : 'high' }[ newgain ] log . info ( f 'Increasing gain to { gain_string } ' ) kpfguide [ 'GAIN' ] . write ( newgain ) time . sleep ( time_shim ) OptimizeGuiderExposure . execute ( args ) else : print ( f 'Recommend incrasing gain to { newgain } ' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set the resulting gain and FPS?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"OptimizeGuiderExposure"},{"location":"scripts/OptimizeGuiderExposure/#optimizeguiderexposure","text":"Bases: KPFTranslatorFunction Target peak = 4000 ADU Reasonable range = 3000-9000 ADU (0.5-1.5x target) Source code in kpf/guider/OptimizeGuiderExposure.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class OptimizeGuiderExposure ( KPFTranslatorFunction ): ''' Target peak = 4000 ADU Reasonable range = 3000-9000 ADU (0.5-1.5x target) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Running OptimizeGuiderExposure' ) setvalues = args . get ( \"set\" , False ) log . debug ( f 'set = { setvalues } ' ) target_peak = 4000 log . debug ( f 'target_peak = { target_peak } ' ) kpfguide = ktl . cache ( 'kpfguide' ) gain = kpfguide [ 'GAIN' ] . read ( binary = True ) # 0 Low 1 Medium 2 High fps = kpfguide [ 'FPS' ] . read ( binary = True ) time_shim = 1 / fps + 0.5 # If TIPTILT_CALC is not on, turn it on if kpfguide [ 'TIPTILT_CALC' ] . read () == 'Inactive' : log . info ( 'Turning TIPTILT_CALC on' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Active' ) time . sleep ( time_shim ) # Check peak value peak = kpfguide [ 'OBJECT_PEAK' ] . read ( binary = True ) peak_ratio = peak / target_peak if peak_ratio > 2 : # Star is dangerously bright, increase FPS new_fps = int ( fps * peak_ratio ) if setvalues is True : log . info ( f 'Setting new FPS = { new_fps } ' ) kpfguide [ 'FPS' ] . write ( new_fps ) else : print ( f 'Recommend new FPS: { new_fps } ' ) elif peak_ratio > 0.5 : # Star is in reasonable brightness range pass elif peak_ratio > 0.1 : # Star is somewhat faint, decrease FPS new_fps = int ( fps * peak_ratio ) if setvalues is True : log . info ( f 'Setting new FPS = { new_fps } ' ) kpfguide [ 'FPS' ] . write ( new_fps ) else : print ( f 'Recommend new FPS: { new_fps } ' ) else : # Star is very faint, possibly undetected log . info ( 'Star is very faint or undetected' ) if gain < 2 : newgain = gain + 1 if setvalues is True : gain_string = { 0 : 'low' , 1 : 'medium' , 2 : 'high' }[ newgain ] log . info ( f 'Increasing gain to { gain_string } ' ) kpfguide [ 'GAIN' ] . write ( newgain ) time . sleep ( time_shim ) OptimizeGuiderExposure . execute ( args ) else : print ( f 'Recommend incrasing gain to { newgain } ' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set the resulting gain and FPS?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"OptimizeGuiderExposure"},{"location":"scripts/ParkSoCal/","text":"ParkSoCal Bases: KPFTranslatorFunction Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. ARGS: None Source code in kpf/socal/ParkSoCal.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ParkSoCal ( KPFTranslatorFunction ): '''Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): SoCalStopAutonomous . execute ({}) log . info ( 'Parking SoCal' ) kpfsocal = ktl . cache ( 'kpfsocal' ) kpfsocal [ 'ENCCMD' ] . write ( 'close' ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) kpfsocal [ 'EKOTARGALT' ] . write ( 0 ) kpfsocal [ 'EKOTARGAZ' ] . write ( 0 ) kpfsocal [ 'EKOMODE' ] . write ( 0 ) kpfsocal [ 'EKOSLEW' ] . write ( 1 ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfsocal = ktl . cache ( 'kpfsocal' ) timeout = cfg . getfloat ( 'SoCal' , 'park_time' , fallback = 300 ) expr = '($kpfsocal.ENCSTA == 1) ' expr += 'and ($kpfsocal.EKOHOME == 1)' success = ktl . waitFor ( expr , timeout = timeout ) if success is False : raise FailedToReachDestination ( 'SoCal failed to park completely' )","title":"ParkSoCal"},{"location":"scripts/ParkSoCal/#parksocal","text":"Bases: KPFTranslatorFunction Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker.","title":"ParkSoCal"},{"location":"scripts/ParkSoCal/#kpf.socal.ParkSoCal.ParkSoCal--args","text":"None Source code in kpf/socal/ParkSoCal.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ParkSoCal ( KPFTranslatorFunction ): '''Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): SoCalStopAutonomous . execute ({}) log . info ( 'Parking SoCal' ) kpfsocal = ktl . cache ( 'kpfsocal' ) kpfsocal [ 'ENCCMD' ] . write ( 'close' ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) kpfsocal [ 'EKOTARGALT' ] . write ( 0 ) kpfsocal [ 'EKOTARGAZ' ] . write ( 0 ) kpfsocal [ 'EKOMODE' ] . write ( 0 ) kpfsocal [ 'EKOSLEW' ] . write ( 1 ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfsocal = ktl . cache ( 'kpfsocal' ) timeout = cfg . getfloat ( 'SoCal' , 'park_time' , fallback = 300 ) expr = '($kpfsocal.ENCSTA == 1) ' expr += 'and ($kpfsocal.EKOHOME == 1)' success = ktl . waitFor ( expr , timeout = timeout ) if success is False : raise FailedToReachDestination ( 'SoCal failed to park completely' )","title":"ARGS:"},{"location":"scripts/PowerCycleCaHK/","text":"PowerCycleCaHK Bases: KPFTranslatorFunction Description Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. KTL Keywords Used kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% Scripts Called - kpf start/stop/status/restart kpfexpose2 - kpf start/stop/status/restart kpf_hk Parameters None Source code in kpf/cahk/PowerCycleCaHK.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class PowerCycleCaHK ( KPFTranslatorFunction ): '''# Description Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. ## KTL Keywords Used - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` ## Scripts Called -`kpf start/stop/status/restart kpfexpose2` -`kpf start/stop/status/restart kpf_hk` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ( 'J5' , 'Andor Newton PS' ), ] for outlet_id , outlet_name in outlets : name = kpfpower [ f 'OUTLET_ { outlet_id } _NAME' ] . read () if name . find ( outlet_name ) < 0 : raise FailedPreCondition ( f \"Outlet name: { outlet_id } != ' { outlet_name } '\" ) @classmethod def perform ( cls , args , logger , cfg ): log . warning ( 'Stopping kpfexpose2 dispatcher' ) cmd = [ 'kpf' , 'stop' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpfexpose2 command appears to have failed\" ) time . sleep ( 2 ) log . warning ( 'Stopping kpf_hk keyword service' ) cmd = [ 'kpf' , 'stop' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpf_hk command appears to have failed\" ) time . sleep ( 2 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Power cycling the Ca HK detector system' ) kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ( 'J5' , 'Andor Newton PS' ), ] for outlet_id , outlet_name in outlets : log . info ( f \"Powering off { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'Off' ) time . sleep ( 10 ) for outlet_id , outlet_name in outlets : log . info ( f \"Powering on { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'On' ) time . sleep ( 10 ) log . warning ( 'Restarting kpf_hk keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpf_hk command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Restarting kpfexpose2 keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpfexpose2 command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Resetting Ca HK' ) ResetCaHKDetector . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"PowerCycleCaHK"},{"location":"scripts/PowerCycleCaHK/#powercyclecahk","text":"Bases: KPFTranslatorFunction","title":"PowerCycleCaHK"},{"location":"scripts/PowerCycleCaHK/#kpf.cahk.PowerCycleCaHK.PowerCycleCaHK--description","text":"Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed.","title":"Description"},{"location":"scripts/PowerCycleCaHK/#kpf.cahk.PowerCycleCaHK.PowerCycleCaHK--ktl-keywords-used","text":"kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5%","title":"KTL Keywords Used"},{"location":"scripts/PowerCycleCaHK/#kpf.cahk.PowerCycleCaHK.PowerCycleCaHK--scripts-called","text":"- kpf start/stop/status/restart kpfexpose2 - kpf start/stop/status/restart kpf_hk","title":"Scripts Called"},{"location":"scripts/PowerCycleCaHK/#kpf.cahk.PowerCycleCaHK.PowerCycleCaHK--parameters","text":"None Source code in kpf/cahk/PowerCycleCaHK.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class PowerCycleCaHK ( KPFTranslatorFunction ): '''# Description Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. ## KTL Keywords Used - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` ## Scripts Called -`kpf start/stop/status/restart kpfexpose2` -`kpf start/stop/status/restart kpf_hk` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ( 'J5' , 'Andor Newton PS' ), ] for outlet_id , outlet_name in outlets : name = kpfpower [ f 'OUTLET_ { outlet_id } _NAME' ] . read () if name . find ( outlet_name ) < 0 : raise FailedPreCondition ( f \"Outlet name: { outlet_id } != ' { outlet_name } '\" ) @classmethod def perform ( cls , args , logger , cfg ): log . warning ( 'Stopping kpfexpose2 dispatcher' ) cmd = [ 'kpf' , 'stop' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpfexpose2 command appears to have failed\" ) time . sleep ( 2 ) log . warning ( 'Stopping kpf_hk keyword service' ) cmd = [ 'kpf' , 'stop' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpf_hk command appears to have failed\" ) time . sleep ( 2 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Power cycling the Ca HK detector system' ) kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ( 'J5' , 'Andor Newton PS' ), ] for outlet_id , outlet_name in outlets : log . info ( f \"Powering off { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'Off' ) time . sleep ( 10 ) for outlet_id , outlet_name in outlets : log . info ( f \"Powering on { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'On' ) time . sleep ( 10 ) log . warning ( 'Restarting kpf_hk keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpf_hk command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Restarting kpfexpose2 keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpfexpose2 command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Resetting Ca HK' ) ResetCaHKDetector . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/PredictExpMeterParameters/","text":"PredictExpMeterParameters Bases: KPFTranslatorFunction Description Estimate the proper exposure meter exposure time given the stellar Gmag. KTL Keywords Used None Scripts Called None Parameters Gmag ( float ) The Gaia g magnitude of the target Source code in kpf/expmeter/PredictExpMeterParameters.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PredictExpMeterParameters ( KPFTranslatorFunction ): '''# Description Estimate the proper exposure meter exposure time given the stellar Gmag. ## KTL Keywords Used None ## Scripts Called None ## Parameters **Gmag** (`float`) > The Gaia g magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) if Gmag < 4.0 : exptime = 0.5 elif Gmag < 9.0 : exptime = 1.0 elif Gmag < 11.0 : exptime = 2.0 elif Gmag < 13.0 : exptime = 4.0 elif Gmag < 15.0 : exptime = 8.0 else : exptime = 16.0 log . info ( f \"Predicted ExpMeterExpTime = { exptime : .1f } s\" ) return { 'ExpMeterExpTime' : exptime } @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The Gaia g magnitude of the target\" ) return super () . add_cmdline_args ( parser , cfg )","title":"PredictExpMeterParameters"},{"location":"scripts/PredictExpMeterParameters/#predictexpmeterparameters","text":"Bases: KPFTranslatorFunction","title":"PredictExpMeterParameters"},{"location":"scripts/PredictExpMeterParameters/#kpf.expmeter.PredictExpMeterParameters.PredictExpMeterParameters--description","text":"Estimate the proper exposure meter exposure time given the stellar Gmag.","title":"Description"},{"location":"scripts/PredictExpMeterParameters/#kpf.expmeter.PredictExpMeterParameters.PredictExpMeterParameters--ktl-keywords-used","text":"None","title":"KTL Keywords Used"},{"location":"scripts/PredictExpMeterParameters/#kpf.expmeter.PredictExpMeterParameters.PredictExpMeterParameters--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/PredictExpMeterParameters/#kpf.expmeter.PredictExpMeterParameters.PredictExpMeterParameters--parameters","text":"Gmag ( float ) The Gaia g magnitude of the target Source code in kpf/expmeter/PredictExpMeterParameters.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class PredictExpMeterParameters ( KPFTranslatorFunction ): '''# Description Estimate the proper exposure meter exposure time given the stellar Gmag. ## KTL Keywords Used None ## Scripts Called None ## Parameters **Gmag** (`float`) > The Gaia g magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) if Gmag < 4.0 : exptime = 0.5 elif Gmag < 9.0 : exptime = 1.0 elif Gmag < 11.0 : exptime = 2.0 elif Gmag < 13.0 : exptime = 4.0 elif Gmag < 15.0 : exptime = 8.0 else : exptime = 16.0 log . info ( f \"Predicted ExpMeterExpTime = { exptime : .1f } s\" ) return { 'ExpMeterExpTime' : exptime } @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The Gaia g magnitude of the target\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/PredictFVCParameters/","text":"PredictFVCParameters Bases: KPFTranslatorFunction Estimate the exposure time given the stellar Jmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Args: :Gmag: The G magnitude of the target Source code in kpf/fvc/PredictFVCParameters.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class PredictFVCParameters ( KPFTranslatorFunction ): '''Estimate the exposure time given the stellar Jmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Args: ===== :Gmag: The G magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) delta_mag = 4 - Gmag flux_ratio = 10 ** ( delta_mag / 2.5 ) if flux_ratio > 10 : exptime = { 'SCI' : 0.1 , 'CAHK' : 1.5 } elif flux_ratio > 5 : exptime = { 'SCI' : 0.2 , 'CAHK' : 3 } elif flux_ratio > 2 : exptime = { 'SCI' : 0.5 , 'CAHK' : 8 } elif flux_ratio > 0.5 : exptime = { 'SCI' : 1 , 'CAHK' : 15 } elif flux_ratio > 0.2 : exptime = { 'SCI' : 5 , 'CAHK' : 15 } elif flux_ratio > 0.05 : exptime = { 'SCI' : 10 , 'CAHK' : 15 } result = { 'SCIFVC_exptime' : exptime [ 'SCI' ], 'CAHKFVC_exptime' : exptime [ 'CAHK' ]} print ( result ) if args . get ( 'set' , False ): SetFVCExpTime . execute ({ 'camera' : 'SCI' , 'exptime' : exptime [ 'SCI' ]}) SetFVCExpTime . execute ({ 'camera' : 'CAHK' , 'exptime' : exptime [ 'CAHK' ]}) return result @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"PredictFVCParameters"},{"location":"scripts/PredictFVCParameters/#predictfvcparameters","text":"Bases: KPFTranslatorFunction Estimate the exposure time given the stellar Jmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15","title":"PredictFVCParameters"},{"location":"scripts/PredictFVCParameters/#kpf.fvc.PredictFVCParameters.PredictFVCParameters--args","text":":Gmag: The G magnitude of the target Source code in kpf/fvc/PredictFVCParameters.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class PredictFVCParameters ( KPFTranslatorFunction ): '''Estimate the exposure time given the stellar Jmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Args: ===== :Gmag: The G magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) delta_mag = 4 - Gmag flux_ratio = 10 ** ( delta_mag / 2.5 ) if flux_ratio > 10 : exptime = { 'SCI' : 0.1 , 'CAHK' : 1.5 } elif flux_ratio > 5 : exptime = { 'SCI' : 0.2 , 'CAHK' : 3 } elif flux_ratio > 2 : exptime = { 'SCI' : 0.5 , 'CAHK' : 8 } elif flux_ratio > 0.5 : exptime = { 'SCI' : 1 , 'CAHK' : 15 } elif flux_ratio > 0.2 : exptime = { 'SCI' : 5 , 'CAHK' : 15 } elif flux_ratio > 0.05 : exptime = { 'SCI' : 10 , 'CAHK' : 15 } result = { 'SCIFVC_exptime' : exptime [ 'SCI' ], 'CAHKFVC_exptime' : exptime [ 'CAHK' ]} print ( result ) if args . get ( 'set' , False ): SetFVCExpTime . execute ({ 'camera' : 'SCI' , 'exptime' : exptime [ 'SCI' ]}) SetFVCExpTime . execute ({ 'camera' : 'CAHK' , 'exptime' : exptime [ 'CAHK' ]}) return result @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Args:"},{"location":"scripts/PredictGuiderParameters/","text":"PredictGuiderParameters Bases: KPFTranslatorFunction Estimate the proper gain and FPS given the stellar Jmag. Args: :Jmag: float The J magnitude of the target Source code in kpf/guider/PredictGuiderParameters.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class PredictGuiderParameters ( KPFTranslatorFunction ): '''Estimate the proper gain and FPS given the stellar Jmag. Args: ===== :Jmag: `float` The J magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Jmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Jmag = args . get ( 'Jmag' ) if Jmag < 5.5 : gain = 'low' fps = 100 elif Jmag < 8.0 : gain = 'medium' fps = 100 elif Jmag < 12.0 : gain = 'high' fps = 100 elif Jmag < 12.8 : gain = 'high' fps = 50 elif Jmag < 13.8 : gain = 'high' fps = 20 elif Jmag < 14.5 : gain = 'high' fps = 10 else : gain = 'high' fps = 10 log . info ( f \"Predicted GuideCamGain = { gain } \" ) log . info ( f \"Predicted GuideFPS = { fps : d } \" ) result = { 'GuideCamGain' : gain , 'GuideFPS' : fps } if args . get ( 'set' , False ): SetGuiderGain . execute ( result ) SetGuiderFPS . execute ( result ) return result @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Jmag' , type = float , help = \"The J magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"PredictGuiderParameters"},{"location":"scripts/PredictGuiderParameters/#predictguiderparameters","text":"Bases: KPFTranslatorFunction Estimate the proper gain and FPS given the stellar Jmag.","title":"PredictGuiderParameters"},{"location":"scripts/PredictGuiderParameters/#kpf.guider.PredictGuiderParameters.PredictGuiderParameters--args","text":":Jmag: float The J magnitude of the target Source code in kpf/guider/PredictGuiderParameters.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class PredictGuiderParameters ( KPFTranslatorFunction ): '''Estimate the proper gain and FPS given the stellar Jmag. Args: ===== :Jmag: `float` The J magnitude of the target ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Jmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): Jmag = args . get ( 'Jmag' ) if Jmag < 5.5 : gain = 'low' fps = 100 elif Jmag < 8.0 : gain = 'medium' fps = 100 elif Jmag < 12.0 : gain = 'high' fps = 100 elif Jmag < 12.8 : gain = 'high' fps = 50 elif Jmag < 13.8 : gain = 'high' fps = 20 elif Jmag < 14.5 : gain = 'high' fps = 10 else : gain = 'high' fps = 10 log . info ( f \"Predicted GuideCamGain = { gain } \" ) log . info ( f \"Predicted GuideFPS = { fps : d } \" ) result = { 'GuideCamGain' : gain , 'GuideFPS' : fps } if args . get ( 'set' , False ): SetGuiderGain . execute ( result ) SetGuiderFPS . execute ( result ) return result @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Jmag' , type = float , help = \"The J magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Args:"},{"location":"scripts/QueryFastReadMode/","text":"QueryFastReadMode Bases: KPFTranslatorFunction Returns True if both ACF files are consistent with fast read mode. ARGS: None Source code in kpf/spectrograph/QueryFastReadMode.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class QueryFastReadMode ( KPFTranslatorFunction ): '''Returns True if both ACF files are consistent with fast read mode. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_ACF = kpfgreen [ 'ACF' ] . read () red_ACF = kpfred [ 'ACF' ] . read () green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) green_fast_file = cfg . get ( 'acf_files' , 'green_fast' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) red_fast_file = cfg . get ( 'acf_files' , 'red_fast' ) if ( green_ACF == green_normal_file ) and ( red_ACF == red_normal_file ): mode = 'normal' elif ( green_ACF == green_fast_file ) and ( red_ACF == red_fast_file ): mode = 'fast' else : mode = 'unknown' log . debug ( f \"ACF Files: { green_ACF } / { red_ACF } mode is { mode } \" ) print ( f \"ACF Files: { green_ACF } / { red_ACF } mode is { mode } \" ) return mode == 'fast' @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"QueryFastReadMode"},{"location":"scripts/QueryFastReadMode/#queryfastreadmode","text":"Bases: KPFTranslatorFunction Returns True if both ACF files are consistent with fast read mode.","title":"QueryFastReadMode"},{"location":"scripts/QueryFastReadMode/#kpf.spectrograph.QueryFastReadMode.QueryFastReadMode--args","text":"None Source code in kpf/spectrograph/QueryFastReadMode.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class QueryFastReadMode ( KPFTranslatorFunction ): '''Returns True if both ACF files are consistent with fast read mode. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_ACF = kpfgreen [ 'ACF' ] . read () red_ACF = kpfred [ 'ACF' ] . read () green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) green_fast_file = cfg . get ( 'acf_files' , 'green_fast' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) red_fast_file = cfg . get ( 'acf_files' , 'red_fast' ) if ( green_ACF == green_normal_file ) and ( red_ACF == red_normal_file ): mode = 'normal' elif ( green_ACF == green_fast_file ) and ( red_ACF == red_fast_file ): mode = 'fast' else : mode = 'unknown' log . debug ( f \"ACF Files: { green_ACF } / { red_ACF } mode is { mode } \" ) print ( f \"ACF Files: { green_ACF } / { red_ACF } mode is { mode } \" ) return mode == 'fast' @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/RecoverDetectors/","text":"RecoverDetectors Bases: KPFTranslatorFunction Try to examine the state of all detectors an run the appropriate recovery ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class RecoverDetectors ( KPFTranslatorFunction ): '''Try to examine the state of all detectors an run the appropriate recovery ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . warning ( 'Attempting a detector recovery' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) kpfmon = ktl . cache ( 'kpfmon' ) camera_status = kpfmon [ 'CAMSTATESTA' ] . read () if camera_status == 'OK' : log . warning ( 'No camera error state detected by kpfmon' ) explainnr = ktl . cache ( 'kpfexpose' , 'EXPLAINNR' ) explainnr_str = explainnr . read () if explainnr_str . find ( 'hk:' ) >= 0 : log . warning ( 'kpfexpose.EXPLAINNR contains hk' ) ResetCaHKDetector . execute ({}) elif camera_status == 'ERROR' : if kpfmon [ 'G_STATESTA' ] . read () == 'ERROR' : ResetGreenDetector . execute ({}) if kpfmon [ 'R_STATESTA' ] . read () == 'ERROR' : ResetRedDetector . execute ({}) if kpfmon [ 'H_STATESTA' ] . read () == 'ERROR' : ResetCaHKDetector . execute ({}) if kpfmon [ 'E_STATESTA' ] . read () == 'ERROR' : ResetExpMeterDetector . execute ({}) else : log . warning ( f 'kpfmon.CAMSTATESTA= { camera_status } . No action taken.' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"RecoverDetectors"},{"location":"scripts/RecoverDetectors/#recoverdetectors","text":"Bases: KPFTranslatorFunction Try to examine the state of all detectors an run the appropriate recovery","title":"RecoverDetectors"},{"location":"scripts/RecoverDetectors/#kpf.spectrograph.ResetDetectors.RecoverDetectors--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 class RecoverDetectors ( KPFTranslatorFunction ): '''Try to examine the state of all detectors an run the appropriate recovery ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . warning ( 'Attempting a detector recovery' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) kpfmon = ktl . cache ( 'kpfmon' ) camera_status = kpfmon [ 'CAMSTATESTA' ] . read () if camera_status == 'OK' : log . warning ( 'No camera error state detected by kpfmon' ) explainnr = ktl . cache ( 'kpfexpose' , 'EXPLAINNR' ) explainnr_str = explainnr . read () if explainnr_str . find ( 'hk:' ) >= 0 : log . warning ( 'kpfexpose.EXPLAINNR contains hk' ) ResetCaHKDetector . execute ({}) elif camera_status == 'ERROR' : if kpfmon [ 'G_STATESTA' ] . read () == 'ERROR' : ResetGreenDetector . execute ({}) if kpfmon [ 'R_STATESTA' ] . read () == 'ERROR' : ResetRedDetector . execute ({}) if kpfmon [ 'H_STATESTA' ] . read () == 'ERROR' : ResetCaHKDetector . execute ({}) if kpfmon [ 'E_STATESTA' ] . read () == 'ERROR' : ResetExpMeterDetector . execute ({}) else : log . warning ( f 'kpfmon.CAMSTATESTA= { camera_status } . No action taken.' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ARGS:"},{"location":"scripts/ResetCaHKDetector/","text":"ResetCaHKDetector Bases: KPFTranslatorFunction Resets the Ca HK detector by aborting the exposure ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ResetCaHKDetector ( KPFTranslatorFunction ): '''Resets the Ca HK detector by aborting the exposure ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpf_hk' , 'EXPOSE' ) log . warning ( f \"Resetting/Aborting: kpf_hk.EXPOSE = abort\" ) expose . write ( 'abort' ) log . debug ( 'Reset/abort command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_hk to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetCaHKDetector"},{"location":"scripts/ResetCaHKDetector/#resetcahkdetector","text":"Bases: KPFTranslatorFunction Resets the Ca HK detector by aborting the exposure","title":"ResetCaHKDetector"},{"location":"scripts/ResetCaHKDetector/#kpf.spectrograph.ResetDetectors.ResetCaHKDetector--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ResetCaHKDetector ( KPFTranslatorFunction ): '''Resets the Ca HK detector by aborting the exposure ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpf_hk' , 'EXPOSE' ) log . warning ( f \"Resetting/Aborting: kpf_hk.EXPOSE = abort\" ) expose . write ( 'abort' ) log . debug ( 'Reset/abort command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_hk to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ARGS:"},{"location":"scripts/ResetDetectors/","text":"ResetDetectors Bases: KPFTranslatorFunction Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class ResetDetectors ( KPFTranslatorFunction ): '''Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) log . warning ( f \"Resetting: kpfexpose.EXPOSE = Reset\" ) kpfexpose [ 'EXPOSE' ] . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetDetectors"},{"location":"scripts/ResetDetectors/#resetdetectors","text":"Bases: KPFTranslatorFunction Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d","title":"ResetDetectors"},{"location":"scripts/ResetDetectors/#kpf.spectrograph.ResetDetectors.ResetDetectors--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class ResetDetectors ( KPFTranslatorFunction ): '''Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) log . warning ( f \"Resetting: kpfexpose.EXPOSE = Reset\" ) kpfexpose [ 'EXPOSE' ] . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ARGS:"},{"location":"scripts/ResetExpMeterDetector/","text":"ResetExpMeterDetector Bases: KPFTranslatorFunction Resets the exposure meter detector ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ResetExpMeterDetector ( KPFTranslatorFunction ): '''Resets the exposure meter detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpf_expmeter' , 'EXPOSE' ) log . warning ( f \"Resetting: kpf_expmeter.EXPOSE = abort\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_expmeter to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetExpMeterDetector"},{"location":"scripts/ResetExpMeterDetector/#resetexpmeterdetector","text":"Bases: KPFTranslatorFunction Resets the exposure meter detector","title":"ResetExpMeterDetector"},{"location":"scripts/ResetExpMeterDetector/#kpf.spectrograph.ResetDetectors.ResetExpMeterDetector--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ResetExpMeterDetector ( KPFTranslatorFunction ): '''Resets the exposure meter detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpf_expmeter' , 'EXPOSE' ) log . warning ( f \"Resetting: kpf_expmeter.EXPOSE = abort\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_expmeter to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ARGS:"},{"location":"scripts/ResetGreenDetector/","text":"ResetGreenDetector Bases: KPFTranslatorFunction Resets the kpfgreen detector ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class ResetGreenDetector ( KPFTranslatorFunction ): '''Resets the kpfgreen detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfgreen.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfgreen to be Readout or Ready\" ) expr = f \"($kpfgreen.EXPOSE == 'Ready') or ($kpfgreen.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetGreenDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetGreenDetector"},{"location":"scripts/ResetGreenDetector/#resetgreendetector","text":"Bases: KPFTranslatorFunction Resets the kpfgreen detector","title":"ResetGreenDetector"},{"location":"scripts/ResetGreenDetector/#kpf.spectrograph.ResetDetectors.ResetGreenDetector--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class ResetGreenDetector ( KPFTranslatorFunction ): '''Resets the kpfgreen detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfgreen.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfgreen to be Readout or Ready\" ) expr = f \"($kpfgreen.EXPOSE == 'Ready') or ($kpfgreen.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetGreenDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ARGS:"},{"location":"scripts/ResetRedDetector/","text":"ResetRedDetector Bases: KPFTranslatorFunction Resets the kpfred detector ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class ResetRedDetector ( KPFTranslatorFunction ): '''Resets the kpfred detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfred.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfred to be Readout or Ready\" ) expr = f \"($kpfred.EXPOSE == 'Ready') or ($kpfred.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetRedDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetRedDetector"},{"location":"scripts/ResetRedDetector/#resetreddetector","text":"Bases: KPFTranslatorFunction Resets the kpfred detector","title":"ResetRedDetector"},{"location":"scripts/ResetRedDetector/#kpf.spectrograph.ResetDetectors.ResetRedDetector--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class ResetRedDetector ( KPFTranslatorFunction ): '''Resets the kpfred detector ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfred.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfred to be Readout or Ready\" ) expr = f \"($kpfred.EXPOSE == 'Ready') or ($kpfred.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetRedDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ARGS:"},{"location":"scripts/Run2DGridSearch/","text":"Run2DGridSearch Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. ARGS: None Source code in kpf/engineering/Run2DGridSearch.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Run2DGridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) additional_text = args . get ( 'comment' , '' ) em_parameters = PredictExpMeterParameters . execute ({ 'Gmag' : Gmag }) fvc_parameters = PredictFVCParameters . execute ({ 'Gmag' : Gmag }) dcs = ktl . cache ( 'dcs1' ) targname = dcs [ 'TARGNAME' ] . read () args = { 'Template_Name' : 'kpf_eng_grid' , 'Template_Version' : 0.4 , 'Grid' : 'TipTilt' , 'dx' : 2 , 'dy' : 2 , 'TimeOnPosition' : 15 , 'TriggerCaHK' : False , 'TriggerGreen' : False , 'TriggerRed' : False , 'TriggerExpMeter' : True , 'UseCRED2' : True , 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_CalSciSky' : False , 'ExpMeter_exptime' : em_parameters [ 'ExpMeterExpTime' ], 'FVCs' : 'SCI,CAHK' , } args . update ( fvc_parameters ) x_args = { 'comment' : f '1D in X { targname } : { additional_text } ' , 'nx' : 15 , 'ny' : 1 , } args . update ( x_args ) GridSearch . execute ( args ) y_args = { 'comment' : f '1D in Y { targname } : { additional_text } ' , 'nx' : 1 , 'ny' : 15 , } args . update ( y_args ) GridSearch . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--comment\" , dest = \"comment\" , type = str , default = '' , help = \"Additional comment text\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Run2DGridSearch"},{"location":"scripts/Run2DGridSearch/#run2dgridsearch","text":"Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine.","title":"Run2DGridSearch"},{"location":"scripts/Run2DGridSearch/#kpf.engineering.Run2DGridSearch.Run2DGridSearch--args","text":"None Source code in kpf/engineering/Run2DGridSearch.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class Run2DGridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): Gmag = args . get ( 'Gmag' ) additional_text = args . get ( 'comment' , '' ) em_parameters = PredictExpMeterParameters . execute ({ 'Gmag' : Gmag }) fvc_parameters = PredictFVCParameters . execute ({ 'Gmag' : Gmag }) dcs = ktl . cache ( 'dcs1' ) targname = dcs [ 'TARGNAME' ] . read () args = { 'Template_Name' : 'kpf_eng_grid' , 'Template_Version' : 0.4 , 'Grid' : 'TipTilt' , 'dx' : 2 , 'dy' : 2 , 'TimeOnPosition' : 15 , 'TriggerCaHK' : False , 'TriggerGreen' : False , 'TriggerRed' : False , 'TriggerExpMeter' : True , 'UseCRED2' : True , 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_CalSciSky' : False , 'ExpMeter_exptime' : em_parameters [ 'ExpMeterExpTime' ], 'FVCs' : 'SCI,CAHK' , } args . update ( fvc_parameters ) x_args = { 'comment' : f '1D in X { targname } : { additional_text } ' , 'nx' : 15 , 'ny' : 1 , } args . update ( x_args ) GridSearch . execute ( args ) y_args = { 'comment' : f '1D in Y { targname } : { additional_text } ' , 'nx' : 1 , 'ny' : 15 , } args . update ( y_args ) GridSearch . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--comment\" , dest = \"comment\" , type = str , default = '' , help = \"Additional comment text\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/RunCalOB/","text":"RunCalOB Bases: KPFTranslatorFunction Script to run a full Calibration OB from the command line. This must have arguments as input, typically from a file using the -f command line tool. This script is abortable. When .abort_execution() is invoked, the kpconfig.SCRIPTSTOP is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: OB - dict A fully specified observing block (OB). Source code in kpf/scripts/RunCalOB.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class RunCalOB ( KPFTranslatorFunction ): '''Script to run a full Calibration OB from the command line. This must have arguments as input, typically from a file using the `-f` command line tool. This script is abortable. When `.abort_execution()` is invoked, the `kpconfig.SCRIPTSTOP` is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: ===== * __OB__ - `dict` A fully specified observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) # Configure: Turn on Lamps try : ConfigureForCalibrations . execute ( OB ) except Exception as e : log . error ( 'ConfigureForCalibrations Failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ConfigureForCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) raise e check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Dark Sequence try : darks = OB . get ( 'SEQ_Darks' , []) if len ( darks ) > 0 : log . info ( f \"Setting source select shutters\" ) SetSourceSelectShutters . execute ({}) # No args defaults all to false log . info ( f \"Setting timed shutters\" ) SetTimedShutters . execute ({}) # No args defaults all to false log . info ( f \"Setting OCTAGON to Home position\" ) SetCalSource . execute ({ 'CalSource' : 'Home' }) log . info ( f \"Setting FlatField Fiber position to 'Blank'\" ) SetFlatFieldFiberPos . execute ({ 'FF_FiberPos' : 'Blank' }) for dark in darks : # Wrap in try/except so that cleanup happens dark [ 'Template_Name' ] = 'kpf_dark' dark [ 'Template_Version' ] = OB [ 'Template_Version' ] ExecuteDark . execute ( dark ) except Exception as e : log . error ( \"ExecuteDarks failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteDarks Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Cleanup log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) sys . exit ( 1 ) # Execute the Cal Sequence try : cals = OB . get ( 'SEQ_Calibrations' , []) for cal in cals : cal [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] cal [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] cal [ 'TriggerRed' ] = OB [ 'TriggerRed' ] # No need to specify TimedShutter_CaHK in OB/calibration cal [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) log . debug ( f \"Automatically setting TimedShutter_CaHK: { cal [ 'TimedShutter_CaHK' ] } \" ) cal [ 'Template_Name' ] = 'kpf_lamp' cal [ 'Template_Version' ] = OB [ 'Template_Version' ] cal [ 'nointensemon' ] = OB . get ( 'nointensemon' , False ) cal [ 'leave_lamps_on' ] = OB . get ( 'leave_lamps_on' , False ) # Only needed for LFC ExecuteCal . execute ( cal ) except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Cleanup log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) sys . exit ( 1 ) # Cleanup: Turn off lamps try : CleanupAfterCalibrations . execute ( OB ) except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser , cfg )","title":"RunCalOB"},{"location":"scripts/RunCalOB/#runcalob","text":"Bases: KPFTranslatorFunction Script to run a full Calibration OB from the command line. This must have arguments as input, typically from a file using the -f command line tool. This script is abortable. When .abort_execution() is invoked, the kpconfig.SCRIPTSTOP is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint.","title":"RunCalOB"},{"location":"scripts/RunCalOB/#kpf.scripts.RunCalOB.RunCalOB--args","text":"OB - dict A fully specified observing block (OB). Source code in kpf/scripts/RunCalOB.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 class RunCalOB ( KPFTranslatorFunction ): '''Script to run a full Calibration OB from the command line. This must have arguments as input, typically from a file using the `-f` command line tool. This script is abortable. When `.abort_execution()` is invoked, the `kpconfig.SCRIPTSTOP` is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: ===== * __OB__ - `dict` A fully specified observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : if key not in [ 'SEQ_Darks' , 'SEQ_Calibrations' ]: log . debug ( f \" { key } : { OB [ key ] } \" ) else : log . debug ( f \" { key } :\" ) for entry in OB [ key ]: log . debug ( f \" { entry } \" ) log . info ( '-------------------------' ) # Configure: Turn on Lamps try : ConfigureForCalibrations . execute ( OB ) except Exception as e : log . error ( 'ConfigureForCalibrations Failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ConfigureForCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) raise e check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Dark Sequence try : darks = OB . get ( 'SEQ_Darks' , []) if len ( darks ) > 0 : log . info ( f \"Setting source select shutters\" ) SetSourceSelectShutters . execute ({}) # No args defaults all to false log . info ( f \"Setting timed shutters\" ) SetTimedShutters . execute ({}) # No args defaults all to false log . info ( f \"Setting OCTAGON to Home position\" ) SetCalSource . execute ({ 'CalSource' : 'Home' }) log . info ( f \"Setting FlatField Fiber position to 'Blank'\" ) SetFlatFieldFiberPos . execute ({ 'FF_FiberPos' : 'Blank' }) for dark in darks : # Wrap in try/except so that cleanup happens dark [ 'Template_Name' ] = 'kpf_dark' dark [ 'Template_Version' ] = OB [ 'Template_Version' ] ExecuteDark . execute ( dark ) except Exception as e : log . error ( \"ExecuteDarks failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteDarks Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Cleanup log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) sys . exit ( 1 ) # Execute the Cal Sequence try : cals = OB . get ( 'SEQ_Calibrations' , []) for cal in cals : cal [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] cal [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] cal [ 'TriggerRed' ] = OB [ 'TriggerRed' ] # No need to specify TimedShutter_CaHK in OB/calibration cal [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) log . debug ( f \"Automatically setting TimedShutter_CaHK: { cal [ 'TimedShutter_CaHK' ] } \" ) cal [ 'Template_Name' ] = 'kpf_lamp' cal [ 'Template_Version' ] = OB [ 'Template_Version' ] cal [ 'nointensemon' ] = OB . get ( 'nointensemon' , False ) cal [ 'leave_lamps_on' ] = OB . get ( 'leave_lamps_on' , False ) # Only needed for LFC ExecuteCal . execute ( cal ) except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Cleanup log . error ( 'Running CleanupAfterCalibrations and exiting' ) CleanupAfterCalibrations . execute ( OB ) sys . exit ( 1 ) # Cleanup: Turn off lamps try : CleanupAfterCalibrations . execute ( OB ) except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/RunSciOB/","text":"RunSciOB Bases: KPFTranslatorFunction Script to run a full Science OB from the command line. This must have arguments as input, typically from a file using the -f command line tool. This script is abortable. When .abort_execution() is invoked, the kpconfig.SCRIPTSTOP is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: OB - dict A fully specified observing block (OB). Source code in kpf/scripts/RunSciOB.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class RunSciOB ( KPFTranslatorFunction ): '''Script to run a full Science OB from the command line. This must have arguments as input, typically from a file using the `-f` command line tool. This script is abortable. When `.abort_execution()` is invoked, the `kpconfig.SCRIPTSTOP` is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: ===== * __OB__ - `dict` A fully specified observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) check_scriptstop () # Configure: log . info ( f \"Configuring for Acquisition\" ) ConfigureForAcquisition . execute ( OB ) WaitForConfigureAcquisition . execute ( OB ) check_scriptstop () log . debug ( 'Asking for user input' ) print () print ( \"###############################################################\" ) print ( \" Before continuing, please ensure that the OA has placed\" ) print ( \" the star on the KPF PO and they have initiated tip tilt\" ) print ( \" corrections (if desired).\" ) print () print ( \" Press 'Enter' to begin exposure(s) or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () log . info ( f \"Configuring for Science\" ) ConfigureForScience . execute ( OB ) WaitForConfigureScience . execute ( OB ) check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Cal Sequence # Wrap in try/except so that cleanup happens observations = OB . get ( 'SEQ_Observations' , []) for observation in observations : observation [ 'Template_Name' ] = 'kpf_sci' observation [ 'Template_Version' ] = OB [ 'Template_Version' ] log . debug ( f \"Automatically setting TimedShutter_CaHK: { OB [ 'TriggerCaHK' ] } \" ) observation [ 'TimedShutter_CaHK' ] = OB [ 'TriggerCaHK' ] observation [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] observation [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] observation [ 'TriggerRed' ] = OB [ 'TriggerRed' ] # Note: pyyaml resolver currently converts off string to False boolean observation [ 'TriggerGuide' ] = ( OB . get ( 'GuideMode' , 'off' ) not in [ 'off' , False ]) observation [ 'Gmag' ] = OB [ 'Gmag' ] try : ExecuteSci . execute ( observation ) except Exception as e : log . error ( \"ExecuteSci failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Cleanup clear_script_keywords () log . error ( 'Running CleanupAfterScience and exiting' ) CleanupAfterScience . execute ( OB ) sys . exit ( 1 ) # Cleanup CleanupAfterScience . execute ( OB ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"RunSciOB"},{"location":"scripts/RunSciOB/#runsciob","text":"Bases: KPFTranslatorFunction Script to run a full Science OB from the command line. This must have arguments as input, typically from a file using the -f command line tool. This script is abortable. When .abort_execution() is invoked, the kpconfig.SCRIPTSTOP is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint.","title":"RunSciOB"},{"location":"scripts/RunSciOB/#kpf.scripts.RunSciOB.RunSciOB--args","text":"OB - dict A fully specified observing block (OB). Source code in kpf/scripts/RunSciOB.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 class RunSciOB ( KPFTranslatorFunction ): '''Script to run a full Science OB from the command line. This must have arguments as input, typically from a file using the `-f` command line tool. This script is abortable. When `.abort_execution()` is invoked, the `kpconfig.SCRIPTSTOP` is set to Yes. This script checked for this value at various locations in the script. As a result, the script will not stop immediately, but will stop when it reaches a breakpoint. ARGS: ===== * __OB__ - `dict` A fully specified observing block (OB). ''' abortable = True @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_sci' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) check_scriptstop () # Configure: log . info ( f \"Configuring for Acquisition\" ) ConfigureForAcquisition . execute ( OB ) WaitForConfigureAcquisition . execute ( OB ) check_scriptstop () log . debug ( 'Asking for user input' ) print () print ( \"###############################################################\" ) print ( \" Before continuing, please ensure that the OA has placed\" ) print ( \" the star on the KPF PO and they have initiated tip tilt\" ) print ( \" corrections (if desired).\" ) print () print ( \" Press 'Enter' to begin exposure(s) or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) check_scriptstop () log . info ( f \"Configuring for Science\" ) ConfigureForScience . execute ( OB ) WaitForConfigureScience . execute ( OB ) check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Cal Sequence # Wrap in try/except so that cleanup happens observations = OB . get ( 'SEQ_Observations' , []) for observation in observations : observation [ 'Template_Name' ] = 'kpf_sci' observation [ 'Template_Version' ] = OB [ 'Template_Version' ] log . debug ( f \"Automatically setting TimedShutter_CaHK: { OB [ 'TriggerCaHK' ] } \" ) observation [ 'TimedShutter_CaHK' ] = OB [ 'TriggerCaHK' ] observation [ 'TriggerCaHK' ] = OB [ 'TriggerCaHK' ] observation [ 'TriggerGreen' ] = OB [ 'TriggerGreen' ] observation [ 'TriggerRed' ] = OB [ 'TriggerRed' ] # Note: pyyaml resolver currently converts off string to False boolean observation [ 'TriggerGuide' ] = ( OB . get ( 'GuideMode' , 'off' ) not in [ 'off' , False ]) observation [ 'Gmag' ] = OB [ 'Gmag' ] try : ExecuteSci . execute ( observation ) except Exception as e : log . error ( \"ExecuteSci failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Cleanup clear_script_keywords () log . error ( 'Running CleanupAfterScience and exiting' ) CleanupAfterScience . execute ( OB ) sys . exit ( 1 ) # Cleanup CleanupAfterScience . execute ( OB ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/RunSoCalObservingLoop/","text":"RunSoCalObservingLoop Bases: KPFTranslatorFunction This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the kpfconfig.SCRIPT% keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the WaitForSoCalOnTarget script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the KPFTranslator configuration file ( kpf_inst_config.ini ). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the WaitForSoCalOnTarget script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using ParkSoCal if the park flag is set. Arguments StartTimeHST - float The time (in decimal hours HST) to begin observing. EndTimeHST - float The time (in decimal hours HST) to end observing. park - bool If True, the script will park SoCal when complete. scheduled - bool If True, the script will not run if the keyword kpfconfig.ALLOWSCHEDULEDCALS is \"No\". Source code in kpf/scripts/RunSoCalObservingLoop.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class RunSoCalObservingLoop ( KPFTranslatorFunction ): '''This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the `kpfconfig.SCRIPT%` keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the `WaitForSoCalOnTarget` script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the `KPFTranslator` configuration file (`kpf_inst_config.ini`). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the `WaitForSoCalOnTarget` script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using `ParkSoCal` if the park flag is set. ## Arguments * __StartTimeHST__ - `float` The time (in decimal hours HST) to begin observing. * __EndTimeHST__ - `float` The time (in decimal hours HST) to end observing. * __park__ - `bool` If True, the script will park SoCal when complete. * __scheduled__ - `bool` If True, the script will not run if the keyword `kpfconfig.ALLOWSCHEDULEDCALS` is \"No\". ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # Check the ALLOWSCHEDULEDCALS value if args . get ( 'scheduled' , True ) is True : ALLOWSCHEDULED = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) . read () if ALLOWSCHEDULED == 'No' : return log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Prepare SoCal parameters to pass to ExecuteCal socal_ND1 = cfg . get ( 'SoCal' , 'ND1' , fallback = 'OD 0.1' ) socal_ND2 = cfg . get ( 'SoCal' , 'ND2' , fallback = 'OD 0.1' ) socal_ExpTime = cfg . getfloat ( 'SoCal' , 'ExpTime' , fallback = 12 ) SoCal_observation = { 'Template_Name' : 'kpf_lamp' , 'Template_Version' : '1.0' , 'TargetName' : 'Sun' , 'TriggerCaHK' : False , 'TimedShutter_CaHK' : False , 'TriggerGreen' : True , 'TriggerRed' : True , 'TriggerExpMeter' : False , 'RunAgitator' : True , 'CalSource' : 'SoCal-SciSky' , 'Object' : 'SoCal' , 'CalND1' : socal_ND1 , 'CalND2' : socal_ND2 , 'ExpTime' : socal_ExpTime , 'nExp' : 15 , 'SSS_Science' : True , 'SSS_Sky' : True , 'TakeSimulCal' : True , 'nointensemon' : True , } readout_red = cfg . getfloat ( 'time_estimates' , f 'readout_red' , fallback = 60 ) readout_green = cfg . getfloat ( 'time_estimates' , f 'readout_green' , fallback = 60 ) readout_cahk = cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ) archon_time_shim = cfg . getfloat ( 'times' , 'archon_temperature_time_shim' , fallback = 2 ) readout = max ([ readout_red , readout_green , readout_cahk ]) SoCal_duration = int ( SoCal_observation [ 'nExp' ]) * max ([ float ( SoCal_observation [ 'ExpTime' ]), archon_time_shim ]) SoCal_duration += int ( SoCal_observation [ 'nExp' ]) * readout log . debug ( f \"Estimated SoCal observation time = { SoCal_duration } \" ) # Prepare Etalon parameters to pass to ExecuteCal Etalon_ND1 = cfg . get ( 'SoCal' , 'EtalonND1' , fallback = 'OD 0.1' ) Etalon_ND2 = cfg . get ( 'SoCal' , 'EtalonND2' , fallback = 'OD 0.1' ) Etalon_ExpTime = cfg . getfloat ( 'SoCal' , 'EtalonExpTime' , fallback = 60 ) Etalon_observation = { 'Template_Name' : 'kpf_lamp' , 'Template_Version' : '1.0' , 'TriggerCaHK' : True , 'TimedShutter_CaHK' : True , 'TriggerGreen' : True , 'TriggerRed' : True , 'TriggerExpMeter' : False , 'RunAgitator' : True , 'CalSource' : 'EtalonFiber' , 'Object' : 'autocal-etalon-all' , 'CalND1' : Etalon_ND1 , 'CalND2' : Etalon_ND2 , 'ExpTime' : Etalon_ExpTime , 'nExp' : 8 , 'SSS_Science' : True , 'SSS_Sky' : True , 'TakeSimulCal' : True , 'nointensemon' : True , } Etalon_duration = int ( Etalon_observation [ 'nExp' ]) * max ([ float ( Etalon_observation [ 'ExpTime' ]), archon_time_shim ]) Etalon_duration += int ( Etalon_observation [ 'nExp' ]) * readout log . debug ( f \"Estimated Etalon observation time = { Etalon_duration } \" ) # Start SoCal in autonomous mode SoCalStartAutonomous . execute ({}) # Start Loop max_wait_per_iteration = 60 start_time = args . get ( 'StartTimeHST' , 9 ) end_time = args . get ( 'EndTimeHST' , 12 ) - SoCal_duration / 3600 - 0.05 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) if now_decimal < start_time : wait = ( start_time - now_decimal ) * 3600 log . info ( f 'Waiting { wait : .0f } s for SoCal window start time' ) time . sleep ( wait ) elif now_decimal > end_time : log . info ( \"End time for today's SoCal window has passed\" ) return SCRIPTPID = ktl . cache ( 'kpfconfig' , 'SCRIPTPID' ) if SCRIPTPID . read ( binary = True ) >= 0 : SCRIPTNAME = ktl . cache ( 'kpfconfig' , 'SCRIPTNAME' ) . read () waittime = ( end_time - now_decimal ) * 3600 - SoCal_duration - 180 log . warning ( f 'Script is currently running: { SCRIPTNAME } ' ) if waittime > 0 : log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) SCRIPTPID . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 10 ) # time shim check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( f 'Starting SoCal observation loop' ) log . info ( f 'Start time: { start_time : .2f } HST' ) log . info ( f 'End Time: { end_time : .2f } HST' ) check_scriptstop () nSoCalObs = 0 nEtalonObs = 0 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) while now_decimal >= start_time and now_decimal < end_time : log . debug ( 'Checking if SoCal is on the Sun' ) on_target = WaitForSoCalOnTarget . execute ({ 'timeout' : max_wait_per_iteration }) observation = { True : SoCal_observation , False : Etalon_observation }[ on_target ] log . info ( f 'SoCal on target: { on_target } ' ) log . info ( f \"Executing { observation [ 'Object' ] } \" ) try : check_scriptstop () ExecuteCal . execute ( observation ) if on_target == True : nSoCalObs += 1 else : nEtalonObs += 1 except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) check_scriptstop () # Update loop inputs now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) log . info ( 'SoCal observation loop completed' ) log . info ( f 'Executed { nSoCalObs } SoCal sequences' ) log . info ( f 'Executed { nEtalonObs } Etalon sequences' ) # Cleanup try : CleanupAfterCalibrations . execute ( Etalon_observation ) except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Park SoCal? if args . get ( 'park' , False ) == True : ParkSoCal . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'StartTimeHST' , type = float , help = 'Start of daily observing window in decimal hours HST.' ) parser . add_argument ( 'EndTimeHST' , type = float , help = 'End of daily observing window in decimal hours HST.' ) parser . add_argument ( \"--park\" , dest = \"park\" , default = False , action = \"store_true\" , help = \"Close and park SoCal when done?\" ) parser . add_argument ( \"--notscheduled\" , dest = \"scheduled\" , default = True , action = \"store_false\" , help = \"Do not respect the kpfconfig.ALLOWSCHEDULEDCALS flag.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"RunSoCalObservingLoop"},{"location":"scripts/RunSoCalObservingLoop/#runsocalobservingloop","text":"Bases: KPFTranslatorFunction This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the kpfconfig.SCRIPT% keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the WaitForSoCalOnTarget script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the KPFTranslator configuration file ( kpf_inst_config.ini ). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the WaitForSoCalOnTarget script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using ParkSoCal if the park flag is set.","title":"RunSoCalObservingLoop"},{"location":"scripts/RunSoCalObservingLoop/#kpf.scripts.RunSoCalObservingLoop.RunSoCalObservingLoop--arguments","text":"StartTimeHST - float The time (in decimal hours HST) to begin observing. EndTimeHST - float The time (in decimal hours HST) to end observing. park - bool If True, the script will park SoCal when complete. scheduled - bool If True, the script will not run if the keyword kpfconfig.ALLOWSCHEDULEDCALS is \"No\". Source code in kpf/scripts/RunSoCalObservingLoop.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class RunSoCalObservingLoop ( KPFTranslatorFunction ): '''This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the `kpfconfig.SCRIPT%` keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the `WaitForSoCalOnTarget` script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the `KPFTranslator` configuration file (`kpf_inst_config.ini`). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the `WaitForSoCalOnTarget` script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using `ParkSoCal` if the park flag is set. ## Arguments * __StartTimeHST__ - `float` The time (in decimal hours HST) to begin observing. * __EndTimeHST__ - `float` The time (in decimal hours HST) to end observing. * __park__ - `bool` If True, the script will park SoCal when complete. * __scheduled__ - `bool` If True, the script will not run if the keyword `kpfconfig.ALLOWSCHEDULEDCALS` is \"No\". ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # Check the ALLOWSCHEDULEDCALS value if args . get ( 'scheduled' , True ) is True : ALLOWSCHEDULED = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) . read () if ALLOWSCHEDULED == 'No' : return log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Prepare SoCal parameters to pass to ExecuteCal socal_ND1 = cfg . get ( 'SoCal' , 'ND1' , fallback = 'OD 0.1' ) socal_ND2 = cfg . get ( 'SoCal' , 'ND2' , fallback = 'OD 0.1' ) socal_ExpTime = cfg . getfloat ( 'SoCal' , 'ExpTime' , fallback = 12 ) SoCal_observation = { 'Template_Name' : 'kpf_lamp' , 'Template_Version' : '1.0' , 'TargetName' : 'Sun' , 'TriggerCaHK' : False , 'TimedShutter_CaHK' : False , 'TriggerGreen' : True , 'TriggerRed' : True , 'TriggerExpMeter' : False , 'RunAgitator' : True , 'CalSource' : 'SoCal-SciSky' , 'Object' : 'SoCal' , 'CalND1' : socal_ND1 , 'CalND2' : socal_ND2 , 'ExpTime' : socal_ExpTime , 'nExp' : 15 , 'SSS_Science' : True , 'SSS_Sky' : True , 'TakeSimulCal' : True , 'nointensemon' : True , } readout_red = cfg . getfloat ( 'time_estimates' , f 'readout_red' , fallback = 60 ) readout_green = cfg . getfloat ( 'time_estimates' , f 'readout_green' , fallback = 60 ) readout_cahk = cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ) archon_time_shim = cfg . getfloat ( 'times' , 'archon_temperature_time_shim' , fallback = 2 ) readout = max ([ readout_red , readout_green , readout_cahk ]) SoCal_duration = int ( SoCal_observation [ 'nExp' ]) * max ([ float ( SoCal_observation [ 'ExpTime' ]), archon_time_shim ]) SoCal_duration += int ( SoCal_observation [ 'nExp' ]) * readout log . debug ( f \"Estimated SoCal observation time = { SoCal_duration } \" ) # Prepare Etalon parameters to pass to ExecuteCal Etalon_ND1 = cfg . get ( 'SoCal' , 'EtalonND1' , fallback = 'OD 0.1' ) Etalon_ND2 = cfg . get ( 'SoCal' , 'EtalonND2' , fallback = 'OD 0.1' ) Etalon_ExpTime = cfg . getfloat ( 'SoCal' , 'EtalonExpTime' , fallback = 60 ) Etalon_observation = { 'Template_Name' : 'kpf_lamp' , 'Template_Version' : '1.0' , 'TriggerCaHK' : True , 'TimedShutter_CaHK' : True , 'TriggerGreen' : True , 'TriggerRed' : True , 'TriggerExpMeter' : False , 'RunAgitator' : True , 'CalSource' : 'EtalonFiber' , 'Object' : 'autocal-etalon-all' , 'CalND1' : Etalon_ND1 , 'CalND2' : Etalon_ND2 , 'ExpTime' : Etalon_ExpTime , 'nExp' : 8 , 'SSS_Science' : True , 'SSS_Sky' : True , 'TakeSimulCal' : True , 'nointensemon' : True , } Etalon_duration = int ( Etalon_observation [ 'nExp' ]) * max ([ float ( Etalon_observation [ 'ExpTime' ]), archon_time_shim ]) Etalon_duration += int ( Etalon_observation [ 'nExp' ]) * readout log . debug ( f \"Estimated Etalon observation time = { Etalon_duration } \" ) # Start SoCal in autonomous mode SoCalStartAutonomous . execute ({}) # Start Loop max_wait_per_iteration = 60 start_time = args . get ( 'StartTimeHST' , 9 ) end_time = args . get ( 'EndTimeHST' , 12 ) - SoCal_duration / 3600 - 0.05 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) if now_decimal < start_time : wait = ( start_time - now_decimal ) * 3600 log . info ( f 'Waiting { wait : .0f } s for SoCal window start time' ) time . sleep ( wait ) elif now_decimal > end_time : log . info ( \"End time for today's SoCal window has passed\" ) return SCRIPTPID = ktl . cache ( 'kpfconfig' , 'SCRIPTPID' ) if SCRIPTPID . read ( binary = True ) >= 0 : SCRIPTNAME = ktl . cache ( 'kpfconfig' , 'SCRIPTNAME' ) . read () waittime = ( end_time - now_decimal ) * 3600 - SoCal_duration - 180 log . warning ( f 'Script is currently running: { SCRIPTNAME } ' ) if waittime > 0 : log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) SCRIPTPID . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 10 ) # time shim check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( f 'Starting SoCal observation loop' ) log . info ( f 'Start time: { start_time : .2f } HST' ) log . info ( f 'End Time: { end_time : .2f } HST' ) check_scriptstop () nSoCalObs = 0 nEtalonObs = 0 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) while now_decimal >= start_time and now_decimal < end_time : log . debug ( 'Checking if SoCal is on the Sun' ) on_target = WaitForSoCalOnTarget . execute ({ 'timeout' : max_wait_per_iteration }) observation = { True : SoCal_observation , False : Etalon_observation }[ on_target ] log . info ( f 'SoCal on target: { on_target } ' ) log . info ( f \"Executing { observation [ 'Object' ] } \" ) try : check_scriptstop () ExecuteCal . execute ( observation ) if on_target == True : nSoCalObs += 1 else : nEtalonObs += 1 except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) check_scriptstop () # Update loop inputs now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) log . info ( 'SoCal observation loop completed' ) log . info ( f 'Executed { nSoCalObs } SoCal sequences' ) log . info ( f 'Executed { nEtalonObs } Etalon sequences' ) # Cleanup try : CleanupAfterCalibrations . execute ( Etalon_observation ) except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Park SoCal? if args . get ( 'park' , False ) == True : ParkSoCal . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'StartTimeHST' , type = float , help = 'Start of daily observing window in decimal hours HST.' ) parser . add_argument ( 'EndTimeHST' , type = float , help = 'End of daily observing window in decimal hours HST.' ) parser . add_argument ( \"--park\" , dest = \"park\" , default = False , action = \"store_true\" , help = \"Close and park SoCal when done?\" ) parser . add_argument ( \"--notscheduled\" , dest = \"scheduled\" , default = True , action = \"store_false\" , help = \"Do not respect the kpfconfig.ALLOWSCHEDULEDCALS flag.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Arguments"},{"location":"scripts/RunTwilightRVStandard/","text":"RunTwilightRVStandard Bases: KPFTranslatorFunction Executes a twilight observation of one a selected RV standard star. This script performs all necessary instrument actions from sart up to shut down. Sequence of Actions (and who performs them) once this script is invoked: - (Script): run StartOfNight - (Script): Start Sci OB + Slew Cal - (OA): Slew to target - (OA): Perform autofoc - (Script): Obtain science data - (OA): Release to regular use, OA can park or do other tasks - (Script): run EndOfNight - (Script): run Calibration Source code in kpf/scripts/RunTwilightRVStandard.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 class RunTwilightRVStandard ( KPFTranslatorFunction ): '''Executes a twilight observation of one a selected RV standard star. This script performs all necessary instrument actions from sart up to shut down. Sequence of Actions (and who performs them) once this script is invoked: - (Script): run StartOfNight - (Script): Start Sci OB + Slew Cal - (OA): Slew to target - (OA): Perform autofoc - (Script): Obtain science data - (OA): Release to regular use, OA can park or do other tasks - (Script): run EndOfNight - (Script): run Calibration ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # --------------------------------- # Select Target # --------------------------------- horizon = 30 * u . deg starlist_file = Path ( f '/s/sdata1701/OBs/kpftwilight/starlist.txt' ) all_targets = rank_targets ( starlist_file , horizon = horizon ) if len ( all_targets ) == 0 : log . error ( f 'No targets available above horizon ( { horizon : .1f } )' ) return targname = all_targets [ 0 ] . targname sciOBfile = starlist_file . parent / f ' { targname } .yaml' with open ( sciOBfile , 'r' ) as f : sciOB = yaml . safe_load ( f ) calOBfile = Path ( '/s/sdata1701/OBs/kpftwilight/twilight_program_cal.yaml' ) if calOBfile . exists () is False : log . error ( f \"Could not load OB file: { calOBfile } \" ) return with open ( calOBfile , 'r' ) as f : calOB = yaml . safe_load ( f ) log_string = f \"Selected: { targname } at { all_targets [ 0 ] . alt () : .1f } , \" \\ f \"priority= { all_targets [ 0 ] . priority } \" log . debug ( log_string ) if args . get ( 'test_only' , False ) is True : print ( log_string ) return # --------------------------------- # Start Of Night # --------------------------------- msg = [ \"\" , \"-------------------------------------------------------------\" , \"Thank you for executing a KPF Twilight Stability Measurement.\" , \"If you encounter urgent problems or questions contact one of\" , \"the KPF SAs. Contact info:\" , \" Josh Walawender: 808-990-4294 (cell)\" , \"\" , \"Please load the starlist at\" , f \" { starlist_file } \" , \"\" , f \"Our target will be:\" , f \" { targname } \" , \"\" , \"If the instrument has not been in use, you will presumably\" , \"need to run the Start Of Night script. This will open the AO\" , \"hatch and configure AO and KPF for observing. This is not\" , \"needed if KPF has been observing immediately prior to this.\" , \"Do you wish to run the Start Of Night Script? [Y/n]\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'cancel' ]: log . warning ( 'User opted to skip Start Of Night script' ) else : StartOfNight . execute ({}) SetProgram . execute ({ 'progname' : 'K444' }) SetObserver . execute ({ 'observer' : 'OA' }) # Wrap operations in try/except to ensure we get to end of night try : log . info ( f \"Configuring for Acquisition\" ) ConfigureForAcquisition . execute ( sciOB ) # --------------------------------- # OA Focus # --------------------------------- msg = [ \"\" , \"-------------------------------------------------------------\" , \"The instrument is being configured now, please begin slewing\" , \"to the target. Once you are on target:\" , \" - Focus on target using autfoc\" , \" - Then place the target on the KPF PO\" , \"When those steps are done, press Enter to continue.\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () # Open an xshow for exposure status cmd = [ 'xshow' , '-s' , 'kpfexpose' , 'EXPOSE' , 'ELAPSED' , 'EXPOSURE' ] xshow_proc = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # --------------------------------- # Execute Observation # --------------------------------- WaitForConfigureAcquisition . execute ( sciOB ) log . info ( f \"Configuring for Science\" ) ConfigureForScience . execute ( sciOB ) WaitForConfigureScience . execute ( sciOB ) # Execute Sequences check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Cal Sequence observations = sciOB . get ( 'SEQ_Observations' , []) for observation in observations : observation [ 'Template_Name' ] = 'kpf_sci' observation [ 'Template_Version' ] = sciOB [ 'Template_Version' ] observation [ 'Gmag' ] = sciOB [ 'Gmag' ] log . debug ( f \"Automatically setting TimedShutter_CaHK: { sciOB [ 'TriggerCaHK' ] } \" ) observation [ 'TimedShutter_CaHK' ] = sciOB [ 'TriggerCaHK' ] observation [ 'TriggerCaHK' ] = sciOB [ 'TriggerCaHK' ] observation [ 'TriggerGreen' ] = sciOB [ 'TriggerGreen' ] observation [ 'TriggerRed' ] = sciOB [ 'TriggerRed' ] observation [ 'TriggerGuide' ] = ( sciOB . get ( 'GuideMode' , 'off' ) != 'off' ) # Wrap in try/except so that cleanup happens try : ExecuteSci . execute ( observation ) except Exception as e : log . error ( \"ExecuteSci failed:\" ) log . error ( e ) clear_script_keywords () except Exception as e : log . error ( f 'Encountered exception during operations' ) log . error ( e ) log . error ( traceback . format_exc ()) # Cleanup CleanupAfterScience . execute ( sciOB ) # Close xshow xshow_proc . terminate () # --------------------------------- # Done with telescope # --------------------------------- log . debug ( 'Observations complete. Alerting OA.' ) msg = [ \"\" , \"-------------------------------------------------------------\" , \"Observation complete. Do you wish to run end of night and\" , \"perform a calibration set? Please answer yes if this is a\" , \"morning twilight or if some other instrument will be observing.\" , \"\" , \"Regardless of the choice below, you may perform other tasks as\" , \"needed after answering.\" , \"\" , \"Run End of Night and then start calibrations? [Y/n]\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' ]: EndOfNight . execute ({}) RunCalOB . execute ( calOB ) # Send email email = { 'To' : 'kpf_info@keck.hawaii.edu,ahoward@caltech.edu,sphalverson@gmail.com' , # 'To': 'jwalawender@keck.hawaii.edu', 'Subject' : 'KPF Twilight Program Completed' , 'Message' : 'A KPF twilight observation has been completed.' } SendEmail . execute ( email ) print () print ( 'Script complete.' ) time . sleep ( 120 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--test' , dest = \"test_only\" , default = False , action = \"store_true\" , help = 'Only execute the target selection code' ) return super () . add_cmdline_args ( parser , cfg )","title":"RunTwilightRVStandard"},{"location":"scripts/RunTwilightRVStandard/#runtwilightrvstandard","text":"Bases: KPFTranslatorFunction Executes a twilight observation of one a selected RV standard star. This script performs all necessary instrument actions from sart up to shut down. Sequence of Actions (and who performs them) once this script is invoked: - (Script): run StartOfNight - (Script): Start Sci OB + Slew Cal - (OA): Slew to target - (OA): Perform autofoc - (Script): Obtain science data - (OA): Release to regular use, OA can park or do other tasks - (Script): run EndOfNight - (Script): run Calibration Source code in kpf/scripts/RunTwilightRVStandard.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 class RunTwilightRVStandard ( KPFTranslatorFunction ): '''Executes a twilight observation of one a selected RV standard star. This script performs all necessary instrument actions from sart up to shut down. Sequence of Actions (and who performs them) once this script is invoked: - (Script): run StartOfNight - (Script): Start Sci OB + Slew Cal - (OA): Slew to target - (OA): Perform autofoc - (Script): Obtain science data - (OA): Release to regular use, OA can park or do other tasks - (Script): run EndOfNight - (Script): run Calibration ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # --------------------------------- # Select Target # --------------------------------- horizon = 30 * u . deg starlist_file = Path ( f '/s/sdata1701/OBs/kpftwilight/starlist.txt' ) all_targets = rank_targets ( starlist_file , horizon = horizon ) if len ( all_targets ) == 0 : log . error ( f 'No targets available above horizon ( { horizon : .1f } )' ) return targname = all_targets [ 0 ] . targname sciOBfile = starlist_file . parent / f ' { targname } .yaml' with open ( sciOBfile , 'r' ) as f : sciOB = yaml . safe_load ( f ) calOBfile = Path ( '/s/sdata1701/OBs/kpftwilight/twilight_program_cal.yaml' ) if calOBfile . exists () is False : log . error ( f \"Could not load OB file: { calOBfile } \" ) return with open ( calOBfile , 'r' ) as f : calOB = yaml . safe_load ( f ) log_string = f \"Selected: { targname } at { all_targets [ 0 ] . alt () : .1f } , \" \\ f \"priority= { all_targets [ 0 ] . priority } \" log . debug ( log_string ) if args . get ( 'test_only' , False ) is True : print ( log_string ) return # --------------------------------- # Start Of Night # --------------------------------- msg = [ \"\" , \"-------------------------------------------------------------\" , \"Thank you for executing a KPF Twilight Stability Measurement.\" , \"If you encounter urgent problems or questions contact one of\" , \"the KPF SAs. Contact info:\" , \" Josh Walawender: 808-990-4294 (cell)\" , \"\" , \"Please load the starlist at\" , f \" { starlist_file } \" , \"\" , f \"Our target will be:\" , f \" { targname } \" , \"\" , \"If the instrument has not been in use, you will presumably\" , \"need to run the Start Of Night script. This will open the AO\" , \"hatch and configure AO and KPF for observing. This is not\" , \"needed if KPF has been observing immediately prior to this.\" , \"Do you wish to run the Start Of Night Script? [Y/n]\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'cancel' ]: log . warning ( 'User opted to skip Start Of Night script' ) else : StartOfNight . execute ({}) SetProgram . execute ({ 'progname' : 'K444' }) SetObserver . execute ({ 'observer' : 'OA' }) # Wrap operations in try/except to ensure we get to end of night try : log . info ( f \"Configuring for Acquisition\" ) ConfigureForAcquisition . execute ( sciOB ) # --------------------------------- # OA Focus # --------------------------------- msg = [ \"\" , \"-------------------------------------------------------------\" , \"The instrument is being configured now, please begin slewing\" , \"to the target. Once you are on target:\" , \" - Focus on target using autfoc\" , \" - Then place the target on the KPF PO\" , \"When those steps are done, press Enter to continue.\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () # Open an xshow for exposure status cmd = [ 'xshow' , '-s' , 'kpfexpose' , 'EXPOSE' , 'ELAPSED' , 'EXPOSURE' ] xshow_proc = subprocess . Popen ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # --------------------------------- # Execute Observation # --------------------------------- WaitForConfigureAcquisition . execute ( sciOB ) log . info ( f \"Configuring for Science\" ) ConfigureForScience . execute ( sciOB ) WaitForConfigureScience . execute ( sciOB ) # Execute Sequences check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # Execute the Cal Sequence observations = sciOB . get ( 'SEQ_Observations' , []) for observation in observations : observation [ 'Template_Name' ] = 'kpf_sci' observation [ 'Template_Version' ] = sciOB [ 'Template_Version' ] observation [ 'Gmag' ] = sciOB [ 'Gmag' ] log . debug ( f \"Automatically setting TimedShutter_CaHK: { sciOB [ 'TriggerCaHK' ] } \" ) observation [ 'TimedShutter_CaHK' ] = sciOB [ 'TriggerCaHK' ] observation [ 'TriggerCaHK' ] = sciOB [ 'TriggerCaHK' ] observation [ 'TriggerGreen' ] = sciOB [ 'TriggerGreen' ] observation [ 'TriggerRed' ] = sciOB [ 'TriggerRed' ] observation [ 'TriggerGuide' ] = ( sciOB . get ( 'GuideMode' , 'off' ) != 'off' ) # Wrap in try/except so that cleanup happens try : ExecuteSci . execute ( observation ) except Exception as e : log . error ( \"ExecuteSci failed:\" ) log . error ( e ) clear_script_keywords () except Exception as e : log . error ( f 'Encountered exception during operations' ) log . error ( e ) log . error ( traceback . format_exc ()) # Cleanup CleanupAfterScience . execute ( sciOB ) # Close xshow xshow_proc . terminate () # --------------------------------- # Done with telescope # --------------------------------- log . debug ( 'Observations complete. Alerting OA.' ) msg = [ \"\" , \"-------------------------------------------------------------\" , \"Observation complete. Do you wish to run end of night and\" , \"perform a calibration set? Please answer yes if this is a\" , \"morning twilight or if some other instrument will be observing.\" , \"\" , \"Regardless of the choice below, you may perform other tasks as\" , \"needed after answering.\" , \"\" , \"Run End of Night and then start calibrations? [Y/n]\" , \"-------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' ]: EndOfNight . execute ({}) RunCalOB . execute ( calOB ) # Send email email = { 'To' : 'kpf_info@keck.hawaii.edu,ahoward@caltech.edu,sphalverson@gmail.com' , # 'To': 'jwalawender@keck.hawaii.edu', 'Subject' : 'KPF Twilight Program Completed' , 'Message' : 'A KPF twilight observation has been completed.' } SendEmail . execute ( email ) print () print ( 'Script complete.' ) time . sleep ( 120 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--test' , dest = \"test_only\" , default = False , action = \"store_true\" , help = 'Only execute the target selection code' ) return super () . add_cmdline_args ( parser , cfg )","title":"RunTwilightRVStandard"},{"location":"scripts/SendPCUtoHome/","text":"SendPCUtoHome Bases: KPFTranslatorFunction Description Send the PCU stage to the \"home\" named position. KTL Keywords Used ao.PCSFNAME ao.PCSFSTST Scripts Called None Parameters None Source code in kpf/ao/SendPCUtoHome.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SendPCUtoHome ( KPFTranslatorFunction ): '''# Description Send the PCU stage to the \"home\" named position. ## KTL Keywords Used - `ao.PCSFNAME` - `ao.PCSFSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to Home\" ) PCSstagekw . write ( 'home' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'home' )","title":"SendPCUtoHome"},{"location":"scripts/SendPCUtoHome/#sendpcutohome","text":"Bases: KPFTranslatorFunction","title":"SendPCUtoHome"},{"location":"scripts/SendPCUtoHome/#kpf.ao.SendPCUtoHome.SendPCUtoHome--description","text":"Send the PCU stage to the \"home\" named position.","title":"Description"},{"location":"scripts/SendPCUtoHome/#kpf.ao.SendPCUtoHome.SendPCUtoHome--ktl-keywords-used","text":"ao.PCSFNAME ao.PCSFSTST","title":"KTL Keywords Used"},{"location":"scripts/SendPCUtoHome/#kpf.ao.SendPCUtoHome.SendPCUtoHome--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SendPCUtoHome/#kpf.ao.SendPCUtoHome.SendPCUtoHome--parameters","text":"None Source code in kpf/ao/SendPCUtoHome.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SendPCUtoHome ( KPFTranslatorFunction ): '''# Description Send the PCU stage to the \"home\" named position. ## KTL Keywords Used - `ao.PCSFNAME` - `ao.PCSFSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to Home\" ) PCSstagekw . write ( 'home' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'home' )","title":"Parameters"},{"location":"scripts/SendPCUtoKPF/","text":"SendPCUtoKPF Bases: KPFTranslatorFunction Description Send the PCU stage to the \"kpf\" named position. KTL Keywords Used ao.PCSFNAME ao.PCSFSTST Scripts Called None Parameters None Source code in kpf/ao/SendPCUtoKPF.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SendPCUtoKPF ( KPFTranslatorFunction ): '''#Description Send the PCU stage to the \"kpf\" named position. ## KTL Keywords Used - `ao.PCSFNAME` - `ao.PCSFSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) success = ktl . waitfor ( \"($ao.PCSFSTST == INPOS)\" , timeout = 120 ) if success is False : raise FailedPreCondition ( 'PCU is in motion' ) success = ktl . waitfor ( \"($ao.PCSFNAME == home)\" , timeout = 120 ) if success is False : raise FailedPreCondition ( 'PCU must be at home before moving to KPF' ) @classmethod def perform ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to KPF\" ) PCSstagekw . write ( 'kpf' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'kpf' )","title":"SendPCUtoKPF"},{"location":"scripts/SendPCUtoKPF/#sendpcutokpf","text":"Bases: KPFTranslatorFunction","title":"SendPCUtoKPF"},{"location":"scripts/SendPCUtoKPF/#kpf.ao.SendPCUtoKPF.SendPCUtoKPF--description","text":"Send the PCU stage to the \"kpf\" named position.","title":"Description"},{"location":"scripts/SendPCUtoKPF/#kpf.ao.SendPCUtoKPF.SendPCUtoKPF--ktl-keywords-used","text":"ao.PCSFNAME ao.PCSFSTST","title":"KTL Keywords Used"},{"location":"scripts/SendPCUtoKPF/#kpf.ao.SendPCUtoKPF.SendPCUtoKPF--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SendPCUtoKPF/#kpf.ao.SendPCUtoKPF.SendPCUtoKPF--parameters","text":"None Source code in kpf/ao/SendPCUtoKPF.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SendPCUtoKPF ( KPFTranslatorFunction ): '''#Description Send the PCU stage to the \"kpf\" named position. ## KTL Keywords Used - `ao.PCSFNAME` - `ao.PCSFSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) success = ktl . waitfor ( \"($ao.PCSFSTST == INPOS)\" , timeout = 120 ) if success is False : raise FailedPreCondition ( 'PCU is in motion' ) success = ktl . waitfor ( \"($ao.PCSFNAME == home)\" , timeout = 120 ) if success is False : raise FailedPreCondition ( 'PCU must be at home before moving to KPF' ) @classmethod def perform ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to KPF\" ) PCSstagekw . write ( 'kpf' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'kpf' )","title":"Parameters"},{"location":"scripts/SetADCAngles/","text":"SetADCAngles Bases: KPFTranslatorFunction Quick and dirty code to manually set ADC angles for a notional NULL position ARGS: None Source code in kpf/fiu/SetADCAngles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SetADCAngles ( KPFTranslatorFunction ): '''Quick and dirty code to manually set ADC angles for a notional NULL position ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) el = args . get ( 'EL' ) za = 90 - el ADC_delta = calculate_ADC_delta ( za ) log . info ( f \"ADC Hack: za= { za : .1f } , ADC_delta= { ADC_delta : .1f } \" ) # Constants common_angle = 60 ADC1_offset = - 5 ADC2_offset = 5 log . debug ( f \"ADC Hack: common_angle= { common_angle : .1f } \" ) log . debug ( f \"ADC Hack: ADC1_offset= { ADC1_offset : .1f } \" ) log . debug ( f \"ADC Hack: ADC2_offset= { ADC2_offset : .1f } \" ) # Calculations ADC1 = common_angle + ADC1_offset + za - ADC_delta ADC2 = common_angle + ADC2_offset - za - ADC_delta log . info ( f \"ADC Hack: Writing ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'EL' , type = float , help = \"The telescope elevation to use in the calculation\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetADCAngles"},{"location":"scripts/SetADCAngles/#setadcangles","text":"Bases: KPFTranslatorFunction Quick and dirty code to manually set ADC angles for a notional NULL position","title":"SetADCAngles"},{"location":"scripts/SetADCAngles/#kpf.fiu.SetADCAngles.SetADCAngles--args","text":"None Source code in kpf/fiu/SetADCAngles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SetADCAngles ( KPFTranslatorFunction ): '''Quick and dirty code to manually set ADC angles for a notional NULL position ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) el = args . get ( 'EL' ) za = 90 - el ADC_delta = calculate_ADC_delta ( za ) log . info ( f \"ADC Hack: za= { za : .1f } , ADC_delta= { ADC_delta : .1f } \" ) # Constants common_angle = 60 ADC1_offset = - 5 ADC2_offset = 5 log . debug ( f \"ADC Hack: common_angle= { common_angle : .1f } \" ) log . debug ( f \"ADC Hack: ADC1_offset= { ADC1_offset : .1f } \" ) log . debug ( f \"ADC Hack: ADC2_offset= { ADC2_offset : .1f } \" ) # Calculations ADC1 = common_angle + ADC1_offset + za - ADC_delta ADC2 = common_angle + ADC2_offset - za - ADC_delta log . info ( f \"ADC Hack: Writing ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'EL' , type = float , help = \"The telescope elevation to use in the calculation\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetADCOffsets/","text":"SetADCOffsets Bases: KPFTranslatorFunction Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. ARGS: None Source code in kpf/fiu/SetADCOffsets.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetADCOffsets ( KPFTranslatorFunction ): '''Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) if kpffiu [ 'ADCTRACK' ] . read () == 'On' : log . info ( f 'Setting ADCTRACK to Off' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) time . sleep ( 1 ) ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) ADC1 = ADC1_nominal + args . get ( 'ADC1OFF' ) ADC2 = ADC2_nominal + args . get ( 'ADC2OFF' ) log . info ( f \"Setting ADC to offset angles: ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) tol = 0.1 ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) adc1targ = ADC1_nominal + args . get ( 'ADC1OFF' ) adc2targ = ADC2_nominal + args . get ( 'ADC2OFF' ) expr = ( f \"($kpffiu.ADC1VAL > { adc1targ - tol } ) \" f \"and ($kpffiu.ADC1VAL < { adc1targ + tol } ) \" f \"and ($kpffiu.ADC2VAL > { adc2targ - tol } ) \" f \"and ($kpffiu.ADC2VAL < { adc2targ + tol } )\" ) success = ktl . waitFor ( expr , timeout = 20 ) if success is False : raise FailedPostCondition ( 'ADC Prisms did not reach destination angles' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1OFF' , type = float , help = \"Offset for ADC1 (in degrees)\" ) parser . add_argument ( 'ADC2OFF' , type = float , help = \"Offset for ADC2 (in degrees)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetADCOffsets"},{"location":"scripts/SetADCOffsets/#setadcoffsets","text":"Bases: KPFTranslatorFunction Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position.","title":"SetADCOffsets"},{"location":"scripts/SetADCOffsets/#kpf.fiu.SetADCOffsets.SetADCOffsets--args","text":"None Source code in kpf/fiu/SetADCOffsets.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetADCOffsets ( KPFTranslatorFunction ): '''Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) if kpffiu [ 'ADCTRACK' ] . read () == 'On' : log . info ( f 'Setting ADCTRACK to Off' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) time . sleep ( 1 ) ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) ADC1 = ADC1_nominal + args . get ( 'ADC1OFF' ) ADC2 = ADC2_nominal + args . get ( 'ADC2OFF' ) log . info ( f \"Setting ADC to offset angles: ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) tol = 0.1 ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) adc1targ = ADC1_nominal + args . get ( 'ADC1OFF' ) adc2targ = ADC2_nominal + args . get ( 'ADC2OFF' ) expr = ( f \"($kpffiu.ADC1VAL > { adc1targ - tol } ) \" f \"and ($kpffiu.ADC1VAL < { adc1targ + tol } ) \" f \"and ($kpffiu.ADC2VAL > { adc2targ - tol } ) \" f \"and ($kpffiu.ADC2VAL < { adc2targ + tol } )\" ) success = ktl . waitFor ( expr , timeout = 20 ) if success is False : raise FailedPostCondition ( 'ADC Prisms did not reach destination angles' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1OFF' , type = float , help = \"Offset for ADC1 (in degrees)\" ) parser . add_argument ( 'ADC2OFF' , type = float , help = \"Offset for ADC2 (in degrees)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetAFMtoMirror/","text":"SetAFMtoMirror Bases: KPFTranslatorFunction Description Set AFM to Mirror so ACAM sees light KTL Keywords Used ao.OBAMNAME ao.OBAMSLEW ao.OBAMSTST Scripts Called None Parameters None Source code in kpf/ao/SetAFMtoMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetAFMtoMirror ( KPFTranslatorFunction ): '''# Description Set AFM to Mirror so ACAM sees light ## KTL Keywords Used - `ao.OBAMNAME` - `ao.OBAMSLEW` - `ao.OBAMSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AFM to Mirror\" ) ao [ 'OBAMNAME' ] . write ( 'Mirror' ) ao [ 'OBAMSLEW' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = '($ao.OBAMSTST == INPOS) and ($ao.OBAMNAME == Mirror)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : ao = ktl . cache ( 'ao' ) FailedToReachDestination ( ao [ 'OBAMNAME' ] . read (), 'Mirror' )","title":"SetAFMtoMirror"},{"location":"scripts/SetAFMtoMirror/#setafmtomirror","text":"Bases: KPFTranslatorFunction","title":"SetAFMtoMirror"},{"location":"scripts/SetAFMtoMirror/#kpf.ao.SetAFMtoMirror.SetAFMtoMirror--description","text":"Set AFM to Mirror so ACAM sees light","title":"Description"},{"location":"scripts/SetAFMtoMirror/#kpf.ao.SetAFMtoMirror.SetAFMtoMirror--ktl-keywords-used","text":"ao.OBAMNAME ao.OBAMSLEW ao.OBAMSTST","title":"KTL Keywords Used"},{"location":"scripts/SetAFMtoMirror/#kpf.ao.SetAFMtoMirror.SetAFMtoMirror--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetAFMtoMirror/#kpf.ao.SetAFMtoMirror.SetAFMtoMirror--parameters","text":"None Source code in kpf/ao/SetAFMtoMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetAFMtoMirror ( KPFTranslatorFunction ): '''# Description Set AFM to Mirror so ACAM sees light ## KTL Keywords Used - `ao.OBAMNAME` - `ao.OBAMSLEW` - `ao.OBAMSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AFM to Mirror\" ) ao [ 'OBAMNAME' ] . write ( 'Mirror' ) ao [ 'OBAMSLEW' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = '($ao.OBAMSTST == INPOS) and ($ao.OBAMNAME == Mirror)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : ao = ktl . cache ( 'ao' ) FailedToReachDestination ( ao [ 'OBAMNAME' ] . read (), 'Mirror' )","title":"Parameters"},{"location":"scripts/SetAFStoNGS/","text":"SetAFStoNGS Bases: KPFTranslatorFunction Description ACAM should be set to NGS focus. LGS focus will not work for KPF. KTL Keywords Used ao.OBASNAME ao.OBASSLEW ao.OBASSTST Scripts Called None Parameters None Source code in kpf/ao/SetAFStoNGS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetAFStoNGS ( KPFTranslatorFunction ): '''# Description ACAM should be set to NGS focus. LGS focus will not work for KPF. ## KTL Keywords Used - `ao.OBASNAME` - `ao.OBASSLEW` - `ao.OBASSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AFS to NGS\" ) ao [ 'OBASNAME' ] . write ( 'ngs' ) ao [ 'OBASSLEW' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = f '($ao.OBASSTST == INPOS) and ($ao.OBASNAME == ngs)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBASNAME' ] . read (), 'ngs' )","title":"SetAFStoNGS"},{"location":"scripts/SetAFStoNGS/#setafstongs","text":"Bases: KPFTranslatorFunction","title":"SetAFStoNGS"},{"location":"scripts/SetAFStoNGS/#kpf.ao.SetAFStoNGS.SetAFStoNGS--description","text":"ACAM should be set to NGS focus. LGS focus will not work for KPF.","title":"Description"},{"location":"scripts/SetAFStoNGS/#kpf.ao.SetAFStoNGS.SetAFStoNGS--ktl-keywords-used","text":"ao.OBASNAME ao.OBASSLEW ao.OBASSTST","title":"KTL Keywords Used"},{"location":"scripts/SetAFStoNGS/#kpf.ao.SetAFStoNGS.SetAFStoNGS--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetAFStoNGS/#kpf.ao.SetAFStoNGS.SetAFStoNGS--parameters","text":"None Source code in kpf/ao/SetAFStoNGS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetAFStoNGS ( KPFTranslatorFunction ): '''# Description ACAM should be set to NGS focus. LGS focus will not work for KPF. ## KTL Keywords Used - `ao.OBASNAME` - `ao.OBASSLEW` - `ao.OBASSTST` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( f \"Setting AFS to NGS\" ) ao [ 'OBASNAME' ] . write ( 'ngs' ) ao [ 'OBASSLEW' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = f '($ao.OBASSTST == INPOS) and ($ao.OBASNAME == ngs)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBASNAME' ] . read (), 'ngs' )","title":"Parameters"},{"location":"scripts/SetAODCStoSIM/","text":"SetAODCStoSIM Bases: KPFTranslatorFunction Description Set AO in AO DCS sim mode, so AO doesn't communicate with telescope KTL Keywords Used ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Scripts Called None Parameters None Source code in kpf/ao/SetAODCStoSIM.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetAODCStoSIM ( KPFTranslatorFunction ): '''# Description Set AO in AO DCS sim mode, so AO doesn't communicate with telescope ## KTL Keywords Used - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( \"Setting AO DCS to Sim\" ) ao [ 'AODCSSIM' ] . write ( '1' ) ao [ 'AOCOMSIM' ] . write ( '1' ) ao [ 'AODCSSFP' ] . write ( '0' ) @classmethod def post_condition ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) aodcssim_success = ktl . waitfor ( '($ao.AODCSSIM == enabled)' , timeout = 3 ) if not aodcssim_success : raise FailedToReachDestination ( ao [ 'AODCSSIM' ] . read (), 'enabled' ) aocomsim_success = ktl . waitfor ( '($ao.AOCOMSIM == enabled)' , timeout = 3 ) if not aocomsim_success : raise FailedToReachDestination ( ao [ 'AOCOMSIM' ] . read (), 'enabled' ) aodcssfp_success = ktl . waitfor ( '($ao.AODCSSFP == disabled)' , timeout = 3 ) if not aodcssfp_success : raise FailedToReachDestination ( ao [ 'AODCSSFP' ] . read (), 'disabled' )","title":"SetAODCStoSIM"},{"location":"scripts/SetAODCStoSIM/#setaodcstosim","text":"Bases: KPFTranslatorFunction","title":"SetAODCStoSIM"},{"location":"scripts/SetAODCStoSIM/#kpf.ao.SetAODCStoSIM.SetAODCStoSIM--description","text":"Set AO in AO DCS sim mode, so AO doesn't communicate with telescope","title":"Description"},{"location":"scripts/SetAODCStoSIM/#kpf.ao.SetAODCStoSIM.SetAODCStoSIM--ktl-keywords-used","text":"ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP","title":"KTL Keywords Used"},{"location":"scripts/SetAODCStoSIM/#kpf.ao.SetAODCStoSIM.SetAODCStoSIM--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetAODCStoSIM/#kpf.ao.SetAODCStoSIM.SetAODCStoSIM--parameters","text":"None Source code in kpf/ao/SetAODCStoSIM.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetAODCStoSIM ( KPFTranslatorFunction ): '''# Description Set AO in AO DCS sim mode, so AO doesn't communicate with telescope ## KTL Keywords Used - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( \"Setting AO DCS to Sim\" ) ao [ 'AODCSSIM' ] . write ( '1' ) ao [ 'AOCOMSIM' ] . write ( '1' ) ao [ 'AODCSSFP' ] . write ( '0' ) @classmethod def post_condition ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) aodcssim_success = ktl . waitfor ( '($ao.AODCSSIM == enabled)' , timeout = 3 ) if not aodcssim_success : raise FailedToReachDestination ( ao [ 'AODCSSIM' ] . read (), 'enabled' ) aocomsim_success = ktl . waitfor ( '($ao.AOCOMSIM == enabled)' , timeout = 3 ) if not aocomsim_success : raise FailedToReachDestination ( ao [ 'AOCOMSIM' ] . read (), 'enabled' ) aodcssfp_success = ktl . waitfor ( '($ao.AODCSSFP == disabled)' , timeout = 3 ) if not aodcssfp_success : raise FailedToReachDestination ( ao [ 'AODCSSFP' ] . read (), 'disabled' )","title":"Parameters"},{"location":"scripts/SetAORotator/","text":"SetAORotator Bases: KPFTranslatorFunction Description Set the AO rotator destination KTL Keywords Used ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Scripts Called None Parameters dest ( float ) Angle in degrees for the physical drive angle of the rotator. Source code in kpf/ao/SetAORotator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class SetAORotator ( KPFTranslatorFunction ): '''# Description Set the AO rotator destination ## KTL Keywords Used - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ## Scripts Called None ## Parameters **dest** (`float`) > Angle in degrees for the physical drive angle of the rotator. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'dest' ) @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) dest = args . get ( 'dest' , 0 ) log . debug ( f \"Setting AO Rotator to { dest : .1f } \" ) ao [ 'OBRT' ] . write ( dest ) ao [ 'OBRTMOVE' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBRTSTST == INPOS)' , timeout = 180 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBRTSTST' ] . read (), 'INPOS' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'dest' , type = float , help = \"Desired rotator position\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetAORotator"},{"location":"scripts/SetAORotator/#setaorotator","text":"Bases: KPFTranslatorFunction","title":"SetAORotator"},{"location":"scripts/SetAORotator/#kpf.ao.SetAORotator.SetAORotator--description","text":"Set the AO rotator destination","title":"Description"},{"location":"scripts/SetAORotator/#kpf.ao.SetAORotator.SetAORotator--ktl-keywords-used","text":"ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP","title":"KTL Keywords Used"},{"location":"scripts/SetAORotator/#kpf.ao.SetAORotator.SetAORotator--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetAORotator/#kpf.ao.SetAORotator.SetAORotator--parameters","text":"dest ( float ) Angle in degrees for the physical drive angle of the rotator. Source code in kpf/ao/SetAORotator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class SetAORotator ( KPFTranslatorFunction ): '''# Description Set the AO rotator destination ## KTL Keywords Used - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ## Scripts Called None ## Parameters **dest** (`float`) > Angle in degrees for the physical drive angle of the rotator. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'dest' ) @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) dest = args . get ( 'dest' , 0 ) log . debug ( f \"Setting AO Rotator to { dest : .1f } \" ) ao [ 'OBRT' ] . write ( dest ) ao [ 'OBRTMOVE' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBRTSTST == INPOS)' , timeout = 180 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBRTSTST' ] . read (), 'INPOS' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'dest' , type = float , help = \"Desired rotator position\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetAORotatorManual/","text":"SetAORotatorManual Bases: KPFTranslatorFunction Description AO rotator needs to be in the Manual mode before observing. KTL Keywords Used ao.OBRTDSRC ao.OBRTMOVE Scripts Called None Parameters None Source code in kpf/ao/SetAORotatorManual.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetAORotatorManual ( KPFTranslatorFunction ): '''# Description AO rotator needs to be in the Manual mode before observing. ## KTL Keywords Used - `ao.OBRTDSRC` - `ao.OBRTMOVE` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( \"Setting AO rotator to manual mode\" ) ao [ 'OBRTDSRC' ] . write ( '0' ) ao [ 'OBRTMOVE' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBRTDSRC == manual)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBRTDSRC' ] . read (), 'manual' )","title":"SetAORotatorManual"},{"location":"scripts/SetAORotatorManual/#setaorotatormanual","text":"Bases: KPFTranslatorFunction","title":"SetAORotatorManual"},{"location":"scripts/SetAORotatorManual/#kpf.ao.SetAORotatorManual.SetAORotatorManual--description","text":"AO rotator needs to be in the Manual mode before observing.","title":"Description"},{"location":"scripts/SetAORotatorManual/#kpf.ao.SetAORotatorManual.SetAORotatorManual--ktl-keywords-used","text":"ao.OBRTDSRC ao.OBRTMOVE","title":"KTL Keywords Used"},{"location":"scripts/SetAORotatorManual/#kpf.ao.SetAORotatorManual.SetAORotatorManual--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetAORotatorManual/#kpf.ao.SetAORotatorManual.SetAORotatorManual--parameters","text":"None Source code in kpf/ao/SetAORotatorManual.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetAORotatorManual ( KPFTranslatorFunction ): '''# Description AO rotator needs to be in the Manual mode before observing. ## KTL Keywords Used - `ao.OBRTDSRC` - `ao.OBRTMOVE` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( \"Setting AO rotator to manual mode\" ) ao [ 'OBRTDSRC' ] . write ( '0' ) ao [ 'OBRTMOVE' ] . write ( '1' ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBRTDSRC == manual)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBRTDSRC' ] . read (), 'manual' )","title":"Parameters"},{"location":"scripts/SetCalSource/","text":"SetCalSource Bases: KPFTranslatorFunction Description Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword. KTL Keywords Used kpfcal.OCTAGON Scripts Called None Parameters CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber Source code in kpf/calbench/SetCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetCalSource ( KPFTranslatorFunction ): '''# Description Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword. ## KTL Keywords Used - `kpfcal.OCTAGON` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) kpfcal = ktl . cache ( 'kpfcal' ) log . debug ( f \"Setting Cal Source (Octagon) to { target } \" ) kpfcal [ 'OCTAGON' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 90 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'OCTAGON' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetCalSource"},{"location":"scripts/SetCalSource/#setcalsource","text":"Bases: KPFTranslatorFunction","title":"SetCalSource"},{"location":"scripts/SetCalSource/#kpf.calbench.SetCalSource.SetCalSource--description","text":"Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword.","title":"Description"},{"location":"scripts/SetCalSource/#kpf.calbench.SetCalSource.SetCalSource--ktl-keywords-used","text":"kpfcal.OCTAGON","title":"KTL Keywords Used"},{"location":"scripts/SetCalSource/#kpf.calbench.SetCalSource.SetCalSource--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetCalSource/#kpf.calbench.SetCalSource.SetCalSource--parameters","text":"CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber Source code in kpf/calbench/SetCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetCalSource ( KPFTranslatorFunction ): '''# Description Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword. ## KTL Keywords Used - `kpfcal.OCTAGON` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) kpfcal = ktl . cache ( 'kpfcal' ) log . debug ( f \"Setting Cal Source (Octagon) to { target } \" ) kpfcal [ 'OCTAGON' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 90 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'OCTAGON' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetExpMeterExpTime/","text":"SetExpMeterExpTime Bases: KPFTranslatorFunction Description Sets the exposure time for the exposure meter KTL Keywords Used kpf_expmeter.EXPOSURE Scripts Called None Parameters ExpMeterExpTime ( float ) The exposure time in seconds Source code in kpf/expmeter/SetExpMeterExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class SetExpMeterExpTime ( KPFTranslatorFunction ): '''# Description Sets the exposure time for the exposure meter ## KTL Keywords Used - `kpf_expmeter.EXPOSURE` ## Scripts Called None ## Parameters **ExpMeterExpTime** (`float`) > The exposure time in seconds ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpMeterExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) exptime = args . get ( 'ExpMeterExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) kpf_expmeter [ 'EXPOSURE' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpMeterExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpf_expmeter.EXPOSURE >= { exptime - tol } ) and \" f \"($kpf_expmeter.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : exposure = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) raise FailedToReachDestination ( exposure . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpMeterExpTime' , type = float , help = \"The exposure time in seconds\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetExpMeterExpTime"},{"location":"scripts/SetExpMeterExpTime/#setexpmeterexptime","text":"Bases: KPFTranslatorFunction","title":"SetExpMeterExpTime"},{"location":"scripts/SetExpMeterExpTime/#kpf.expmeter.SetExpMeterExpTime.SetExpMeterExpTime--description","text":"Sets the exposure time for the exposure meter","title":"Description"},{"location":"scripts/SetExpMeterExpTime/#kpf.expmeter.SetExpMeterExpTime.SetExpMeterExpTime--ktl-keywords-used","text":"kpf_expmeter.EXPOSURE","title":"KTL Keywords Used"},{"location":"scripts/SetExpMeterExpTime/#kpf.expmeter.SetExpMeterExpTime.SetExpMeterExpTime--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetExpMeterExpTime/#kpf.expmeter.SetExpMeterExpTime.SetExpMeterExpTime--parameters","text":"ExpMeterExpTime ( float ) The exposure time in seconds Source code in kpf/expmeter/SetExpMeterExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class SetExpMeterExpTime ( KPFTranslatorFunction ): '''# Description Sets the exposure time for the exposure meter ## KTL Keywords Used - `kpf_expmeter.EXPOSURE` ## Scripts Called None ## Parameters **ExpMeterExpTime** (`float`) > The exposure time in seconds ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpMeterExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) exptime = args . get ( 'ExpMeterExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) kpf_expmeter [ 'EXPOSURE' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpMeterExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpf_expmeter.EXPOSURE >= { exptime - tol } ) and \" f \"($kpf_expmeter.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : exposure = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) raise FailedToReachDestination ( exposure . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpMeterExpTime' , type = float , help = \"The exposure time in seconds\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetExpMeterTerminationParameters/","text":"SetExpMeterTerminationParameters Bases: KPFTranslatorFunction Description Sets the exposure meter exposure termination control parameters Threshold bin definition (from kpf_expmeter.THRESHOLDBIN) Values: 0 All 1 498.125 2 604.375 3 710.625 4 816.875 Relationship (slope) between expmeter flux and science spectrograph flux (from Jon Zink: https://cal-planet-search.slack.com/archives/CE57W8VL0/p1692294839416559?thread_ts=1692226289.791179&cid=CE57W8VL0) bin,m 498.12,4.568570548557381 604.38,11.125201914680732 710.62,10.02578758982348 816.88,12.446153099971543 KTL Keywords Used kpf_expmeter.THRESHOLDBIN kpf_expmeter.THRESHOLD kpf_expmeter.USETHRESHOLD Scripts Called None Parameters Band ( int ) Which of the 4 exposure meter bands to use (1=498nm, 2=604nm, 3=711nm, 4=817nm) Flux ( float ) The flux (e/nm) in the science spectrum desired Source code in kpf/expmeter/SetExpMeterTerminationParameters.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class SetExpMeterTerminationParameters ( KPFTranslatorFunction ): '''# Description Sets the exposure meter exposure termination control parameters Threshold bin definition (from kpf_expmeter.THRESHOLDBIN) Values: 0 All 1 498.125 2 604.375 3 710.625 4 816.875 Relationship (slope) between expmeter flux and science spectrograph flux (from Jon Zink: https://cal-planet-search.slack.com/archives/CE57W8VL0/p1692294839416559?thread_ts=1692226289.791179&cid=CE57W8VL0) bin,m 498.12,4.568570548557381 604.38,11.125201914680732 710.62,10.02578758982348 816.88,12.446153099971543 ## KTL Keywords Used - `kpf_expmeter.THRESHOLDBIN` - `kpf_expmeter.THRESHOLD` - `kpf_expmeter.USETHRESHOLD` ## Scripts Called None ## Parameters **Band** (`int`) > Which of the 4 exposure meter bands to use (1=498nm, 2=604nm, 3=711nm, 4=817nm) **Flux** (`float`) > The flux (e/nm) in the science spectrum desired ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpMeterThreshold' , allowed_types = [ int , float ], value_min = 0 ) check_input ( args , 'ExpMeterBin' ) # Manually check ExpMeterBin inputs band = args . get ( 'ExpMeterBin' ) tbin = ktl . cache ( 'kpf_expmeter' , 'THRESHOLDBIN' ) allowed_values = list ( tbin . _getEnumerators ()) if isinstance ( band , float ): band = str ( band ) if isinstance ( band , str ): if band not in allowed_values : raise FailedPreCondition ( f \"ExpMeterBin ' { band } ' not in { allowed_values } \" ) else : raise FailedPreCondition ( f \"ExpMeterBin ' { band } ' could not be parsed\" ) @classmethod def perform ( cls , args , logger , cfg ): band = str ( args . get ( 'ExpMeterBin' )) spectrograph_flux = args . get ( 'ExpMeterThreshold' ) expmeter_flux = expeter_flux_target ( spectrograph_flux , band ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'THRESHOLDBIN' ] . write ( band ) kpf_expmeter [ 'THRESHOLD' ] . write ( expmeter_flux ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpMeterBin' , type = int , choices = [ 1 , 2 , 3 , 4 ], help = \"Which exposure meter band to use (1, 2, 3, or 4)\" ) parser . add_argument ( 'ExpMeterThreshold' , type = float , help = \"Threshold flux in e-/nm in the main spectrograph\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetExpMeterTerminationParameters"},{"location":"scripts/SetExpMeterTerminationParameters/#setexpmeterterminationparameters","text":"Bases: KPFTranslatorFunction","title":"SetExpMeterTerminationParameters"},{"location":"scripts/SetExpMeterTerminationParameters/#kpf.expmeter.SetExpMeterTerminationParameters.SetExpMeterTerminationParameters--description","text":"Sets the exposure meter exposure termination control parameters Threshold bin definition (from kpf_expmeter.THRESHOLDBIN) Values: 0 All 1 498.125 2 604.375 3 710.625 4 816.875 Relationship (slope) between expmeter flux and science spectrograph flux (from Jon Zink: https://cal-planet-search.slack.com/archives/CE57W8VL0/p1692294839416559?thread_ts=1692226289.791179&cid=CE57W8VL0) bin,m 498.12,4.568570548557381 604.38,11.125201914680732 710.62,10.02578758982348 816.88,12.446153099971543","title":"Description"},{"location":"scripts/SetExpMeterTerminationParameters/#kpf.expmeter.SetExpMeterTerminationParameters.SetExpMeterTerminationParameters--ktl-keywords-used","text":"kpf_expmeter.THRESHOLDBIN kpf_expmeter.THRESHOLD kpf_expmeter.USETHRESHOLD","title":"KTL Keywords Used"},{"location":"scripts/SetExpMeterTerminationParameters/#kpf.expmeter.SetExpMeterTerminationParameters.SetExpMeterTerminationParameters--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetExpMeterTerminationParameters/#kpf.expmeter.SetExpMeterTerminationParameters.SetExpMeterTerminationParameters--parameters","text":"Band ( int ) Which of the 4 exposure meter bands to use (1=498nm, 2=604nm, 3=711nm, 4=817nm) Flux ( float ) The flux (e/nm) in the science spectrum desired Source code in kpf/expmeter/SetExpMeterTerminationParameters.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class SetExpMeterTerminationParameters ( KPFTranslatorFunction ): '''# Description Sets the exposure meter exposure termination control parameters Threshold bin definition (from kpf_expmeter.THRESHOLDBIN) Values: 0 All 1 498.125 2 604.375 3 710.625 4 816.875 Relationship (slope) between expmeter flux and science spectrograph flux (from Jon Zink: https://cal-planet-search.slack.com/archives/CE57W8VL0/p1692294839416559?thread_ts=1692226289.791179&cid=CE57W8VL0) bin,m 498.12,4.568570548557381 604.38,11.125201914680732 710.62,10.02578758982348 816.88,12.446153099971543 ## KTL Keywords Used - `kpf_expmeter.THRESHOLDBIN` - `kpf_expmeter.THRESHOLD` - `kpf_expmeter.USETHRESHOLD` ## Scripts Called None ## Parameters **Band** (`int`) > Which of the 4 exposure meter bands to use (1=498nm, 2=604nm, 3=711nm, 4=817nm) **Flux** (`float`) > The flux (e/nm) in the science spectrum desired ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpMeterThreshold' , allowed_types = [ int , float ], value_min = 0 ) check_input ( args , 'ExpMeterBin' ) # Manually check ExpMeterBin inputs band = args . get ( 'ExpMeterBin' ) tbin = ktl . cache ( 'kpf_expmeter' , 'THRESHOLDBIN' ) allowed_values = list ( tbin . _getEnumerators ()) if isinstance ( band , float ): band = str ( band ) if isinstance ( band , str ): if band not in allowed_values : raise FailedPreCondition ( f \"ExpMeterBin ' { band } ' not in { allowed_values } \" ) else : raise FailedPreCondition ( f \"ExpMeterBin ' { band } ' could not be parsed\" ) @classmethod def perform ( cls , args , logger , cfg ): band = str ( args . get ( 'ExpMeterBin' )) spectrograph_flux = args . get ( 'ExpMeterThreshold' ) expmeter_flux = expeter_flux_target ( spectrograph_flux , band ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'THRESHOLDBIN' ] . write ( band ) kpf_expmeter [ 'THRESHOLD' ] . write ( expmeter_flux ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpMeterBin' , type = int , choices = [ 1 , 2 , 3 , 4 ], help = \"Which exposure meter band to use (1, 2, 3, or 4)\" ) parser . add_argument ( 'ExpMeterThreshold' , type = float , help = \"Threshold flux in e-/nm in the main spectrograph\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetExpTime/","text":"SetExpTime Bases: KPFTranslatorFunction Sets the exposure time for the science detectors in the kpfexpose keyword service. ARGS: :ExpTime: float The exposure time in seconds Source code in kpf/spectrograph/SetExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetExpTime ( KPFTranslatorFunction ): '''Sets the exposure time for the science detectors in the kpfexpose keyword service. ARGS: ===== :ExpTime: `float` The exposure time in seconds ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = args . get ( 'ExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) kpfexpose [ 'EXPOSURE' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpfexpose.EXPOSURE >= { exptime - tol } ) and \" f \"($kpfexpose.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : exposure = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) raise FailedToReachDestination ( exposure . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpTime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetExpTime"},{"location":"scripts/SetExpTime/#setexptime","text":"Bases: KPFTranslatorFunction Sets the exposure time for the science detectors in the kpfexpose keyword service.","title":"SetExpTime"},{"location":"scripts/SetExpTime/#kpf.spectrograph.SetExpTime.SetExpTime--args","text":":ExpTime: float The exposure time in seconds Source code in kpf/spectrograph/SetExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetExpTime ( KPFTranslatorFunction ): '''Sets the exposure time for the science detectors in the kpfexpose keyword service. ARGS: ===== :ExpTime: `float` The exposure time in seconds ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = args . get ( 'ExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) kpfexpose [ 'EXPOSURE' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpfexpose.EXPOSURE >= { exptime - tol } ) and \" f \"($kpfexpose.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : exposure = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) raise FailedToReachDestination ( exposure . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ExpTime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetFVCExpTime/","text":"SetFVCExpTime Bases: KPFTranslatorFunction Set the exposure time of the specified fiber viewing camera ARGS: :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. Source code in kpf/fvc/SetFVCExpTime.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class SetFVCExpTime ( KPFTranslatorFunction ): '''Set the exposure time of the specified fiber viewing camera ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) check_input ( args , 'exptime' , value_min = 0.005 , value_max = 60 ) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = args . get ( 'exptime' ) log . debug ( f \"Setting { camera } FVC exposure time to { exptime : .3f } s\" ) kpffvc [ f ' { camera } EXPTIME' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) tol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) expr = ( f '($kpffvc. { camera } EXPTIME > { exptime } - { tol } ) ' \\ f 'and ($kpffvc. { camera } EXPTIME < { exptime } + { tol } )' ) success = ktl . waitfor ( expr , timeout = timeout ) if success is not True : exptimekw = ktl . cache ( 'kpffvc' , f \" { camera } EXPTIME\" ) raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetFVCExpTime"},{"location":"scripts/SetFVCExpTime/#setfvcexptime","text":"Bases: KPFTranslatorFunction Set the exposure time of the specified fiber viewing camera","title":"SetFVCExpTime"},{"location":"scripts/SetFVCExpTime/#kpf.fvc.SetFVCExpTime.SetFVCExpTime--args","text":":camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. Source code in kpf/fvc/SetFVCExpTime.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class SetFVCExpTime ( KPFTranslatorFunction ): '''Set the exposure time of the specified fiber viewing camera ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) check_input ( args , 'exptime' , value_min = 0.005 , value_max = 60 ) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = args . get ( 'exptime' ) log . debug ( f \"Setting { camera } FVC exposure time to { exptime : .3f } s\" ) kpffvc [ f ' { camera } EXPTIME' ] . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) tol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) expr = ( f '($kpffvc. { camera } EXPTIME > { exptime } - { tol } ) ' \\ f 'and ($kpffvc. { camera } EXPTIME < { exptime } + { tol } )' ) success = ktl . waitfor ( expr , timeout = timeout ) if success is not True : exptimekw = ktl . cache ( 'kpffvc' , f \" { camera } EXPTIME\" ) raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetFlatFieldFiberPos/","text":"SetFlatFieldFiberPos Bases: KPFTranslatorFunction Description Set the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. KTL Keywords Used kpfcal.FF_FIBERPOS Scripts Called None Parameters FF_FiberPos ( str ) The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class SetFlatFieldFiberPos ( KPFTranslatorFunction ): '''# Description Set the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. ## KTL Keywords Used - `kpfcal.FF_FIBERPOS` ## Scripts Called None ## Parameters **FF_FiberPos** (`str`) > The name of the flat field fiber position desired. <br>Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) log . debug ( f \"Setting FF_FiberPos to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'FF_FiberPos' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'FF_FiberPos' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetFlatFieldFiberPos"},{"location":"scripts/SetFlatFieldFiberPos/#setflatfieldfiberpos","text":"Bases: KPFTranslatorFunction","title":"SetFlatFieldFiberPos"},{"location":"scripts/SetFlatFieldFiberPos/#kpf.calbench.SetFlatFieldFiberPos.SetFlatFieldFiberPos--description","text":"Set the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword.","title":"Description"},{"location":"scripts/SetFlatFieldFiberPos/#kpf.calbench.SetFlatFieldFiberPos.SetFlatFieldFiberPos--ktl-keywords-used","text":"kpfcal.FF_FIBERPOS","title":"KTL Keywords Used"},{"location":"scripts/SetFlatFieldFiberPos/#kpf.calbench.SetFlatFieldFiberPos.SetFlatFieldFiberPos--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetFlatFieldFiberPos/#kpf.calbench.SetFlatFieldFiberPos.SetFlatFieldFiberPos--parameters","text":"FF_FiberPos ( str ) The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class SetFlatFieldFiberPos ( KPFTranslatorFunction ): '''# Description Set the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. ## KTL Keywords Used - `kpfcal.FF_FIBERPOS` ## Scripts Called None ## Parameters **FF_FiberPos** (`str`) > The name of the flat field fiber position desired. <br>Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) log . debug ( f \"Setting FF_FiberPos to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'FF_FiberPos' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'FF_FiberPos' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetGuiderExpTime/","text":"SetGuiderExpTime Bases: KPFTranslatorFunction Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. ARGS: :exptime: float The exposure time in seconds. Source code in kpf/guider/SetGuiderExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class SetGuiderExpTime ( KPFTranslatorFunction ): '''Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. ARGS: ===== :exptime: `float` The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'exptime' , value_min = 0 ) @classmethod def perform ( cls , args , logger , cfg ): exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptime = args . get ( 'exptime' ) exptimekw . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): exptol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptimeread = exptimekw . read ( binary = True ) exptime = args . get ( 'exptime' ) expr = ( f '($kpfguide.EXPTIME >= { exptime - exptol } ) and ' \\ f '($kpfguide.EXPTIME <= { exptime + exptol } )' ) success = ktl . waitFor ( expr , timeout = exptimeread + 1 ) if not success : raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetGuiderExpTime"},{"location":"scripts/SetGuiderExpTime/#setguiderexptime","text":"Bases: KPFTranslatorFunction Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like.","title":"SetGuiderExpTime"},{"location":"scripts/SetGuiderExpTime/#kpf.guider.SetGuiderExpTime.SetGuiderExpTime--args","text":":exptime: float The exposure time in seconds. Source code in kpf/guider/SetGuiderExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class SetGuiderExpTime ( KPFTranslatorFunction ): '''Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. ARGS: ===== :exptime: `float` The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'exptime' , value_min = 0 ) @classmethod def perform ( cls , args , logger , cfg ): exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptime = args . get ( 'exptime' ) exptimekw . write ( exptime ) @classmethod def post_condition ( cls , args , logger , cfg ): exptol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptimeread = exptimekw . read ( binary = True ) exptime = args . get ( 'exptime' ) expr = ( f '($kpfguide.EXPTIME >= { exptime - exptol } ) and ' \\ f '($kpfguide.EXPTIME <= { exptime + exptol } )' ) success = ktl . waitFor ( expr , timeout = exptimeread + 1 ) if not success : raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetGuiderFPS/","text":"SetGuiderFPS Bases: KPFTranslatorFunction Set the guider FPS (frames per second) via the kpfguide.FPS keyword. ARGS: :fps: float Number of frames per second Source code in kpf/guider/SetGuiderFPS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SetGuiderFPS ( KPFTranslatorFunction ): '''Set the guider FPS (frames per second) via the kpfguide.FPS keyword. ARGS: ===== :fps: `float` Number of frames per second ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideFPS' , value_min = 0.0001 , value_max = 400 ) return True @classmethod def perform ( cls , args , logger , cfg ): fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) log . debug ( f 'Setting guider FPS to { fps } ' ) fpskw . write ( fps ) @classmethod def post_condition ( cls , args , logger , cfg ): fpstol = cfg . getfloat ( 'tolerances' , 'guider_fps_tolerance' , fallback = 0.01 ) fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) expr = ( f '($kpfguide.FPS >= { fps - fpstol } ) and ' \\ f '($kpfguide.FPS <= { fps + fpstol } )' ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( fpskw . read (), fps ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideFPS' , type = float , help = 'The frames per second (FPS)' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetGuiderFPS"},{"location":"scripts/SetGuiderFPS/#setguiderfps","text":"Bases: KPFTranslatorFunction Set the guider FPS (frames per second) via the kpfguide.FPS keyword.","title":"SetGuiderFPS"},{"location":"scripts/SetGuiderFPS/#kpf.guider.SetGuiderFPS.SetGuiderFPS--args","text":":fps: float Number of frames per second Source code in kpf/guider/SetGuiderFPS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class SetGuiderFPS ( KPFTranslatorFunction ): '''Set the guider FPS (frames per second) via the kpfguide.FPS keyword. ARGS: ===== :fps: `float` Number of frames per second ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideFPS' , value_min = 0.0001 , value_max = 400 ) return True @classmethod def perform ( cls , args , logger , cfg ): fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) log . debug ( f 'Setting guider FPS to { fps } ' ) fpskw . write ( fps ) @classmethod def post_condition ( cls , args , logger , cfg ): fpstol = cfg . getfloat ( 'tolerances' , 'guider_fps_tolerance' , fallback = 0.01 ) fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) expr = ( f '($kpfguide.FPS >= { fps - fpstol } ) and ' \\ f '($kpfguide.FPS <= { fps + fpstol } )' ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( fpskw . read (), fps ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideFPS' , type = float , help = 'The frames per second (FPS)' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetGuiderGain/","text":"SetGuiderGain Bases: KPFTranslatorFunction Set the guider gain via the kpfguide.GAIN keyword. ARGS: :gain: str The desired gain (high, medium, or low) Source code in kpf/guider/SetGuiderGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetGuiderGain ( KPFTranslatorFunction ): '''Set the guider gain via the kpfguide.GAIN keyword. ARGS: ===== :gain: `str` The desired gain (high, medium, or low) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideCamGain' , allowed_values = [ 'high' , 'medium' , 'low' ]) @classmethod def perform ( cls , args , logger , cfg ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) log . debug ( f 'Setting guider gain to { gain } ' ) gainkw . write ( gain ) @classmethod def post_condition ( cls , args , logger , cfg ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) expr = ( f \"($kpfguide.GAIN == ' { gain } ')\" ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( gainkw . read (), gain ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideCamGain' , type = str , choices = [ 'high' , 'medium' , 'low' ], help = 'The gain' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetGuiderGain"},{"location":"scripts/SetGuiderGain/#setguidergain","text":"Bases: KPFTranslatorFunction Set the guider gain via the kpfguide.GAIN keyword.","title":"SetGuiderGain"},{"location":"scripts/SetGuiderGain/#kpf.guider.SetGuiderGain.SetGuiderGain--args","text":":gain: str The desired gain (high, medium, or low) Source code in kpf/guider/SetGuiderGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetGuiderGain ( KPFTranslatorFunction ): '''Set the guider gain via the kpfguide.GAIN keyword. ARGS: ===== :gain: `str` The desired gain (high, medium, or low) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideCamGain' , allowed_values = [ 'high' , 'medium' , 'low' ]) @classmethod def perform ( cls , args , logger , cfg ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) log . debug ( f 'Setting guider gain to { gain } ' ) gainkw . write ( gain ) @classmethod def post_condition ( cls , args , logger , cfg ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) expr = ( f \"($kpfguide.GAIN == ' { gain } ')\" ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( gainkw . read (), gain ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideCamGain' , type = str , choices = [ 'high' , 'medium' , 'low' ], help = 'The gain' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetGuiderOutdir/","text":"SetGuiderOutdir Bases: KPFTranslatorFunction Set the value of the kpfguide.OUTDIR keyword ARGS: :outdir: str The desired output path Source code in kpf/guider/SetGuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetGuiderOutdir ( KPFTranslatorFunction ): '''Set the value of the kpfguide.OUTDIR keyword ARGS: ===== :outdir: `str` The desired output path ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'outdir' ) @classmethod def perform ( cls , args , logger , cfg ): newoutdir = Path ( args . get ( 'outdir' )) . expanduser () . absolute () kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'OUTDIR' ] . write ( f \" { newoutdir } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'outdir' , type = str , help = 'The desired output path' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetGuiderOutdir"},{"location":"scripts/SetGuiderOutdir/#setguideroutdir","text":"Bases: KPFTranslatorFunction Set the value of the kpfguide.OUTDIR keyword","title":"SetGuiderOutdir"},{"location":"scripts/SetGuiderOutdir/#kpf.guider.SetGuiderOutdir.SetGuiderOutdir--args","text":":outdir: str The desired output path Source code in kpf/guider/SetGuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetGuiderOutdir ( KPFTranslatorFunction ): '''Set the value of the kpfguide.OUTDIR keyword ARGS: ===== :outdir: `str` The desired output path ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'outdir' ) @classmethod def perform ( cls , args , logger , cfg ): newoutdir = Path ( args . get ( 'outdir' )) . expanduser () . absolute () kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'OUTDIR' ] . write ( f \" { newoutdir } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'outdir' , type = str , help = 'The desired output path' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetLFCtoAstroComb/","text":"SetLFCtoAstroComb Bases: KPFTranslatorFunction Description Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. KTL Keywords Used kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA Scripts Called kpf.calbench.WaitForLFCReady Parameters None Source code in kpf/calbench/SetLFCtoAstroComb.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetLFCtoAstroComb ( KPFTranslatorFunction ): '''# Description Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. ## KTL Keywords Used - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` ## Scripts Called - `kpf.calbench.WaitForLFCReady` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) @classmethod def perform ( cls , args , logger , cfg ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to AstroComb' ) lfc_mode . write ( 'AstroComb' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): success = WaitForLFCReady . execute ({}) if success is not True : raise FailedPostCondition ( 'LFC did not reach expected state' )","title":"SetLFCtoAstroComb"},{"location":"scripts/SetLFCtoAstroComb/#setlfctoastrocomb","text":"Bases: KPFTranslatorFunction","title":"SetLFCtoAstroComb"},{"location":"scripts/SetLFCtoAstroComb/#kpf.calbench.SetLFCtoAstroComb.SetLFCtoAstroComb--description","text":"Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC.","title":"Description"},{"location":"scripts/SetLFCtoAstroComb/#kpf.calbench.SetLFCtoAstroComb.SetLFCtoAstroComb--ktl-keywords-used","text":"kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA","title":"KTL Keywords Used"},{"location":"scripts/SetLFCtoAstroComb/#kpf.calbench.SetLFCtoAstroComb.SetLFCtoAstroComb--scripts-called","text":"kpf.calbench.WaitForLFCReady","title":"Scripts Called"},{"location":"scripts/SetLFCtoAstroComb/#kpf.calbench.SetLFCtoAstroComb.SetLFCtoAstroComb--parameters","text":"None Source code in kpf/calbench/SetLFCtoAstroComb.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetLFCtoAstroComb ( KPFTranslatorFunction ): '''# Description Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. ## KTL Keywords Used - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` ## Scripts Called - `kpf.calbench.WaitForLFCReady` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) @classmethod def perform ( cls , args , logger , cfg ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to AstroComb' ) lfc_mode . write ( 'AstroComb' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): success = WaitForLFCReady . execute ({}) if success is not True : raise FailedPostCondition ( 'LFC did not reach expected state' )","title":"Parameters"},{"location":"scripts/SetLFCtoStandbyHigh/","text":"SetLFCtoStandbyHigh Bases: KPFTranslatorFunction Description Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. KTL Keywords Used kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA Scripts Called None Parameters None Source code in kpf/calbench/SetLFCtoStandbyHigh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetLFCtoStandbyHigh ( KPFTranslatorFunction ): '''# Description Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. ## KTL Keywords Used - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) @classmethod def perform ( cls , args , logger , cfg ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to StandbyHigh' ) lfc_mode . write ( 'StandbyHigh' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): LFCready = ktl . cache ( 'kpfmon' , 'LFCREADYSTA' ) timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 60 ) success = LFCready . waitFor ( '== \"OK\"' , timeout = timeout ) if success is not True : raise FailedPostCondition ( 'kpfmon.LFCREADYSTA is not OK' )","title":"SetLFCtoStandbyHigh"},{"location":"scripts/SetLFCtoStandbyHigh/#setlfctostandbyhigh","text":"Bases: KPFTranslatorFunction","title":"SetLFCtoStandbyHigh"},{"location":"scripts/SetLFCtoStandbyHigh/#kpf.calbench.SetLFCtoStandbyHigh.SetLFCtoStandbyHigh--description","text":"Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete.","title":"Description"},{"location":"scripts/SetLFCtoStandbyHigh/#kpf.calbench.SetLFCtoStandbyHigh.SetLFCtoStandbyHigh--ktl-keywords-used","text":"kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA","title":"KTL Keywords Used"},{"location":"scripts/SetLFCtoStandbyHigh/#kpf.calbench.SetLFCtoStandbyHigh.SetLFCtoStandbyHigh--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetLFCtoStandbyHigh/#kpf.calbench.SetLFCtoStandbyHigh.SetLFCtoStandbyHigh--parameters","text":"None Source code in kpf/calbench/SetLFCtoStandbyHigh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetLFCtoStandbyHigh ( KPFTranslatorFunction ): '''# Description Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. ## KTL Keywords Used - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) @classmethod def perform ( cls , args , logger , cfg ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to StandbyHigh' ) lfc_mode . write ( 'StandbyHigh' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): LFCready = ktl . cache ( 'kpfmon' , 'LFCREADYSTA' ) timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 60 ) success = LFCready . waitFor ( '== \"OK\"' , timeout = timeout ) if success is not True : raise FailedPostCondition ( 'kpfmon.LFCREADYSTA is not OK' )","title":"Parameters"},{"location":"scripts/SetMasterBiasToDefault/","text":"SetMasterBiasToDefault Bases: KPFTranslatorFunction Description Sets the master bias file for the exposure meter to the default value KTL Keywords Used kpf_expmeter.BIAS_FILE Scripts Called None Parameters None Source code in kpf/expmeter/SetMasterBiasToDefault.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SetMasterBiasToDefault ( KPFTranslatorFunction ): '''# Description Sets the master bias file for the exposure meter to the default value ## KTL Keywords Used - `kpf_expmeter.BIAS_FILE` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) default_file = '/kroot/rel/default/data/kpf_expmeter/full_bias.fits' log . debug ( f \"Setting master bias file to { default_file } \" ) kpf_expmeter [ 'BIAS_FILE' ] . write ( default_file ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"SetMasterBiasToDefault"},{"location":"scripts/SetMasterBiasToDefault/#setmasterbiastodefault","text":"Bases: KPFTranslatorFunction","title":"SetMasterBiasToDefault"},{"location":"scripts/SetMasterBiasToDefault/#kpf.expmeter.SetMasterBiasToDefault.SetMasterBiasToDefault--description","text":"Sets the master bias file for the exposure meter to the default value","title":"Description"},{"location":"scripts/SetMasterBiasToDefault/#kpf.expmeter.SetMasterBiasToDefault.SetMasterBiasToDefault--ktl-keywords-used","text":"kpf_expmeter.BIAS_FILE","title":"KTL Keywords Used"},{"location":"scripts/SetMasterBiasToDefault/#kpf.expmeter.SetMasterBiasToDefault.SetMasterBiasToDefault--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetMasterBiasToDefault/#kpf.expmeter.SetMasterBiasToDefault.SetMasterBiasToDefault--parameters","text":"None Source code in kpf/expmeter/SetMasterBiasToDefault.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SetMasterBiasToDefault ( KPFTranslatorFunction ): '''# Description Sets the master bias file for the exposure meter to the default value ## KTL Keywords Used - `kpf_expmeter.BIAS_FILE` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) default_file = '/kroot/rel/default/data/kpf_expmeter/full_bias.fits' log . debug ( f \"Setting master bias file to { default_file } \" ) kpf_expmeter [ 'BIAS_FILE' ] . write ( default_file ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/SetND/","text":"SetND Bases: KPFTranslatorFunction Description Set the filter in the ND1 & ND2 filter wheels via the kpfcal.ND1POS and kpfcal.ND2POS keywords. KTL Keywords Used None Scripts Called kpf.calbench.SetND1 kpf.calbench.SetND2 Parameters CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class SetND ( KPFTranslatorFunction ): '''# Description Set the filter in the ND1 & ND2 filter wheels via the `kpfcal.ND1POS` and `kpfcal.ND2POS` keywords. ## KTL Keywords Used None ## Scripts Called - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): SetND1 . execute ( args ) SetND2 . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetND"},{"location":"scripts/SetND/#setnd","text":"Bases: KPFTranslatorFunction","title":"SetND"},{"location":"scripts/SetND/#kpf.calbench.SetND.SetND--description","text":"Set the filter in the ND1 & ND2 filter wheels via the kpfcal.ND1POS and kpfcal.ND2POS keywords.","title":"Description"},{"location":"scripts/SetND/#kpf.calbench.SetND.SetND--ktl-keywords-used","text":"None","title":"KTL Keywords Used"},{"location":"scripts/SetND/#kpf.calbench.SetND.SetND--scripts-called","text":"kpf.calbench.SetND1 kpf.calbench.SetND2","title":"Scripts Called"},{"location":"scripts/SetND/#kpf.calbench.SetND.SetND--parameters","text":"CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class SetND ( KPFTranslatorFunction ): '''# Description Set the filter in the ND1 & ND2 filter wheels via the `kpfcal.ND1POS` and `kpfcal.ND2POS` keywords. ## KTL Keywords Used None ## Scripts Called - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): SetND1 . execute ( args ) SetND2 . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetND1/","text":"SetND1 Bases: KPFTranslatorFunction Description Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. KTL Keywords Used kpfcal.ND1POS Scripts Called None Parameters CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetND1 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. ## KTL Keywords Used - `kpfcal.ND1POS` ## Scripts Called None ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND1' ) log . debug ( f \"Setting ND1POS to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'ND1POS' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetND1"},{"location":"scripts/SetND1/#setnd1","text":"Bases: KPFTranslatorFunction","title":"SetND1"},{"location":"scripts/SetND1/#kpf.calbench.SetND1.SetND1--description","text":"Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword.","title":"Description"},{"location":"scripts/SetND1/#kpf.calbench.SetND1.SetND1--ktl-keywords-used","text":"kpfcal.ND1POS","title":"KTL Keywords Used"},{"location":"scripts/SetND1/#kpf.calbench.SetND1.SetND1--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetND1/#kpf.calbench.SetND1.SetND1--parameters","text":"CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetND1 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. ## KTL Keywords Used - `kpfcal.ND1POS` ## Scripts Called None ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND1' ) log . debug ( f \"Setting ND1POS to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'ND1POS' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetND2/","text":"SetND2 Bases: KPFTranslatorFunction Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. KTL Keywords Used kpfcal.ND2POS Scripts Called None Parameters CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetND2 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. ## KTL Keywords Used - `kpfcal.ND2POS` ## Scripts Called None ## Parameters **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND2' ) log . debug ( f \"Setting ND2POS to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'ND2POS' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetND2"},{"location":"scripts/SetND2/#setnd2","text":"Bases: KPFTranslatorFunction","title":"SetND2"},{"location":"scripts/SetND2/#kpf.calbench.SetND2.SetND2--description","text":"Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword.","title":"Description"},{"location":"scripts/SetND2/#kpf.calbench.SetND2.SetND2--ktl-keywords-used","text":"kpfcal.ND2POS","title":"KTL Keywords Used"},{"location":"scripts/SetND2/#kpf.calbench.SetND2.SetND2--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/SetND2/#kpf.calbench.SetND2.SetND2--parameters","text":"CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) Wait for move to complete before returning? default: True Source code in kpf/calbench/SetND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class SetND2 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. ## KTL Keywords Used - `kpfcal.ND2POS` ## Scripts Called None ## Parameters **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` **wait** (`bool`) > Wait for move to complete before returning? <br>default: True ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND2' ) log . debug ( f \"Setting ND2POS to { target } \" ) kpfcal = ktl . cache ( 'kpfcal' ) kpfcal [ 'ND2POS' ] . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/SetObject/","text":"SetObject Bases: KPFTranslatorFunction Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. ARGS: :Object: str The desired object keyword value. Source code in kpf/spectrograph/SetObject.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetObject ( KPFTranslatorFunction ): '''Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :Object: `str` The desired object keyword value. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) obj = args . get ( 'Object' , '' ) if obj is None : obj = '' log . debug ( f \"Setting OBJECT to ' { obj } '\" ) kpfexpose [ 'OBJECT' ] . write ( obj ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): obj = args . get ( 'Object' , '' ) if obj is None : obj = '' timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f \"($kpfexpose.OBJECT == ' { obj } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : objectkw = ktl . cache ( 'kpfexpose' , 'OBJECT' ) raise FailedToReachDestination ( objectkw . read (), obj ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Object' , type = str , help = 'The OBJECT keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetObject"},{"location":"scripts/SetObject/#setobject","text":"Bases: KPFTranslatorFunction Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service.","title":"SetObject"},{"location":"scripts/SetObject/#kpf.spectrograph.SetObject.SetObject--args","text":":Object: str The desired object keyword value. Source code in kpf/spectrograph/SetObject.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetObject ( KPFTranslatorFunction ): '''Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :Object: `str` The desired object keyword value. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) obj = args . get ( 'Object' , '' ) if obj is None : obj = '' log . debug ( f \"Setting OBJECT to ' { obj } '\" ) kpfexpose [ 'OBJECT' ] . write ( obj ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): obj = args . get ( 'Object' , '' ) if obj is None : obj = '' timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f \"($kpfexpose.OBJECT == ' { obj } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : objectkw = ktl . cache ( 'kpfexpose' , 'OBJECT' ) raise FailedToReachDestination ( objectkw . read (), obj ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'Object' , type = str , help = 'The OBJECT keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetObserver/","text":"SetObserver Bases: KPFTranslatorFunction Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. ARGS: :observer: str The desired value of the OBSERVER keyword. Source code in kpf/spectrograph/SetObserver.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetObserver ( KPFTranslatorFunction ): '''Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :observer: `str` The desired value of the OBSERVER keyword. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'observer' ) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) observer = args . get ( 'observer' ) log . info ( f \"Setting OBSERVER to { observer } \" ) kpfexpose [ 'OBSERVER' ] . write ( observer ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): observer = args . get ( 'observer' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f '($kpfexpose.OBSERVER == \" { observer } \")' success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : observerkw = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) raise FailedToReachDestination ( observerkw . read () . strip (), observer . strip ()) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'observer' , type = str , help = 'The OBSERVER keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetObserver"},{"location":"scripts/SetObserver/#setobserver","text":"Bases: KPFTranslatorFunction Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service.","title":"SetObserver"},{"location":"scripts/SetObserver/#kpf.spectrograph.SetObserver.SetObserver--args","text":":observer: str The desired value of the OBSERVER keyword. Source code in kpf/spectrograph/SetObserver.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetObserver ( KPFTranslatorFunction ): '''Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :observer: `str` The desired value of the OBSERVER keyword. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'observer' ) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) observer = args . get ( 'observer' ) log . info ( f \"Setting OBSERVER to { observer } \" ) kpfexpose [ 'OBSERVER' ] . write ( observer ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): observer = args . get ( 'observer' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f '($kpfexpose.OBSERVER == \" { observer } \")' success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : observerkw = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) raise FailedToReachDestination ( observerkw . read () . strip (), observer . strip ()) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'observer' , type = str , help = 'The OBSERVER keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetObserverFromSchedule/","text":"SetObserverFromSchedule Bases: KPFTranslatorFunction Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. ARGS: :progname: str The program name to set if a choice is needed. Source code in kpf/utils/SetObserverFromSchedule.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class SetObserverFromSchedule ( KPFTranslatorFunction ): '''Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. ARGS: ===== :progname: `str` The program name to set if a choice is needed. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y-%m- %d ' ) KPF_programs = [ s for s in get_schedule ( date_str , 1 ) if s [ 'Instrument' ] == 'KPF' ] nKPFprograms = len ( KPF_programs ) log . debug ( f \"Found { nKPFprograms } KPF programs in schedule for tonight\" ) project_codes = [ p [ 'ProjCode' ] for p in KPF_programs ] # Look at the schedule to find programs scheduled for tonight if nKPFprograms == 0 : log . warning ( f \"No KPF programs found on schedule\" ) progname = None elif nKPFprograms == 1 : progname = KPF_programs [ 0 ][ 'ProjCode' ] elif nKPFprograms > 1 : progname = args . get ( 'progname' , None ) if progname is None : print () print ( f \"########################################\" ) print ( f \" Found { nKPFprograms } KPF programs for tonight:\" ) for project_code in project_codes : print ( f \" { project_code } \" ) print ( f \" Please enter the program ID for your observations:\" ) print ( f \"########################################\" ) print () progname = input () if progname . strip () not in project_codes : log . warning ( f \"Project code { progname } not on schedule\" ) # Set the program if progname is None : time . sleep ( 0.5 ) # try time shim for log line print () print ( f \" Please enter the program ID for your observations:\" ) print () progname = input () if progname == '' : log . info ( 'No progname specified' ) else : SetProgram . execute ({ 'progname' : progname }) # Set Observers this_program = [ p for p in KPF_programs if p [ 'ProjCode' ] == progname ] if len ( this_program ) > 0 : observers = this_program [ 0 ][ 'Observers' ] else : print () print ( f \" Please enter the observer names:\" ) print () observers = input () log . info ( f \"Setting observer list: { observers } \" ) SetObserver . execute ({ 'observer' : observers }) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"SetObserverFromSchedule"},{"location":"scripts/SetObserverFromSchedule/#setobserverfromschedule","text":"Bases: KPFTranslatorFunction Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given.","title":"SetObserverFromSchedule"},{"location":"scripts/SetObserverFromSchedule/#kpf.utils.SetObserverFromSchedule.SetObserverFromSchedule--args","text":":progname: str The program name to set if a choice is needed. Source code in kpf/utils/SetObserverFromSchedule.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class SetObserverFromSchedule ( KPFTranslatorFunction ): '''Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. ARGS: ===== :progname: `str` The program name to set if a choice is needed. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y-%m- %d ' ) KPF_programs = [ s for s in get_schedule ( date_str , 1 ) if s [ 'Instrument' ] == 'KPF' ] nKPFprograms = len ( KPF_programs ) log . debug ( f \"Found { nKPFprograms } KPF programs in schedule for tonight\" ) project_codes = [ p [ 'ProjCode' ] for p in KPF_programs ] # Look at the schedule to find programs scheduled for tonight if nKPFprograms == 0 : log . warning ( f \"No KPF programs found on schedule\" ) progname = None elif nKPFprograms == 1 : progname = KPF_programs [ 0 ][ 'ProjCode' ] elif nKPFprograms > 1 : progname = args . get ( 'progname' , None ) if progname is None : print () print ( f \"########################################\" ) print ( f \" Found { nKPFprograms } KPF programs for tonight:\" ) for project_code in project_codes : print ( f \" { project_code } \" ) print ( f \" Please enter the program ID for your observations:\" ) print ( f \"########################################\" ) print () progname = input () if progname . strip () not in project_codes : log . warning ( f \"Project code { progname } not on schedule\" ) # Set the program if progname is None : time . sleep ( 0.5 ) # try time shim for log line print () print ( f \" Please enter the program ID for your observations:\" ) print () progname = input () if progname == '' : log . info ( 'No progname specified' ) else : SetProgram . execute ({ 'progname' : progname }) # Set Observers this_program = [ p for p in KPF_programs if p [ 'ProjCode' ] == progname ] if len ( this_program ) > 0 : observers = this_program [ 0 ][ 'Observers' ] else : print () print ( f \" Please enter the observer names:\" ) print () observers = input () log . info ( f \"Setting observer list: { observers } \" ) SetObserver . execute ({ 'observer' : observers }) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/SetOutdirs/","text":"SetOutdirs Bases: KPFTranslatorFunction Set output directories for all detectors based on the current date. ARGS: None Source code in kpf/utils/SetOutdirs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SetOutdirs ( KPFTranslatorFunction ): '''Set output directories for all detectors based on the current date. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( f \"SetOutdirs invoked\" ) utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) magiq_outdir = Path ( f \"/s/sdata1701/kpfguide/ { date_str } \" ) log . debug ( f \"base outdir: { outdir } \" ) log . debug ( f \"magiq outdir: { magiq_outdir } \" ) if args . get ( 'CRED2' , True ) is True : log . info ( f \"Setting guider OUTDIR to { magiq_outdir } \" ) guide_outdir = ktl . cache ( 'kpfguide' , 'OUTDIR' ) try : guide_outdir . write ( f \" { magiq_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting guider outdir\" ) log . error ( e ) log . info ( f \"Setting guider TRIGOUTDIR to { outdir / 'CRED2' } \" ) trig_outdir = ktl . cache ( 'kpfguide' , 'TRIGOUTDIR' ) try : trig_outdir . write ( f \" { outdir / 'CRED2' } \" ) except Exception as e : log . error ( f \"ERROR setting guider TRIGOUTDIR\" ) log . error ( e ) kpffvc = ktl . cache ( 'kpffvc' ) if args . get ( 'FVC1' , True ) is True : log . info ( f \"Setting FVC1 OUTDIR to { outdir / 'FVC1' } \" ) try : kpffvc [ 'SCIOUTDIR' ] . write ( f \" { outdir / 'FVC1' } \" ) except Exception as e : log . error ( f \"ERROR setting SCI FVC outdir\" ) log . error ( e ) if args . get ( 'FVC2' , True ) is True : log . info ( f \"Setting FVC2 OUTDIR to { outdir / 'FVC2' } \" ) try : kpffvc [ 'CAHKOUTDIR' ] . write ( f \" { outdir / 'FVC2' } \" ) except Exception as e : log . error ( f \"ERROR setting CAHK FVC outdir\" ) log . error ( e ) if args . get ( 'FVC3' , True ) is True : log . info ( f \"Setting FVC3 OUTDIR to { outdir / 'FVC3' } \" ) try : kpffvc [ 'CALOUTDIR' ] . write ( f \" { outdir / 'FVC3' } \" ) except Exception as e : log . error ( f \"ERROR setting CAL FVC outdir\" ) log . error ( e ) if args . get ( 'FVC4' , True ) is True : log . info ( f \"Setting FVC4 OUTDIR to { outdir / 'FVC4' } \" ) try : kpffvc [ 'EXTOUTDIR' ] . write ( f \" { outdir / 'FVC4' } \" ) except Exception as e : log . error ( f \"ERROR setting EXT FVC outdir\" ) log . error ( e ) if args . get ( 'ExpMeter' , True ) is True : expmeter_outdir = outdir / 'ExpMeter' log . info ( f \"Setting exposure meter DATADIR to { expmeter_outdir } \" ) kpf_expmeter_outdir = ktl . cache ( 'kpf_expmeter' , 'DATADIR' ) try : kpf_expmeter_outdir . write ( f \" { expmeter_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting ExpMeter outdir\" ) log . error ( e ) if args . get ( 'CaHK' , True ) is True : cahk_outdir = outdir / 'CaHK' log . info ( f \"Setting CaHK RECORDDIR to { cahk_outdir } \" ) kpf_hk_outdir = ktl . cache ( 'kpf_hk' , 'RECORDDIR' ) try : kpf_hk_outdir . write ( f \" { cahk_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting CaHK outdir\" ) log . error ( e ) if args . get ( 'Green' , True ) is True : green_outdir = outdir / 'Green' log . info ( f \"Setting Green FITSDIR to { green_outdir } \" ) kpfgreen_outdir = ktl . cache ( 'kpfgreen' , 'FITSDIR' ) try : kpfgreen_outdir . write ( f \" { green_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Green outdir\" ) log . error ( e ) if args . get ( 'Red' , True ) is True : red_outdir = outdir / 'Red' log . info ( f \"Setting Red FITSDIR to { red_outdir } \" ) kpfred_outdir = ktl . cache ( 'kpfred' , 'FITSDIR' ) try : kpfred_outdir . write ( f \" { red_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Red outdir\" ) log . error ( e ) if args . get ( 'L0' , True ) is True : L0_outdir = outdir / 'L0' log . info ( f \"Setting kpfasemble OUTDIR to { L0_outdir } \" ) kpfassemble_outdir = ktl . cache ( 'kpfassemble' , 'OUTDIR' ) try : kpfassemble_outdir . write ( f \" { L0_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting kpfasemble outdir\" ) log . error ( e ) @classmethod def post_condition ( cls , args , logger , cfg ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) tests = [] if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.OUTDIR == '/s/sdata1701/kpfguide'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.TRIGOUTDIR == ' { outdir } /CRED2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC1' , True ) is True : expr = f \"$kpffvc.SCIOUTDIR == ' { outdir } /FVC1'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC2' , True ) is True : expr = f \"$kpffvc.CAHKOUTDIR == ' { outdir } /FVC2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC3' , True ) is True : expr = f \"$kpffvc.CALOUTDIR == ' { outdir } /FVC3'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC4' , False ) is True : expr = f \"$kpffvc.EXTOUTDIR == ' { outdir } /FVC4'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'ExpMeter' , True ) is True : expr = f \"$kpf_expmeter.DATADIR == ' { outdir } /ExpMeter'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CaHK' , True ) is True : expr = f \"$kpf_hk.RECORDDIR == ' { outdir } /CaHK'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Green' , True ) is True : expr = f \"$kpfgreen.FITSDIR == ' { outdir } /Green'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Red' , True ) is True : expr = f \"$kpfred.FITSDIR == ' { outdir } /Red'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'L0' , True ) is True : expr = f \"$kpfassemble.OUTDIR == ' { outdir } /L0'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) return np . all ( np . array ( tests )) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser = cls . _add_bool_arg ( parser , 'CRED2' , 'Set CRED2 OUTDIR (kpfguide.OUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC1' , 'Set FVC1 OUTDIR (kpffvc.SCIOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC2' , 'Set FVC2 OUTDIR (kpffvc.CAHKOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC3' , 'Set FVC3 OUTDIR (kpffvc.CALOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC4' , 'Set FVC4 OUTDIR (kpffvc.EXTOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'ExpMeter' , 'Set ExpMeter OUTDIR (kpf_expmeter.DATADIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'CaHK' , 'Set CaHK OUTDIR (kpf_hk.RECORDDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'Green' , 'Set Green OUTDIR (kpfgreen.FITSDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'Red' , 'Set Red OUTDIR (kpfred.FITSDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'L0' , 'Set Red OUTDIR (kpfassemble.OUTDIR)?' , default = True ) return super () . add_cmdline_args ( parser , cfg )","title":"SetOutdirs"},{"location":"scripts/SetOutdirs/#setoutdirs","text":"Bases: KPFTranslatorFunction Set output directories for all detectors based on the current date.","title":"SetOutdirs"},{"location":"scripts/SetOutdirs/#kpf.utils.SetOutdirs.SetOutdirs--args","text":"None Source code in kpf/utils/SetOutdirs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SetOutdirs ( KPFTranslatorFunction ): '''Set output directories for all detectors based on the current date. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( f \"SetOutdirs invoked\" ) utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) magiq_outdir = Path ( f \"/s/sdata1701/kpfguide/ { date_str } \" ) log . debug ( f \"base outdir: { outdir } \" ) log . debug ( f \"magiq outdir: { magiq_outdir } \" ) if args . get ( 'CRED2' , True ) is True : log . info ( f \"Setting guider OUTDIR to { magiq_outdir } \" ) guide_outdir = ktl . cache ( 'kpfguide' , 'OUTDIR' ) try : guide_outdir . write ( f \" { magiq_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting guider outdir\" ) log . error ( e ) log . info ( f \"Setting guider TRIGOUTDIR to { outdir / 'CRED2' } \" ) trig_outdir = ktl . cache ( 'kpfguide' , 'TRIGOUTDIR' ) try : trig_outdir . write ( f \" { outdir / 'CRED2' } \" ) except Exception as e : log . error ( f \"ERROR setting guider TRIGOUTDIR\" ) log . error ( e ) kpffvc = ktl . cache ( 'kpffvc' ) if args . get ( 'FVC1' , True ) is True : log . info ( f \"Setting FVC1 OUTDIR to { outdir / 'FVC1' } \" ) try : kpffvc [ 'SCIOUTDIR' ] . write ( f \" { outdir / 'FVC1' } \" ) except Exception as e : log . error ( f \"ERROR setting SCI FVC outdir\" ) log . error ( e ) if args . get ( 'FVC2' , True ) is True : log . info ( f \"Setting FVC2 OUTDIR to { outdir / 'FVC2' } \" ) try : kpffvc [ 'CAHKOUTDIR' ] . write ( f \" { outdir / 'FVC2' } \" ) except Exception as e : log . error ( f \"ERROR setting CAHK FVC outdir\" ) log . error ( e ) if args . get ( 'FVC3' , True ) is True : log . info ( f \"Setting FVC3 OUTDIR to { outdir / 'FVC3' } \" ) try : kpffvc [ 'CALOUTDIR' ] . write ( f \" { outdir / 'FVC3' } \" ) except Exception as e : log . error ( f \"ERROR setting CAL FVC outdir\" ) log . error ( e ) if args . get ( 'FVC4' , True ) is True : log . info ( f \"Setting FVC4 OUTDIR to { outdir / 'FVC4' } \" ) try : kpffvc [ 'EXTOUTDIR' ] . write ( f \" { outdir / 'FVC4' } \" ) except Exception as e : log . error ( f \"ERROR setting EXT FVC outdir\" ) log . error ( e ) if args . get ( 'ExpMeter' , True ) is True : expmeter_outdir = outdir / 'ExpMeter' log . info ( f \"Setting exposure meter DATADIR to { expmeter_outdir } \" ) kpf_expmeter_outdir = ktl . cache ( 'kpf_expmeter' , 'DATADIR' ) try : kpf_expmeter_outdir . write ( f \" { expmeter_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting ExpMeter outdir\" ) log . error ( e ) if args . get ( 'CaHK' , True ) is True : cahk_outdir = outdir / 'CaHK' log . info ( f \"Setting CaHK RECORDDIR to { cahk_outdir } \" ) kpf_hk_outdir = ktl . cache ( 'kpf_hk' , 'RECORDDIR' ) try : kpf_hk_outdir . write ( f \" { cahk_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting CaHK outdir\" ) log . error ( e ) if args . get ( 'Green' , True ) is True : green_outdir = outdir / 'Green' log . info ( f \"Setting Green FITSDIR to { green_outdir } \" ) kpfgreen_outdir = ktl . cache ( 'kpfgreen' , 'FITSDIR' ) try : kpfgreen_outdir . write ( f \" { green_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Green outdir\" ) log . error ( e ) if args . get ( 'Red' , True ) is True : red_outdir = outdir / 'Red' log . info ( f \"Setting Red FITSDIR to { red_outdir } \" ) kpfred_outdir = ktl . cache ( 'kpfred' , 'FITSDIR' ) try : kpfred_outdir . write ( f \" { red_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Red outdir\" ) log . error ( e ) if args . get ( 'L0' , True ) is True : L0_outdir = outdir / 'L0' log . info ( f \"Setting kpfasemble OUTDIR to { L0_outdir } \" ) kpfassemble_outdir = ktl . cache ( 'kpfassemble' , 'OUTDIR' ) try : kpfassemble_outdir . write ( f \" { L0_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting kpfasemble outdir\" ) log . error ( e ) @classmethod def post_condition ( cls , args , logger , cfg ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) tests = [] if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.OUTDIR == '/s/sdata1701/kpfguide'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.TRIGOUTDIR == ' { outdir } /CRED2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC1' , True ) is True : expr = f \"$kpffvc.SCIOUTDIR == ' { outdir } /FVC1'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC2' , True ) is True : expr = f \"$kpffvc.CAHKOUTDIR == ' { outdir } /FVC2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC3' , True ) is True : expr = f \"$kpffvc.CALOUTDIR == ' { outdir } /FVC3'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC4' , False ) is True : expr = f \"$kpffvc.EXTOUTDIR == ' { outdir } /FVC4'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'ExpMeter' , True ) is True : expr = f \"$kpf_expmeter.DATADIR == ' { outdir } /ExpMeter'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CaHK' , True ) is True : expr = f \"$kpf_hk.RECORDDIR == ' { outdir } /CaHK'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Green' , True ) is True : expr = f \"$kpfgreen.FITSDIR == ' { outdir } /Green'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Red' , True ) is True : expr = f \"$kpfred.FITSDIR == ' { outdir } /Red'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'L0' , True ) is True : expr = f \"$kpfassemble.OUTDIR == ' { outdir } /L0'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) return np . all ( np . array ( tests )) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser = cls . _add_bool_arg ( parser , 'CRED2' , 'Set CRED2 OUTDIR (kpfguide.OUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC1' , 'Set FVC1 OUTDIR (kpffvc.SCIOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC2' , 'Set FVC2 OUTDIR (kpffvc.CAHKOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC3' , 'Set FVC3 OUTDIR (kpffvc.CALOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'FVC4' , 'Set FVC4 OUTDIR (kpffvc.EXTOUTDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'ExpMeter' , 'Set ExpMeter OUTDIR (kpf_expmeter.DATADIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'CaHK' , 'Set CaHK OUTDIR (kpf_hk.RECORDDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'Green' , 'Set Green OUTDIR (kpfgreen.FITSDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'Red' , 'Set Red OUTDIR (kpfred.FITSDIR)?' , default = True ) parser = cls . _add_bool_arg ( parser , 'L0' , 'Set Red OUTDIR (kpfassemble.OUTDIR)?' , default = True ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetProgram/","text":"SetProgram Bases: KPFTranslatorFunction Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. ARGS: :progname: str The program ID to set. Source code in kpf/spectrograph/SetProgram.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class SetProgram ( KPFTranslatorFunction ): '''Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :progname: `str` The program ID to set. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'progname' ) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) progname = args . get ( 'progname' ) log . debug ( 'Waiting for kpfexpose to be ready' ) WaitForReady . execute ({}) log . info ( f \"Setting PROGNAME to ' { progname } '\" ) kpfexpose [ 'PROGNAME' ] . write ( progname ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): progname = args . get ( 'progname' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f \"($kpfexpose.PROGNAME == ' { progname } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : prognamekw = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) raise FailedToReachDestination ( prognamekw . read (), progname ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'progname' , type = str , help = 'The PROGNAME keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetProgram"},{"location":"scripts/SetProgram/#setprogram","text":"Bases: KPFTranslatorFunction Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service.","title":"SetProgram"},{"location":"scripts/SetProgram/#kpf.spectrograph.SetProgram.SetProgram--args","text":":progname: str The program ID to set. Source code in kpf/spectrograph/SetProgram.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class SetProgram ( KPFTranslatorFunction ): '''Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. ARGS: ===== :progname: `str` The program ID to set. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'progname' ) @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) progname = args . get ( 'progname' ) log . debug ( 'Waiting for kpfexpose to be ready' ) WaitForReady . execute ({}) log . info ( f \"Setting PROGNAME to ' { progname } '\" ) kpfexpose [ 'PROGNAME' ] . write ( progname ) time_shim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): progname = args . get ( 'progname' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = f \"($kpfexpose.PROGNAME == ' { progname } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : prognamekw = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) raise FailedToReachDestination ( prognamekw . read (), progname ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'progname' , type = str , help = 'The PROGNAME keyword' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetReadModeFast/","text":"SetReadModeFast Bases: KPFTranslatorFunction Configure both detectors to fast read mode by changing the ACF files they are using. ARGS: None Source code in kpf/spectrograph/SetReadModeFast.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetReadModeFast ( KPFTranslatorFunction ): '''Configure both detectors to fast read mode by changing the ACF files they are using. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_fast_file = cfg . get ( 'acf_files' , 'green_fast' ) red_fast_file = cfg . get ( 'acf_files' , 'red_fast' ) kpfgreen [ 'ACF' ] . write ( green_fast_file ) kpfred [ 'ACF' ] . write ( red_fast_file ) time . sleep ( 2 ) @classmethod def post_condition ( cls , args , logger , cfg ): if QueryFastReadMode . execute ({}) != True : raise FailedPostCondition ( f \"Read mode change failed\" )","title":"SetReadModeFast"},{"location":"scripts/SetReadModeFast/#setreadmodefast","text":"Bases: KPFTranslatorFunction Configure both detectors to fast read mode by changing the ACF files they are using.","title":"SetReadModeFast"},{"location":"scripts/SetReadModeFast/#kpf.spectrograph.SetReadModeFast.SetReadModeFast--args","text":"None Source code in kpf/spectrograph/SetReadModeFast.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetReadModeFast ( KPFTranslatorFunction ): '''Configure both detectors to fast read mode by changing the ACF files they are using. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_fast_file = cfg . get ( 'acf_files' , 'green_fast' ) red_fast_file = cfg . get ( 'acf_files' , 'red_fast' ) kpfgreen [ 'ACF' ] . write ( green_fast_file ) kpfred [ 'ACF' ] . write ( red_fast_file ) time . sleep ( 2 ) @classmethod def post_condition ( cls , args , logger , cfg ): if QueryFastReadMode . execute ({}) != True : raise FailedPostCondition ( f \"Read mode change failed\" )","title":"ARGS:"},{"location":"scripts/SetReadModeNormal/","text":"SetReadModeNormal Bases: KPFTranslatorFunction Configure both detectors to normal read mode by changing the ACF files they are using. ARGS: None Source code in kpf/spectrograph/SetReadModeNormal.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetReadModeNormal ( KPFTranslatorFunction ): '''Configure both detectors to normal read mode by changing the ACF files they are using. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) kpfgreen [ 'ACF' ] . write ( green_normal_file ) kpfred [ 'ACF' ] . write ( red_normal_file ) time . sleep ( 2 ) @classmethod def post_condition ( cls , args , logger , cfg ): if QueryFastReadMode . execute ({}) != False : raise FailedPostCondition ( f \"Read mode change failed\" )","title":"SetReadModeNormal"},{"location":"scripts/SetReadModeNormal/#setreadmodenormal","text":"Bases: KPFTranslatorFunction Configure both detectors to normal read mode by changing the ACF files they are using.","title":"SetReadModeNormal"},{"location":"scripts/SetReadModeNormal/#kpf.spectrograph.SetReadModeNormal.SetReadModeNormal--args","text":"None Source code in kpf/spectrograph/SetReadModeNormal.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetReadModeNormal ( KPFTranslatorFunction ): '''Configure both detectors to normal read mode by changing the ACF files they are using. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfgreen = ktl . cache ( 'kpfgreen' ) kpfred = ktl . cache ( 'kpfred' ) green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) kpfgreen [ 'ACF' ] . write ( green_normal_file ) kpfred [ 'ACF' ] . write ( red_normal_file ) time . sleep ( 2 ) @classmethod def post_condition ( cls , args , logger , cfg ): if QueryFastReadMode . execute ({}) != False : raise FailedPostCondition ( f \"Read mode change failed\" )","title":"ARGS:"},{"location":"scripts/SetSimulCalSource/","text":"SetSimulCalSource Bases: KPFTranslatorFunction Set the slew cal and simultaneous calibration source. Valid names: EtalonFiber, U_gold, U_daily, Th_daily, Th_gold, LFCFiber ARGS: :calsource: The calibration source to use (must be one of Etalon, LFC, Th_daily, Th_gold, U_daily, U_gold). Source code in kpf/utils/SetSimulCalSource.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetSimulCalSource ( KPFTranslatorFunction ): '''Set the slew cal and simultaneous calibration source. Valid names: EtalonFiber, U_gold, U_daily, Th_daily, Th_gold, LFCFiber ARGS: ===== :calsource: The calibration source to use (must be one of Etalon, LFC, Th_daily, Th_gold, U_daily, U_gold). ''' @classmethod def pre_condition ( cls , args , logger , cfg ): valid_names = [ 'EtalonFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'LFCFiber' ] if args . get ( 'CalSource' , None ) not in valid_names : raise FailedPreCondition ( f \"calsource ' { calsource } ' must be one of { valid_names } \" ) @classmethod def perform ( cls , args , logger , cfg ): log . info ( f \"Setting simul cal / slew cal source\" ) calsource = args . get ( 'CalSource' ) kpfconfig = ktl . cache ( 'kpfconfig' ) slew_cal_file = Path ( f '/kroot/rel/default/data/obs/kpf/SlewCal_ { calsource } .yaml' ) if slew_cal_file . exists () is False : raise KPFException ( f 'The slew cal file for { calsource } does not exist' ) else : log . info ( f 'Writing kpfconfig.SIMULCALSOURCE = { calsource } ' ) kpfconfig [ 'SIMULCALSOURCE' ] . write ( calsource ) log . info ( f 'Writing kpfconfig.SLEWCALFILE = { slew_cal_file } ' ) kpfconfig [ 'SLEWCALFILE' ] . write ( f \" { slew_cal_file } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'EtalonFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'LFCFiber' ], help = 'Which lamp to use for simultaneous calibration and slew cals' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetSimulCalSource"},{"location":"scripts/SetSimulCalSource/#setsimulcalsource","text":"Bases: KPFTranslatorFunction Set the slew cal and simultaneous calibration source. Valid names: EtalonFiber, U_gold, U_daily, Th_daily, Th_gold, LFCFiber","title":"SetSimulCalSource"},{"location":"scripts/SetSimulCalSource/#kpf.utils.SetSimulCalSource.SetSimulCalSource--args","text":":calsource: The calibration source to use (must be one of Etalon, LFC, Th_daily, Th_gold, U_daily, U_gold). Source code in kpf/utils/SetSimulCalSource.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetSimulCalSource ( KPFTranslatorFunction ): '''Set the slew cal and simultaneous calibration source. Valid names: EtalonFiber, U_gold, U_daily, Th_daily, Th_gold, LFCFiber ARGS: ===== :calsource: The calibration source to use (must be one of Etalon, LFC, Th_daily, Th_gold, U_daily, U_gold). ''' @classmethod def pre_condition ( cls , args , logger , cfg ): valid_names = [ 'EtalonFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'LFCFiber' ] if args . get ( 'CalSource' , None ) not in valid_names : raise FailedPreCondition ( f \"calsource ' { calsource } ' must be one of { valid_names } \" ) @classmethod def perform ( cls , args , logger , cfg ): log . info ( f \"Setting simul cal / slew cal source\" ) calsource = args . get ( 'CalSource' ) kpfconfig = ktl . cache ( 'kpfconfig' ) slew_cal_file = Path ( f '/kroot/rel/default/data/obs/kpf/SlewCal_ { calsource } .yaml' ) if slew_cal_file . exists () is False : raise KPFException ( f 'The slew cal file for { calsource } does not exist' ) else : log . info ( f 'Writing kpfconfig.SIMULCALSOURCE = { calsource } ' ) kpfconfig [ 'SIMULCALSOURCE' ] . write ( calsource ) log . info ( f 'Writing kpfconfig.SLEWCALFILE = { slew_cal_file } ' ) kpfconfig [ 'SLEWCALFILE' ] . write ( f \" { slew_cal_file } \" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'EtalonFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'LFCFiber' ], help = 'Which lamp to use for simultaneous calibration and slew cals' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetSourceSelectShutters/","text":"SetSourceSelectShutters Bases: KPFTranslatorFunction Opens and closes the source select shutters via the kpfexpose.SRC_SHUTTERS keyword. ARGS: :SSS_Science: bool Open the SciSelect shutter? (default=False) :SSS_Sky: bool Open the SkySelect shutter? (default=False) :SSS_CalSciSky: bool Open the Cal_SciSky shutter? (default=False) :SSS_SoCalSci: bool Open the SoCalSci shutter? (default=False) :SSS_SoCalCal: bool Open the SoCalCal shutter? (default=False) Source code in kpf/spectrograph/SetSourceSelectShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class SetSourceSelectShutters ( KPFTranslatorFunction ): '''Opens and closes the source select shutters via the `kpfexpose.SRC_SHUTTERS` keyword. ARGS: ===== :SSS_Science: `bool` Open the SciSelect shutter? (default=False) :SSS_Sky: `bool` Open the SkySelect shutter? (default=False) :SSS_CalSciSky: `bool` Open the Cal_SciSky shutter? (default=False) :SSS_SoCalSci: `bool` Open the SoCalSci shutter? (default=False) :SSS_SoCalCal: `bool` Open the SoCalCal shutter? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): shutter_list = [] if args . get ( 'SSS_Science' , False ) is True : shutter_list . append ( 'SciSelect' ) if args . get ( 'SSS_Sky' , False ) is True : shutter_list . append ( 'SkySelect' ) if args . get ( 'SSS_SoCalSci' , False ) is True : shutter_list . append ( 'SoCalSci' ) if args . get ( 'SSS_SoCalCal' , False ) is True : shutter_list . append ( 'SoCalCal' ) if args . get ( 'SSS_CalSciSky' , False ) is True : shutter_list . append ( 'Cal_SciSky' ) shutters_string = ',' . join ( shutter_list ) log . debug ( f \"Setting source select shutters to ' { shutters_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'SRC_SHUTTERS' ] . write ( shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( timeshim ) shutters = kpfexpose [ 'SRC_SHUTTERS' ] . read () shutter_list = shutters . split ( ',' ) shutter_names = [( 'SciSelect' , 'SSS_Science' ), ( 'SkySelect' , 'SSS_Sky' ), ( 'SoCalSci' , 'SSS_SoCalSci' ), ( 'SoCalCal' , 'SSS_SoCalCal' ), ( 'Cal_SciSky' , 'SSS_CalSciSky' )] for shutter in shutter_names : shutter_status = shutter [ 0 ] in shutter_list shutter_target = args . get ( shutter [ 1 ], False ) if shutter_target != shutter_status : raise FailedToReachDestination ( shutter_status , shutter_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , dest = \"SSS_Science\" , default = False , action = \"store_true\" , help = \"Open the SciSelect shutter?\" ) parser . add_argument ( \"--Sky\" , \"--sky\" , dest = \"SSS_Sky\" , default = False , action = \"store_true\" , help = \"Open the SkySelect shutter?\" ) parser . add_argument ( \"--CalSciSky\" , dest = \"SSS_CalSciSky\" , default = False , action = \"store_true\" , help = \"Open the Cal_SciSky shutter?\" ) parser . add_argument ( \"--SoCalSci\" , dest = \"SSS_SoCalSci\" , default = False , action = \"store_true\" , help = \"Open the SoCalSci shutter?\" ) parser . add_argument ( \"--SoCalCal\" , dest = \"SSS_SoCalCal\" , default = False , action = \"store_true\" , help = \"Open the SoCalCal shutter?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetSourceSelectShutters"},{"location":"scripts/SetSourceSelectShutters/#setsourceselectshutters","text":"Bases: KPFTranslatorFunction Opens and closes the source select shutters via the kpfexpose.SRC_SHUTTERS keyword.","title":"SetSourceSelectShutters"},{"location":"scripts/SetSourceSelectShutters/#kpf.spectrograph.SetSourceSelectShutters.SetSourceSelectShutters--args","text":":SSS_Science: bool Open the SciSelect shutter? (default=False) :SSS_Sky: bool Open the SkySelect shutter? (default=False) :SSS_CalSciSky: bool Open the Cal_SciSky shutter? (default=False) :SSS_SoCalSci: bool Open the SoCalSci shutter? (default=False) :SSS_SoCalCal: bool Open the SoCalCal shutter? (default=False) Source code in kpf/spectrograph/SetSourceSelectShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class SetSourceSelectShutters ( KPFTranslatorFunction ): '''Opens and closes the source select shutters via the `kpfexpose.SRC_SHUTTERS` keyword. ARGS: ===== :SSS_Science: `bool` Open the SciSelect shutter? (default=False) :SSS_Sky: `bool` Open the SkySelect shutter? (default=False) :SSS_CalSciSky: `bool` Open the Cal_SciSky shutter? (default=False) :SSS_SoCalSci: `bool` Open the SoCalSci shutter? (default=False) :SSS_SoCalCal: `bool` Open the SoCalCal shutter? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): shutter_list = [] if args . get ( 'SSS_Science' , False ) is True : shutter_list . append ( 'SciSelect' ) if args . get ( 'SSS_Sky' , False ) is True : shutter_list . append ( 'SkySelect' ) if args . get ( 'SSS_SoCalSci' , False ) is True : shutter_list . append ( 'SoCalSci' ) if args . get ( 'SSS_SoCalCal' , False ) is True : shutter_list . append ( 'SoCalCal' ) if args . get ( 'SSS_CalSciSky' , False ) is True : shutter_list . append ( 'Cal_SciSky' ) shutters_string = ',' . join ( shutter_list ) log . debug ( f \"Setting source select shutters to ' { shutters_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'SRC_SHUTTERS' ] . write ( shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( timeshim ) shutters = kpfexpose [ 'SRC_SHUTTERS' ] . read () shutter_list = shutters . split ( ',' ) shutter_names = [( 'SciSelect' , 'SSS_Science' ), ( 'SkySelect' , 'SSS_Sky' ), ( 'SoCalSci' , 'SSS_SoCalSci' ), ( 'SoCalCal' , 'SSS_SoCalCal' ), ( 'Cal_SciSky' , 'SSS_CalSciSky' )] for shutter in shutter_names : shutter_status = shutter [ 0 ] in shutter_list shutter_target = args . get ( shutter [ 1 ], False ) if shutter_target != shutter_status : raise FailedToReachDestination ( shutter_status , shutter_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , dest = \"SSS_Science\" , default = False , action = \"store_true\" , help = \"Open the SciSelect shutter?\" ) parser . add_argument ( \"--Sky\" , \"--sky\" , dest = \"SSS_Sky\" , default = False , action = \"store_true\" , help = \"Open the SkySelect shutter?\" ) parser . add_argument ( \"--CalSciSky\" , dest = \"SSS_CalSciSky\" , default = False , action = \"store_true\" , help = \"Open the Cal_SciSky shutter?\" ) parser . add_argument ( \"--SoCalSci\" , dest = \"SSS_SoCalSci\" , default = False , action = \"store_true\" , help = \"Open the SoCalSci shutter?\" ) parser . add_argument ( \"--SoCalCal\" , dest = \"SSS_SoCalCal\" , default = False , action = \"store_true\" , help = \"Open the SoCalCal shutter?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTargetInfo/","text":"SetTargetInfo Bases: KPFTranslatorFunction Set the target info keywords based on the target information in the OB. ARGS OB : ( dict ) A fully specified observing block (OB) or at least the target components of an OB. Source code in kpf/utils/SetTargetInfo.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetTargetInfo ( KPFTranslatorFunction ): '''Set the target info keywords based on the target information in the OB. ### ARGS **OB**: (`dict`) A fully specified observing block (OB) or at least the target components of an OB. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( f \"Setting target parameters\" ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) dcs = ktl . cache ( 'dcs1' ) kpfconfig [ 'TARGET_NAME' ] . write ( OB . get ( 'TargetName' , '' )) kpfconfig [ 'TARGET_GAIA' ] . write ( OB . get ( 'GaiaID' , '' )) kpfconfig [ 'TARGET_2MASS' ] . write ( OB . get ( '2MASSID' , '' )) kpfconfig [ 'TARGET_GMAG' ] . write ( OB . get ( 'Gmag' , '' )) kpfconfig [ 'TARGET_JMAG' ] . write ( OB . get ( 'Jmag' , '' )) TARGET_TEFF = OB . get ( 'Teff' , 45000 ) try : kpf_expmeter [ 'TARGET_TEFF' ] . write ( float ( TARGET_TEFF )) except : log . warning ( f \"Unable to set kpf_expmeter.TARGET_TEFF to { TARGET_TEFF } ( { type ( TARGET_TEFF ) } )\" ) TARGPLAX = OB . get ( 'Parallax' , 0 ) try : dcs [ 'TARGPLAX' ] . write ( float ( TARGPLAX )) except : log . warning ( f \"Unable to set dcs.TARGPLAX to { TARGPLAX } ( { type ( TARGPLAX ) } )\" ) TARGRADV = OB . get ( 'RadialVelocity' , 0 ) try : dcs [ 'TARGRADV' ] . write ( float ( TARGRADV )) except : log . warning ( f \"Unable to set dcs.TARGRADV to { TARGRADV } ( { type ( TARGRADV ) } )\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"SetTargetInfo"},{"location":"scripts/SetTargetInfo/#settargetinfo","text":"Bases: KPFTranslatorFunction Set the target info keywords based on the target information in the OB.","title":"SetTargetInfo"},{"location":"scripts/SetTargetInfo/#kpf.utils.SetTargetInfo.SetTargetInfo--args","text":"OB : ( dict ) A fully specified observing block (OB) or at least the target components of an OB. Source code in kpf/utils/SetTargetInfo.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetTargetInfo ( KPFTranslatorFunction ): '''Set the target info keywords based on the target information in the OB. ### ARGS **OB**: (`dict`) A fully specified observing block (OB) or at least the target components of an OB. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , OB , logger , cfg ): log . info ( f \"Setting target parameters\" ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) dcs = ktl . cache ( 'dcs1' ) kpfconfig [ 'TARGET_NAME' ] . write ( OB . get ( 'TargetName' , '' )) kpfconfig [ 'TARGET_GAIA' ] . write ( OB . get ( 'GaiaID' , '' )) kpfconfig [ 'TARGET_2MASS' ] . write ( OB . get ( '2MASSID' , '' )) kpfconfig [ 'TARGET_GMAG' ] . write ( OB . get ( 'Gmag' , '' )) kpfconfig [ 'TARGET_JMAG' ] . write ( OB . get ( 'Jmag' , '' )) TARGET_TEFF = OB . get ( 'Teff' , 45000 ) try : kpf_expmeter [ 'TARGET_TEFF' ] . write ( float ( TARGET_TEFF )) except : log . warning ( f \"Unable to set kpf_expmeter.TARGET_TEFF to { TARGET_TEFF } ( { type ( TARGET_TEFF ) } )\" ) TARGPLAX = OB . get ( 'Parallax' , 0 ) try : dcs [ 'TARGPLAX' ] . write ( float ( TARGPLAX )) except : log . warning ( f \"Unable to set dcs.TARGPLAX to { TARGPLAX } ( { type ( TARGPLAX ) } )\" ) TARGRADV = OB . get ( 'RadialVelocity' , 0 ) try : dcs [ 'TARGRADV' ] . write ( float ( TARGRADV )) except : log . warning ( f \"Unable to set dcs.TARGRADV to { TARGRADV } ( { type ( TARGRADV ) } )\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS"},{"location":"scripts/SetTimedShutters/","text":"SetTimedShutters Bases: KPFTranslatorFunction Selects which timed shutters will be triggered by setting the kpfexpose.TIMED_SHUTTERS keyword value. ARGS: :TimedShutter_Scrambler: bool Open the TimedShutter_Scrambler shutter? (default=False) :TimedShutter_SimulCal: bool Open the TimedShutter_SimulCal shutter? (default=False) :TimedShutter_CaHK: bool Open the TimedShutter_CaHK shutter? (default=False) :TimedShutter_FlatField: bool Open the TimedShutter_FlatField shutter? (default=False) Source code in kpf/spectrograph/SetTimedShutters.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class SetTimedShutters ( KPFTranslatorFunction ): '''Selects which timed shutters will be triggered by setting the `kpfexpose.TIMED_SHUTTERS` keyword value. ARGS: ===== :TimedShutter_Scrambler: `bool` Open the TimedShutter_Scrambler shutter? (default=False) :TimedShutter_SimulCal: `bool` Open the TimedShutter_SimulCal shutter? (default=False) :TimedShutter_CaHK: `bool` Open the TimedShutter_CaHK shutter? (default=False) :TimedShutter_FlatField: `bool` Open the TimedShutter_FlatField shutter? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Scrambler 2 SimulCal 3 FF_Fiber 4 Ca_HK timed_shutters_list = [] if args . get ( 'TimedShutter_Scrambler' , False ) is True : timed_shutters_list . append ( 'Scrambler' ) if args . get ( 'TimedShutter_SimulCal' , False ) is True : timed_shutters_list . append ( 'SimulCal' ) if args . get ( 'TimedShutter_FlatField' , False ) is True : timed_shutters_list . append ( 'FF_Fiber' ) if args . get ( 'TimedShutter_CaHK' , False ) is True : timed_shutters_list . append ( 'Ca_HK' ) timed_shutters_string = ',' . join ( timed_shutters_list ) log . debug ( f \"Setting timed shutters to ' { timed_shutters_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'TIMED_TARG' ] . write ( timed_shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( timeshim ) shutters = kpfexpose [ 'TIMED_TARG' ] . read () log . debug ( f \"TIMED_TARG: { shutters } \" ) shutter_list = shutters . split ( ',' ) shutter_names = [( 'Scrambler' , 'TimedShutter_Scrambler' ), ( 'SimulCal' , 'TimedShutter_SimulCal' ), ( 'FF_Fiber' , 'TimedShutter_FlatField' ), ( 'Ca_HK' , 'TimedShutter_CaHK' )] for shutter in shutter_names : shutter_status = shutter [ 0 ] in shutter_list shutter_target = args . get ( shutter [ 1 ], False ) if shutter_target != shutter_status : raise FailedToReachDestination ( shutter_status , shutter_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Scrambler\" , \"--scrambler\" , dest = \"TimedShutter_Scrambler\" , default = False , action = \"store_true\" , help = \"Open the Scrambler Timed Shutter during exposure?\" ) parser . add_argument ( \"--SimulCal\" , \"--simulcal\" , dest = \"TimedShutter_SimulCal\" , default = False , action = \"store_true\" , help = \"Open the SimulCal Timed Shutter during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TimedShutter_CaHK\" , default = False , action = \"store_true\" , help = \"Open the CaHK Timed Shutter during exposure?\" ) parser . add_argument ( \"--FlatField\" , \"--flatfield\" , dest = \"TimedShutter_FlatField\" , default = False , action = \"store_true\" , help = \"Open the FlatField Timed Shutter during exposure?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTimedShutters"},{"location":"scripts/SetTimedShutters/#settimedshutters","text":"Bases: KPFTranslatorFunction Selects which timed shutters will be triggered by setting the kpfexpose.TIMED_SHUTTERS keyword value.","title":"SetTimedShutters"},{"location":"scripts/SetTimedShutters/#kpf.spectrograph.SetTimedShutters.SetTimedShutters--args","text":":TimedShutter_Scrambler: bool Open the TimedShutter_Scrambler shutter? (default=False) :TimedShutter_SimulCal: bool Open the TimedShutter_SimulCal shutter? (default=False) :TimedShutter_CaHK: bool Open the TimedShutter_CaHK shutter? (default=False) :TimedShutter_FlatField: bool Open the TimedShutter_FlatField shutter? (default=False) Source code in kpf/spectrograph/SetTimedShutters.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class SetTimedShutters ( KPFTranslatorFunction ): '''Selects which timed shutters will be triggered by setting the `kpfexpose.TIMED_SHUTTERS` keyword value. ARGS: ===== :TimedShutter_Scrambler: `bool` Open the TimedShutter_Scrambler shutter? (default=False) :TimedShutter_SimulCal: `bool` Open the TimedShutter_SimulCal shutter? (default=False) :TimedShutter_CaHK: `bool` Open the TimedShutter_CaHK shutter? (default=False) :TimedShutter_FlatField: `bool` Open the TimedShutter_FlatField shutter? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Scrambler 2 SimulCal 3 FF_Fiber 4 Ca_HK timed_shutters_list = [] if args . get ( 'TimedShutter_Scrambler' , False ) is True : timed_shutters_list . append ( 'Scrambler' ) if args . get ( 'TimedShutter_SimulCal' , False ) is True : timed_shutters_list . append ( 'SimulCal' ) if args . get ( 'TimedShutter_FlatField' , False ) is True : timed_shutters_list . append ( 'FF_Fiber' ) if args . get ( 'TimedShutter_CaHK' , False ) is True : timed_shutters_list . append ( 'Ca_HK' ) timed_shutters_string = ',' . join ( timed_shutters_list ) log . debug ( f \"Setting timed shutters to ' { timed_shutters_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'TIMED_TARG' ] . write ( timed_shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( timeshim ) shutters = kpfexpose [ 'TIMED_TARG' ] . read () log . debug ( f \"TIMED_TARG: { shutters } \" ) shutter_list = shutters . split ( ',' ) shutter_names = [( 'Scrambler' , 'TimedShutter_Scrambler' ), ( 'SimulCal' , 'TimedShutter_SimulCal' ), ( 'FF_Fiber' , 'TimedShutter_FlatField' ), ( 'Ca_HK' , 'TimedShutter_CaHK' )] for shutter in shutter_names : shutter_status = shutter [ 0 ] in shutter_list shutter_target = args . get ( shutter [ 1 ], False ) if shutter_target != shutter_status : raise FailedToReachDestination ( shutter_status , shutter_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Scrambler\" , \"--scrambler\" , dest = \"TimedShutter_Scrambler\" , default = False , action = \"store_true\" , help = \"Open the Scrambler Timed Shutter during exposure?\" ) parser . add_argument ( \"--SimulCal\" , \"--simulcal\" , dest = \"TimedShutter_SimulCal\" , default = False , action = \"store_true\" , help = \"Open the SimulCal Timed Shutter during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TimedShutter_CaHK\" , default = False , action = \"store_true\" , help = \"Open the CaHK Timed Shutter during exposure?\" ) parser . add_argument ( \"--FlatField\" , \"--flatfield\" , dest = \"TimedShutter_FlatField\" , default = False , action = \"store_true\" , help = \"Open the FlatField Timed Shutter during exposure?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTipTiltCalculations/","text":"SetTipTiltCalculations Bases: KPFTranslatorFunction Turn the tip tilt calculation software on or off. ARGS: :calculations: The desired state of the calculations (Active or Inactive) Source code in kpf/fiu/SetTipTiltCalculations.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltCalculations ( KPFTranslatorFunction ): '''Turn the tip tilt calculation software on or off. ARGS: ===== :calculations: The desired state of the calculations (Active or Inactive) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'calculations' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): calculations = args . get ( 'calculations' ) tiptiltcalc = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) tiptiltcalc . write ( calculations ) @classmethod def post_condition ( cls , args , logger , cfg ): calculations = args . get ( 'calculations' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CALC == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptilt = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) raise FailedToReachDestination ( tiptilt . read (), calculations ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'calculations' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Calulations \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTipTiltCalculations"},{"location":"scripts/SetTipTiltCalculations/#settiptiltcalculations","text":"Bases: KPFTranslatorFunction Turn the tip tilt calculation software on or off.","title":"SetTipTiltCalculations"},{"location":"scripts/SetTipTiltCalculations/#kpf.fiu.SetTipTiltCalculations.SetTipTiltCalculations--args","text":":calculations: The desired state of the calculations (Active or Inactive) Source code in kpf/fiu/SetTipTiltCalculations.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltCalculations ( KPFTranslatorFunction ): '''Turn the tip tilt calculation software on or off. ARGS: ===== :calculations: The desired state of the calculations (Active or Inactive) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'calculations' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): calculations = args . get ( 'calculations' ) tiptiltcalc = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) tiptiltcalc . write ( calculations ) @classmethod def post_condition ( cls , args , logger , cfg ): calculations = args . get ( 'calculations' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CALC == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptilt = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) raise FailedToReachDestination ( tiptilt . read (), calculations ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'calculations' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Calulations \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTipTiltControl/","text":"SetTipTiltControl Bases: KPFTranslatorFunction Turn the tip tilt control software on or off. ARGS: :control: The desired state of the calculations (Active or Inactive) Source code in kpf/fiu/SetTipTiltControl.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltControl ( KPFTranslatorFunction ): '''Turn the tip tilt control software on or off. ARGS: ===== :control: The desired state of the calculations (Active or Inactive) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'control' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): control = args . get ( 'control' ) tiptiltcontrol = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) tiptiltcontrol . write ( control ) @classmethod def post_condition ( cls , args , logger , cfg ): control = args . get ( 'control' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CONTROL == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptiltcontrol = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) raise FailedToReachDestination ( tiptiltcontrol . read (), control ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'control' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Control \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTipTiltControl"},{"location":"scripts/SetTipTiltControl/#settiptiltcontrol","text":"Bases: KPFTranslatorFunction Turn the tip tilt control software on or off.","title":"SetTipTiltControl"},{"location":"scripts/SetTipTiltControl/#kpf.fiu.SetTipTiltControl.SetTipTiltControl--args","text":":control: The desired state of the calculations (Active or Inactive) Source code in kpf/fiu/SetTipTiltControl.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltControl ( KPFTranslatorFunction ): '''Turn the tip tilt control software on or off. ARGS: ===== :control: The desired state of the calculations (Active or Inactive) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'control' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): control = args . get ( 'control' ) tiptiltcontrol = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) tiptiltcontrol . write ( control ) @classmethod def post_condition ( cls , args , logger , cfg ): control = args . get ( 'control' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CONTROL == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptiltcontrol = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) raise FailedToReachDestination ( tiptiltcontrol . read (), control ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'control' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Control \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTipTiltGain/","text":"SetTipTiltGain Bases: KPFTranslatorFunction Set the CRED2 camera gain ARGS: :GuideLoopGain: The desired gain value Source code in kpf/fiu/SetTipTiltGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltGain ( KPFTranslatorFunction ): '''Set the CRED2 camera gain ARGS: ===== :GuideLoopGain: The desired gain value ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideLoopGain' , value_min = 0 , value_max = 1 ) @classmethod def perform ( cls , args , logger , cfg ): gain = float ( args . get ( 'GuideLoopGain' )) tiptiltgain = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) tiptiltgain . write ( gain ) @classmethod def post_condition ( cls , args , logger , cfg ): gain = float ( args . get ( 'GuideLoopGain' )) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_gain_tolerance' , fallback = 0.001 ) expr = ( f \"($kpfguide.TIPTILT_GAIN >= { gain - tol } ) and \" f \"($kpfguide.TIPTILT_GAIN <= { gain + tol } )\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptiltgain = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) raise FailedToReachDestination ( tiptiltgain . read (), gain ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideLoopGain' , type = float , help = \"Tip tilt control loop gain\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTipTiltGain"},{"location":"scripts/SetTipTiltGain/#settiptiltgain","text":"Bases: KPFTranslatorFunction Set the CRED2 camera gain","title":"SetTipTiltGain"},{"location":"scripts/SetTipTiltGain/#kpf.fiu.SetTipTiltGain.SetTipTiltGain--args","text":":GuideLoopGain: The desired gain value Source code in kpf/fiu/SetTipTiltGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetTipTiltGain ( KPFTranslatorFunction ): '''Set the CRED2 camera gain ARGS: ===== :GuideLoopGain: The desired gain value ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'GuideLoopGain' , value_min = 0 , value_max = 1 ) @classmethod def perform ( cls , args , logger , cfg ): gain = float ( args . get ( 'GuideLoopGain' )) tiptiltgain = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) tiptiltgain . write ( gain ) @classmethod def post_condition ( cls , args , logger , cfg ): gain = float ( args . get ( 'GuideLoopGain' )) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_gain_tolerance' , fallback = 0.001 ) expr = ( f \"($kpfguide.TIPTILT_GAIN >= { gain - tol } ) and \" f \"($kpfguide.TIPTILT_GAIN <= { gain + tol } )\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : tiptiltgain = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) raise FailedToReachDestination ( tiptiltgain . read (), gain ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'GuideLoopGain' , type = float , help = \"Tip tilt control loop gain\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTipTiltPosition/","text":"SetTipTiltPosition Bases: KPFTranslatorFunction Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the :py:func: SetTipTiltTargetPixel translator module function. ARGS: :x: The desired X position (TTXVAX). :y: The desired Y position (TTYVAX). Source code in kpf/fiu/SetTipTiltPosition.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class SetTipTiltPosition ( KPFTranslatorFunction ): '''Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the :py:func:`SetTipTiltTargetPixel` translator module function. ARGS: ===== :x: The desired X position (TTXVAX). :y: The desired Y position (TTYVAX). ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'x' ) check_input ( args , 'y' ) @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'TTXVAX' ] . write ( args . get ( 'x' )) kpffiu [ 'TTYVAX' ] . write ( args . get ( 'y' )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) xdest = args . get ( 'x' ) ydest = args . get ( 'y' ) expr = ( f '($kpffiu.TTXVAX > { xdest - tol } ) and ' \\ f '($kpffiu.TTXVAX < { xdest + tol } )' ) successx = ktl . waitFor ( expr , timeout = timeout ) if successx is not True : raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), xdest ) expr = ( f '($kpffiu.TTYVAX > { ydest - tol } ) and ' \\ f '($kpffiu.TTYVAX < { ydest + tol } )' ) successy = ktl . waitFor ( expr , timeout = timeout ) if successy is not True : raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), ydest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'x' , type = float , help = \"X position of the tip tilt mirror (TTXVAX)\" ) parser . add_argument ( 'y' , type = float , help = \"X position of the tip tilt mirror (TTYVAX)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTipTiltPosition"},{"location":"scripts/SetTipTiltPosition/#settiptiltposition","text":"Bases: KPFTranslatorFunction Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the :py:func: SetTipTiltTargetPixel translator module function.","title":"SetTipTiltPosition"},{"location":"scripts/SetTipTiltPosition/#kpf.fiu.SetTipTiltPosition.SetTipTiltPosition--args","text":":x: The desired X position (TTXVAX). :y: The desired Y position (TTYVAX). Source code in kpf/fiu/SetTipTiltPosition.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class SetTipTiltPosition ( KPFTranslatorFunction ): '''Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the :py:func:`SetTipTiltTargetPixel` translator module function. ARGS: ===== :x: The desired X position (TTXVAX). :y: The desired Y position (TTYVAX). ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'x' ) check_input ( args , 'y' ) @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'TTXVAX' ] . write ( args . get ( 'x' )) kpffiu [ 'TTYVAX' ] . write ( args . get ( 'y' )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) xdest = args . get ( 'x' ) ydest = args . get ( 'y' ) expr = ( f '($kpffiu.TTXVAX > { xdest - tol } ) and ' \\ f '($kpffiu.TTXVAX < { xdest + tol } )' ) successx = ktl . waitFor ( expr , timeout = timeout ) if successx is not True : raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), xdest ) expr = ( f '($kpffiu.TTYVAX > { ydest - tol } ) and ' \\ f '($kpffiu.TTYVAX < { ydest + tol } )' ) successy = ktl . waitFor ( expr , timeout = timeout ) if successy is not True : raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), ydest ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'x' , type = float , help = \"X position of the tip tilt mirror (TTXVAX)\" ) parser . add_argument ( 'y' , type = float , help = \"X position of the tip tilt mirror (TTYVAX)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTipTiltTargetPixel/","text":"SetTipTiltTargetPixel Bases: KPFTranslatorFunction Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. ARGS: :x: The desired X target pixel :y: The desired Y target pixel Source code in kpf/fiu/SetTipTiltTargetPixel.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetTipTiltTargetPixel ( KPFTranslatorFunction ): '''Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. ARGS: ===== :x: The desired X target pixel :y: The desired Y target pixel ''' @classmethod def pre_condition ( cls , args , logger , cfg ): min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) check_input ( args , 'x' , value_min = min_x_pixel , value_max = max_x_pixel ) check_input ( args , 'y' , value_min = min_y_pixel , value_max = max_y_pixel ) @classmethod def perform ( cls , args , logger , cfg ): x = args . get ( 'x' ) y = args . get ( 'y' ) pixtarget = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) pixtarget . write (( x , y )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.01 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'x' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) parser . add_argument ( 'y' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTipTiltTargetPixel"},{"location":"scripts/SetTipTiltTargetPixel/#settiptilttargetpixel","text":"Bases: KPFTranslatorFunction Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword.","title":"SetTipTiltTargetPixel"},{"location":"scripts/SetTipTiltTargetPixel/#kpf.fiu.SetTipTiltTargetPixel.SetTipTiltTargetPixel--args","text":":x: The desired X target pixel :y: The desired Y target pixel Source code in kpf/fiu/SetTipTiltTargetPixel.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetTipTiltTargetPixel ( KPFTranslatorFunction ): '''Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. ARGS: ===== :x: The desired X target pixel :y: The desired Y target pixel ''' @classmethod def pre_condition ( cls , args , logger , cfg ): min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) check_input ( args , 'x' , value_min = min_x_pixel , value_max = max_x_pixel ) check_input ( args , 'y' , value_min = min_y_pixel , value_max = max_y_pixel ) @classmethod def perform ( cls , args , logger , cfg ): x = args . get ( 'x' ) y = args . get ( 'y' ) pixtarget = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) pixtarget . write (( x , y )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.01 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'x' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) parser . add_argument ( 'y' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetTriggeredDetectors/","text":"SetTriggeredDetectors Bases: KPFTranslatorFunction Selects which cameras will be triggered by setting the kpfexpose.TRIG_TARG keyword value. ARGS: :TriggerRed: bool Trigger the Red detector? (default=False) :TriggerGreen: bool Trigger the Green detector? (default=False) :TriggerCaHK: bool Trigger the CaH&K detector? (default=False) :TriggerExpMeter: bool Trigger the ExpMeter detector? (default=False) Source code in kpf/spectrograph/SetTriggeredDetectors.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class SetTriggeredDetectors ( KPFTranslatorFunction ): '''Selects which cameras will be triggered by setting the `kpfexpose.TRIG_TARG` keyword value. ARGS: ===== :TriggerRed: `bool` Trigger the Red detector? (default=False) :TriggerGreen: `bool` Trigger the Green detector? (default=False) :TriggerCaHK: `bool` Trigger the CaH&K detector? (default=False) :TriggerExpMeter: `bool` Trigger the ExpMeter detector? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfconfig = ktl . cache ( 'kpfconfig' ) detector_list = [] if args . get ( 'TriggerRed' , False ) is True : if kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Red detector is not enabled' ) else : detector_list . append ( 'Red' ) if args . get ( 'TriggerGreen' , False ) is True : if kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Green detector is not enabled' ) else : detector_list . append ( 'Green' ) if args . get ( 'TriggerCaHK' , False ) is True : if kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Ca HK detector is not enabled' ) else : detector_list . append ( 'Ca_HK' ) if args . get ( 'TriggerExpMeter' , False ) is True : if kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'ExpMeter detector is not enabled' ) else : detector_list . append ( 'ExpMeter' ) if args . get ( 'TriggerGuide' , False ) is True : detector_list . append ( 'Guide' ) detectors_string = ',' . join ( detector_list ) log . debug ( f \"Setting triggered detectors to ' { detectors_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'TRIG_TARG' ] . write ( detectors_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfconfig = ktl . cache ( 'kpfconfig' ) kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( timeshim ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) detector_names = [( 'Red' , 'TriggerRed' ), ( 'Green' , 'TriggerGreen' ), ( 'Ca_HK' , 'TriggerCaHK' ), ( 'ExpMeter' , 'TriggerExpMeter' ), # ('Guide', 'TriggerGuide'), ] # Don't check on guide because there is no enabled keyword for it for detector in detector_names : detector_status = detector [ 0 ] in detector_list enabled = kpfconfig [ f ' { detector [ 0 ] . upper () } _ENABLED' ] . read ( binary = True ) detector_target = args . get ( detector [ 1 ], False ) and enabled if detector_target != detector_status : raise FailedToReachDestination ( detector_status , detector_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Red\" , \"--red\" , \"-r\" , dest = \"TriggerRed\" , default = False , action = \"store_true\" , help = \"Trigger the Red detector during exposure?\" ) parser . add_argument ( \"--Green\" , \"--green\" , \"-g\" , dest = \"TriggerGreen\" , default = False , action = \"store_true\" , help = \"Trigger the Green detector during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TriggerCaHK\" , default = False , action = \"store_true\" , help = \"Trigger the CaHK detector during exposure?\" ) parser . add_argument ( \"--ExpMeter\" , \"--expmeter\" , \"--EM\" , \"--em\" , dest = \"TriggerExpMeter\" , default = False , action = \"store_true\" , help = \"Trigger the ExpMeter detector during exposure?\" ) parser . add_argument ( \"--Guide\" , \"--Guider\" , \"--guide\" , \"--guider\" , \"--CRED2\" , dest = \"TriggerGuide\" , default = False , action = \"store_true\" , help = \"Trigger the Guider detector during exposure?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"SetTriggeredDetectors"},{"location":"scripts/SetTriggeredDetectors/#settriggereddetectors","text":"Bases: KPFTranslatorFunction Selects which cameras will be triggered by setting the kpfexpose.TRIG_TARG keyword value.","title":"SetTriggeredDetectors"},{"location":"scripts/SetTriggeredDetectors/#kpf.spectrograph.SetTriggeredDetectors.SetTriggeredDetectors--args","text":":TriggerRed: bool Trigger the Red detector? (default=False) :TriggerGreen: bool Trigger the Green detector? (default=False) :TriggerCaHK: bool Trigger the CaH&K detector? (default=False) :TriggerExpMeter: bool Trigger the ExpMeter detector? (default=False) Source code in kpf/spectrograph/SetTriggeredDetectors.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class SetTriggeredDetectors ( KPFTranslatorFunction ): '''Selects which cameras will be triggered by setting the `kpfexpose.TRIG_TARG` keyword value. ARGS: ===== :TriggerRed: `bool` Trigger the Red detector? (default=False) :TriggerGreen: `bool` Trigger the Green detector? (default=False) :TriggerCaHK: `bool` Trigger the CaH&K detector? (default=False) :TriggerExpMeter: `bool` Trigger the ExpMeter detector? (default=False) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfconfig = ktl . cache ( 'kpfconfig' ) detector_list = [] if args . get ( 'TriggerRed' , False ) is True : if kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Red detector is not enabled' ) else : detector_list . append ( 'Red' ) if args . get ( 'TriggerGreen' , False ) is True : if kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Green detector is not enabled' ) else : detector_list . append ( 'Green' ) if args . get ( 'TriggerCaHK' , False ) is True : if kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Ca HK detector is not enabled' ) else : detector_list . append ( 'Ca_HK' ) if args . get ( 'TriggerExpMeter' , False ) is True : if kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'ExpMeter detector is not enabled' ) else : detector_list . append ( 'ExpMeter' ) if args . get ( 'TriggerGuide' , False ) is True : detector_list . append ( 'Guide' ) detectors_string = ',' . join ( detector_list ) log . debug ( f \"Setting triggered detectors to ' { detectors_string } '\" ) kpfexpose = ktl . cache ( 'kpfexpose' ) kpfexpose [ 'TRIG_TARG' ] . write ( detectors_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args , logger , cfg ): kpfconfig = ktl . cache ( 'kpfconfig' ) kpfexpose = ktl . cache ( 'kpfexpose' ) timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.1 ) sleep ( timeshim ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) detector_names = [( 'Red' , 'TriggerRed' ), ( 'Green' , 'TriggerGreen' ), ( 'Ca_HK' , 'TriggerCaHK' ), ( 'ExpMeter' , 'TriggerExpMeter' ), # ('Guide', 'TriggerGuide'), ] # Don't check on guide because there is no enabled keyword for it for detector in detector_names : detector_status = detector [ 0 ] in detector_list enabled = kpfconfig [ f ' { detector [ 0 ] . upper () } _ENABLED' ] . read ( binary = True ) detector_target = args . get ( detector [ 1 ], False ) and enabled if detector_target != detector_status : raise FailedToReachDestination ( detector_status , detector_target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Red\" , \"--red\" , \"-r\" , dest = \"TriggerRed\" , default = False , action = \"store_true\" , help = \"Trigger the Red detector during exposure?\" ) parser . add_argument ( \"--Green\" , \"--green\" , \"-g\" , dest = \"TriggerGreen\" , default = False , action = \"store_true\" , help = \"Trigger the Green detector during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TriggerCaHK\" , default = False , action = \"store_true\" , help = \"Trigger the CaHK detector during exposure?\" ) parser . add_argument ( \"--ExpMeter\" , \"--expmeter\" , \"--EM\" , \"--em\" , dest = \"TriggerExpMeter\" , default = False , action = \"store_true\" , help = \"Trigger the ExpMeter detector during exposure?\" ) parser . add_argument ( \"--Guide\" , \"--Guider\" , \"--guide\" , \"--guider\" , \"--CRED2\" , dest = \"TriggerGuide\" , default = False , action = \"store_true\" , help = \"Trigger the Guider detector during exposure?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/SetupAOforACAM/","text":"SetupAOforACAM Bases: KPFTranslatorFunction Description Set up AO in the safe mode for ACAM operation to assist KPF acquisition Set AFM to Mirror Set AFS to ngs KTL Keywords Used None Scripts Called kpf.ao.SetAFMtoMirror kpf.ao.SetAFStoNGS Parameters None Source code in kpf/ao/SetupAOforACAM.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetupAOforACAM ( KPFTranslatorFunction ): '''# Description Set up AO in the safe mode for ACAM operation to assist KPF acquisition - Set AFM to Mirror - Set AFS to ngs ## KTL Keywords Used None ## Scripts Called - `kpf.ao.SetAFMtoMirror` - `kpf.ao.SetAFStoNGS` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Set AFM to Mirror' ) SetAFMtoMirror . execute ({}) log . info ( 'Set AFS to NGS' ) SetAFStoNGS . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"SetupAOforACAM"},{"location":"scripts/SetupAOforACAM/#setupaoforacam","text":"Bases: KPFTranslatorFunction","title":"SetupAOforACAM"},{"location":"scripts/SetupAOforACAM/#kpf.ao.SetupAOforACAM.SetupAOforACAM--description","text":"Set up AO in the safe mode for ACAM operation to assist KPF acquisition Set AFM to Mirror Set AFS to ngs","title":"Description"},{"location":"scripts/SetupAOforACAM/#kpf.ao.SetupAOforACAM.SetupAOforACAM--ktl-keywords-used","text":"None","title":"KTL Keywords Used"},{"location":"scripts/SetupAOforACAM/#kpf.ao.SetupAOforACAM.SetupAOforACAM--scripts-called","text":"kpf.ao.SetAFMtoMirror kpf.ao.SetAFStoNGS","title":"Scripts Called"},{"location":"scripts/SetupAOforACAM/#kpf.ao.SetupAOforACAM.SetupAOforACAM--parameters","text":"None Source code in kpf/ao/SetupAOforACAM.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetupAOforACAM ( KPFTranslatorFunction ): '''# Description Set up AO in the safe mode for ACAM operation to assist KPF acquisition - Set AFM to Mirror - Set AFS to ngs ## KTL Keywords Used None ## Scripts Called - `kpf.ao.SetAFMtoMirror` - `kpf.ao.SetAFStoNGS` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Set AFM to Mirror' ) SetAFMtoMirror . execute ({}) log . info ( 'Set AFS to NGS' ) SetAFStoNGS . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/SetupAOforKPF/","text":"SetupAOforKPF Bases: KPFTranslatorFunction Description Set up AO in the safe mode for KPF operation Set AO roator in Manual mode Set AO rotator to 0 deg Turn off HEPA Set AO in DCS sim mode Home PCU Move PCU to the KPF position Open AO hatch KTL Keywords Used ao.PCSFNAME Scripts Called kpf.ao.SetAORotatorManual kpf.ao.SetAORotator kpf.ao.TurnHepaOff kpf.ao.SetAODCStoSIM kpf.ao.TurnLightSourceOff kpf.ao.SendPCUtoHome kpf.ao.SendPCUtoKPF Parameters None Source code in kpf/ao/SetupAOforKPF.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class SetupAOforKPF ( KPFTranslatorFunction ): '''# Description Set up AO in the safe mode for KPF operation - Set AO roator in Manual mode - Set AO rotator to 0 deg - Turn off HEPA - Set AO in DCS sim mode - Home PCU - Move PCU to the KPF position - Open AO hatch ## KTL Keywords Used - `ao.PCSFNAME` ## Scripts Called - `kpf.ao.SetAORotatorManual` - `kpf.ao.SetAORotator` - `kpf.ao.TurnHepaOff` - `kpf.ao.SetAODCStoSIM` - `kpf.ao.TurnLightSourceOff` - `kpf.ao.SendPCUtoHome` - `kpf.ao.SendPCUtoKPF` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Set AO rotator to Manual' ) SetAORotatorManual . execute ({}) log . info ( 'Set AO rotator to 0 deg' ) SetAORotator . execute ({ 'dest' : 0 }) log . info ( 'Turn off HEPA' ) TurnHepaOff . execute ({}) log . info ( 'Set AO in DCS sim mode' ) SetAODCStoSIM . execute ({}) log . info ( 'Turn K1 AO light source off' ) TurnLightSourceOff . execute ({}) PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSstagekw . read () != 'kpf' : log . info ( 'Move PCU to Home' ) SendPCUtoHome . execute ({}) log . info ( 'Move PCU to KPF' ) SendPCUtoKPF . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"SetupAOforKPF"},{"location":"scripts/SetupAOforKPF/#setupaoforkpf","text":"Bases: KPFTranslatorFunction","title":"SetupAOforKPF"},{"location":"scripts/SetupAOforKPF/#kpf.ao.SetupAOforKPF.SetupAOforKPF--description","text":"Set up AO in the safe mode for KPF operation Set AO roator in Manual mode Set AO rotator to 0 deg Turn off HEPA Set AO in DCS sim mode Home PCU Move PCU to the KPF position Open AO hatch","title":"Description"},{"location":"scripts/SetupAOforKPF/#kpf.ao.SetupAOforKPF.SetupAOforKPF--ktl-keywords-used","text":"ao.PCSFNAME","title":"KTL Keywords Used"},{"location":"scripts/SetupAOforKPF/#kpf.ao.SetupAOforKPF.SetupAOforKPF--scripts-called","text":"kpf.ao.SetAORotatorManual kpf.ao.SetAORotator kpf.ao.TurnHepaOff kpf.ao.SetAODCStoSIM kpf.ao.TurnLightSourceOff kpf.ao.SendPCUtoHome kpf.ao.SendPCUtoKPF","title":"Scripts Called"},{"location":"scripts/SetupAOforKPF/#kpf.ao.SetupAOforKPF.SetupAOforKPF--parameters","text":"None Source code in kpf/ao/SetupAOforKPF.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class SetupAOforKPF ( KPFTranslatorFunction ): '''# Description Set up AO in the safe mode for KPF operation - Set AO roator in Manual mode - Set AO rotator to 0 deg - Turn off HEPA - Set AO in DCS sim mode - Home PCU - Move PCU to the KPF position - Open AO hatch ## KTL Keywords Used - `ao.PCSFNAME` ## Scripts Called - `kpf.ao.SetAORotatorManual` - `kpf.ao.SetAORotator` - `kpf.ao.TurnHepaOff` - `kpf.ao.SetAODCStoSIM` - `kpf.ao.TurnLightSourceOff` - `kpf.ao.SendPCUtoHome` - `kpf.ao.SendPCUtoKPF` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . info ( 'Set AO rotator to Manual' ) SetAORotatorManual . execute ({}) log . info ( 'Set AO rotator to 0 deg' ) SetAORotator . execute ({ 'dest' : 0 }) log . info ( 'Turn off HEPA' ) TurnHepaOff . execute ({}) log . info ( 'Set AO in DCS sim mode' ) SetAODCStoSIM . execute ({}) log . info ( 'Turn K1 AO light source off' ) TurnLightSourceOff . execute ({}) PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSstagekw . read () != 'kpf' : log . info ( 'Move PCU to Home' ) SendPCUtoHome . execute ({}) log . info ( 'Move PCU to KPF' ) SendPCUtoKPF . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/SetupExpMeter/","text":"SetupExpMeter Bases: KPFTranslatorFunction Description Configure the exposure meter using the given OB arguments. KTL Keywords Used kpf_expmeter.USETHRESHOLD kpfconfig.EXPMETER_ENABLED Scripts Called kpf.expmeter.SetExpMeterTerminationParameters Parameters ExpMeterMode ( str ) See Science OB definition TriggerExpMeter ( bool ) See Science OB definition Source code in kpf/expmeter/SetupExpMeter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class SetupExpMeter ( KPFTranslatorFunction ): '''# Description Configure the exposure meter using the given OB arguments. ## KTL Keywords Used - `kpf_expmeter.USETHRESHOLD` - `kpfconfig.EXPMETER_ENABLED` ## Scripts Called - `kpf.expmeter.SetExpMeterTerminationParameters` ## Parameters **ExpMeterMode** (`str`) > See Science OB definition **TriggerExpMeter** (`bool`) > See Science OB definition ''' abortable = False @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Template_Name' , allowed_values = [ 'kpf_lamp' , 'kpf_sci' ]) check_input ( args , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpfconfig = ktl . cache ( 'kpfconfig' ) ## ---------------------------------------------------------------- ## Configure exposure meter ## ---------------------------------------------------------------- log . debug ( 'Setting up exposure meter using SetupExpMeter' ) EM_mode = args . get ( 'ExpMeterMode' , 'off' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_mode == 'monitor' and EM_enabled : kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) args [ 'TriggerExpMeter' ] = True elif EM_mode == 'control' and EM_enabled : args [ 'TriggerExpMeter' ] = True try : SetExpMeterTerminationParameters . execute ( args ) except Exception as e : log . error ( 'SetExpMeterTerminationParameters failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) elif EM_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both args [ 'TriggerExpMeter' ] = False elif EM_enabled == False : log . warning ( 'ExpMeter is disabled' ) else : log . warning ( f \"ExpMeterMode { EM_mode } is not available\" ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Must return args as we have edited them return args @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser , cfg )","title":"SetupExpMeter"},{"location":"scripts/SetupExpMeter/#setupexpmeter","text":"Bases: KPFTranslatorFunction","title":"SetupExpMeter"},{"location":"scripts/SetupExpMeter/#kpf.expmeter.SetupExpMeter.SetupExpMeter--description","text":"Configure the exposure meter using the given OB arguments.","title":"Description"},{"location":"scripts/SetupExpMeter/#kpf.expmeter.SetupExpMeter.SetupExpMeter--ktl-keywords-used","text":"kpf_expmeter.USETHRESHOLD kpfconfig.EXPMETER_ENABLED","title":"KTL Keywords Used"},{"location":"scripts/SetupExpMeter/#kpf.expmeter.SetupExpMeter.SetupExpMeter--scripts-called","text":"kpf.expmeter.SetExpMeterTerminationParameters","title":"Scripts Called"},{"location":"scripts/SetupExpMeter/#kpf.expmeter.SetupExpMeter.SetupExpMeter--parameters","text":"ExpMeterMode ( str ) See Science OB definition TriggerExpMeter ( bool ) See Science OB definition Source code in kpf/expmeter/SetupExpMeter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class SetupExpMeter ( KPFTranslatorFunction ): '''# Description Configure the exposure meter using the given OB arguments. ## KTL Keywords Used - `kpf_expmeter.USETHRESHOLD` - `kpfconfig.EXPMETER_ENABLED` ## Scripts Called - `kpf.expmeter.SetExpMeterTerminationParameters` ## Parameters **ExpMeterMode** (`str`) > See Science OB definition **TriggerExpMeter** (`bool`) > See Science OB definition ''' abortable = False @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'Template_Name' , allowed_values = [ 'kpf_lamp' , 'kpf_sci' ]) check_input ( args , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , args , logger , cfg ): kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpfconfig = ktl . cache ( 'kpfconfig' ) ## ---------------------------------------------------------------- ## Configure exposure meter ## ---------------------------------------------------------------- log . debug ( 'Setting up exposure meter using SetupExpMeter' ) EM_mode = args . get ( 'ExpMeterMode' , 'off' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_mode == 'monitor' and EM_enabled : kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) args [ 'TriggerExpMeter' ] = True elif EM_mode == 'control' and EM_enabled : args [ 'TriggerExpMeter' ] = True try : SetExpMeterTerminationParameters . execute ( args ) except Exception as e : log . error ( 'SetExpMeterTerminationParameters failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) elif EM_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both args [ 'TriggerExpMeter' ] = False elif EM_enabled == False : log . warning ( 'ExpMeter is disabled' ) else : log . warning ( f \"ExpMeterMode { EM_mode } is not available\" ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'No' ) # Must return args as we have edited them return args @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/ShutdownTipTilt/","text":"ShutdownTipTilt Bases: KPFTranslatorFunction Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. ARGS: None Source code in kpf/fiu/ShutdownTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ShutdownTipTilt ( KPFTranslatorFunction ): '''Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpffiu = ktl . cache ( 'kpffiu' ) xopen = kpffiu [ 'TTXSRV' ] . read () == 'Open' yopen = kpffiu [ 'TTYSRV' ] . read () == 'Open' if xopen and yopen : # No actions needed return elif xopen == False and yopen == False : # Both axis are in closed loop mode # Shut down tip tilt activity and park mirror before opening loops kpfguide [ 'TIPTILT_CONTROL' ] . write ( 'Inactive' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Inactive' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) else : # We're in a mixed state, just open the loops log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) success1 = ktl . waitFor ( '($kpffiu.TTXSRV == open)' , timeout = timeout ) success2 = ktl . waitFor ( '($kpffiu.TTYSRV == open)' , timeout = timeout ) if success1 == False or success2 == False : raise FailedPostCondition ( f 'TT[X and/or Y]SRV did not open' )","title":"ShutdownTipTilt"},{"location":"scripts/ShutdownTipTilt/#shutdowntiptilt","text":"Bases: KPFTranslatorFunction Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0.","title":"ShutdownTipTilt"},{"location":"scripts/ShutdownTipTilt/#kpf.fiu.ShutdownTipTilt.ShutdownTipTilt--args","text":"None Source code in kpf/fiu/ShutdownTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class ShutdownTipTilt ( KPFTranslatorFunction ): '''Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpffiu = ktl . cache ( 'kpffiu' ) xopen = kpffiu [ 'TTXSRV' ] . read () == 'Open' yopen = kpffiu [ 'TTYSRV' ] . read () == 'Open' if xopen and yopen : # No actions needed return elif xopen == False and yopen == False : # Both axis are in closed loop mode # Shut down tip tilt activity and park mirror before opening loops kpfguide [ 'TIPTILT_CONTROL' ] . write ( 'Inactive' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Inactive' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) else : # We're in a mixed state, just open the loops log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) success1 = ktl . waitFor ( '($kpffiu.TTXSRV == open)' , timeout = timeout ) success2 = ktl . waitFor ( '($kpffiu.TTYSRV == open)' , timeout = timeout ) if success1 == False or success2 == False : raise FailedPostCondition ( f 'TT[X and/or Y]SRV did not open' )","title":"ARGS:"},{"location":"scripts/SoCalStartAutonomous/","text":"SoCalStartAutonomous Bases: KPFTranslatorFunction Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 ARGS: None Source code in kpf/socal/SoCalStartAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStartAutonomous ( KPFTranslatorFunction ): '''Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 1' ) AUTONOMOUS . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 1' )","title":"SoCalStartAutonomous"},{"location":"scripts/SoCalStartAutonomous/#socalstartautonomous","text":"Bases: KPFTranslatorFunction Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1","title":"SoCalStartAutonomous"},{"location":"scripts/SoCalStartAutonomous/#kpf.socal.SoCalStartAutonomous.SoCalStartAutonomous--args","text":"None Source code in kpf/socal/SoCalStartAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStartAutonomous ( KPFTranslatorFunction ): '''Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 1' ) AUTONOMOUS . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 1' )","title":"ARGS:"},{"location":"scripts/SoCalStopAutonomous/","text":"SoCalStopAutonomous Bases: KPFTranslatorFunction Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 ARGS: None Source code in kpf/socal/SoCalStopAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStopAutonomous ( KPFTranslatorFunction ): '''Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 0' ) AUTONOMOUS . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 0' )","title":"SoCalStopAutonomous"},{"location":"scripts/SoCalStopAutonomous/#socalstopautonomous","text":"Bases: KPFTranslatorFunction Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0","title":"SoCalStopAutonomous"},{"location":"scripts/SoCalStopAutonomous/#kpf.socal.SoCalStopAutonomous.SoCalStopAutonomous--args","text":"None Source code in kpf/socal/SoCalStopAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStopAutonomous ( KPFTranslatorFunction ): '''Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 0' ) AUTONOMOUS . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 0' )","title":"ARGS:"},{"location":"scripts/StartAgitator/","text":"StartAgitator Bases: KPFTranslatorFunction Start the agitator motion and wait the appropriate startup time before returning. ARGS: None Source code in kpf/spectrograph/StartAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class StartAgitator ( KPFTranslatorFunction ): '''Start the agitator motion and wait the appropriate startup time before returning. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if agitator . read () == 'Running' : log . debug ( 'Agitator is running' ) else : startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) log . debug ( 'Starting agitator motion' ) try : agitator . write ( 'Run' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) agitator . write ( 'Run' ) time . sleep ( startup ) @classmethod def post_condition ( cls , args , logger , cfg ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) success = ktl . waitFor ( '$kpfmot.AGITATOR == Running' , timeout = startup ) if success is not True : agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) raise FailedToReachDestination ( agitator . read (), 'Running' )","title":"StartAgitator"},{"location":"scripts/StartAgitator/#startagitator","text":"Bases: KPFTranslatorFunction Start the agitator motion and wait the appropriate startup time before returning.","title":"StartAgitator"},{"location":"scripts/StartAgitator/#kpf.spectrograph.StartAgitator.StartAgitator--args","text":"None Source code in kpf/spectrograph/StartAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class StartAgitator ( KPFTranslatorFunction ): '''Start the agitator motion and wait the appropriate startup time before returning. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if agitator . read () == 'Running' : log . debug ( 'Agitator is running' ) else : startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) log . debug ( 'Starting agitator motion' ) try : agitator . write ( 'Run' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) agitator . write ( 'Run' ) time . sleep ( startup ) @classmethod def post_condition ( cls , args , logger , cfg ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) success = ktl . waitFor ( '$kpfmot.AGITATOR == Running' , timeout = startup ) if success is not True : agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) raise FailedToReachDestination ( agitator . read (), 'Running' )","title":"ARGS:"},{"location":"scripts/StartExposure/","text":"StartExposure Bases: KPFTranslatorFunction Begins an triggered exposure by setting the kpfexpose.EXPOSE keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. ARGS: None Source code in kpf/spectrograph/StartExposure.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class StartExposure ( KPFTranslatorFunction ): '''Begins an triggered exposure by setting the `kpfexpose.EXPOSE` keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) WaitForReady . execute ({}) log . debug ( f \"Beginning Exposure\" ) expose . write ( 'Start' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = f \"(kpfexpose.EXPOSE != Start)\" kpfexpose = ktl . cache ( 'kpfexpose' ) trig_targ = kpfexpose [ 'TRIG_TARG' ] . read () . split ( ',' ) if 'Green' in trig_targ : expr += ' and ($kpfgreen.EXPSTATE != Start)' if 'Red' in trig_targ : expr += ' and ($kpfred.EXPSTATE != Start)' if 'Ca_HK' in trig_targ : expr += ' and ($kpf_hk.EXPSTATE != Start)' exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) timeout = 6 left_start_state = ktl . waitFor ( expr , timeout = timeout ) if left_start_state is False : log . error ( f 'We are still in start state after { timeout } s' ) # Figure out which detector is stuck in the start state? green_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) . read () log . debug ( f 'kpfgreen.EXPSTATE = { green_expstate } ' ) red_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) . read () log . debug ( f 'kpfred.EXPSTATE = { red_expstate } ' ) cahk_expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) . read () log . debug ( f 'kpf_hk.EXPSTATE = { cahk_expstate } ' ) # Abort the current exposure elapsed = kpfexpose [ 'ELAPSED' ] . read ( binary = True ) remaining = exptime - elapsed if remaining <= 10 : # Don't stop exposure, just wait it out log . debug ( f 'Waiting out remaining { remaining } s of exposure' ) time . sleep ( remaining + 2 ) else : log . warning ( 'Stopping current exposure (with read out)' ) kpfexpose [ 'EXPOSE' ] . write ( 'End' ) time . sleep ( 2 ) # Time shim, this time is a WAG # Now reset the offending detector if green_expstate == 'Start' : ResetGreenDetector . execute ({}) if red_expstate == 'Start' : ResetRedDetector . execute ({}) if cahk_expstate == 'Start' : ResetCaHKDetector . execute ({}) # Now start a fresh exposure WaitForReady . execute ({}) time . sleep ( 1.0 ) # This time shim and the WaitForReady are hacks to catch if the WaitForReady . execute ({}) # reset detector went in to readout, but we didn't know. log . warning ( 'Restarting exposure' ) StartExposure . execute ( args )","title":"StartExposure"},{"location":"scripts/StartExposure/#startexposure","text":"Bases: KPFTranslatorFunction Begins an triggered exposure by setting the kpfexpose.EXPOSE keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done.","title":"StartExposure"},{"location":"scripts/StartExposure/#kpf.spectrograph.StartExposure.StartExposure--args","text":"None Source code in kpf/spectrograph/StartExposure.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class StartExposure ( KPFTranslatorFunction ): '''Begins an triggered exposure by setting the `kpfexpose.EXPOSE` keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) WaitForReady . execute ({}) log . debug ( f \"Beginning Exposure\" ) expose . write ( 'Start' ) @classmethod def post_condition ( cls , args , logger , cfg ): expr = f \"(kpfexpose.EXPOSE != Start)\" kpfexpose = ktl . cache ( 'kpfexpose' ) trig_targ = kpfexpose [ 'TRIG_TARG' ] . read () . split ( ',' ) if 'Green' in trig_targ : expr += ' and ($kpfgreen.EXPSTATE != Start)' if 'Red' in trig_targ : expr += ' and ($kpfred.EXPSTATE != Start)' if 'Ca_HK' in trig_targ : expr += ' and ($kpf_hk.EXPSTATE != Start)' exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) timeout = 6 left_start_state = ktl . waitFor ( expr , timeout = timeout ) if left_start_state is False : log . error ( f 'We are still in start state after { timeout } s' ) # Figure out which detector is stuck in the start state? green_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) . read () log . debug ( f 'kpfgreen.EXPSTATE = { green_expstate } ' ) red_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) . read () log . debug ( f 'kpfred.EXPSTATE = { red_expstate } ' ) cahk_expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) . read () log . debug ( f 'kpf_hk.EXPSTATE = { cahk_expstate } ' ) # Abort the current exposure elapsed = kpfexpose [ 'ELAPSED' ] . read ( binary = True ) remaining = exptime - elapsed if remaining <= 10 : # Don't stop exposure, just wait it out log . debug ( f 'Waiting out remaining { remaining } s of exposure' ) time . sleep ( remaining + 2 ) else : log . warning ( 'Stopping current exposure (with read out)' ) kpfexpose [ 'EXPOSE' ] . write ( 'End' ) time . sleep ( 2 ) # Time shim, this time is a WAG # Now reset the offending detector if green_expstate == 'Start' : ResetGreenDetector . execute ({}) if red_expstate == 'Start' : ResetRedDetector . execute ({}) if cahk_expstate == 'Start' : ResetCaHKDetector . execute ({}) # Now start a fresh exposure WaitForReady . execute ({}) time . sleep ( 1.0 ) # This time shim and the WaitForReady are hacks to catch if the WaitForReady . execute ({}) # reset detector went in to readout, but we didn't know. log . warning ( 'Restarting exposure' ) StartExposure . execute ( args )","title":"ARGS:"},{"location":"scripts/StartGUIs/","text":"StartGUIs Bases: KPFTranslatorFunction Start KPF GUIs ARGS None Source code in kpf/utils/StartGUIs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class StartGUIs ( KPFTranslatorFunction ): '''Start KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Get DISPLAY varibales env = os . environ uidisp = {} # for dispno in [0, 1, 2, 3]: # uidisp_proc = subprocess.run(['uidisp', f'{dispno}'], env=env, # stdout=subprocess.PIPE) # uidisp[dispno] = uidisp_proc.stdout.decode().strip('\\n') kvncstatus_proc = subprocess . run ([ 'kvncstatus' ], env = env , stdout = subprocess . PIPE ) kvncstatus = Table . read ( kvncstatus_proc . stdout . decode (), format = 'ascii' ) username = os . getlogin () display = { 'control0' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control0' ][ 'Display' ][ 0 ], 'control1' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control1' ][ 'Display' ][ 0 ], 'control2' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control2' ][ 'Display' ][ 0 ], 'telstatus' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -telstatus' ][ 'Display' ][ 0 ], } # Start GUIs if needed for GUI in GUI_list : # Find out of GUIs are Running log . debug ( f \"Setting DISPLAY to kpf { display [ GUI [ 'display' ]] } \" ) env [ 'DISPLAY' ] = f \"kpf { display [ GUI [ 'display' ]] } \" window_names = get_window_list ( env = env ) GUIname = GUI [ 'name' ] if GUIname not in window_names and args . get ( 'position_only' , False ) is False : instrume = ktl . cache ( 'dcs1' , 'INSTRUME' ) if GUIname == 'MAGIQ - Observer UI: KPF on Keck1' and instrume . read () != 'KPF' : log . info ( f 'Selected instrument is not KPF, not starting magiq' ) success = False else : log . info ( f \"Starting ' { GUIname } ' GUI\" ) gui_proc = subprocess . Popen ( GUI [ 'cmd' ], env = env , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) success = waitfor_window_to_appear ( GUIname , env = env ) if success is False : log . error ( f ' { GUIname } did not come up' ) stdout , stderr = gui_proc . communicate () log . error ( f \"STDERR: { stderr . decode () } \" ) log . error ( f \"STDOUT: { stdout . decode () } \" ) else : log . info ( f \"Existing ' { GUIname } ' window found\" ) success = True time . sleep ( 2 ) if GUI . get ( 'position' , None ) is not None and success is True : log . info ( f \"Positioning ' { GUIname } ' GUI\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , f '\" { GUIname } \"' , '-e' , GUI [ 'position' ]] log . debug ( f \" Running: { ' ' . join ( wmctrl_cmd ) } \" ) wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUI [ 'cmd' ][ 0 ] == 'xterm' : xterm_title = GUI [ 'cmd' ][ 2 ] success = waitfor_window_to_appear ( xterm_title , env = env ) log . info ( f \"Minimizing ' { xterm_title } '\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , xterm_title , '-b' , 'add,hidden' ] wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUIname == 'SAOImage kpfds9' : # Configure ds9 initial color maps and scaling cmaps = { '1' : 'cool' , '2' : 'green' , '3' : 'heat' } for frameno in cmaps . keys (): xpaset_cmds = [[ 'xpaset' , '-p' , 'kpfds9' , 'frame' , 'frameno' , f ' { frameno } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'cmap' , f ' { cmaps [ frameno ] } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'scale' , '99.5' ]] for xpaset_cmd in xpaset_cmds : xpa_proc = subprocess . Popen ( xpaset_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--position\" , \"-p\" , dest = \"position_only\" , default = False , action = \"store_true\" , help = \"Only position the GUIs, do not start\" ) return super () . add_cmdline_args ( parser , cfg )","title":"StartGUIs"},{"location":"scripts/StartGUIs/#startguis","text":"Bases: KPFTranslatorFunction Start KPF GUIs","title":"StartGUIs"},{"location":"scripts/StartGUIs/#kpf.utils.StartGUIs.StartGUIs--args","text":"None Source code in kpf/utils/StartGUIs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 class StartGUIs ( KPFTranslatorFunction ): '''Start KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Get DISPLAY varibales env = os . environ uidisp = {} # for dispno in [0, 1, 2, 3]: # uidisp_proc = subprocess.run(['uidisp', f'{dispno}'], env=env, # stdout=subprocess.PIPE) # uidisp[dispno] = uidisp_proc.stdout.decode().strip('\\n') kvncstatus_proc = subprocess . run ([ 'kvncstatus' ], env = env , stdout = subprocess . PIPE ) kvncstatus = Table . read ( kvncstatus_proc . stdout . decode (), format = 'ascii' ) username = os . getlogin () display = { 'control0' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control0' ][ 'Display' ][ 0 ], 'control1' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control1' ][ 'Display' ][ 0 ], 'control2' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control2' ][ 'Display' ][ 0 ], 'telstatus' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -telstatus' ][ 'Display' ][ 0 ], } # Start GUIs if needed for GUI in GUI_list : # Find out of GUIs are Running log . debug ( f \"Setting DISPLAY to kpf { display [ GUI [ 'display' ]] } \" ) env [ 'DISPLAY' ] = f \"kpf { display [ GUI [ 'display' ]] } \" window_names = get_window_list ( env = env ) GUIname = GUI [ 'name' ] if GUIname not in window_names and args . get ( 'position_only' , False ) is False : instrume = ktl . cache ( 'dcs1' , 'INSTRUME' ) if GUIname == 'MAGIQ - Observer UI: KPF on Keck1' and instrume . read () != 'KPF' : log . info ( f 'Selected instrument is not KPF, not starting magiq' ) success = False else : log . info ( f \"Starting ' { GUIname } ' GUI\" ) gui_proc = subprocess . Popen ( GUI [ 'cmd' ], env = env , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) success = waitfor_window_to_appear ( GUIname , env = env ) if success is False : log . error ( f ' { GUIname } did not come up' ) stdout , stderr = gui_proc . communicate () log . error ( f \"STDERR: { stderr . decode () } \" ) log . error ( f \"STDOUT: { stdout . decode () } \" ) else : log . info ( f \"Existing ' { GUIname } ' window found\" ) success = True time . sleep ( 2 ) if GUI . get ( 'position' , None ) is not None and success is True : log . info ( f \"Positioning ' { GUIname } ' GUI\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , f '\" { GUIname } \"' , '-e' , GUI [ 'position' ]] log . debug ( f \" Running: { ' ' . join ( wmctrl_cmd ) } \" ) wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUI [ 'cmd' ][ 0 ] == 'xterm' : xterm_title = GUI [ 'cmd' ][ 2 ] success = waitfor_window_to_appear ( xterm_title , env = env ) log . info ( f \"Minimizing ' { xterm_title } '\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , xterm_title , '-b' , 'add,hidden' ] wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUIname == 'SAOImage kpfds9' : # Configure ds9 initial color maps and scaling cmaps = { '1' : 'cool' , '2' : 'green' , '3' : 'heat' } for frameno in cmaps . keys (): xpaset_cmds = [[ 'xpaset' , '-p' , 'kpfds9' , 'frame' , 'frameno' , f ' { frameno } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'cmap' , f ' { cmaps [ frameno ] } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'scale' , '99.5' ]] for xpaset_cmd in xpaset_cmds : xpa_proc = subprocess . Popen ( xpaset_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--position\" , \"-p\" , dest = \"position_only\" , default = False , action = \"store_true\" , help = \"Only position the GUIs, do not start\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS"},{"location":"scripts/StartGuiderContinuous/","text":"StartGuiderContinuous Bases: KPFTranslatorFunction Put the guider in to continuous exposure mode and set images to be saved. ARGS: None Source code in kpf/guider/StartGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class StartGuiderContinuous ( KPFTranslatorFunction ): '''Put the guider in to continuous exposure mode and set images to be saved. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'active' ) kpfguide [ 'SAVE' ] . write ( 'active' ) @classmethod def post_condition ( cls , args , logger , cfg ): if guider_is_active () == False : raise FailedPostCondition ( 'Guider is not active' ) if guider_is_saving () == False : raise FailedPostCondition ( 'Guider is not saving' )","title":"StartGuiderContinuous"},{"location":"scripts/StartGuiderContinuous/#startguidercontinuous","text":"Bases: KPFTranslatorFunction Put the guider in to continuous exposure mode and set images to be saved.","title":"StartGuiderContinuous"},{"location":"scripts/StartGuiderContinuous/#kpf.guider.StartGuiderContinuous.StartGuiderContinuous--args","text":"None Source code in kpf/guider/StartGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class StartGuiderContinuous ( KPFTranslatorFunction ): '''Put the guider in to continuous exposure mode and set images to be saved. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'active' ) kpfguide [ 'SAVE' ] . write ( 'active' ) @classmethod def post_condition ( cls , args , logger , cfg ): if guider_is_active () == False : raise FailedPostCondition ( 'Guider is not active' ) if guider_is_saving () == False : raise FailedPostCondition ( 'Guider is not saving' )","title":"ARGS:"},{"location":"scripts/StartOfNight/","text":"StartOfNight Bases: KPFTranslatorFunction Send KPF in to a reasonable starting configuration set FIU mode to observing Setup AO for KPF Configure DCS (ROTDEST and ROTMODE) ARGS: AO - bool Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) Source code in kpf/scripts/StartOfNight.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class StartOfNight ( KPFTranslatorFunction ): '''Send KPF in to a reasonable starting configuration - set FIU mode to observing - Setup AO for KPF - Configure DCS (ROTDEST and ROTMODE) ARGS: ===== * __AO__ - `bool` Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( f \"Running KPF Start of Night script\" ) # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) if scriptname not in [ '' , 'None' , None ] or pid >= 0 : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Depending on when you are seeing this, it may be a scheduled\" , \"nighttime calibration which can and should be interrupted to\" , \"enable observing.\" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running StartOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # Setup AO if args . get ( 'AO' , True ) is True : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"This script will configure the FIU and AO bench for observing.\" , \"The AO bench area should be clear of personnel before proceeding.\" , \"Do you wish to to continue?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : SetupAOforKPF . execute ({}) log . info ( 'Open AO hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'open' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) print () print ( '----------------------------------------------------------' ) print ( 'AO hatch reported problems moving. Make sure stars are' ) print ( 'visible on guide camera before proceeding.' ) print ( '----------------------------------------------------------' ) print () # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Disallow cron job calibration scripts log . info ( 'Set ALLOWSCHEDULEDCALS to No' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'No' ) # Configure FIU log . info ( 'Configure FIU for \"Observing\"' ) ConfigureFIU . execute ({ 'mode' : 'Observing' }) # Set DCS rotator parameters dcs = ktl . cache ( 'dcs1' ) inst = dcs [ 'INSTRUME' ] . read () if inst == 'KPF' : log . info ( f \"Setting dcs.ROTDEST = 0\" ) dcs [ 'ROTDEST' ] . write ( 0 ) log . info ( f \"Setting dcs.ROTMODE = stationary\" ) dcs [ 'ROTMODE' ] . write ( 'stationary' ) else : log . warning ( f \"Instrument is { inst } , not configuring DCS\" ) # Report Agitator status runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : log . info ( f \"Agitator use is enabled\" ) else : log . warning ( f \"Agitator use is disabled for tonight\" ) # Pre-configure cal source calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () log . info ( f \"Setting simultaneous CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : True }) # Power on Simulcal lamp if needed if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'on' }) # Set tip tilt loop gain to default value kpfguide = ktl . cache ( 'kpfguide' ) tip_tilt_gain = cfg . getfloat ( 'tiptilt' , 'tiptilt_loop_gain' , fallback = 0.3 ) log . info ( f \"Setting default tip tilt loop gain of { tip_tilt_gain } \" ) SetTipTiltGain . execute ({ 'GuideLoopGain' : tip_tilt_gain }) # Set tip tilt loop detection threshold to default value detect_snr = cfg . getfloat ( 'tiptilt' , 'detect_snr' , fallback = 7 ) log . info ( f \"Setting default tip tilt detection SNR of { detect_snr } \" ) kpfguide [ 'OBJECT_INTENSITY' ] . write ( detect_snr ) # Set tip tilt loop detection area to default value detect_area = cfg . getfloat ( 'tiptilt' , 'detect_area' , fallback = 100 ) log . info ( f \"Setting default tip tilt detection area of { detect_area } \" ) kpfguide [ 'OBJECT_AREA' ] . write ( detect_area ) # Set tip tilt loop deblend parameter to default value deblend = cfg . getfloat ( 'tiptilt' , 'deblend' , fallback = 1 ) log . info ( f \"Setting default tip tilt deblending parameter of { deblend } \" ) kpfguide [ 'OBJECT_DBCONT' ] . write ( 1.0 ) # Set DAR parameter to default value log . info ( f \"Ensuring DAR correction is on\" ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) # Set Outdirs if expose . read () != 'Ready' : log . info ( 'Waiting for kpfexpose to be Ready' ) WaitForReady . execute ({}) SetOutdirs . execute ({}) # Set guider gain to high for initial acquisition and focus SetGuiderGain . execute ({ 'GuideCamGain' : 'high' }) # Set progname and observer SetObserverFromSchedule . execute ({}) # Summarize Detector Disabled States cahk_enabled = kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) if cahk_enabled is False : log . warning ( f \"The CA_HK detector is disabled tonight\" ) green_enabled = kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) if green_enabled is False : log . warning ( f \"The Green detector is disabled tonight\" ) red_enabled = kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) if red_enabled is False : log . warning ( f \"The Red detector is disabled tonight\" ) expmeter_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) if expmeter_enabled is False : log . warning ( f \"The ExpMeter detector is disabled tonight\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"StartOfNight"},{"location":"scripts/StartOfNight/#startofnight","text":"Bases: KPFTranslatorFunction Send KPF in to a reasonable starting configuration set FIU mode to observing Setup AO for KPF Configure DCS (ROTDEST and ROTMODE)","title":"StartOfNight"},{"location":"scripts/StartOfNight/#kpf.scripts.StartOfNight.StartOfNight--args","text":"AO - bool Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) Source code in kpf/scripts/StartOfNight.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 class StartOfNight ( KPFTranslatorFunction ): '''Send KPF in to a reasonable starting configuration - set FIU mode to observing - Setup AO for KPF - Configure DCS (ROTDEST and ROTMODE) ARGS: ===== * __AO__ - `bool` Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( f \"Running KPF Start of Night script\" ) # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) if scriptname not in [ '' , 'None' , None ] or pid >= 0 : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Depending on when you are seeing this, it may be a scheduled\" , \"nighttime calibration which can and should be interrupted to\" , \"enable observing.\" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running StartOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # Setup AO if args . get ( 'AO' , True ) is True : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"This script will configure the FIU and AO bench for observing.\" , \"The AO bench area should be clear of personnel before proceeding.\" , \"Do you wish to to continue?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : SetupAOforKPF . execute ({}) log . info ( 'Open AO hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'open' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) print () print ( '----------------------------------------------------------' ) print ( 'AO hatch reported problems moving. Make sure stars are' ) print ( 'visible on guide camera before proceeding.' ) print ( '----------------------------------------------------------' ) print () # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Disallow cron job calibration scripts log . info ( 'Set ALLOWSCHEDULEDCALS to No' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'No' ) # Configure FIU log . info ( 'Configure FIU for \"Observing\"' ) ConfigureFIU . execute ({ 'mode' : 'Observing' }) # Set DCS rotator parameters dcs = ktl . cache ( 'dcs1' ) inst = dcs [ 'INSTRUME' ] . read () if inst == 'KPF' : log . info ( f \"Setting dcs.ROTDEST = 0\" ) dcs [ 'ROTDEST' ] . write ( 0 ) log . info ( f \"Setting dcs.ROTMODE = stationary\" ) dcs [ 'ROTMODE' ] . write ( 'stationary' ) else : log . warning ( f \"Instrument is { inst } , not configuring DCS\" ) # Report Agitator status runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : log . info ( f \"Agitator use is enabled\" ) else : log . warning ( f \"Agitator use is disabled for tonight\" ) # Pre-configure cal source calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () log . info ( f \"Setting simultaneous CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : True }) # Power on Simulcal lamp if needed if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'on' }) # Set tip tilt loop gain to default value kpfguide = ktl . cache ( 'kpfguide' ) tip_tilt_gain = cfg . getfloat ( 'tiptilt' , 'tiptilt_loop_gain' , fallback = 0.3 ) log . info ( f \"Setting default tip tilt loop gain of { tip_tilt_gain } \" ) SetTipTiltGain . execute ({ 'GuideLoopGain' : tip_tilt_gain }) # Set tip tilt loop detection threshold to default value detect_snr = cfg . getfloat ( 'tiptilt' , 'detect_snr' , fallback = 7 ) log . info ( f \"Setting default tip tilt detection SNR of { detect_snr } \" ) kpfguide [ 'OBJECT_INTENSITY' ] . write ( detect_snr ) # Set tip tilt loop detection area to default value detect_area = cfg . getfloat ( 'tiptilt' , 'detect_area' , fallback = 100 ) log . info ( f \"Setting default tip tilt detection area of { detect_area } \" ) kpfguide [ 'OBJECT_AREA' ] . write ( detect_area ) # Set tip tilt loop deblend parameter to default value deblend = cfg . getfloat ( 'tiptilt' , 'deblend' , fallback = 1 ) log . info ( f \"Setting default tip tilt deblending parameter of { deblend } \" ) kpfguide [ 'OBJECT_DBCONT' ] . write ( 1.0 ) # Set DAR parameter to default value log . info ( f \"Ensuring DAR correction is on\" ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) # Set Outdirs if expose . read () != 'Ready' : log . info ( 'Waiting for kpfexpose to be Ready' ) WaitForReady . execute ({}) SetOutdirs . execute ({}) # Set guider gain to high for initial acquisition and focus SetGuiderGain . execute ({ 'GuideCamGain' : 'high' }) # Set progname and observer SetObserverFromSchedule . execute ({}) # Summarize Detector Disabled States cahk_enabled = kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) if cahk_enabled is False : log . warning ( f \"The CA_HK detector is disabled tonight\" ) green_enabled = kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) if green_enabled is False : log . warning ( f \"The Green detector is disabled tonight\" ) red_enabled = kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) if red_enabled is False : log . warning ( f \"The Red detector is disabled tonight\" ) expmeter_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) if expmeter_enabled is False : log . warning ( f \"The ExpMeter detector is disabled tonight\" ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/StartTipTilt/","text":"StartTipTilt Bases: KPFTranslatorFunction Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: None Source code in kpf/fiu/StartTipTilt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class StartTipTilt ( KPFTranslatorFunction ): '''Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expr = \"($kpffiu.TTXSRV == 'Closed') and ($kpffiu.TTYSRV == 'Closed')\" servo_loops_closed = ktl . waitFor ( expr , timeout = 0.5 ) if not servo_loops_closed : kpffiu = ktl . cache ( 'kpffiu' ) log . info ( 'Closing servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'Closed' ) kpffiu [ 'TTYSRV' ] . write ( 'Closed' ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( 10 * movetime ) kpfguide = ktl . cache ( 'kpfguide' ) log . debug ( f 'Ensuring kpfguide.DAR_ENABLE is yes' ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) log . info ( 'Turning kpfguide.ALL_LOOPS on' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"StartTipTilt"},{"location":"scripts/StartTipTilt/#starttiptilt","text":"Bases: KPFTranslatorFunction Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD).","title":"StartTipTilt"},{"location":"scripts/StartTipTilt/#kpf.fiu.StartTipTilt.StartTipTilt--args","text":"None Source code in kpf/fiu/StartTipTilt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class StartTipTilt ( KPFTranslatorFunction ): '''Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expr = \"($kpffiu.TTXSRV == 'Closed') and ($kpffiu.TTYSRV == 'Closed')\" servo_loops_closed = ktl . waitFor ( expr , timeout = 0.5 ) if not servo_loops_closed : kpffiu = ktl . cache ( 'kpffiu' ) log . info ( 'Closing servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'Closed' ) kpffiu [ 'TTYSRV' ] . write ( 'Closed' ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( 10 * movetime ) kpfguide = ktl . cache ( 'kpfguide' ) log . debug ( f 'Ensuring kpfguide.DAR_ENABLE is yes' ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) log . info ( 'Turning kpfguide.ALL_LOOPS on' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/StartTriggerFile/","text":"StartTriggerFile Bases: KPFTranslatorFunction Start a \"trigger file\" from the guide camera. ARGS: None Source code in kpf/guider/StartTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class StartTriggerFile ( KPFTranslatorFunction ): '''Start a \"trigger file\" from the guide camera. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) cube = kpfguide [ 'TRIGCUBE' ] . read () log . info ( f \"Start guider trigger file data collection: TRIGCUBE= { cube } \" ) kpfguide [ 'TRIGGER' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"StartTriggerFile"},{"location":"scripts/StartTriggerFile/#starttriggerfile","text":"Bases: KPFTranslatorFunction Start a \"trigger file\" from the guide camera.","title":"StartTriggerFile"},{"location":"scripts/StartTriggerFile/#kpf.guider.StartTriggerFile.StartTriggerFile--args","text":"None Source code in kpf/guider/StartTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class StartTriggerFile ( KPFTranslatorFunction ): '''Start a \"trigger file\" from the guide camera. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) cube = kpfguide [ 'TRIGCUBE' ] . read () log . info ( f \"Start guider trigger file data collection: TRIGCUBE= { cube } \" ) kpfguide [ 'TRIGGER' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/StartUp/","text":"StartUp Bases: KPFTranslatorFunction Start KPF software for afternoon setup. ARGS: None Source code in kpf/scripts/StartUp.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class StartUp ( KPFTranslatorFunction ): '''Start KPF software for afternoon setup. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Start GUIs StartGUIs . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"StartUp"},{"location":"scripts/StartUp/#startup","text":"Bases: KPFTranslatorFunction Start KPF software for afternoon setup.","title":"StartUp"},{"location":"scripts/StartUp/#kpf.scripts.StartUp.StartUp--args","text":"None Source code in kpf/scripts/StartUp.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class StartUp ( KPFTranslatorFunction ): '''Start KPF software for afternoon setup. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Start GUIs StartGUIs . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/StopAgitator/","text":"StopAgitator Bases: KPFTranslatorFunction Stop the agitator motion. ARGS: None Source code in kpf/spectrograph/StopAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class StopAgitator ( KPFTranslatorFunction ): '''Stop the agitator motion. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if agitator . read () == 'Stopped' : log . debug ( 'Agitator is stopped' ) else : log . debug ( 'Stopping agitator' ) try : agitator . write ( 'Stop' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) agitator . write ( 'Stop' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) success = ktl . waitFor ( '$kpfmot.AGITATOR == Stopped' , timeout = timeout ) if success is not True : agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) raise FailedToReachDestination ( agitator . read (), 'Stopped' )","title":"StopAgitator"},{"location":"scripts/StopAgitator/#stopagitator","text":"Bases: KPFTranslatorFunction Stop the agitator motion.","title":"StopAgitator"},{"location":"scripts/StopAgitator/#kpf.spectrograph.StopAgitator.StopAgitator--args","text":"None Source code in kpf/spectrograph/StopAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class StopAgitator ( KPFTranslatorFunction ): '''Stop the agitator motion. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if agitator . read () == 'Stopped' : log . debug ( 'Agitator is stopped' ) else : log . debug ( 'Stopping agitator' ) try : agitator . write ( 'Stop' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) agitator . write ( 'Stop' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) success = ktl . waitFor ( '$kpfmot.AGITATOR == Stopped' , timeout = timeout ) if success is not True : agitator = ktl . cache ( 'kpfmot' , 'AGITATOR' ) raise FailedToReachDestination ( agitator . read (), 'Stopped' )","title":"ARGS:"},{"location":"scripts/StopGUIs/","text":"StopGUIs Bases: KPFTranslatorFunction Stop KPF GUIs ARGS None Source code in kpf/utils/StopGUIs.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class StopGUIs ( KPFTranslatorFunction ): '''Stop KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for GUI in GUI_list : GUIname = GUI [ 'name' ] if GUI [ 'cmd' ][ 0 ] == 'kpf' : GUIscriptname = GUI [ 'cmd' ][ 2 ] status_cmd = GUI [ 'cmd' ] status_cmd [ 1 ] = 'status' log . info ( f \"Getting status of ' { GUIname } ' GUI\" ) gui_proc = subprocess . run ( status_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) stdout = gui_proc . stdout . decode () . strip () is_running = re . search ( 'is running on' , stdout ) if is_running is not None : stop_cmd = GUI [ 'cmd' ] stop_cmd [ 1 ] = 'stop' log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stopout = subprocess . run ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" { stopout . returncode } \" ) log . debug ( f \" { stopout . stdout . decode () } \" ) log . debug ( f \" { stopout . stderr . decode () } \" ) else : log . info ( f \" { GUIname } is not running\" ) log . debug ( f \" { stdout } \" ) elif GUIname == 'MAGIQ - Observer UI' : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stop_cmd = GUI [ 'cmd' ] stop_cmd [ 4 ] = 'stop' gui_proc = subprocess . Popen ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) else : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) kill_process ( GUI [ 'cmd' ], server = 'kpf' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"StopGUIs"},{"location":"scripts/StopGUIs/#stopguis","text":"Bases: KPFTranslatorFunction Stop KPF GUIs","title":"StopGUIs"},{"location":"scripts/StopGUIs/#kpf.utils.StopGUIs.StopGUIs--args","text":"None Source code in kpf/utils/StopGUIs.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class StopGUIs ( KPFTranslatorFunction ): '''Stop KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for GUI in GUI_list : GUIname = GUI [ 'name' ] if GUI [ 'cmd' ][ 0 ] == 'kpf' : GUIscriptname = GUI [ 'cmd' ][ 2 ] status_cmd = GUI [ 'cmd' ] status_cmd [ 1 ] = 'status' log . info ( f \"Getting status of ' { GUIname } ' GUI\" ) gui_proc = subprocess . run ( status_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) stdout = gui_proc . stdout . decode () . strip () is_running = re . search ( 'is running on' , stdout ) if is_running is not None : stop_cmd = GUI [ 'cmd' ] stop_cmd [ 1 ] = 'stop' log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stopout = subprocess . run ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" { stopout . returncode } \" ) log . debug ( f \" { stopout . stdout . decode () } \" ) log . debug ( f \" { stopout . stderr . decode () } \" ) else : log . info ( f \" { GUIname } is not running\" ) log . debug ( f \" { stdout } \" ) elif GUIname == 'MAGIQ - Observer UI' : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stop_cmd = GUI [ 'cmd' ] stop_cmd [ 4 ] = 'stop' gui_proc = subprocess . Popen ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) else : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) kill_process ( GUI [ 'cmd' ], server = 'kpf' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS"},{"location":"scripts/StopGuiderContinuous/","text":"StopGuiderContinuous Bases: KPFTranslatorFunction Stop the guider's continuous exposure mode and stop saving images. ARGS: None Source code in kpf/guider/StopGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class StopGuiderContinuous ( KPFTranslatorFunction ): '''Stop the guider's continuous exposure mode and stop saving images. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'inactive' ) kpfguide [ 'SAVE' ] . write ( 'inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): if guider_is_active () != False : raise FailedPostCondition ( 'Guider is not inactive' ) if guider_is_saving () != False : raise FailedPostCondition ( 'Guider is still saving' )","title":"StopGuiderContinuous"},{"location":"scripts/StopGuiderContinuous/#stopguidercontinuous","text":"Bases: KPFTranslatorFunction Stop the guider's continuous exposure mode and stop saving images.","title":"StopGuiderContinuous"},{"location":"scripts/StopGuiderContinuous/#kpf.guider.StopGuiderContinuous.StopGuiderContinuous--args","text":"None Source code in kpf/guider/StopGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class StopGuiderContinuous ( KPFTranslatorFunction ): '''Stop the guider's continuous exposure mode and stop saving images. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'inactive' ) kpfguide [ 'SAVE' ] . write ( 'inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): if guider_is_active () != False : raise FailedPostCondition ( 'Guider is not inactive' ) if guider_is_saving () != False : raise FailedPostCondition ( 'Guider is still saving' )","title":"ARGS:"},{"location":"scripts/StopTipTilt/","text":"StopTipTilt Bases: KPFTranslatorFunction Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: None Source code in kpf/fiu/StopTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopTipTilt ( KPFTranslatorFunction ): '''Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) success = TIPTILT_CALC . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( TIPTILT_CALC . read (), 'Inactive' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) success = TIPTILT_CONTROL . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( TIPTILT_CONTROL . read (), 'Inactive' ) OFFLOAD = ktl . cache ( 'kpfguide' , 'OFFLOAD' ) success = OFFLOAD . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( OFFLOAD . read (), 'Inactive' )","title":"StopTipTilt"},{"location":"scripts/StopTipTilt/#stoptiptilt","text":"Bases: KPFTranslatorFunction Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD).","title":"StopTipTilt"},{"location":"scripts/StopTipTilt/#kpf.fiu.StopTipTilt.StopTipTilt--args","text":"None Source code in kpf/fiu/StopTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopTipTilt ( KPFTranslatorFunction ): '''Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) success = TIPTILT_CALC . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( TIPTILT_CALC . read (), 'Inactive' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) success = TIPTILT_CONTROL . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( TIPTILT_CONTROL . read (), 'Inactive' ) OFFLOAD = ktl . cache ( 'kpfguide' , 'OFFLOAD' ) success = OFFLOAD . waitFor ( \"== 'Inactive'\" ) if success is False : raise FailedToReachDestination ( OFFLOAD . read (), 'Inactive' )","title":"ARGS:"},{"location":"scripts/StopTriggerFile/","text":"StopTriggerFile Bases: KPFTranslatorFunction Stop a \"trigger file\" from the guide camera. ARGS: None Source code in kpf/guider/StopTriggerFile.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class StopTriggerFile ( KPFTranslatorFunction ): '''Stop a \"trigger file\" from the guide camera. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Stopping guider trigger file data collection\" ) kpfguide [ 'TRIGGER' ] . write ( 'Inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"StopTriggerFile"},{"location":"scripts/StopTriggerFile/#stoptriggerfile","text":"Bases: KPFTranslatorFunction Stop a \"trigger file\" from the guide camera.","title":"StopTriggerFile"},{"location":"scripts/StopTriggerFile/#kpf.guider.StopTriggerFile.StopTriggerFile--args","text":"None Source code in kpf/guider/StopTriggerFile.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class StopTriggerFile ( KPFTranslatorFunction ): '''Stop a \"trigger file\" from the guide camera. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Stopping guider trigger file data collection\" ) kpfguide [ 'TRIGGER' ] . write ( 'Inactive' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/TakeADCGridData/","text":"TakeADCGridData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeADCGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1min = args . get ( 'ADC1MIN' , 60 ) adc1max = args . get ( 'ADC1MAX' , 70 ) adc2min = args . get ( 'ADC2MIN' , 60 ) adc2max = args . get ( 'ADC2MAX' , 70 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1vals = np . arange ( adc1min , adc1max + adcstep , adcstep ) adc2vals = np . arange ( adc2min , adc2max + adcstep , adcstep ) adcsleeptime = 1 fvcsleeptime = 0.25 ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' )) for i , adc1 in enumerate ( adc1vals ): for j , adc2 in enumerate ( adc2vals ): log . info ( f 'Moving ADC1 to { adc1 : .1f } , ADC2 to { adc2 : .1f } ' ) ADC1VAL . write ( f \" { adc1 : .1f } \" ) ADC2VAL . write ( f \" { adc2 : .1f } \" ) time . sleep ( adcsleeptime ) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1MIN' , type = float , help = \"Starting ADC1 angle\" ) parser . add_argument ( 'ADC1MAX' , type = float , help = \"Ending ADC1 angle\" ) parser . add_argument ( 'ADC2MIN' , type = float , help = \"Starting ADC2 angle\" ) parser . add_argument ( 'ADC2MAX' , type = float , help = \"Ending ADC2 angle\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCGridData"},{"location":"scripts/TakeADCGridData/#takeadcgriddata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeADCGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1min = args . get ( 'ADC1MIN' , 60 ) adc1max = args . get ( 'ADC1MAX' , 70 ) adc2min = args . get ( 'ADC2MIN' , 60 ) adc2max = args . get ( 'ADC2MAX' , 70 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1vals = np . arange ( adc1min , adc1max + adcstep , adcstep ) adc2vals = np . arange ( adc2min , adc2max + adcstep , adcstep ) adcsleeptime = 1 fvcsleeptime = 0.25 ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' )) for i , adc1 in enumerate ( adc1vals ): for j , adc2 in enumerate ( adc2vals ): log . info ( f 'Moving ADC1 to { adc1 : .1f } , ADC2 to { adc2 : .1f } ' ) ADC1VAL . write ( f \" { adc1 : .1f } \" ) ADC2VAL . write ( f \" { adc2 : .1f } \" ) time . sleep ( adcsleeptime ) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1MIN' , type = float , help = \"Starting ADC1 angle\" ) parser . add_argument ( 'ADC1MAX' , type = float , help = \"Ending ADC1 angle\" ) parser . add_argument ( 'ADC2MIN' , type = float , help = \"Starting ADC2 angle\" ) parser . add_argument ( 'ADC2MAX' , type = float , help = \"Ending ADC2 angle\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCGridData"},{"location":"scripts/TakeADCOffsetGridData/","text":"TakeADCOffsetGridData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCOffsetGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TakeADCOffsetGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1delta = args . get ( 'ADC1DELTA' , 5 ) adc2delta = args . get ( 'ADC2DELTA' , 5 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1deltas = np . arange ( - adc1delta , adc1delta , adcstep ) adc2deltas = np . arange ( - adc2delta , adc2delta , adcstep ) fvcsleeptime = 0.25 ADCPRISMS = ktl . cache ( 'kpffiu' , 'ADCPRISMS' ) ADCPRISMS . monitor () ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'DELTA1' , 'DELTA2' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' , 'f4' , 'f4' )) for i , delta1 in enumerate ( adc1deltas ): for j , delta2 in enumerate ( adc2deltas ): log . info ( f 'Moving ADCs to offset positions: { delta1 : .1f } , { delta2 : .1f } ' ) SetADCOffsets . execute ({ 'ADC1OFF' : delta1 , 'ADC2OFF' : delta2 }) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'DELTA1' : delta1 , 'DELTA2' : delta2 , 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1DELTA' , type = float , help = \"Maximum ADC1 offset from nominal\" ) parser . add_argument ( 'ADC2DELTA' , type = float , help = \"Maximum ADC2 offset from nominal\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCOffsetGridData"},{"location":"scripts/TakeADCOffsetGridData/#takeadcoffsetgriddata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCOffsetGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TakeADCOffsetGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1delta = args . get ( 'ADC1DELTA' , 5 ) adc2delta = args . get ( 'ADC2DELTA' , 5 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1deltas = np . arange ( - adc1delta , adc1delta , adcstep ) adc2deltas = np . arange ( - adc2delta , adc2delta , adcstep ) fvcsleeptime = 0.25 ADCPRISMS = ktl . cache ( 'kpffiu' , 'ADCPRISMS' ) ADCPRISMS . monitor () ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'DELTA1' , 'DELTA2' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' , 'f4' , 'f4' )) for i , delta1 in enumerate ( adc1deltas ): for j , delta2 in enumerate ( adc2deltas ): log . info ( f 'Moving ADCs to offset positions: { delta1 : .1f } , { delta2 : .1f } ' ) SetADCOffsets . execute ({ 'ADC1OFF' : delta1 , 'ADC2OFF' : delta2 }) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'DELTA1' : delta1 , 'DELTA2' : delta2 , 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1DELTA' , type = float , help = \"Maximum ADC1 offset from nominal\" ) parser . add_argument ( 'ADC2DELTA' , type = float , help = \"Maximum ADC2 offset from nominal\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCOffsetGridData"},{"location":"scripts/TakeExpMeterBiases/","text":"TakeExpMeterBiases Bases: KPFTranslatorFunction Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) KTL Keywords Used kpfconfig.EXPMETER_ENABLED kpfconfig.ALLOWSCHEDULEDCALS kpf_expmeter.COOLING kpf_expmeter.COOLTARG kpf_expmeter.COOLTEMP kpf_expmeter.BINX kpf_expmeter.BINY kpf_expmeter.TOP kpf_expmeter.LEFT kpf_expmeter.WIDTH kpf_expmeter.HEIGHT kpf_expmeter.EXPOSURE kpf_expmeter.OBJECT kpf_expmeter.OBSERVER kpf_expmeter.EXPMODE kpf_expmeter.EXPSTATE kpf_expmeter.EXPOSE kpf_expmeter.SEQNUM kpf_expmeter.FITSFILE kpfexpose.TRIG_TARG Scripts Called kpf.calbench.SetCalSource kpf.calbench.WaitForCalSource kpf.spectrograph.WaitForReady kpf.spectrograph.SetSourceSelectShutters kpf.expmeter.BuildMasterBias kpf.spectrograph.ResetDetectors.ResetExpMeterDetector Parameters nExp ( int ) The number of frames to take combine ( bool ) Combine the files in to a master bias? output ( str ) The output combined bias file update ( bool ) Update the bias file in use with the newly generated file? (only used if combine is True) Source code in kpf/expmeter/TakeExpMeterBiases.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class TakeExpMeterBiases ( KPFTranslatorFunction ): '''Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) ## KTL Keywords Used - `kpfconfig.EXPMETER_ENABLED` - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpf_expmeter.COOLING` - `kpf_expmeter.COOLTARG` - `kpf_expmeter.COOLTEMP` - `kpf_expmeter.BINX` - `kpf_expmeter.BINY` - `kpf_expmeter.TOP` - `kpf_expmeter.LEFT` - `kpf_expmeter.WIDTH` - `kpf_expmeter.HEIGHT` - `kpf_expmeter.EXPOSURE` - `kpf_expmeter.OBJECT` - `kpf_expmeter.OBSERVER` - `kpf_expmeter.EXPMODE` - `kpf_expmeter.EXPSTATE` - `kpf_expmeter.EXPOSE` - `kpf_expmeter.SEQNUM` - `kpf_expmeter.FITSFILE` - `kpfexpose.TRIG_TARG` ## Scripts Called - `kpf.calbench.SetCalSource` - `kpf.calbench.WaitForCalSource` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.expmeter.BuildMasterBias` - `kpf.spectrograph.ResetDetectors.ResetExpMeterDetector` ## Parameters **nExp** (`int`) > The number of frames to take **combine** (`bool`) > Combine the files in to a master bias? **output** (`str`) > The output combined bias file **update** (`bool`) > Update the bias file in use with the newly generated file? (only used if combine is True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'nExp' , allowed_types = [ int ]) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Check exposure meter enabled kpfconfig = ktl . cache ( 'kpfconfig' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_enabled == False : raise FailedPreCondition ( 'Exposure meter is not enabled' ) # Check on exposure meter detector status if kpf_expmeter [ 'COOLING' ] . read ( binary = True ) != True : raise FailedPreCondition ( 'Exposure meter cooling is not On' ) cooltarg = kpf_expmeter [ 'COOLTARG' ] . read ( binary = True ) currtemp = kpf_expmeter [ 'CURRTEMP' ] . read ( binary = True ) deltaT = abs ( currtemp - cooltarg ) deltaT_threshold = cfg . getfloat ( 'tolerances' , 'expmeter_detector_temperature_tolerance' , fallback = 0.5 ) if deltaT > deltaT_threshold : raise FailedPreCondition ( 'Exposure meter not near target temperature' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # Check if we're ok to take data allowscheduledcals = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if allowscheduledcals . read ( binary = True ) == False : log . warning ( f 'kpfconfig.ALLOWSCHEDULEDCALS=No. Not taking biases.' ) return [] # Proceed with taking biases nExp = int ( args . get ( 'nExp' )) log . info ( f \"Taking { nExp } exposure meter bias frames\" ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set exposure meter to full frame to take biases log . info ( f \"Setting exposure meter to full frame for biases\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 0 ) kpf_expmeter [ 'WIDTH' ] . write ( 1072 ) kpf_expmeter [ 'HEIGHT' ] . write ( 1024 ) kpf_expmeter [ 'EXPOSURE' ] . write ( 0.12 ) kpf_expmeter [ 'OBJECT' ] . write ( 'bias' ) kpf_expmeter [ 'OBSERVER' ] . write ( 'TakeExpMeterBiases' ) kpf_expmeter [ 'EXPMODE' ] . write ( 'Continuous' ) log . debug ( 'Set Octagon to Home and close all source select shutters' ) SetCalSource . execute ({ 'CalSource' : 'Home' }) WaitForReady . execute ({}) SetSourceSelectShutters . execute ({}) WaitForCalSource . execute ({ 'CalSource' : 'Home' }) # Set TRIG_TARG to None, so that kpfassemble doesn't try # to pick up this data set trig_targ = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) trig_targ . write ( 'None' ) ready = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) if ready is not True : raise KPFException ( f \"Exposure Meter did not reach ready state\" ) # Start continuous exposures log . info ( f \"Starting continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'Start' ) started = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"!= 'Ready'\" , timeout = 5 ) if started is not True : raise KPFException ( f \"Exposure Meter did not start exposures\" ) got_frames = kpf_expmeter [ 'SEQNUM' ] . waitFor ( f \"== { nExp } \" , timeout = 2 * nExp ) if got_frames is not True : raise KPFException ( f \"Exposure Meter did not get all exposures\" ) log . info ( f \"Stopping continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'End' ) # Arbitrary wait to let file writing and DRP finish time . sleep ( 2 ) # Get FITSFILE lastfile = Path ( kpf_expmeter [ 'FITSFILE' ] . read ()) if lastfile . exists () is False : raise KPFException ( f \"Could not find file: { lastfile } \" ) filename_parts = lastfile . name . split ( '.' ) filename_parts [ 1 ] = '*' biases = [ f for f in lastfile . parent . glob ( '.' . join ( filename_parts ))] # Set exposure meter back to operations settings log . info ( f \"Setting exposure meter to operational windowing\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 1 ) kpf_expmeter [ 'WIDTH' ] . write ( 651 ) kpf_expmeter [ 'HEIGHT' ] . write ( 300 ) kpf_expmeter [ 'OBJECT' ] . write ( '' ) if args . get ( 'combine' , False ) is True : BuildMasterBias . execute ({ 'files' : biases , 'output' : args . get ( 'output' ), 'update' : args . get ( 'update' )}) return biases @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) expstate . monitor () timeout = 60 ready = expstate . waitFor ( \"== 'Ready'\" , timeout = timeout ) if ready is not True : log . error ( f 'ExpMeter is not Ready after { timeout } s' ) log . warning ( f 'ExpMeter is { expstate . ascii } . Resetting.' ) ResetExpMeterDetector . execute ({}) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'nExp' , type = int , help = \"The number of frames to take\" ) parser . add_argument ( \"-c\" , \"--combine\" , dest = \"combine\" , default = False , action = \"store_true\" , help = \"Combine the files in to a master bias?\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file? (only used if --combine is used)\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeExpMeterBiases"},{"location":"scripts/TakeExpMeterBiases/#takeexpmeterbiases","text":"Bases: KPFTranslatorFunction Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No)","title":"TakeExpMeterBiases"},{"location":"scripts/TakeExpMeterBiases/#kpf.expmeter.TakeExpMeterBiases.TakeExpMeterBiases--ktl-keywords-used","text":"kpfconfig.EXPMETER_ENABLED kpfconfig.ALLOWSCHEDULEDCALS kpf_expmeter.COOLING kpf_expmeter.COOLTARG kpf_expmeter.COOLTEMP kpf_expmeter.BINX kpf_expmeter.BINY kpf_expmeter.TOP kpf_expmeter.LEFT kpf_expmeter.WIDTH kpf_expmeter.HEIGHT kpf_expmeter.EXPOSURE kpf_expmeter.OBJECT kpf_expmeter.OBSERVER kpf_expmeter.EXPMODE kpf_expmeter.EXPSTATE kpf_expmeter.EXPOSE kpf_expmeter.SEQNUM kpf_expmeter.FITSFILE kpfexpose.TRIG_TARG","title":"KTL Keywords Used"},{"location":"scripts/TakeExpMeterBiases/#kpf.expmeter.TakeExpMeterBiases.TakeExpMeterBiases--scripts-called","text":"kpf.calbench.SetCalSource kpf.calbench.WaitForCalSource kpf.spectrograph.WaitForReady kpf.spectrograph.SetSourceSelectShutters kpf.expmeter.BuildMasterBias kpf.spectrograph.ResetDetectors.ResetExpMeterDetector","title":"Scripts Called"},{"location":"scripts/TakeExpMeterBiases/#kpf.expmeter.TakeExpMeterBiases.TakeExpMeterBiases--parameters","text":"nExp ( int ) The number of frames to take combine ( bool ) Combine the files in to a master bias? output ( str ) The output combined bias file update ( bool ) Update the bias file in use with the newly generated file? (only used if combine is True) Source code in kpf/expmeter/TakeExpMeterBiases.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class TakeExpMeterBiases ( KPFTranslatorFunction ): '''Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) ## KTL Keywords Used - `kpfconfig.EXPMETER_ENABLED` - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpf_expmeter.COOLING` - `kpf_expmeter.COOLTARG` - `kpf_expmeter.COOLTEMP` - `kpf_expmeter.BINX` - `kpf_expmeter.BINY` - `kpf_expmeter.TOP` - `kpf_expmeter.LEFT` - `kpf_expmeter.WIDTH` - `kpf_expmeter.HEIGHT` - `kpf_expmeter.EXPOSURE` - `kpf_expmeter.OBJECT` - `kpf_expmeter.OBSERVER` - `kpf_expmeter.EXPMODE` - `kpf_expmeter.EXPSTATE` - `kpf_expmeter.EXPOSE` - `kpf_expmeter.SEQNUM` - `kpf_expmeter.FITSFILE` - `kpfexpose.TRIG_TARG` ## Scripts Called - `kpf.calbench.SetCalSource` - `kpf.calbench.WaitForCalSource` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.expmeter.BuildMasterBias` - `kpf.spectrograph.ResetDetectors.ResetExpMeterDetector` ## Parameters **nExp** (`int`) > The number of frames to take **combine** (`bool`) > Combine the files in to a master bias? **output** (`str`) > The output combined bias file **update** (`bool`) > Update the bias file in use with the newly generated file? (only used if combine is True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'nExp' , allowed_types = [ int ]) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Check exposure meter enabled kpfconfig = ktl . cache ( 'kpfconfig' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_enabled == False : raise FailedPreCondition ( 'Exposure meter is not enabled' ) # Check on exposure meter detector status if kpf_expmeter [ 'COOLING' ] . read ( binary = True ) != True : raise FailedPreCondition ( 'Exposure meter cooling is not On' ) cooltarg = kpf_expmeter [ 'COOLTARG' ] . read ( binary = True ) currtemp = kpf_expmeter [ 'CURRTEMP' ] . read ( binary = True ) deltaT = abs ( currtemp - cooltarg ) deltaT_threshold = cfg . getfloat ( 'tolerances' , 'expmeter_detector_temperature_tolerance' , fallback = 0.5 ) if deltaT > deltaT_threshold : raise FailedPreCondition ( 'Exposure meter not near target temperature' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): # Check if we're ok to take data allowscheduledcals = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if allowscheduledcals . read ( binary = True ) == False : log . warning ( f 'kpfconfig.ALLOWSCHEDULEDCALS=No. Not taking biases.' ) return [] # Proceed with taking biases nExp = int ( args . get ( 'nExp' )) log . info ( f \"Taking { nExp } exposure meter bias frames\" ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set exposure meter to full frame to take biases log . info ( f \"Setting exposure meter to full frame for biases\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 0 ) kpf_expmeter [ 'WIDTH' ] . write ( 1072 ) kpf_expmeter [ 'HEIGHT' ] . write ( 1024 ) kpf_expmeter [ 'EXPOSURE' ] . write ( 0.12 ) kpf_expmeter [ 'OBJECT' ] . write ( 'bias' ) kpf_expmeter [ 'OBSERVER' ] . write ( 'TakeExpMeterBiases' ) kpf_expmeter [ 'EXPMODE' ] . write ( 'Continuous' ) log . debug ( 'Set Octagon to Home and close all source select shutters' ) SetCalSource . execute ({ 'CalSource' : 'Home' }) WaitForReady . execute ({}) SetSourceSelectShutters . execute ({}) WaitForCalSource . execute ({ 'CalSource' : 'Home' }) # Set TRIG_TARG to None, so that kpfassemble doesn't try # to pick up this data set trig_targ = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) trig_targ . write ( 'None' ) ready = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) if ready is not True : raise KPFException ( f \"Exposure Meter did not reach ready state\" ) # Start continuous exposures log . info ( f \"Starting continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'Start' ) started = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"!= 'Ready'\" , timeout = 5 ) if started is not True : raise KPFException ( f \"Exposure Meter did not start exposures\" ) got_frames = kpf_expmeter [ 'SEQNUM' ] . waitFor ( f \"== { nExp } \" , timeout = 2 * nExp ) if got_frames is not True : raise KPFException ( f \"Exposure Meter did not get all exposures\" ) log . info ( f \"Stopping continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'End' ) # Arbitrary wait to let file writing and DRP finish time . sleep ( 2 ) # Get FITSFILE lastfile = Path ( kpf_expmeter [ 'FITSFILE' ] . read ()) if lastfile . exists () is False : raise KPFException ( f \"Could not find file: { lastfile } \" ) filename_parts = lastfile . name . split ( '.' ) filename_parts [ 1 ] = '*' biases = [ f for f in lastfile . parent . glob ( '.' . join ( filename_parts ))] # Set exposure meter back to operations settings log . info ( f \"Setting exposure meter to operational windowing\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 1 ) kpf_expmeter [ 'WIDTH' ] . write ( 651 ) kpf_expmeter [ 'HEIGHT' ] . write ( 300 ) kpf_expmeter [ 'OBJECT' ] . write ( '' ) if args . get ( 'combine' , False ) is True : BuildMasterBias . execute ({ 'files' : biases , 'output' : args . get ( 'output' ), 'update' : args . get ( 'update' )}) return biases @classmethod def post_condition ( cls , args , logger , cfg ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) expstate . monitor () timeout = 60 ready = expstate . waitFor ( \"== 'Ready'\" , timeout = timeout ) if ready is not True : log . error ( f 'ExpMeter is not Ready after { timeout } s' ) log . warning ( f 'ExpMeter is { expstate . ascii } . Resetting.' ) ResetExpMeterDetector . execute ({}) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'nExp' , type = int , help = \"The number of frames to take\" ) parser . add_argument ( \"-c\" , \"--combine\" , dest = \"combine\" , default = False , action = \"store_true\" , help = \"Combine the files in to a master bias?\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file? (only used if --combine is used)\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/TakeFVCContinuous/","text":"TakeFVCContinuous Bases: KPFTranslatorFunction Take exposures with the specified FVC continuously and display to ds9. ARGS: :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. Source code in kpf/fvc/TakeFVCContinuous.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class TakeFVCContinuous ( KPFTranslatorFunction ): '''Take exposures with the specified FVC continuously and display to ds9. ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) SetFVCExpTime . execute ( args ) while True : TakeFVCExposure . execute ({ 'camera' : camera , 'display' : True }) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeFVCContinuous"},{"location":"scripts/TakeFVCContinuous/#takefvccontinuous","text":"Bases: KPFTranslatorFunction Take exposures with the specified FVC continuously and display to ds9.","title":"TakeFVCContinuous"},{"location":"scripts/TakeFVCContinuous/#kpf.fvc.TakeFVCContinuous.TakeFVCContinuous--args","text":":camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. Source code in kpf/fvc/TakeFVCContinuous.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class TakeFVCContinuous ( KPFTranslatorFunction ): '''Take exposures with the specified FVC continuously and display to ds9. ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :exptime: The exposure time in seconds. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) SetFVCExpTime . execute ( args ) while True : TakeFVCExposure . execute ({ 'camera' : camera , 'display' : True }) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/TakeFVCExposure/","text":"TakeFVCExposure Bases: KPFTranslatorFunction Take an exposure with the specified fiber viewing camera ARGS: :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :wait: (bool) Wait for move to complete before returning? (default: True) :display: (bool) Display the resulting image to the engineering ds9 instance for FVCs using XPA. Source code in kpf/fvc/TakeFVCExposure.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TakeFVCExposure ( KPFTranslatorFunction ): '''Take an exposure with the specified fiber viewing camera ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :wait: (bool) Wait for move to complete before returning? (default: True) :display: (bool) Display the resulting image to the engineering ds9 instance for FVCs using XPA. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = kpffvc [ f ' { camera } EXPTIME' ] . read ( binary = True ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] initial_lastfile = lastfile . read () wait = args . get ( 'wait' , True ) kpffvc [ f ' { camera } EXPOSE' ] . write ( 'yes' , wait = wait ) if wait is True : timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) expr = f \"($kpffvc. { camera } LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) if wait is True and args . get ( 'display' , False ) is True : display_name = cfg . get ( 'display' , 'fvc_xpa_target' , fallback = 'FVC' ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { lastfile . read () } \" , '<' , f \" { lastfile . read () } \" ] log . debug ( f \"Running: { ' ' . join ( ds9cmd ) } \" ) subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_ { camera . lower () } fvc.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] log . debug ( f \"Running: { ' ' . join ( overlaycmd ) } \" ) subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) return kpffvc [ f \" { camera } LASTFILE\" ] . read () @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' , 'SCI' ) kpffvc = ktl . cache ( 'kpffvc' ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] lastfile . monitor () new_file = Path ( f \" { lastfile } \" ) log . debug ( f \" { camera } FVC LASTFILE: { new_file } \" ) if new_file . exists () == False : raise FailedPostCondition ( f 'Output file not found: { new_file } ' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) parser . add_argument ( \"--display\" , dest = \"display\" , default = False , action = \"store_true\" , help = \"Display image via engineering ds9?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeFVCExposure"},{"location":"scripts/TakeFVCExposure/#takefvcexposure","text":"Bases: KPFTranslatorFunction Take an exposure with the specified fiber viewing camera","title":"TakeFVCExposure"},{"location":"scripts/TakeFVCExposure/#kpf.fvc.TakeFVCExposure.TakeFVCExposure--args","text":":camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :wait: (bool) Wait for move to complete before returning? (default: True) :display: (bool) Display the resulting image to the engineering ds9 instance for FVCs using XPA. Source code in kpf/fvc/TakeFVCExposure.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TakeFVCExposure ( KPFTranslatorFunction ): '''Take an exposure with the specified fiber viewing camera ARGS: ===== :camera: Which FVC camera (SCI, CAHK, EXT, CAL)? :wait: (bool) Wait for move to complete before returning? (default: True) :display: (bool) Display the resulting image to the engineering ds9 instance for FVCs using XPA. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args , logger , cfg ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = kpffvc [ f ' { camera } EXPTIME' ] . read ( binary = True ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] initial_lastfile = lastfile . read () wait = args . get ( 'wait' , True ) kpffvc [ f ' { camera } EXPOSE' ] . write ( 'yes' , wait = wait ) if wait is True : timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) expr = f \"($kpffvc. { camera } LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) if wait is True and args . get ( 'display' , False ) is True : display_name = cfg . get ( 'display' , 'fvc_xpa_target' , fallback = 'FVC' ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { lastfile . read () } \" , '<' , f \" { lastfile . read () } \" ] log . debug ( f \"Running: { ' ' . join ( ds9cmd ) } \" ) subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_ { camera . lower () } fvc.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] log . debug ( f \"Running: { ' ' . join ( overlaycmd ) } \" ) subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) return kpffvc [ f \" { camera } LASTFILE\" ] . read () @classmethod def post_condition ( cls , args , logger , cfg ): camera = args . get ( 'camera' , 'SCI' ) kpffvc = ktl . cache ( 'kpffvc' ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] lastfile . monitor () new_file = Path ( f \" { lastfile } \" ) log . debug ( f \" { camera } FVC LASTFILE: { new_file } \" ) if new_file . exists () == False : raise FailedPostCondition ( f 'Output file not found: { new_file } ' ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) parser . add_argument ( \"--display\" , dest = \"display\" , default = False , action = \"store_true\" , help = \"Display image via engineering ds9?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/TakeGuiderCube/","text":"TakeGuiderCube Bases: KPFTranslatorFunction Take a \"trigger file\" from the guide camera of a given duration. ARGS: :duration: float The duration in seconds of the image set. :ImageCube: bool Collect the full cube of images? (default True) This will slow down file write considerably. Source code in kpf/guider/TakeGuiderCube.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class TakeGuiderCube ( KPFTranslatorFunction ): '''Take a \"trigger file\" from the guide camera of a given duration. ARGS: ===== :duration: `float` The duration in seconds of the image set. :ImageCube: `bool` Collect the full cube of images? (default True) This will slow down file write considerably. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'duration' , value_min = 0 ) @classmethod def perform ( cls , args , logger , cfg ): duration = float ( args . get ( 'duration' )) kpfguide = ktl . cache ( 'kpfguide' ) # Read initial conditions, so we can set them back at the end initial_trigcube = kpfguide [ 'TRIGCUBE' ] . read () initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () initial_all_loops = kpfguide [ 'ALL_LOOPS' ] . read () # Do we want to take the image cube? collect_image_cube = args . get ( 'ImageCube' , True ) set_trigcube = { True : 'Active' , False : 'Inactive' }[ collect_image_cube ] kpfguide [ 'TRIGCUBE' ] . write ( set_trigcube ) # Trigger data collection log . info ( f \"Starting guider cube data collection, duration = { duration : .1f } s\" ) StartTriggerFile . execute ({}) time . sleep ( duration ) StopTriggerFile . execute ({}) # Stop all loops if we're writing out a full image cube # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write('Inactive', wait=False) cube_file = WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_lastfile }) # Reset TRIGCUBE kpfguide [ 'TRIGCUBE' ] . write ( initial_trigcube ) # Reset ALL_LOOPS to initial values # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write(initial_all_loops) return cube_file @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration in seconds' ) parser . add_argument ( \"--noTRIGCUBE\" , dest = \"ImageCube\" , default = True , action = \"store_false\" , help = \"Collect the full image cube?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeGuiderCube"},{"location":"scripts/TakeGuiderCube/#takeguidercube","text":"Bases: KPFTranslatorFunction Take a \"trigger file\" from the guide camera of a given duration.","title":"TakeGuiderCube"},{"location":"scripts/TakeGuiderCube/#kpf.guider.TakeGuiderCube.TakeGuiderCube--args","text":":duration: float The duration in seconds of the image set. :ImageCube: bool Collect the full cube of images? (default True) This will slow down file write considerably. Source code in kpf/guider/TakeGuiderCube.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class TakeGuiderCube ( KPFTranslatorFunction ): '''Take a \"trigger file\" from the guide camera of a given duration. ARGS: ===== :duration: `float` The duration in seconds of the image set. :ImageCube: `bool` Collect the full cube of images? (default True) This will slow down file write considerably. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'duration' , value_min = 0 ) @classmethod def perform ( cls , args , logger , cfg ): duration = float ( args . get ( 'duration' )) kpfguide = ktl . cache ( 'kpfguide' ) # Read initial conditions, so we can set them back at the end initial_trigcube = kpfguide [ 'TRIGCUBE' ] . read () initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () initial_all_loops = kpfguide [ 'ALL_LOOPS' ] . read () # Do we want to take the image cube? collect_image_cube = args . get ( 'ImageCube' , True ) set_trigcube = { True : 'Active' , False : 'Inactive' }[ collect_image_cube ] kpfguide [ 'TRIGCUBE' ] . write ( set_trigcube ) # Trigger data collection log . info ( f \"Starting guider cube data collection, duration = { duration : .1f } s\" ) StartTriggerFile . execute ({}) time . sleep ( duration ) StopTriggerFile . execute ({}) # Stop all loops if we're writing out a full image cube # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write('Inactive', wait=False) cube_file = WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_lastfile }) # Reset TRIGCUBE kpfguide [ 'TRIGCUBE' ] . write ( initial_trigcube ) # Reset ALL_LOOPS to initial values # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write(initial_all_loops) return cube_file @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration in seconds' ) parser . add_argument ( \"--noTRIGCUBE\" , dest = \"ImageCube\" , default = True , action = \"store_false\" , help = \"Collect the full image cube?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/TakeGuiderExposure/","text":"TakeGuiderExposure Bases: KPFTranslatorFunction Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. ARGS: None Source code in kpf/guider/TakeGuiderExposure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class TakeGuiderExposure ( KPFTranslatorFunction ): '''Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) lastfile = kpfguide [ 'LASTFILE' ] if guider_is_active (): if guider_is_saving (): GrabGuiderExposure . execute ({}) else : # not sure what right action is here log . warning ( 'Guider is active, but not saving. No image saved.' ) else : TriggerSingleGuiderExposure . execute ({}) lastfile . monitor () lastfile . wait ( timeout = exptime * 2 + 1 ) # Wait for update which signals a new file @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"TakeGuiderExposure"},{"location":"scripts/TakeGuiderExposure/#takeguiderexposure","text":"Bases: KPFTranslatorFunction Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure.","title":"TakeGuiderExposure"},{"location":"scripts/TakeGuiderExposure/#kpf.guider.TakeGuiderExposure.TakeGuiderExposure--args","text":"None Source code in kpf/guider/TakeGuiderExposure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class TakeGuiderExposure ( KPFTranslatorFunction ): '''Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfguide = ktl . cache ( 'kpfguide' ) exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) lastfile = kpfguide [ 'LASTFILE' ] if guider_is_active (): if guider_is_saving (): GrabGuiderExposure . execute ({}) else : # not sure what right action is here log . warning ( 'Guider is active, but not saving. No image saved.' ) else : TriggerSingleGuiderExposure . execute ({}) lastfile . monitor () lastfile . wait ( timeout = exptime * 2 + 1 ) # Wait for update which signals a new file @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/TakeGuiderSensitivityData/","text":"TakeGuiderSensitivityData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeGuiderSensitivityData.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TakeGuiderSensitivityData ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_tgsd' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.3' ) check_input ( OB , 'FPSvalues' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) images_file = log_dir / Path ( f ' { this_file_name } _images_ { now_str } .txt' ) images = Table ( names = ( 'cube file' , 'fps' ), dtype = ( 'a90' , 'f4' )) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Guider gain is { kpfguide [ 'GAIN' ] . read () } \" ) log . info ( f \"Ensuring TRIGCUBE is Active\" ) kpfguide [ 'TRIGCUBE' ] . write ( 'Active' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read ( binary = True ) cube_duration = OB . get ( 'cube_duration' ) for FPS in OB . get ( 'FPSvalues' ): log . info ( f \"Setting FPS to { FPS } \" ) SetGuiderFPS . execute ({ 'GuideFPS' : FPS }) # Start cube collection log . info ( f 'Starting data collection for { cube_duration } s' ) initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () kpfguide [ 'TRIGGER' ] . write ( 'Active' ) log . debug ( f \"Sleeping { cube_duration } s\" ) time . sleep ( cube_duration ) # End cube collection kpfguide [ 'TRIGGER' ] . write ( 'Inactive' , wait = False ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) # Wait for cube file to be updated ktl . waitFor ( f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \" cube file: { cube_file } \" ) if all_loops == 1 : kpfguide [ 'ALL_LOOPS' ] . write ( 1 ) row = { 'cube file' : cube_file , 'fps' : FPS } images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"TakeGuiderSensitivityData"},{"location":"scripts/TakeGuiderSensitivityData/#takeguidersensitivitydata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeGuiderSensitivityData.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TakeGuiderSensitivityData ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_tgsd' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.3' ) check_input ( OB , 'FPSvalues' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) images_file = log_dir / Path ( f ' { this_file_name } _images_ { now_str } .txt' ) images = Table ( names = ( 'cube file' , 'fps' ), dtype = ( 'a90' , 'f4' )) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Guider gain is { kpfguide [ 'GAIN' ] . read () } \" ) log . info ( f \"Ensuring TRIGCUBE is Active\" ) kpfguide [ 'TRIGCUBE' ] . write ( 'Active' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read ( binary = True ) cube_duration = OB . get ( 'cube_duration' ) for FPS in OB . get ( 'FPSvalues' ): log . info ( f \"Setting FPS to { FPS } \" ) SetGuiderFPS . execute ({ 'GuideFPS' : FPS }) # Start cube collection log . info ( f 'Starting data collection for { cube_duration } s' ) initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () kpfguide [ 'TRIGGER' ] . write ( 'Active' ) log . debug ( f \"Sleeping { cube_duration } s\" ) time . sleep ( cube_duration ) # End cube collection kpfguide [ 'TRIGGER' ] . write ( 'Inactive' , wait = False ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) # Wait for cube file to be updated ktl . waitFor ( f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \" cube file: { cube_file } \" ) if all_loops == 1 : kpfguide [ 'ALL_LOOPS' ] . write ( 1 ) row = { 'cube file' : cube_file , 'fps' : FPS } images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"TakeGuiderSensitivityData"},{"location":"scripts/TakeIntensityReading/","text":"TakeIntensityReading Bases: KPFTranslatorFunction Description Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. KTL Keywords Used kpflamps.INTENSEMON kpfcal.SERIALCONN kpfcal.INTENMON kpfcal.NAVG kpfcal.AVG kpfcal.MEASURING Scripts Called kpf.utils.SendEmail Parameters None Source code in kpf/calbench/TakeIntensityReading.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class TakeIntensityReading ( KPFTranslatorFunction ): '''# Description Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. ## KTL Keywords Used - `kpflamps.INTENSEMON` - `kpfcal.SERIALCONN` - `kpfcal.INTENMON` - `kpfcal.NAVG` - `kpfcal.AVG` - `kpfcal.MEASURING` ## Scripts Called - `kpf.utils.SendEmail` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfcal = ktl . cache ( 'kpfcal' ) intensemon = ktl . cache ( 'kpflamps' , 'INTENSEMON' ) # Turn on intensity monitor if intensemon . read () == 'Off' : log . debug ( 'Turning kpflamps.INTENSEMON on' ) intensemon . write ( 'On' ) boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) time . sleep ( boottime ) # Verify serial connection is active if kpfcal [ 'SERIALCONN' ] . read () == 'Off' : log . debug ( 'Initiating serial connection' ) kpfcal [ 'SERIALCONN' ] . write ( 'On' ) expr = f \"($kpfcal.SERIALCONN == 'On')\" boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) success = ktl . waitFor ( expr , timeout = boottime ) if success is False : msg = f 'Intensity monitor serial connection is Off' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor in to beam log . info ( 'Moving Intensity Monitor in to beam' ) kpfcal [ 'INTENMON' ] . write ( 'Boresight' ) # Set averaging navg = cfg . getfloat ( 'times' , 'intenmon_avg_time' , fallback = 60 ) log . info ( f 'Starting measurement: NAVG= { navg } ' ) kpfcal [ 'NAVG' ] . write ( navg ) kpfcal [ 'AVG' ] . write ( 'On' ) # Check whether measuring is taking place expr = f \"($kpfcal.MEASURING == 'Yes')\" success = ktl . waitFor ( expr , timeout = 5 ) if success is False : msg = f 'Intensity monitor is not measuring' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Wait for readings to be complete expr = f \"($kpfcal.AVG == 'Off')\" success = ktl . waitFor ( expr , timeout = navg + 10 ) if success is False : msg = f 'Intensity monitor measurement timed out' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor out of beam log . info ( 'Moving Intensity Monitor out of beam' ) kpfcal [ 'INTENMON' ] . write ( 'Out' ) # Turn off intensity monitor log . debug ( 'Turning kpflamps.INTENSEMON off' ) intensemon . write ( 'Off' ) log . debug ( 'Turning kpfcal.SERIALCONN off' ) kpfcal [ 'SERIALCONN' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"TakeIntensityReading"},{"location":"scripts/TakeIntensityReading/#takeintensityreading","text":"Bases: KPFTranslatorFunction","title":"TakeIntensityReading"},{"location":"scripts/TakeIntensityReading/#kpf.calbench.TakeIntensityReading.TakeIntensityReading--description","text":"Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity.","title":"Description"},{"location":"scripts/TakeIntensityReading/#kpf.calbench.TakeIntensityReading.TakeIntensityReading--ktl-keywords-used","text":"kpflamps.INTENSEMON kpfcal.SERIALCONN kpfcal.INTENMON kpfcal.NAVG kpfcal.AVG kpfcal.MEASURING","title":"KTL Keywords Used"},{"location":"scripts/TakeIntensityReading/#kpf.calbench.TakeIntensityReading.TakeIntensityReading--scripts-called","text":"kpf.utils.SendEmail","title":"Scripts Called"},{"location":"scripts/TakeIntensityReading/#kpf.calbench.TakeIntensityReading.TakeIntensityReading--parameters","text":"None Source code in kpf/calbench/TakeIntensityReading.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class TakeIntensityReading ( KPFTranslatorFunction ): '''# Description Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. ## KTL Keywords Used - `kpflamps.INTENSEMON` - `kpfcal.SERIALCONN` - `kpfcal.INTENMON` - `kpfcal.NAVG` - `kpfcal.AVG` - `kpfcal.MEASURING` ## Scripts Called - `kpf.utils.SendEmail` ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfcal = ktl . cache ( 'kpfcal' ) intensemon = ktl . cache ( 'kpflamps' , 'INTENSEMON' ) # Turn on intensity monitor if intensemon . read () == 'Off' : log . debug ( 'Turning kpflamps.INTENSEMON on' ) intensemon . write ( 'On' ) boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) time . sleep ( boottime ) # Verify serial connection is active if kpfcal [ 'SERIALCONN' ] . read () == 'Off' : log . debug ( 'Initiating serial connection' ) kpfcal [ 'SERIALCONN' ] . write ( 'On' ) expr = f \"($kpfcal.SERIALCONN == 'On')\" boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) success = ktl . waitFor ( expr , timeout = boottime ) if success is False : msg = f 'Intensity monitor serial connection is Off' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor in to beam log . info ( 'Moving Intensity Monitor in to beam' ) kpfcal [ 'INTENMON' ] . write ( 'Boresight' ) # Set averaging navg = cfg . getfloat ( 'times' , 'intenmon_avg_time' , fallback = 60 ) log . info ( f 'Starting measurement: NAVG= { navg } ' ) kpfcal [ 'NAVG' ] . write ( navg ) kpfcal [ 'AVG' ] . write ( 'On' ) # Check whether measuring is taking place expr = f \"($kpfcal.MEASURING == 'Yes')\" success = ktl . waitFor ( expr , timeout = 5 ) if success is False : msg = f 'Intensity monitor is not measuring' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Wait for readings to be complete expr = f \"($kpfcal.AVG == 'Off')\" success = ktl . waitFor ( expr , timeout = navg + 10 ) if success is False : msg = f 'Intensity monitor measurement timed out' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor out of beam log . info ( 'Moving Intensity Monitor out of beam' ) kpfcal [ 'INTENMON' ] . write ( 'Out' ) # Turn off intensity monitor log . debug ( 'Turning kpflamps.INTENSEMON off' ) intensemon . write ( 'Off' ) log . debug ( 'Turning kpfcal.SERIALCONN off' ) kpfcal [ 'SERIALCONN' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/TestTipTiltMirrorRange/","text":"TestTipTiltMirrorRange Bases: KPFTranslatorFunction ARGS: None Source code in kpf/fiu/TestTipTiltMirrorRange.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class TestTipTiltMirrorRange ( KPFTranslatorFunction ): ''' ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Measure tip tilt ranges log . info ( 'Beginning TestTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) axis = [ 'X' , 'Y' ] for i , ax in enumerate ( axis ): nominal_range = kpfguide [ f 'TIPTILT_ { ax } RANGE' ] . read ( binary = True ) home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True )[ i ] commanded_position = home - nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) commanded_position = home + nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) time . sleep ( movetime * 100 ) InitializeTipTilt . execute ({}) time . sleep ( movetime * 100 ) ShutdownTipTilt . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"TestTipTiltMirrorRange"},{"location":"scripts/TestTipTiltMirrorRange/#testtiptiltmirrorrange","text":"Bases: KPFTranslatorFunction","title":"TestTipTiltMirrorRange"},{"location":"scripts/TestTipTiltMirrorRange/#kpf.fiu.TestTipTiltMirrorRange.TestTipTiltMirrorRange--args","text":"None Source code in kpf/fiu/TestTipTiltMirrorRange.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class TestTipTiltMirrorRange ( KPFTranslatorFunction ): ''' ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # Measure tip tilt ranges log . info ( 'Beginning TestTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) axis = [ 'X' , 'Y' ] for i , ax in enumerate ( axis ): nominal_range = kpfguide [ f 'TIPTILT_ { ax } RANGE' ] . read ( binary = True ) home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True )[ i ] commanded_position = home - nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) commanded_position = home + nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) time . sleep ( movetime * 100 ) InitializeTipTilt . execute ({}) time . sleep ( movetime * 100 ) ShutdownTipTilt . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/TriggerGreenMiniFill/","text":"TriggerGreenMiniFill Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerGreenMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerGreenMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Green fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting green mini fill' ) kpffill [ 'GREENSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'GREENFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping green mini fill' ) kpffill [ 'GREENSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected green mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : msg = 'Green still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerGreenMiniFill"},{"location":"scripts/TriggerGreenMiniFill/#triggergreenminifill","text":"Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerGreenMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerGreenMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Green fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting green mini fill' ) kpffill [ 'GREENSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'GREENFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping green mini fill' ) kpffill [ 'GREENSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected green mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : msg = 'Green still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerGreenMiniFill"},{"location":"scripts/TriggerRedMiniFill/","text":"TriggerRedMiniFill Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerRedMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerRedMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'REDFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Red fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting Red mini fill' ) kpffill [ 'REDSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'REDFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping Red mini fill' ) kpffill [ 'REDSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected Red mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'RedFILLIP' ] . read () == 'True' : msg = 'Red still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerRedMiniFill"},{"location":"scripts/TriggerRedMiniFill/#triggerredminifill","text":"Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerRedMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerRedMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'REDFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Red fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting Red mini fill' ) kpffill [ 'REDSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'REDFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping Red mini fill' ) kpffill [ 'REDSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected Red mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'RedFILLIP' ] . read () == 'True' : msg = 'Red still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerRedMiniFill"},{"location":"scripts/TurnHepaOff/","text":"TurnHepaOff Bases: KPFTranslatorFunction Description Turn HEPA Filter system off KTL Keywords Used ao.OBHPAON ao.OBHPASTA Scripts Called None Parameters None Source code in kpf/ao/TurnHepaOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnHepaOff ( KPFTranslatorFunction ): '''# Description Turn HEPA Filter system off ## KTL Keywords Used - `ao.OBHPAON` - `ao.OBHPASTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Setting AO HEPA filter to off' ) ao [ 'OBHPAON' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBHPASTA == off)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBHPASTA' ] . read (), 'off' )","title":"TurnHepaOff"},{"location":"scripts/TurnHepaOff/#turnhepaoff","text":"Bases: KPFTranslatorFunction","title":"TurnHepaOff"},{"location":"scripts/TurnHepaOff/#kpf.ao.TurnHepaOff.TurnHepaOff--description","text":"Turn HEPA Filter system off","title":"Description"},{"location":"scripts/TurnHepaOff/#kpf.ao.TurnHepaOff.TurnHepaOff--ktl-keywords-used","text":"ao.OBHPAON ao.OBHPASTA","title":"KTL Keywords Used"},{"location":"scripts/TurnHepaOff/#kpf.ao.TurnHepaOff.TurnHepaOff--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/TurnHepaOff/#kpf.ao.TurnHepaOff.TurnHepaOff--parameters","text":"None Source code in kpf/ao/TurnHepaOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnHepaOff ( KPFTranslatorFunction ): '''# Description Turn HEPA Filter system off ## KTL Keywords Used - `ao.OBHPAON` - `ao.OBHPASTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Setting AO HEPA filter to off' ) ao [ 'OBHPAON' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBHPASTA == off)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBHPASTA' ] . read (), 'off' )","title":"Parameters"},{"location":"scripts/TurnHepaOn/","text":"TurnHepaOn Bases: KPFTranslatorFunction Description Turn HEPA Filter system on KTL Keywords Used ao.OBHPAON ao.OBHPASTA Scripts Called None Parameters None Source code in kpf/ao/TurnHepaOn.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnHepaOn ( KPFTranslatorFunction ): '''# Description Turn HEPA Filter system on ## KTL Keywords Used - `ao.OBHPAON` - `ao.OBHPASTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Setting AO HEPA filter to on' ) ao [ 'OBHPAON' ] . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBHPASTA == on)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBHPASTA' ] . read (), 'on' )","title":"TurnHepaOn"},{"location":"scripts/TurnHepaOn/#turnhepaon","text":"Bases: KPFTranslatorFunction","title":"TurnHepaOn"},{"location":"scripts/TurnHepaOn/#kpf.ao.TurnHepaOn.TurnHepaOn--description","text":"Turn HEPA Filter system on","title":"Description"},{"location":"scripts/TurnHepaOn/#kpf.ao.TurnHepaOn.TurnHepaOn--ktl-keywords-used","text":"ao.OBHPAON ao.OBHPASTA","title":"KTL Keywords Used"},{"location":"scripts/TurnHepaOn/#kpf.ao.TurnHepaOn.TurnHepaOn--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/TurnHepaOn/#kpf.ao.TurnHepaOn.TurnHepaOn--parameters","text":"None Source code in kpf/ao/TurnHepaOn.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnHepaOn ( KPFTranslatorFunction ): '''# Description Turn HEPA Filter system on ## KTL Keywords Used - `ao.OBHPAON` - `ao.OBHPASTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Setting AO HEPA filter to on' ) ao [ 'OBHPAON' ] . write ( 1 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBHPASTA == on)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBHPASTA' ] . read (), 'on' )","title":"Parameters"},{"location":"scripts/TurnLightSourceOff/","text":"TurnLightSourceOff Bases: KPFTranslatorFunction Description Turn K1 AO light source off KTL Keywords Used ao.OBSWON ao.OBSWSTA Scripts Called None Parameters None Source code in kpf/ao/TurnLightSourceOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnLightSourceOff ( KPFTranslatorFunction ): '''# Description Turn K1 AO light source off ## KTL Keywords Used - `ao.OBSWON` - `ao.OBSWSTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Turning AO light source off' ) ao [ 'OBSWON' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBSWSTA == off)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBSWSTA' ] . read (), 'off' )","title":"TurnLightSourceOff"},{"location":"scripts/TurnLightSourceOff/#turnlightsourceoff","text":"Bases: KPFTranslatorFunction","title":"TurnLightSourceOff"},{"location":"scripts/TurnLightSourceOff/#kpf.ao.TurnLightSourceOff.TurnLightSourceOff--description","text":"Turn K1 AO light source off","title":"Description"},{"location":"scripts/TurnLightSourceOff/#kpf.ao.TurnLightSourceOff.TurnLightSourceOff--ktl-keywords-used","text":"ao.OBSWON ao.OBSWSTA","title":"KTL Keywords Used"},{"location":"scripts/TurnLightSourceOff/#kpf.ao.TurnLightSourceOff.TurnLightSourceOff--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/TurnLightSourceOff/#kpf.ao.TurnLightSourceOff.TurnLightSourceOff--parameters","text":"None Source code in kpf/ao/TurnLightSourceOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class TurnLightSourceOff ( KPFTranslatorFunction ): '''# Description Turn K1 AO light source off ## KTL Keywords Used - `ao.OBSWON` - `ao.OBSWSTA` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ao = ktl . cache ( 'ao' ) log . debug ( 'Turning AO light source off' ) ao [ 'OBSWON' ] . write ( 0 ) @classmethod def post_condition ( cls , args , logger , cfg ): success = ktl . waitfor ( '($ao.OBSWSTA == off)' , timeout = 3 ) if success is not True : ao = ktl . cache ( 'ao' ) raise FailedToReachDestination ( ao [ 'OBSWSTA' ] . read (), 'off' )","title":"Parameters"},{"location":"scripts/UnlockFIU/","text":"UnlockFIU Bases: KPFTranslatorFunction Unlock the FIU mechanisms ARGS: None Source code in kpf/fiu/UnlockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class UnlockFIU ( KPFTranslatorFunction ): '''Unlock the FIU mechanisms ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( '' ) kpffiu [ 'adc2lck' ] . write ( '' ) kpffiu [ 'foldlck' ] . write ( '' ) kpffiu [ 'hkxlck=' ] . write ( '' ) kpffiu [ 'hkylck=' ] . write ( '' ) kpffiu [ 'ttxlck=' ] . write ( '' ) kpffiu [ 'ttylck=' ] . write ( '' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"UnlockFIU"},{"location":"scripts/UnlockFIU/#unlockfiu","text":"Bases: KPFTranslatorFunction Unlock the FIU mechanisms","title":"UnlockFIU"},{"location":"scripts/UnlockFIU/#kpf.fiu.UnlockFIU.UnlockFIU--args","text":"None Source code in kpf/fiu/UnlockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class UnlockFIU ( KPFTranslatorFunction ): '''Unlock the FIU mechanisms ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( '' ) kpffiu [ 'adc2lck' ] . write ( '' ) kpffiu [ 'foldlck' ] . write ( '' ) kpffiu [ 'hkxlck=' ] . write ( '' ) kpffiu [ 'hkylck=' ] . write ( '' ) kpffiu [ 'ttxlck=' ] . write ( '' ) kpffiu [ 'ttylck=' ] . write ( '' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/VerifyCurrentBase/","text":"VerifyCurrentBase Bases: KPFTranslatorFunction Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) ARGS: None Source code in kpf/fiu/VerifyCurrentBase.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class VerifyCurrentBase ( KPFTranslatorFunction ): '''Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ponamekw = ktl . cache ( 'dcs1' , 'PONAME' ) poname = ponamekw . read () . upper () kpfguide = ktl . cache ( 'kpfguide' ) current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) science_base = kpfguide [ 'SCIENCE_BASE' ] . read ( binary = True ) sky_base = kpfguide [ 'SKY_BASE' ] . read ( binary = True ) science_match = np . all ( np . isclose ( current_base , science_base , atol = 0.01 )) sky_match = np . all ( np . isclose ( current_base , sky_base , atol = 0.01 )) msg = f \"CURRENT_BASE=\" if science_match : log . debug ( f \"CURRENT_BASE is science fiber, PO = { poname } \" ) msg += 'SCIENCE_BASE' elif sky_match : log . debug ( f \"CURRENT_BASE is sky fiber, PO = { poname } \" ) msg += 'SKY_BASE' else : log . debug ( f \"CURRENT_BASE is { current_base } , PO = { poname } \" ) msg += 'custom' poname_match = ( science_match and poname == 'KPF' ) \\ or ( sky_match and poname == 'SKY' ) if poname_match : msg += f \" which is consistent with PONAME= { poname } \" log . debug ( msg ) else : msg += f \" which is NOT consistent with PONAME= { poname } \" log . error ( msg ) print ( msg ) return poname_match @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"VerifyCurrentBase"},{"location":"scripts/VerifyCurrentBase/#verifycurrentbase","text":"Bases: KPFTranslatorFunction Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME)","title":"VerifyCurrentBase"},{"location":"scripts/VerifyCurrentBase/#kpf.fiu.VerifyCurrentBase.VerifyCurrentBase--args","text":"None Source code in kpf/fiu/VerifyCurrentBase.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class VerifyCurrentBase ( KPFTranslatorFunction ): '''Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): ponamekw = ktl . cache ( 'dcs1' , 'PONAME' ) poname = ponamekw . read () . upper () kpfguide = ktl . cache ( 'kpfguide' ) current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) science_base = kpfguide [ 'SCIENCE_BASE' ] . read ( binary = True ) sky_base = kpfguide [ 'SKY_BASE' ] . read ( binary = True ) science_match = np . all ( np . isclose ( current_base , science_base , atol = 0.01 )) sky_match = np . all ( np . isclose ( current_base , sky_base , atol = 0.01 )) msg = f \"CURRENT_BASE=\" if science_match : log . debug ( f \"CURRENT_BASE is science fiber, PO = { poname } \" ) msg += 'SCIENCE_BASE' elif sky_match : log . debug ( f \"CURRENT_BASE is sky fiber, PO = { poname } \" ) msg += 'SKY_BASE' else : log . debug ( f \"CURRENT_BASE is { current_base } , PO = { poname } \" ) msg += 'custom' poname_match = ( science_match and poname == 'KPF' ) \\ or ( sky_match and poname == 'SKY' ) if poname_match : msg += f \" which is consistent with PONAME= { poname } \" log . debug ( msg ) else : msg += f \" which is NOT consistent with PONAME= { poname } \" log . error ( msg ) print ( msg ) return poname_match @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/WaitForCalSource/","text":"WaitForCalSource Bases: KPFTranslatorFunction Description Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). KTL Keywords Used kpfcal.OCTAGON Scripts Called None Parameters CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber Source code in kpf/calbench/WaitForCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class WaitForCalSource ( KPFTranslatorFunction ): '''# Description Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). ## KTL Keywords Used - `kpfcal.OCTAGON` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for octagon\" ) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'OCTAGON' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForCalSource"},{"location":"scripts/WaitForCalSource/#waitforcalsource","text":"Bases: KPFTranslatorFunction","title":"WaitForCalSource"},{"location":"scripts/WaitForCalSource/#kpf.calbench.WaitForCalSource.WaitForCalSource--description","text":"Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword).","title":"Description"},{"location":"scripts/WaitForCalSource/#kpf.calbench.WaitForCalSource.WaitForCalSource--ktl-keywords-used","text":"kpfcal.OCTAGON","title":"KTL Keywords Used"},{"location":"scripts/WaitForCalSource/#kpf.calbench.WaitForCalSource.WaitForCalSource--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/WaitForCalSource/#kpf.calbench.WaitForCalSource.WaitForCalSource--parameters","text":"CalSource ( str ) Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber Source code in kpf/calbench/WaitForCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class WaitForCalSource ( KPFTranslatorFunction ): '''# Description Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). ## KTL Keywords Used - `kpfcal.OCTAGON` ## Scripts Called None ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for octagon\" ) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfcal = ktl . cache ( 'kpfcal' ) raise FailedToReachDestination ( kpfcal [ 'OCTAGON' ] . read (), target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForConfigureCalibrations/","text":"WaitForConfigureCalibrations Bases: KPFTranslatorFunction Script which waits for the instrument to be configured for calibrations. ARGS: None Source code in kpf/scripts/WaitForConfigureCalibrations.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class WaitForConfigureCalibrations ( KPFTranslatorFunction ): '''Script which waits for the instrument to be configured for calibrations. ARGS: ===== None ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , OB , logger , cfg ): WaitForCalSource . execute ( OB ) WaitForConfigureFIU . execute ({ 'mode' : 'Calibration' }) WaitForReady . execute ({}) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"WaitForConfigureCalibrations"},{"location":"scripts/WaitForConfigureCalibrations/#waitforconfigurecalibrations","text":"Bases: KPFTranslatorFunction Script which waits for the instrument to be configured for calibrations.","title":"WaitForConfigureCalibrations"},{"location":"scripts/WaitForConfigureCalibrations/#kpf.scripts.WaitForConfigureCalibrations.WaitForConfigureCalibrations--args","text":"None Source code in kpf/scripts/WaitForConfigureCalibrations.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class WaitForConfigureCalibrations ( KPFTranslatorFunction ): '''Script which waits for the instrument to be configured for calibrations. ARGS: ===== None ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_cal' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.5' ) @classmethod def perform ( cls , OB , logger , cfg ): WaitForCalSource . execute ( OB ) WaitForConfigureFIU . execute ({ 'mode' : 'Calibration' }) WaitForReady . execute ({}) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/WaitForConfigureFIU/","text":"WaitForConfigureFIU Bases: KPFTranslatorFunction Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. ARGS: :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration Source code in kpf/fiu/WaitForConfigureFIU.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class WaitForConfigureFIU ( KPFTranslatorFunction ): '''Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. ARGS: ===== :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) ntries = cfg . getint ( 'retries' , 'fiu_mode_tries' , fallback = 2 ) shim_time = cfg . getfloat ( 'times' , 'fiu_mode_shim_time' , fallback = 2 ) for i in range ( ntries ): ok = WaitForConfigureFIUOnce . execute ({ 'mode' : dest }) if ok is False : log . warning ( f 'FIU move failed on attempt { i + 1 } of { ntries } ' ) time . sleep ( shim_time ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : True }) else : break @classmethod def post_condition ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) kpffiu = ktl . cache ( 'kpffiu' ) modes = kpffiu [ 'MODE' ] . read () if dest . lower () not in modes . lower () . split ( ',' ): raise FailedToReachDestination ( modes , dest ) else : log . info ( f \"FIU mode is now { dest } \" ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForConfigureFIU"},{"location":"scripts/WaitForConfigureFIU/#waitforconfigurefiu","text":"Bases: KPFTranslatorFunction Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination.","title":"WaitForConfigureFIU"},{"location":"scripts/WaitForConfigureFIU/#kpf.fiu.WaitForConfigureFIU.WaitForConfigureFIU--args","text":":mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration Source code in kpf/fiu/WaitForConfigureFIU.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class WaitForConfigureFIU ( KPFTranslatorFunction ): '''Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. ARGS: ===== :mode: The desired FIU mode. One of: Stowed, Alignment, Acquisition, Observing, Calibration ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) ntries = cfg . getint ( 'retries' , 'fiu_mode_tries' , fallback = 2 ) shim_time = cfg . getfloat ( 'times' , 'fiu_mode_shim_time' , fallback = 2 ) for i in range ( ntries ): ok = WaitForConfigureFIUOnce . execute ({ 'mode' : dest }) if ok is False : log . warning ( f 'FIU move failed on attempt { i + 1 } of { ntries } ' ) time . sleep ( shim_time ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : True }) else : break @classmethod def post_condition ( cls , args , logger , cfg ): dest = args . get ( 'mode' ) kpffiu = ktl . cache ( 'kpffiu' ) modes = kpffiu [ 'MODE' ] . read () if dest . lower () not in modes . lower () . split ( ',' ): raise FailedToReachDestination ( modes , dest ) else : log . info ( f \"FIU mode is now { dest } \" ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) return super () . add_cmdline_args ( parser , cfg )","title":"ARGS:"},{"location":"scripts/WaitForFlatFieldFiberPos/","text":"WaitForFlatFieldFiberPos Bases: KPFTranslatorFunction Description Wait for the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. KTL Keywords Used kpfcal.FF_FIBERPOS Scripts Called None Parameters FF_FiberPos ( str ) The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" Source code in kpf/calbench/WaitForFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WaitForFlatFieldFiberPos ( KPFTranslatorFunction ): '''# Description Wait for the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. ## KTL Keywords Used - `kpfcal.FF_FIBERPOS` ## Scripts Called None ## Parameters **FF_FiberPos** (`str`) > The name of the flat field fiber position desired. <br>Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for FF_FiberPos filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = 0.1 ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForFlatFieldFiberPos"},{"location":"scripts/WaitForFlatFieldFiberPos/#waitforflatfieldfiberpos","text":"Bases: KPFTranslatorFunction","title":"WaitForFlatFieldFiberPos"},{"location":"scripts/WaitForFlatFieldFiberPos/#kpf.calbench.WaitForFlatFieldFiberPos.WaitForFlatFieldFiberPos--description","text":"Wait for the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword.","title":"Description"},{"location":"scripts/WaitForFlatFieldFiberPos/#kpf.calbench.WaitForFlatFieldFiberPos.WaitForFlatFieldFiberPos--ktl-keywords-used","text":"kpfcal.FF_FIBERPOS","title":"KTL Keywords Used"},{"location":"scripts/WaitForFlatFieldFiberPos/#kpf.calbench.WaitForFlatFieldFiberPos.WaitForFlatFieldFiberPos--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/WaitForFlatFieldFiberPos/#kpf.calbench.WaitForFlatFieldFiberPos.WaitForFlatFieldFiberPos--parameters","text":"FF_FiberPos ( str ) The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" Source code in kpf/calbench/WaitForFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WaitForFlatFieldFiberPos ( KPFTranslatorFunction ): '''# Description Wait for the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. ## KTL Keywords Used - `kpfcal.FF_FIBERPOS` ## Scripts Called None ## Parameters **FF_FiberPos** (`str`) > The name of the flat field fiber position desired. <br>Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\" ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for FF_FiberPos filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): target = args . get ( 'FF_FiberPos' ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = 0.1 ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForLFCReady/","text":"WaitForLFCReady Bases: KPFTranslatorFunction Description Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode KTL Keywords Used kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA kpfcal.WOBBLE kpfcal.OPERATIONMODE kpfcal.SPECFLAT Scripts Called None Parameters None Source code in kpf/calbench/WaitForLFCReady.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class WaitForLFCReady ( KPFTranslatorFunction ): '''# Description Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode ## KTL Keywords Used - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` - `kpfcal.WOBBLE` - `kpfcal.OPERATIONMODE` - `kpfcal.SPECFLAT` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expr = f \"($kpfmon.HB_MENLOSTA == 'OK')\" expr += f \"and ($kpfmon.LFCREADYSTA == 'OK')\" expr += f \"and ($kpfcal.WOBBLE == 'False')\" expr += f \"and ($kpfcal.OPERATIONMODE == 'AstroComb')\" expr += f \"and ($kpfcal.SPECFLAT == 'True')\" timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 300 ) success = ktl . waitFor ( expr , timeout = timeout ) return success @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"WaitForLFCReady"},{"location":"scripts/WaitForLFCReady/#waitforlfcready","text":"Bases: KPFTranslatorFunction","title":"WaitForLFCReady"},{"location":"scripts/WaitForLFCReady/#kpf.calbench.WaitForLFCReady.WaitForLFCReady--description","text":"Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode","title":"Description"},{"location":"scripts/WaitForLFCReady/#kpf.calbench.WaitForLFCReady.WaitForLFCReady--ktl-keywords-used","text":"kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA kpfcal.WOBBLE kpfcal.OPERATIONMODE kpfcal.SPECFLAT","title":"KTL Keywords Used"},{"location":"scripts/WaitForLFCReady/#kpf.calbench.WaitForLFCReady.WaitForLFCReady--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/WaitForLFCReady/#kpf.calbench.WaitForLFCReady.WaitForLFCReady--parameters","text":"None Source code in kpf/calbench/WaitForLFCReady.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class WaitForLFCReady ( KPFTranslatorFunction ): '''# Description Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode ## KTL Keywords Used - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` - `kpfcal.WOBBLE` - `kpfcal.OPERATIONMODE` - `kpfcal.SPECFLAT` ## Scripts Called None ## Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): expr = f \"($kpfmon.HB_MENLOSTA == 'OK')\" expr += f \"and ($kpfmon.LFCREADYSTA == 'OK')\" expr += f \"and ($kpfcal.WOBBLE == 'False')\" expr += f \"and ($kpfcal.OPERATIONMODE == 'AstroComb')\" expr += f \"and ($kpfcal.SPECFLAT == 'True')\" timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 300 ) success = ktl . waitFor ( expr , timeout = timeout ) return success @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/WaitForLampWarm/","text":"WaitForLampWarm Bases: KPFTranslatorFunction Description Wait for the specified lamp to be warm. KTL Keywords Used kpflamps.FF_FIBER_STATUS kpflamps.FF_FIBER_TIMEON kpflamps.FF_FIBER_THRESHOLD kpflamps.BRDBANDFIBER_STATUS kpflamps.BRDBANDFIBER_TIMEON kpflamps.BRDBANDFIBER_THRESHOLD kpflamps.TH_DAILY_STATUS kpflamps.TH_DAILY_TIMEON kpflamps.TH_DAILY_THRESHOLD kpflamps.TH_GOLD_STATUS kpflamps.TH_GOLD_TIMEON kpflamps.TH_GOLD_THRESHOLD kpflamps.U_DAILY_STATUS kpflamps.U_DAILY_TIMEON kpflamps.U_DAILY_THRESHOLD kpflamps.U_GOLD_STATUS kpflamps.U_GOLD_TIMEON kpflamps.U_GOLD_THRESHOLD Scripts Called kpf.calbench.CalLampPower Parameters CalSource ( str ) Which lamp to check? Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat Source code in kpf/calbench/WaitForLampWarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class WaitForLampWarm ( KPFTranslatorFunction ): '''# Description Wait for the specified lamp to be warm. ## KTL Keywords Used - `kpflamps.FF_FIBER_STATUS` - `kpflamps.FF_FIBER_TIMEON` - `kpflamps.FF_FIBER_THRESHOLD` - `kpflamps.BRDBANDFIBER_STATUS` - `kpflamps.BRDBANDFIBER_TIMEON` - `kpflamps.BRDBANDFIBER_THRESHOLD` - `kpflamps.TH_DAILY_STATUS` - `kpflamps.TH_DAILY_TIMEON` - `kpflamps.TH_DAILY_THRESHOLD` - `kpflamps.TH_GOLD_STATUS` - `kpflamps.TH_GOLD_TIMEON` - `kpflamps.TH_GOLD_THRESHOLD` - `kpflamps.U_DAILY_STATUS` - `kpflamps.U_DAILY_TIMEON` - `kpflamps.U_DAILY_THRESHOLD` - `kpflamps.U_GOLD_STATUS` - `kpflamps.U_GOLD_TIMEON` - `kpflamps.U_GOLD_THRESHOLD` ## Scripts Called - `kpf.calbench.CalLampPower` ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'CalSource' ) @classmethod def perform ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : kpflamps = ktl . cache ( 'kpflamps' ) log . debug ( f 'Lamp { lamp } does need to be warmed up before use' ) # Check that lamp is actually on lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : log . warning ( f \"Lamp { lamp } is not on: { lamp_status } \" ) CalLampPower . execute ({ 'lamp' : args . get ( 'CalSource' ), 'power' : 'on' }) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : raise KPFException ( f \"Lamp { lamp } should be on: { lamp_status } \" ) elif lamp_status == 'Warm' : log . debug ( f \"Lamp { lamp } is warm\" ) elif lamp_status == 'Warming' : lamp_timeon = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) lamp_threshold = kpflamps [ f ' { lamp } _THRESHOLD' ] . read ( binary = True ) time_to_wait = lamp_threshold - lamp_timeon log . info ( f \"Lamp { lamp } is warming\" ) log . info ( f \"Estimated time remaining = { time_to_wait : .0f } s\" ) while lamp_statuskw . read () != 'Warm' : # Check if scriptstop has been activated check_scriptstop () log . debug ( f 'Waiting for { lamp } _STATUS == Warm' ) expr = f \"($kpflamps. { lamp } _STATUS == 'Warm')\" warm = ktl . waitFor ( expr , timeout = 30 ) if warm is False : new_lamp_timeton = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) if new_lamp_timeton <= lamp_timeon : break lamp_timeon = new_lamp_timeton @classmethod def post_condition ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status != 'Warm' : raise FailedPostCondition ( f \"Lamp { lamp } should be warm: { lamp_status } \" ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' ], help = 'Which lamp are we waiting on?' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForLampWarm"},{"location":"scripts/WaitForLampWarm/#waitforlampwarm","text":"Bases: KPFTranslatorFunction","title":"WaitForLampWarm"},{"location":"scripts/WaitForLampWarm/#kpf.calbench.WaitForLampWarm.WaitForLampWarm--description","text":"Wait for the specified lamp to be warm.","title":"Description"},{"location":"scripts/WaitForLampWarm/#kpf.calbench.WaitForLampWarm.WaitForLampWarm--ktl-keywords-used","text":"kpflamps.FF_FIBER_STATUS kpflamps.FF_FIBER_TIMEON kpflamps.FF_FIBER_THRESHOLD kpflamps.BRDBANDFIBER_STATUS kpflamps.BRDBANDFIBER_TIMEON kpflamps.BRDBANDFIBER_THRESHOLD kpflamps.TH_DAILY_STATUS kpflamps.TH_DAILY_TIMEON kpflamps.TH_DAILY_THRESHOLD kpflamps.TH_GOLD_STATUS kpflamps.TH_GOLD_TIMEON kpflamps.TH_GOLD_THRESHOLD kpflamps.U_DAILY_STATUS kpflamps.U_DAILY_TIMEON kpflamps.U_DAILY_THRESHOLD kpflamps.U_GOLD_STATUS kpflamps.U_GOLD_TIMEON kpflamps.U_GOLD_THRESHOLD","title":"KTL Keywords Used"},{"location":"scripts/WaitForLampWarm/#kpf.calbench.WaitForLampWarm.WaitForLampWarm--scripts-called","text":"kpf.calbench.CalLampPower","title":"Scripts Called"},{"location":"scripts/WaitForLampWarm/#kpf.calbench.WaitForLampWarm.WaitForLampWarm--parameters","text":"CalSource ( str ) Which lamp to check? Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat Source code in kpf/calbench/WaitForLampWarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class WaitForLampWarm ( KPFTranslatorFunction ): '''# Description Wait for the specified lamp to be warm. ## KTL Keywords Used - `kpflamps.FF_FIBER_STATUS` - `kpflamps.FF_FIBER_TIMEON` - `kpflamps.FF_FIBER_THRESHOLD` - `kpflamps.BRDBANDFIBER_STATUS` - `kpflamps.BRDBANDFIBER_TIMEON` - `kpflamps.BRDBANDFIBER_THRESHOLD` - `kpflamps.TH_DAILY_STATUS` - `kpflamps.TH_DAILY_TIMEON` - `kpflamps.TH_DAILY_THRESHOLD` - `kpflamps.TH_GOLD_STATUS` - `kpflamps.TH_GOLD_TIMEON` - `kpflamps.TH_GOLD_THRESHOLD` - `kpflamps.U_DAILY_STATUS` - `kpflamps.U_DAILY_TIMEON` - `kpflamps.U_DAILY_THRESHOLD` - `kpflamps.U_GOLD_STATUS` - `kpflamps.U_GOLD_TIMEON` - `kpflamps.U_GOLD_THRESHOLD` ## Scripts Called - `kpf.calbench.CalLampPower` ## Parameters **CalSource** (`str`) > Which lamp to check? <br>Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'CalSource' ) @classmethod def perform ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : kpflamps = ktl . cache ( 'kpflamps' ) log . debug ( f 'Lamp { lamp } does need to be warmed up before use' ) # Check that lamp is actually on lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : log . warning ( f \"Lamp { lamp } is not on: { lamp_status } \" ) CalLampPower . execute ({ 'lamp' : args . get ( 'CalSource' ), 'power' : 'on' }) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : raise KPFException ( f \"Lamp { lamp } should be on: { lamp_status } \" ) elif lamp_status == 'Warm' : log . debug ( f \"Lamp { lamp } is warm\" ) elif lamp_status == 'Warming' : lamp_timeon = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) lamp_threshold = kpflamps [ f ' { lamp } _THRESHOLD' ] . read ( binary = True ) time_to_wait = lamp_threshold - lamp_timeon log . info ( f \"Lamp { lamp } is warming\" ) log . info ( f \"Estimated time remaining = { time_to_wait : .0f } s\" ) while lamp_statuskw . read () != 'Warm' : # Check if scriptstop has been activated check_scriptstop () log . debug ( f 'Waiting for { lamp } _STATUS == Warm' ) expr = f \"($kpflamps. { lamp } _STATUS == 'Warm')\" warm = ktl . waitFor ( expr , timeout = 30 ) if warm is False : new_lamp_timeton = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) if new_lamp_timeton <= lamp_timeon : break lamp_timeon = new_lamp_timeton @classmethod def post_condition ( cls , args , logger , cfg ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status != 'Warm' : raise FailedPostCondition ( f \"Lamp { lamp } should be warm: { lamp_status } \" ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' ], help = 'Which lamp are we waiting on?' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForND/","text":"WaitForND Bases: KPFTranslatorFunction Description Wait for both ND filter wheels. KTL Keywords Used None Scripts Called kpf.calbench.SetND1 kpf.calbench.SetND2 Parameters CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Source code in kpf/calbench/WaitForND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class WaitForND ( KPFTranslatorFunction ): '''# Description Wait for both ND filter wheels. ## KTL Keywords Used None ## Scripts Called - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForND"},{"location":"scripts/WaitForND/#waitfornd","text":"Bases: KPFTranslatorFunction","title":"WaitForND"},{"location":"scripts/WaitForND/#kpf.calbench.WaitForND.WaitForND--description","text":"Wait for both ND filter wheels.","title":"Description"},{"location":"scripts/WaitForND/#kpf.calbench.WaitForND.WaitForND--ktl-keywords-used","text":"None","title":"KTL Keywords Used"},{"location":"scripts/WaitForND/#kpf.calbench.WaitForND.WaitForND--scripts-called","text":"kpf.calbench.SetND1 kpf.calbench.SetND2","title":"Scripts Called"},{"location":"scripts/WaitForND/#kpf.calbench.WaitForND.WaitForND--parameters","text":"CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Source code in kpf/calbench/WaitForND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class WaitForND ( KPFTranslatorFunction ): '''# Description Wait for both ND filter wheels. ## KTL Keywords Used None ## Scripts Called - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForND1/","text":"WaitForND1 Bases: KPFTranslatorFunction Description Wait for the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. KTL Keywords Used kpfcal.ND1POS Scripts Called None Parameters CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 Source code in kpf/calbench/WaitForND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class WaitForND1 ( KPFTranslatorFunction ): '''# Description Wait for the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. ## KTL Keywords Used - `kpfcal.ND1POS` ## Scripts Called None ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND1' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND1POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND1 filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForND1"},{"location":"scripts/WaitForND1/#waitfornd1","text":"Bases: KPFTranslatorFunction","title":"WaitForND1"},{"location":"scripts/WaitForND1/#kpf.calbench.WaitForND1.WaitForND1--description","text":"Wait for the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword.","title":"Description"},{"location":"scripts/WaitForND1/#kpf.calbench.WaitForND1.WaitForND1--ktl-keywords-used","text":"kpfcal.ND1POS","title":"KTL Keywords Used"},{"location":"scripts/WaitForND1/#kpf.calbench.WaitForND1.WaitForND1--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/WaitForND1/#kpf.calbench.WaitForND1.WaitForND1--parameters","text":"CalND1 ( str ) The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 Source code in kpf/calbench/WaitForND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class WaitForND1 ( KPFTranslatorFunction ): '''# Description Wait for the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. ## KTL Keywords Used - `kpfcal.ND1POS` ## Scripts Called None ## Parameters **CalND1** (`str`) > The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. <br>Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND1' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND1POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND1 filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForND2/","text":"WaitForND2 Bases: KPFTranslatorFunction Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. KTL Keywords Used kpfcal.ND2POS Scripts Called None Parameters CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Source code in kpf/calbench/WaitForND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class WaitForND2 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. ## KTL Keywords Used - `kpfcal.ND2POS` ## Scripts Called None ## Parameters **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND2' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND2POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND2 filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"WaitForND2"},{"location":"scripts/WaitForND2/#waitfornd2","text":"Bases: KPFTranslatorFunction","title":"WaitForND2"},{"location":"scripts/WaitForND2/#kpf.calbench.WaitForND2.WaitForND2--description","text":"Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword.","title":"Description"},{"location":"scripts/WaitForND2/#kpf.calbench.WaitForND2.WaitForND2--ktl-keywords-used","text":"kpfcal.ND2POS","title":"KTL Keywords Used"},{"location":"scripts/WaitForND2/#kpf.calbench.WaitForND2.WaitForND2--scripts-called","text":"None","title":"Scripts Called"},{"location":"scripts/WaitForND2/#kpf.calbench.WaitForND2.WaitForND2--parameters","text":"CalND2 ( str ) The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Source code in kpf/calbench/WaitForND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class WaitForND2 ( KPFTranslatorFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. ## KTL Keywords Used - `kpfcal.ND2POS` ## Scripts Called None ## Parameters **CalND2** (`str`) > The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. <br>Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` ''' @classmethod def pre_condition ( cls , args , logger , cfg ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args , logger , cfg ): target = args . get ( 'CalND2' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND2POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND2 filter wheel\" ) @classmethod def post_condition ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 0.8\" , \"OD 1.0\" , \"OD 4.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/WaitForReadout/","text":"WaitForReadout Bases: KPFTranslatorFunction Waits for the kpfexpose.EXPOSE keyword to be \"Readout\". This will block until the camera enters the readout state. ARGS: None Source code in kpf/spectrograph/WaitForReadout.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class WaitForReadout ( KPFTranslatorFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Readout\". This will block until the camera enters the readout state. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) wait_time = exptime + buffer_time if starting_status < 3 else buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 4)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 4)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 4)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 4)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for readout to begin\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) if 'Green' in detector_list : nextfile = ktl . cache ( 'kpfgreen' , 'NEXTFILE' ) log . debug ( f \"Green nextfile: { nextfile . read () } \" ) if 'Red' in detector_list : nextfile = ktl . cache ( 'kpfred' , 'NEXTFILE' ) log . debug ( f \"Red nextfile: { nextfile . read () } \" ) else : log . warning ( 'WaitForReadout failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): expr = \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready or Readout\" )","title":"WaitForReadout"},{"location":"scripts/WaitForReadout/#waitforreadout","text":"Bases: KPFTranslatorFunction Waits for the kpfexpose.EXPOSE keyword to be \"Readout\". This will block until the camera enters the readout state.","title":"WaitForReadout"},{"location":"scripts/WaitForReadout/#kpf.spectrograph.WaitForReadout.WaitForReadout--args","text":"None Source code in kpf/spectrograph/WaitForReadout.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class WaitForReadout ( KPFTranslatorFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Readout\". This will block until the camera enters the readout state. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) wait_time = exptime + buffer_time if starting_status < 3 else buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 4)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 4)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 4)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 4)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for readout to begin\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) if 'Green' in detector_list : nextfile = ktl . cache ( 'kpfgreen' , 'NEXTFILE' ) log . debug ( f \"Green nextfile: { nextfile . read () } \" ) if 'Red' in detector_list : nextfile = ktl . cache ( 'kpfred' , 'NEXTFILE' ) log . debug ( f \"Red nextfile: { nextfile . read () } \" ) else : log . warning ( 'WaitForReadout failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): expr = \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready or Readout\" )","title":"ARGS:"},{"location":"scripts/WaitForReady/","text":"WaitForReady Bases: KPFTranslatorFunction Waits for the kpfexpose.EXPOSE keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. ARGS: None Source code in kpf/spectrograph/WaitForReady.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class WaitForReady ( KPFTranslatorFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) read_times = [ cfg . getfloat ( 'time_estimates' , 'readout_red' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_green' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ), cfg . getfloat ( 'time_estimates' , 'readout_expmeter' , fallback = 1 ), ] slowest_read = max ( read_times ) wait_time = exptime + slowest_read + buffer_time if starting_status < 3 else slowest_read + buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 0)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 0)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 0)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 0)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for detectors to be ready\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) else : log . warning ( 'WaitForReady failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) if kpfexpose [ 'EXPOSE' ] . read () == 'Readout' : # Readout errors are handled in kpfred and kpfgreen services. # Just wait some extra time for that to recover the system. success = ktl . waitFor ( wait_logic , timeout = wait_time ) else : RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): expr = \"($kpfexpose.EXPOSE == 'Ready')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready\" )","title":"WaitForReady"},{"location":"scripts/WaitForReady/#waitforready","text":"Bases: KPFTranslatorFunction Waits for the kpfexpose.EXPOSE keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time.","title":"WaitForReady"},{"location":"scripts/WaitForReady/#kpf.spectrograph.WaitForReady.WaitForReady--args","text":"None Source code in kpf/spectrograph/WaitForReady.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class WaitForReady ( KPFTranslatorFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) read_times = [ cfg . getfloat ( 'time_estimates' , 'readout_red' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_green' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ), cfg . getfloat ( 'time_estimates' , 'readout_expmeter' , fallback = 1 ), ] slowest_read = max ( read_times ) wait_time = exptime + slowest_read + buffer_time if starting_status < 3 else slowest_read + buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 0)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 0)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 0)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 0)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for detectors to be ready\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) else : log . warning ( 'WaitForReady failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) if kpfexpose [ 'EXPOSE' ] . read () == 'Readout' : # Readout errors are handled in kpfred and kpfgreen services. # Just wait some extra time for that to recover the system. success = ktl . waitFor ( wait_logic , timeout = wait_time ) else : RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args , logger , cfg ): expr = \"($kpfexpose.EXPOSE == 'Ready')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready\" )","title":"ARGS:"},{"location":"scripts/WaitForSoCalOnTarget/","text":"WaitForSoCalOnTarget Bases: KPFTranslatorFunction Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. ARGS: None Source code in kpf/socal/WaitForSoCalOnTarget.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class WaitForSoCalOnTarget ( KPFTranslatorFunction ): '''Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) pyrirrad_threshold = cfg . getfloat ( 'SoCal' , 'pyrirrad_threshold' , fallback = 1000 ) expr = '($kpfsocal.ENCSTA == 0) ' expr += 'and ($kpfsocal.EKOONLINE == Online)' expr += 'and ($kpfsocal.EKOMODE == 3)' expr += f 'and ($kpfsocal.PYRIRRAD > { pyrirrad_threshold } )' expr += 'and ($kpfsocal.AUTONOMOUS == 1)' expr += 'and ($kpfsocal.CAN_OPEN == True)' expr += 'and ($kpfsocal.IS_OPEN == True)' expr += 'and ($kpfsocal.IS_TRACKING == True)' expr += 'and ($kpfsocal.ONLINE == True)' expr += 'and ($kpfsocal.STATE == Tracking)' on_target = ktl . waitFor ( expr , timeout = timeout ) msg = { True : 'On Target' , False : 'NOT On Target' }[ on_target ] print ( msg ) if on_target == False : kpfsocal = ktl . cache ( 'kpfsocal' ) if kpfsocal [ 'ENCSTA' ] . read ( binary = True ) != 0 : log . debug ( f 'ENCSTA != 0' ) if kpfsocal [ 'EKOONLINE' ] . read () != 'Online' : log . debug ( f 'EKOONLINE != Online' ) if kpfsocal [ 'EKOMODE' ] . read ( binary = True ) != 3 : log . debug ( f 'EKOMODE != 3' ) if kpfsocal [ 'PYRIRRAD' ] . read ( binary = True ) < pyrirrad_threshold : log . debug ( f 'PYRIRRAD < { pyrirrad_threshold } ' ) if kpfsocal [ 'AUTONOMOUS' ] . read ( binary = True ) != 1 : log . debug ( f 'AUTONOMOUS != 1' ) if kpfsocal [ 'IS_OPEN' ] . read ( binary = True ) != True : log . debug ( f 'IS_OPEN != True' ) if kpfsocal [ 'IS_TRACKING' ] . read ( binary = True ) != True : log . debug ( f 'IS_TRACKING != True' ) if kpfsocal [ 'ONLINE' ] . read ( binary = True ) != True : log . debug ( f 'ONLINE != True' ) if kpfsocal [ 'STATE' ] . read () != 'Tracking' : log . debug ( f 'STATE != Tracking' ) return on_target @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"WaitForSoCalOnTarget"},{"location":"scripts/WaitForSoCalOnTarget/#waitforsocalontarget","text":"Bases: KPFTranslatorFunction Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True.","title":"WaitForSoCalOnTarget"},{"location":"scripts/WaitForSoCalOnTarget/#kpf.socal.WaitForSoCalOnTarget.WaitForSoCalOnTarget--args","text":"None Source code in kpf/socal/WaitForSoCalOnTarget.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class WaitForSoCalOnTarget ( KPFTranslatorFunction ): '''Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) pyrirrad_threshold = cfg . getfloat ( 'SoCal' , 'pyrirrad_threshold' , fallback = 1000 ) expr = '($kpfsocal.ENCSTA == 0) ' expr += 'and ($kpfsocal.EKOONLINE == Online)' expr += 'and ($kpfsocal.EKOMODE == 3)' expr += f 'and ($kpfsocal.PYRIRRAD > { pyrirrad_threshold } )' expr += 'and ($kpfsocal.AUTONOMOUS == 1)' expr += 'and ($kpfsocal.CAN_OPEN == True)' expr += 'and ($kpfsocal.IS_OPEN == True)' expr += 'and ($kpfsocal.IS_TRACKING == True)' expr += 'and ($kpfsocal.ONLINE == True)' expr += 'and ($kpfsocal.STATE == Tracking)' on_target = ktl . waitFor ( expr , timeout = timeout ) msg = { True : 'On Target' , False : 'NOT On Target' }[ on_target ] print ( msg ) if on_target == False : kpfsocal = ktl . cache ( 'kpfsocal' ) if kpfsocal [ 'ENCSTA' ] . read ( binary = True ) != 0 : log . debug ( f 'ENCSTA != 0' ) if kpfsocal [ 'EKOONLINE' ] . read () != 'Online' : log . debug ( f 'EKOONLINE != Online' ) if kpfsocal [ 'EKOMODE' ] . read ( binary = True ) != 3 : log . debug ( f 'EKOMODE != 3' ) if kpfsocal [ 'PYRIRRAD' ] . read ( binary = True ) < pyrirrad_threshold : log . debug ( f 'PYRIRRAD < { pyrirrad_threshold } ' ) if kpfsocal [ 'AUTONOMOUS' ] . read ( binary = True ) != 1 : log . debug ( f 'AUTONOMOUS != 1' ) if kpfsocal [ 'IS_OPEN' ] . read ( binary = True ) != True : log . debug ( f 'IS_OPEN != True' ) if kpfsocal [ 'IS_TRACKING' ] . read ( binary = True ) != True : log . debug ( f 'IS_TRACKING != True' ) if kpfsocal [ 'ONLINE' ] . read ( binary = True ) != True : log . debug ( f 'ONLINE != True' ) if kpfsocal [ 'STATE' ] . read () != 'Tracking' : log . debug ( f 'STATE != Tracking' ) return on_target @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/WaitForTipTilt/","text":"WaitForTipTilt Bases: KPFTranslatorFunction Dumb versions which simply waits for a few seconds. ARGS: None Source code in kpf/fiu/WaitForTipTilt.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WaitForTipTilt ( KPFTranslatorFunction ): '''Dumb versions which simply waits for a few seconds. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): loop_close_time = cfg . getfloat ( 'times' , 'tip_tilt_close_time' , fallback = 3 ) time . sleep ( loop_close_time ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"WaitForTipTilt"},{"location":"scripts/WaitForTipTilt/#waitfortiptilt","text":"Bases: KPFTranslatorFunction Dumb versions which simply waits for a few seconds.","title":"WaitForTipTilt"},{"location":"scripts/WaitForTipTilt/#kpf.fiu.WaitForTipTilt.WaitForTipTilt--args","text":"None Source code in kpf/fiu/WaitForTipTilt.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WaitForTipTilt ( KPFTranslatorFunction ): '''Dumb versions which simply waits for a few seconds. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): loop_close_time = cfg . getfloat ( 'times' , 'tip_tilt_close_time' , fallback = 3 ) time . sleep ( loop_close_time ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/WaitForTriggerFile/","text":"WaitForTriggerFile Bases: KPFTranslatorFunction Wait for a trigger file in progress to finish being collected. ARGS: None Source code in kpf/guider/WaitForTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class WaitForTriggerFile ( KPFTranslatorFunction ): '''Wait for a trigger file in progress to finish being collected. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'initial_lastfile' ) @classmethod def perform ( cls , args , logger , cfg ): initial_lastfile = args . get ( 'initial_lastfile' , False ) kpfguide = ktl . cache ( 'kpfguide' ) log . debug ( f \"Waiting for guider trigger file to be written out\" ) # Wait for cube file to be updated expr = f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" success = ktl . waitFor ( expr , timeout = 20 ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \"New cube file: { cube_file } \" ) return cube_file @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"WaitForTriggerFile"},{"location":"scripts/WaitForTriggerFile/#waitfortriggerfile","text":"Bases: KPFTranslatorFunction Wait for a trigger file in progress to finish being collected.","title":"WaitForTriggerFile"},{"location":"scripts/WaitForTriggerFile/#kpf.guider.WaitForTriggerFile.WaitForTriggerFile--args","text":"None Source code in kpf/guider/WaitForTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class WaitForTriggerFile ( KPFTranslatorFunction ): '''Wait for a trigger file in progress to finish being collected. ARGS: ===== None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): check_input ( args , 'initial_lastfile' ) @classmethod def perform ( cls , args , logger , cfg ): initial_lastfile = args . get ( 'initial_lastfile' , False ) kpfguide = ktl . cache ( 'kpfguide' ) log . debug ( f \"Waiting for guider trigger file to be written out\" ) # Wait for cube file to be updated expr = f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" success = ktl . waitFor ( expr , timeout = 20 ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \"New cube file: { cube_file } \" ) return cube_file @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/ZeroOutSlewCalTime/","text":"ZeroOutSlewCalTime Bases: KPFTranslatorFunction Zero out the slew cal timer by setting it to the current timestamp. ARGS None Source code in kpf/utils/ZeroOutSlewCalTime.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ZeroOutSlewCalTime ( KPFTranslatorFunction ): '''Zero out the slew cal timer by setting it to the current timestamp. ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . debug ( 'Updating LASTSLEWCAL time stamp to reset slew cal timer' ) ktl . write ( 'kpfconfig' , 'LASTSLEWCAL' , time . time (), binary = True ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ZeroOutSlewCalTime"},{"location":"scripts/ZeroOutSlewCalTime/#zerooutslewcaltime","text":"Bases: KPFTranslatorFunction Zero out the slew cal timer by setting it to the current timestamp.","title":"ZeroOutSlewCalTime"},{"location":"scripts/ZeroOutSlewCalTime/#kpf.utils.ZeroOutSlewCalTime.ZeroOutSlewCalTime--args","text":"None Source code in kpf/utils/ZeroOutSlewCalTime.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ZeroOutSlewCalTime ( KPFTranslatorFunction ): '''Zero out the slew cal timer by setting it to the current timestamp. ### ARGS None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): log . debug ( 'Updating LASTSLEWCAL time stamp to reset slew cal timer' ) ktl . write ( 'kpfconfig' , 'LASTSLEWCAL' , time . time (), binary = True ) @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS"}]}