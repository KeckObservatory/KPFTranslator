{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Keck Planet Finder (KPF) Email Contact: kpf_info@keck.hawaii.edu Instrument Scientist: Josh Walawender Deputy Instrument Scientist: Sherry Yeh Current Status: KPF Instrument Status Instrument Description The Keck Planet Finder (KPF) is a \ufb01ber-fed, high-resolution, high-stability cross dispersed, spectrometer designed to characterize exoplanets via Doppler spectroscopy with a goal of a single measurement precision of 0.3 m/s or better. KPF covers a wavelength range of 445 nm to 870 nm over green and red channels. KPF consists of 3 independant spectrographs: The primary science spectrograph described above which is designed to be highly stable and has both a green and red arm. The spectrograph optical bench is made from low expansion Zerodur and is kept is a temperature stabilized environment. A Calcium H&K spectrograph which gets the light blueward of the main science spectrograph and is used to simultaneously measure stellar activity using the Ca H&K lines. The exposure meter spectrograph which gets a portion of the science light and is used to measure the flux level during long exposures of the primary science detectors. The exposure meter both measures the time weighted flux midpoint of each exposure, and can also be used to terminate an exposure at a specified flux level. All three spectrographs are fed by optical fiber from the Fiber Injection Unit (FIU) which sits on the Keck I AO bench. The light entering the FIU is not AO corrected, but is fed off a fast tip tilt mirror which is used to maintain the target star's position on the science fiber within 50 mas rms of the fiber center. Performance of the tip tilt loop is to be confirmed during commissioning. During observations, the spectrograph can be fed with light from a simultaneous calibration fiber. This places calibration light alongside science and sky spectra in the pseudo-slit. The calibration light is fed from the calibration bench which contains several calibration sources. In addition to the simultaneous calibration light, the calibration bench can be configured to feed light up to the FIU and through the science and sky fibers in order to bring cal light in to the science and sky portions of the pseudo-slit. The system overview diagram showing the relationships between the different subsystems of the instrument. KPF's Zerodur optical bench during integration at the Space Sciences Lab at UC Berkeley. The echelle grating can be seen at the upper right.","title":"KPF Home"},{"location":"#keck-planet-finder-kpf","text":"Email Contact: kpf_info@keck.hawaii.edu Instrument Scientist: Josh Walawender Deputy Instrument Scientist: Sherry Yeh Current Status: KPF Instrument Status","title":"Keck Planet Finder (KPF)"},{"location":"#instrument-description","text":"The Keck Planet Finder (KPF) is a \ufb01ber-fed, high-resolution, high-stability cross dispersed, spectrometer designed to characterize exoplanets via Doppler spectroscopy with a goal of a single measurement precision of 0.3 m/s or better. KPF covers a wavelength range of 445 nm to 870 nm over green and red channels. KPF consists of 3 independant spectrographs: The primary science spectrograph described above which is designed to be highly stable and has both a green and red arm. The spectrograph optical bench is made from low expansion Zerodur and is kept is a temperature stabilized environment. A Calcium H&K spectrograph which gets the light blueward of the main science spectrograph and is used to simultaneously measure stellar activity using the Ca H&K lines. The exposure meter spectrograph which gets a portion of the science light and is used to measure the flux level during long exposures of the primary science detectors. The exposure meter both measures the time weighted flux midpoint of each exposure, and can also be used to terminate an exposure at a specified flux level. All three spectrographs are fed by optical fiber from the Fiber Injection Unit (FIU) which sits on the Keck I AO bench. The light entering the FIU is not AO corrected, but is fed off a fast tip tilt mirror which is used to maintain the target star's position on the science fiber within 50 mas rms of the fiber center. Performance of the tip tilt loop is to be confirmed during commissioning. During observations, the spectrograph can be fed with light from a simultaneous calibration fiber. This places calibration light alongside science and sky spectra in the pseudo-slit. The calibration light is fed from the calibration bench which contains several calibration sources. In addition to the simultaneous calibration light, the calibration bench can be configured to feed light up to the FIU and through the science and sky fibers in order to bring cal light in to the science and sky portions of the pseudo-slit. The system overview diagram showing the relationships between the different subsystems of the instrument. KPF's Zerodur optical bench during integration at the Space Sciences Lab at UC Berkeley. The echelle grating can be seen at the upper right.","title":"Instrument Description"},{"location":"CalibrationProperties/","text":"Calibration Properties CalSource : str Name of the calibration source Object : str Object name for the FITS header nExp : int Number of Exposures ExpTime : float [seconds] Exposure Time TriggerCaHK : bool Trigger the Ca H & K detector for this observation? TriggerGreen : bool Trigger the Green detector for this observation? TriggerRed : bool Trigger the Red detector for this observation? IntensityMonitor : bool Run an Intensity Monitor measurement on this lamp before taking data? CalND1 : str Cal Bench filter 1 position. Throughput = 10^-OD. Values: OD 0.1, OD 1.0, OD 1.3, OD 2.0, OD 3.0, OD 4.0 CalND2 : str Cal Bench filter 2 position. Throughput = 10^-OD. Values: OD 0.1, OD 0.3, OD 0.5, OD 0.8, OD 1.0, OD 4.0 OpenScienceShutter : bool Open the Source Select Shutter for the Science fiber? OpenSkyShutter : bool Open the Source Select Shutter for the Sky fiber? TakeSimulCal : bool Inject simultaneous calibration light on to the detector during exposure? WideFlatPos : str If the WideFlat source is chosen, which wheel position to use? ExpMeterMode : str Exposure meter mode? (monitor, control, off) ExpMeterExpTime : float [seconds] Exposure Time for the exposure meter ExpMeterBin : int Which wavelength bin to use for exposure meter termination? (1=498nm, 2=604nm, 3=711nm, 4=817nm) ExpMeterThreshold : float [e-/nm] Threshold flux at the science detector at which to terminate the exposure","title":"Calibration Properties"},{"location":"CalibrationProperties/#calibration-properties","text":"CalSource : str Name of the calibration source Object : str Object name for the FITS header nExp : int Number of Exposures ExpTime : float [seconds] Exposure Time TriggerCaHK : bool Trigger the Ca H & K detector for this observation? TriggerGreen : bool Trigger the Green detector for this observation? TriggerRed : bool Trigger the Red detector for this observation? IntensityMonitor : bool Run an Intensity Monitor measurement on this lamp before taking data? CalND1 : str Cal Bench filter 1 position. Throughput = 10^-OD. Values: OD 0.1, OD 1.0, OD 1.3, OD 2.0, OD 3.0, OD 4.0 CalND2 : str Cal Bench filter 2 position. Throughput = 10^-OD. Values: OD 0.1, OD 0.3, OD 0.5, OD 0.8, OD 1.0, OD 4.0 OpenScienceShutter : bool Open the Source Select Shutter for the Science fiber? OpenSkyShutter : bool Open the Source Select Shutter for the Sky fiber? TakeSimulCal : bool Inject simultaneous calibration light on to the detector during exposure? WideFlatPos : str If the WideFlat source is chosen, which wheel position to use? ExpMeterMode : str Exposure meter mode? (monitor, control, off) ExpMeterExpTime : float [seconds] Exposure Time for the exposure meter ExpMeterBin : int Which wavelength bin to use for exposure meter termination? (1=498nm, 2=604nm, 3=711nm, 4=817nm) ExpMeterThreshold : float [e-/nm] Threshold flux at the science detector at which to terminate the exposure","title":"Calibration Properties"},{"location":"KPFTranslator/","text":"KPF Translator Most of KPF operations are controlled via the KPF Translator which is composed of Python code, which interacts with the underlying KTL keywords to automate various tasks. Each script is actually a Python class which is invoked by an execute() method which itself calls the pre_condition() , perform() , and post_condition() methods. This three-part structure allows the script to check that the system is ready for the action to be performed, then execute the action, then confirm a successful execution. These scripts can also be invoked via a command line interface to the underlying python and are used for everything from small, atomic actions which might require only a single KTL keyword write to execute, to large scripts which need significant flow control such as executing a science observation at night -- including configuring the instrument, waiting for the telescope and tip-tilt system to acquire the target, executing the specified exposures, and finally performing clean up actions.","title":"Instrument Software"},{"location":"KPFTranslator/#kpf-translator","text":"Most of KPF operations are controlled via the KPF Translator which is composed of Python code, which interacts with the underlying KTL keywords to automate various tasks. Each script is actually a Python class which is invoked by an execute() method which itself calls the pre_condition() , perform() , and post_condition() methods. This three-part structure allows the script to check that the system is ready for the action to be performed, then execute the action, then confirm a successful execution. These scripts can also be invoked via a command line interface to the underlying python and are used for everything from small, atomic actions which might require only a single KTL keyword write to execute, to large scripts which need significant flow control such as executing a science observation at night -- including configuring the instrument, waiting for the telescope and tip-tilt system to acquire the target, executing the specified exposures, and finally performing clean up actions.","title":"KPF Translator"},{"location":"KPFvsHIRES/","text":"Comparing KPF to HIRES This page attempts to compare KPF and HIRES for users who may be wondering which instrument they should propose for. Fundamentally HIRES is a more flexible instrument with selectable grating angles to control the wavelength coverage and selectable slits which allow the user to trade off throughput against spectral resolution while KPF is a fixed format spectrograph with a fixed input fiber. HIRES also has a wider spectral coverage than KPF and even includes the option to change the internal optics to optimize either blue or red sensitivity. Though KPF has the Calcium H&K spectrograph, a dedicated arm to examine the 382-402 nm wavelength range around the Ca H&K lines. KPF, on the other hand, has higher spectral resolution even though it has a larger entrance aperture on sky and so it may be more sensitive for use cases which need that combination. Of course, KPF is also highly stabilized and is optimized for precision radial velocity measurements. Summary Table Comparison KPF HIRES Optical Input 1.14 arcsec octagonal fibers for science and sky (fixed format) Selectable deckers and slits for different sky projections (e.g., B5 = 0.87 x 3.5 arcsec) Wavelength Coverage Fixed format: 445-870 nm (high-res) 382-402 nm (med-res) ~300-1000 nm in an adjustable format (moving the spectral format across detector) Resolving Power R=98k (445-870 nm) depends on slit e.g. R=49k for 0.86 arcsec-wide slit R=80k for 0.40 arcsec-wide slit Throughput (sky to CCD) ~8-10% peak-of-blaze (measured) 5-6% peak-of-blaze for B5-B1 deckers (measured) Doppler Precision 0.5 m/s noise floor (req.) 0.3 m/s (goal) ~2 m/s systematic noise floor Doppler Speed ~8-10x faster than HIRES Limited by need for high SNR to model iodine spectrum Instrument Efficiency Comparison Prior to delivery of KPF, the KPF Team made a series of HIRES observations of a spectrophotometric standard using deckers that spanned the full range of slit widths (but not all slit lengths, which only affects spatial information). In the plot below, each blue line plots the peak-of-blaze efficiency from the top of the atmosphere to detected photoelectrons. The red line is the predicted KPF efficiency curve based on Steve Gibson\u2019s detailed optical model, efficiency curves for each optic (measured, if available), and a model of seeing and the atmosphere that match the airmass and seeing values for the actual HIRES observations. We saw later that the KPF model is pretty good \u2014 it\u2019s ~10% low for wavelengths > 500 nm and is too high for bluer wavelengths (>>10% off for the bluest wavelength). Comparison of the measured efficiency for HIRES to the KPF modeled efficiency (later validated, but see discussion above). The huge range of HIRES efficiency depending on decker is the biggest factor. For science at lower resolution, KPF and HIRES have comparable efficiency. For high-resolution, KPF is much more efficient. Common Observations WMKO obtained observations designed to compare KPF and HIRES directly on a variety of science targets during 2025A. This comparison reflects the status of the instruments as they were on 2025 May 15. Unfortunately, at the time, KPF was impacted by excess pattern noise which raised the apparent read noise from the nominal ~5 electrons to ~13 electrons. This will affect all of the KPF data below. Please see the KPF status page for the current state of KPF. Here is a list of what was observed: Target Mag KPF HIRES (Ech, XD, Slit, Bin) Requestor 29/P-comet V~16 4x300 s 4x300 s (0.1, -0.06, 1.148\", 2x2) McKay TW Hydra V=10.5 2x300 s 2x300 s (0.0, 0.90, 1.148\", 2x2) Hillenbrand HD 96735 R=8.8 2x120 s 2x120 s (0.0, -0.10, 0.861\", 3x1) Zhang HIP 54597 R=9.8 2x240 s 2x240 s (0.0, -0.10, 0.861\", 3x1) Zhang J1622+5521 R=16.2 2x1800 s 2x1800 s (0.1, 0.763, 1.148\", 2x2) Redfield HD 187982 V=5.3 1x20 s 1x15 s (0.0, 0.2423, 0.4\", 1x1) Cooke HD 199478 V=5.2 1x20 s 1x15 s (0.0, 0.2423, 0.4\", 1x1) Cooke BD+35 1801 R=8.0 3x60 s 3x60 s (0.1, -0.06, 0.4\", 1x1) Nisak J142543.3+540619 R=17.8 3x600 s 3x600 s (0.102, 0.7625, 1.148\", 2x2) O\u2019Meara BL Lac R=17.2 4x600 s 1x2400 s (0.102, 0.7625, 1.148\", 2x2) O\u2019Meara HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 1.148\", 1x1) Staff HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 0.861\", 1x1) Staff HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 0.574\", 1x1) Staff HIRES Raw Data All HIRES Science Files: HIRES_sci_27859_1.tar All HIRES Calibration Files: HIRES_cal_27859_1.tar HIRES Reduced Data A subset of the HIRES observations were reduced automatically at KOA for the following targets: BD+35 1801 TW Hya J142543.3+540619 J1622+5521 targets These files are available here: HIRES_sci_51156_1.tar KPF Reduced Data The reduced data for KPF is available in the table below. The \"Level 1\" file is the extracted 1D spectrum. For details on working with KPF L1 files, see the KPF DRP page on L1 data format . Target KPF L1 Files 29/P-comet KP.20250516.22710.24 KP.20250516.22765.38 KP.20250516.23176.73 KP.20250516.23597.65 KP.20250516.23946.39 TW Hydra KP.20250516.28039.30 KP.20250516.28387.71 HD 96735 KP.20250516.29269.54 KP.20250516.29438.05 HIP 54597 KP.20250516.31424.80 KP.20250516.31713.37 J1622+5521 KP.20250516.41859.48 KP.20250516.43707.83 HD 187982 KP.20250516.52220.22 HD 199478 KP.20250516.52378.17 BD+35 1801 KP.20250516.20851.88 KP.20250516.21018.50 KP.20250516.21139.89 J142543.3+540619 KP.20250516.32813.20 KP.20250516.33461.60 KP.20250516.34123.45 BL Lac KP.20250516.46263.92 KP.20250516.46912.59 KP.20250516.47561.22 KP.20250516.48209.59 HR 7596 KP.20250516.53456.67","title":"KPF vs. HIRES"},{"location":"KPFvsHIRES/#comparing-kpf-to-hires","text":"This page attempts to compare KPF and HIRES for users who may be wondering which instrument they should propose for. Fundamentally HIRES is a more flexible instrument with selectable grating angles to control the wavelength coverage and selectable slits which allow the user to trade off throughput against spectral resolution while KPF is a fixed format spectrograph with a fixed input fiber. HIRES also has a wider spectral coverage than KPF and even includes the option to change the internal optics to optimize either blue or red sensitivity. Though KPF has the Calcium H&K spectrograph, a dedicated arm to examine the 382-402 nm wavelength range around the Ca H&K lines. KPF, on the other hand, has higher spectral resolution even though it has a larger entrance aperture on sky and so it may be more sensitive for use cases which need that combination. Of course, KPF is also highly stabilized and is optimized for precision radial velocity measurements.","title":"Comparing KPF to HIRES"},{"location":"KPFvsHIRES/#summary-table","text":"Comparison KPF HIRES Optical Input 1.14 arcsec octagonal fibers for science and sky (fixed format) Selectable deckers and slits for different sky projections (e.g., B5 = 0.87 x 3.5 arcsec) Wavelength Coverage Fixed format: 445-870 nm (high-res) 382-402 nm (med-res) ~300-1000 nm in an adjustable format (moving the spectral format across detector) Resolving Power R=98k (445-870 nm) depends on slit e.g. R=49k for 0.86 arcsec-wide slit R=80k for 0.40 arcsec-wide slit Throughput (sky to CCD) ~8-10% peak-of-blaze (measured) 5-6% peak-of-blaze for B5-B1 deckers (measured) Doppler Precision 0.5 m/s noise floor (req.) 0.3 m/s (goal) ~2 m/s systematic noise floor Doppler Speed ~8-10x faster than HIRES Limited by need for high SNR to model iodine spectrum","title":"Summary Table"},{"location":"KPFvsHIRES/#instrument-efficiency-comparison","text":"Prior to delivery of KPF, the KPF Team made a series of HIRES observations of a spectrophotometric standard using deckers that spanned the full range of slit widths (but not all slit lengths, which only affects spatial information). In the plot below, each blue line plots the peak-of-blaze efficiency from the top of the atmosphere to detected photoelectrons. The red line is the predicted KPF efficiency curve based on Steve Gibson\u2019s detailed optical model, efficiency curves for each optic (measured, if available), and a model of seeing and the atmosphere that match the airmass and seeing values for the actual HIRES observations. We saw later that the KPF model is pretty good \u2014 it\u2019s ~10% low for wavelengths > 500 nm and is too high for bluer wavelengths (>>10% off for the bluest wavelength). Comparison of the measured efficiency for HIRES to the KPF modeled efficiency (later validated, but see discussion above). The huge range of HIRES efficiency depending on decker is the biggest factor. For science at lower resolution, KPF and HIRES have comparable efficiency. For high-resolution, KPF is much more efficient.","title":"Instrument Efficiency Comparison"},{"location":"KPFvsHIRES/#common-observations","text":"WMKO obtained observations designed to compare KPF and HIRES directly on a variety of science targets during 2025A. This comparison reflects the status of the instruments as they were on 2025 May 15. Unfortunately, at the time, KPF was impacted by excess pattern noise which raised the apparent read noise from the nominal ~5 electrons to ~13 electrons. This will affect all of the KPF data below. Please see the KPF status page for the current state of KPF. Here is a list of what was observed: Target Mag KPF HIRES (Ech, XD, Slit, Bin) Requestor 29/P-comet V~16 4x300 s 4x300 s (0.1, -0.06, 1.148\", 2x2) McKay TW Hydra V=10.5 2x300 s 2x300 s (0.0, 0.90, 1.148\", 2x2) Hillenbrand HD 96735 R=8.8 2x120 s 2x120 s (0.0, -0.10, 0.861\", 3x1) Zhang HIP 54597 R=9.8 2x240 s 2x240 s (0.0, -0.10, 0.861\", 3x1) Zhang J1622+5521 R=16.2 2x1800 s 2x1800 s (0.1, 0.763, 1.148\", 2x2) Redfield HD 187982 V=5.3 1x20 s 1x15 s (0.0, 0.2423, 0.4\", 1x1) Cooke HD 199478 V=5.2 1x20 s 1x15 s (0.0, 0.2423, 0.4\", 1x1) Cooke BD+35 1801 R=8.0 3x60 s 3x60 s (0.1, -0.06, 0.4\", 1x1) Nisak J142543.3+540619 R=17.8 3x600 s 3x600 s (0.102, 0.7625, 1.148\", 2x2) O\u2019Meara BL Lac R=17.2 4x600 s 1x2400 s (0.102, 0.7625, 1.148\", 2x2) O\u2019Meara HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 1.148\", 1x1) Staff HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 0.861\", 1x1) Staff HR 7596 R=5.6 1x20 s 1x15 s (0.0, 0.2423, 0.574\", 1x1) Staff","title":"Common Observations"},{"location":"KPFvsHIRES/#hires-raw-data","text":"All HIRES Science Files: HIRES_sci_27859_1.tar All HIRES Calibration Files: HIRES_cal_27859_1.tar","title":"HIRES Raw Data"},{"location":"KPFvsHIRES/#hires-reduced-data","text":"A subset of the HIRES observations were reduced automatically at KOA for the following targets: BD+35 1801 TW Hya J142543.3+540619 J1622+5521 targets These files are available here: HIRES_sci_51156_1.tar","title":"HIRES Reduced Data"},{"location":"KPFvsHIRES/#kpf-reduced-data","text":"The reduced data for KPF is available in the table below. The \"Level 1\" file is the extracted 1D spectrum. For details on working with KPF L1 files, see the KPF DRP page on L1 data format . Target KPF L1 Files 29/P-comet KP.20250516.22710.24 KP.20250516.22765.38 KP.20250516.23176.73 KP.20250516.23597.65 KP.20250516.23946.39 TW Hydra KP.20250516.28039.30 KP.20250516.28387.71 HD 96735 KP.20250516.29269.54 KP.20250516.29438.05 HIP 54597 KP.20250516.31424.80 KP.20250516.31713.37 J1622+5521 KP.20250516.41859.48 KP.20250516.43707.83 HD 187982 KP.20250516.52220.22 HD 199478 KP.20250516.52378.17 BD+35 1801 KP.20250516.20851.88 KP.20250516.21018.50 KP.20250516.21139.89 J142543.3+540619 KP.20250516.32813.20 KP.20250516.33461.60 KP.20250516.34123.45 BL Lac KP.20250516.46263.92 KP.20250516.46912.59 KP.20250516.47561.22 KP.20250516.48209.59 HR 7596 KP.20250516.53456.67","title":"KPF Reduced Data"},{"location":"ObservationProperties/","text":"Observation Properties Object : str This value will go in to the FITS header as the OBJECT keyword value. This is can be used as a notes field for the observer to explain how this set of exposures differs from any following observations of this target. This field can be left blank or set to the target name, it is entirely up to the observer. nExp : int Number of Exposures to take for this observation. ExpTime : float [seconds] The exposure time in seconds. Note that if the exposure meter is controlling the exposure duration, this exposure time is the maximum value which will be allowed (the exposure meter may cut the exposure short if the desired flux level is reached). TriggerCaHK : bool Trigger the Ca H & K detector for this observation? TriggerGreen : bool Trigger the Green detector for this observation? TriggerRed : bool Trigger the Red detector for this observation? BlockSky : bool Block the sky fiber during the observation? ExpMeterMode : str Exposure meter mode (monitor, control, off). In \"monitor\" the exposure meter will take exposure during the science exposure and record fluxes. This data will be stored in the resulting FITS file can be used to determine the flux weighted exposure midpoint in time for accurate barycentric correction. In \"control\" the exposure meter will terminate the exposure when the desired threshold is reached (see ExpMeterBin and ExpMeterThreshold) AutoExpMeter : bool Set the exposure time on the exposure meter automatically based on the target G magnitude? ExpMeterExpTime : float [seconds] The exposure time in seconds for individual exposure meter exposures. This is ignored if AutoExpMeter is True. ExpMeterBin : int Which wavelength bin to use for exposure meter termination? (1=498nm, 2=604nm, 3=711nm, 4=817nm) ExpMeterThreshold : float [Mphotons/angstrom] Flux at the science detector at peak of order at which to terminate the exposure TakeSimulCal : bool Inject simultaneous calibration light on to the detector during exposure? AutoNDFilters : bool Automatically set ND filters for the simultaneous calibration light? This requires that Teff be within the allowed range of the exposure time calculator software (2700 - 6600 K). CalND1 : str Cal Bench filter 1 position. Throughput = 10^-OD. Values: OD 0.1, OD 1.0, OD 1.3, OD 2.0, OD 3.0, OD 4.0 CalND2 : str Cal Bench filter 2 position. Throughput = 10^-OD. Values: OD 0.1, OD 0.3, OD 0.5, OD 0.8, OD 1.0, OD 4.0 NodN : float [arcseconds] Distance to nod the telescope North before starting exposure. NodE : float [arcseconds] Distance to nod the telescope East before starting exposure. GuideHere : bool Should the tip tilt system try to lock on to target at this position?","title":"Observation Properties"},{"location":"ObservationProperties/#observation-properties","text":"Object : str This value will go in to the FITS header as the OBJECT keyword value. This is can be used as a notes field for the observer to explain how this set of exposures differs from any following observations of this target. This field can be left blank or set to the target name, it is entirely up to the observer. nExp : int Number of Exposures to take for this observation. ExpTime : float [seconds] The exposure time in seconds. Note that if the exposure meter is controlling the exposure duration, this exposure time is the maximum value which will be allowed (the exposure meter may cut the exposure short if the desired flux level is reached). TriggerCaHK : bool Trigger the Ca H & K detector for this observation? TriggerGreen : bool Trigger the Green detector for this observation? TriggerRed : bool Trigger the Red detector for this observation? BlockSky : bool Block the sky fiber during the observation? ExpMeterMode : str Exposure meter mode (monitor, control, off). In \"monitor\" the exposure meter will take exposure during the science exposure and record fluxes. This data will be stored in the resulting FITS file can be used to determine the flux weighted exposure midpoint in time for accurate barycentric correction. In \"control\" the exposure meter will terminate the exposure when the desired threshold is reached (see ExpMeterBin and ExpMeterThreshold) AutoExpMeter : bool Set the exposure time on the exposure meter automatically based on the target G magnitude? ExpMeterExpTime : float [seconds] The exposure time in seconds for individual exposure meter exposures. This is ignored if AutoExpMeter is True. ExpMeterBin : int Which wavelength bin to use for exposure meter termination? (1=498nm, 2=604nm, 3=711nm, 4=817nm) ExpMeterThreshold : float [Mphotons/angstrom] Flux at the science detector at peak of order at which to terminate the exposure TakeSimulCal : bool Inject simultaneous calibration light on to the detector during exposure? AutoNDFilters : bool Automatically set ND filters for the simultaneous calibration light? This requires that Teff be within the allowed range of the exposure time calculator software (2700 - 6600 K). CalND1 : str Cal Bench filter 1 position. Throughput = 10^-OD. Values: OD 0.1, OD 1.0, OD 1.3, OD 2.0, OD 3.0, OD 4.0 CalND2 : str Cal Bench filter 2 position. Throughput = 10^-OD. Values: OD 0.1, OD 0.3, OD 0.5, OD 0.8, OD 1.0, OD 4.0 NodN : float [arcseconds] Distance to nod the telescope North before starting exposure. NodE : float [arcseconds] Distance to nod the telescope East before starting exposure. GuideHere : bool Should the tip tilt system try to lock on to target at this position?","title":"Observation Properties"},{"location":"TargetProperties/","text":"Target Properties TargetName : str Name of the target, chosen by the observer. This will appear in the TARGNAME FITS header field and is the equivalent of the star list target name, but is not the same as the OBJECT field (see the Observation Properties for that). GaiaID : str Gaia ID of the target (e.g. DR3 123456789012345678) 2MASSID : str 2MASS ID of the target (e.g. J12345678-1234567) Parallax : float [milliarcsec] Parallax of the target RadialVelocity : float [km/s] Estimated radial velocity of the target Gmag : float [magnitude] Gaia G magnitude of the target. This is used for the algorithm which automatically sets the exposure meter exposure time and the algorithm which sets the simultaneous calibration filters. Jmag : float [magnitude] J magnitude of the target. This is used by the algorithm which automatically sets the guider gain and frame rate. Teff : float [K] Effective temperature of the target (allowed range 2600 - 45000 K). This is used by the algorithm which sets the simultaneous calibration filters. For that to work, this must lie within the range of 2700 - 6600 K. RA : str [hh:mm:ss.ss] Right Ascension of the target (at Epoch) Dec : str [dd:mm:ss.ss] Declination of the target (at Epoch) Equinox : str [str] Equinox of the coordinate system (in Jyear format, e.g. J2000 or decimal year, e.g. 2000.0) PMRA : float [seconds-of-time/year] Proper motion in RA PMDEC : float [arcsec/year] Proper motion in Dec Epoch : str [str] Epoch of the coordinate measurement DRA : float [arcsec/hr divided by 15] Non sidereal tracking rate in RA DDEC : float [arcsec/hr] Non sidereal tracking rate in Dec","title":"Target Properties"},{"location":"TargetProperties/#target-properties","text":"TargetName : str Name of the target, chosen by the observer. This will appear in the TARGNAME FITS header field and is the equivalent of the star list target name, but is not the same as the OBJECT field (see the Observation Properties for that). GaiaID : str Gaia ID of the target (e.g. DR3 123456789012345678) 2MASSID : str 2MASS ID of the target (e.g. J12345678-1234567) Parallax : float [milliarcsec] Parallax of the target RadialVelocity : float [km/s] Estimated radial velocity of the target Gmag : float [magnitude] Gaia G magnitude of the target. This is used for the algorithm which automatically sets the exposure meter exposure time and the algorithm which sets the simultaneous calibration filters. Jmag : float [magnitude] J magnitude of the target. This is used by the algorithm which automatically sets the guider gain and frame rate. Teff : float [K] Effective temperature of the target (allowed range 2600 - 45000 K). This is used by the algorithm which sets the simultaneous calibration filters. For that to work, this must lie within the range of 2700 - 6600 K. RA : str [hh:mm:ss.ss] Right Ascension of the target (at Epoch) Dec : str [dd:mm:ss.ss] Declination of the target (at Epoch) Equinox : str [str] Equinox of the coordinate system (in Jyear format, e.g. J2000 or decimal year, e.g. 2000.0) PMRA : float [seconds-of-time/year] Proper motion in RA PMDEC : float [arcsec/year] Proper motion in Dec Epoch : str [str] Epoch of the coordinate measurement DRA : float [arcsec/hr divided by 15] Non sidereal tracking rate in RA DDEC : float [arcsec/hr] Non sidereal tracking rate in Dec","title":"Target Properties"},{"location":"afternoonsetup/","text":"Afternoon Setup The afternoon setup process for the instrument itself is minimal. Calibrations are automated, so unless you have very special requirements for your observation (if so please contact the Staff Astronomer supporting your night in advance), then observers will not need to execute any calibrations. Prior to starting observing, observers should run: KPF Control Menu --> Start KPF GUIs from the background menu (or kpfStartGUIs from the command line on any KPF machine). This will start the KPF GUIs and can be run at any time prior to observing. Preparing Observing Blocks (OBs) Observers should use the afternoon to prepare Observing Blocks (OBs) and their star list if they have not done so already. Connecting to VNCs Observers can connect to the Keck VNCs to control the instrument from Keck HQ in Waimea, one of the Keck Remote Observing Stations, or from home using the Remote Observing Software. For details, see the Remote Observing documentation. Starting KPF GUIs The KPF GUIs can be started at any time. To do so, choose KPF Control Menu -> Start KPF GUIs from the FVWM menu. Check that the GUIs come up properly in the various VNC sessions. Each session is described below. control0 The control0 VNC session should contain: OB GUI : This is where the observer can build and execute observing blocks. Tip Tilt GUI : This is a view-only version of the GUI the OAs use to control the tip tilt system. Observers can use this to see the tip tilt system status and images, but observers can not control the system. control1 The control1 VNC session should contain: FIU GUI : This shows the status of the FIU including the light path. This is a good place to look if you are not seeing stars on the guider and want to know if the guider should eb seeing the sky. Exposure Meter GUI : This will show the progress of the flux measured by the exposure meter over the course of a single exposure. Spectrograph GUI : This shows the staus of the overall instrument (including a simplified FIU status). The light paths which are illuminated will show up as colored lines and arrows here to indicate where light is being directed by the various components. control2 The control2 VNC session should contain: A ds9 instance which shows the latest raw image from the Ca H&K, Green, and Red detectors. Eventsounds GUI : This is a standard Keck GUI where the users can enable/disable sounds and change what sound is produced by a given event. telstatus The telstatus VNC session should contain: FACSUM : A standard Keck GUI showing the status of the facility (telescope and dome). XMET : A standard Keck GUI showing various weather telemetry values. The OAs have more weather information which is not shown here, but this is a good summary. Magiq Observer UI : A standard Keck GUI for viewing guider images and interacting with star lists. Note that the Magiq UI may not come up if the StartGUIs script was run while KPF was not the selected instrument. The Magiq UI will always come up with the guider for the selected instrument when launched. If Magiq is not running, launch it via Telescope GUIs --> Magiq Guider UI from the FVWM menu.","title":"Afternoon Setup"},{"location":"afternoonsetup/#afternoon-setup","text":"The afternoon setup process for the instrument itself is minimal. Calibrations are automated, so unless you have very special requirements for your observation (if so please contact the Staff Astronomer supporting your night in advance), then observers will not need to execute any calibrations. Prior to starting observing, observers should run: KPF Control Menu --> Start KPF GUIs from the background menu (or kpfStartGUIs from the command line on any KPF machine). This will start the KPF GUIs and can be run at any time prior to observing.","title":"Afternoon Setup"},{"location":"afternoonsetup/#preparing-observing-blocks-obs","text":"Observers should use the afternoon to prepare Observing Blocks (OBs) and their star list if they have not done so already.","title":"Preparing Observing Blocks (OBs)"},{"location":"afternoonsetup/#connecting-to-vncs","text":"Observers can connect to the Keck VNCs to control the instrument from Keck HQ in Waimea, one of the Keck Remote Observing Stations, or from home using the Remote Observing Software. For details, see the Remote Observing documentation.","title":"Connecting to VNCs"},{"location":"afternoonsetup/#starting-kpf-guis","text":"The KPF GUIs can be started at any time. To do so, choose KPF Control Menu -> Start KPF GUIs from the FVWM menu. Check that the GUIs come up properly in the various VNC sessions. Each session is described below.","title":"Starting KPF GUIs"},{"location":"afternoonsetup/#control0","text":"The control0 VNC session should contain: OB GUI : This is where the observer can build and execute observing blocks. Tip Tilt GUI : This is a view-only version of the GUI the OAs use to control the tip tilt system. Observers can use this to see the tip tilt system status and images, but observers can not control the system.","title":"control0"},{"location":"afternoonsetup/#control1","text":"The control1 VNC session should contain: FIU GUI : This shows the status of the FIU including the light path. This is a good place to look if you are not seeing stars on the guider and want to know if the guider should eb seeing the sky. Exposure Meter GUI : This will show the progress of the flux measured by the exposure meter over the course of a single exposure. Spectrograph GUI : This shows the staus of the overall instrument (including a simplified FIU status). The light paths which are illuminated will show up as colored lines and arrows here to indicate where light is being directed by the various components.","title":"control1"},{"location":"afternoonsetup/#control2","text":"The control2 VNC session should contain: A ds9 instance which shows the latest raw image from the Ca H&K, Green, and Red detectors. Eventsounds GUI : This is a standard Keck GUI where the users can enable/disable sounds and change what sound is produced by a given event.","title":"control2"},{"location":"afternoonsetup/#telstatus","text":"The telstatus VNC session should contain: FACSUM : A standard Keck GUI showing the status of the facility (telescope and dome). XMET : A standard Keck GUI showing various weather telemetry values. The OAs have more weather information which is not shown here, but this is a good summary. Magiq Observer UI : A standard Keck GUI for viewing guider images and interacting with star lists. Note that the Magiq UI may not come up if the StartGUIs script was run while KPF was not the selected instrument. The Magiq UI will always come up with the guider for the selected instrument when launched. If Magiq is not running, launch it via Telescope GUIs --> Magiq Guider UI from the FVWM menu.","title":"telstatus"},{"location":"agitator/","text":"Agitator KPF includes a mechanical oscillator which agitates the fibers to aid in mode scrambling in the fibers. The agitator is located directly beneath the azimuth ring of the Keck I telescope. It is automatically turned on and off during science and calibration observations and needs no user intervention. The agitator oscillates at about 2 Hz.","title":"Agitator"},{"location":"agitator/#agitator","text":"KPF includes a mechanical oscillator which agitates the fibers to aid in mode scrambling in the fibers. The agitator is located directly beneath the azimuth ring of the Keck I telescope. It is automatically turned on and off during science and calibration observations and needs no user intervention. The agitator oscillates at about 2 Hz.","title":"Agitator"},{"location":"buildingOBs/","text":"Building Observing Blocks (OBs) The basic unit of KPF nighttime operations is the Observing Block (OB). An OB describes a single visit to a science target and the observations made there. The data contained in the OB is a set of keyword-value pairs. Observers can create OBs in 3 ways: As text files which can be read in by the KPF software and executed. As a database entry by filling out an OB via the KPF-CC Web Form . Please note that the KPF-CC web form is not capable of recording all features of an OB, but should cover 90+% of use cases. Classical observers are also welcome to use the form. Building an OB \"live\" using the KPF OB GUI. The data in an OB can be divided in to three categories: Target : The OB will contain information about the target beyond what is in a typical Keck Star List entry in order to flow that information to the FITS header and the data reduction pipeline (DRP). The target section is only needed if the OB has observations (i.e. it is not purely a calibration OB). Here is a description of all Target Properties . Calibrations : An OB can contain calibrations, these are not typically used by the observer (slewcals are handled separately). Here is a description of all Calibration Properties . The Calibrations section of an ON is a list of Calibration entries. Observations : Finally, the OB will contain a list of observations to be made of the target. For typical KPF observers, this will only have one entry, but multiple entries are supported. Each entry describes a set of exposures on the target and contains the information on how those exposures should be executed. Here is a description of all Observation Properties . The Observations section of an ON is a list of Observation entries. Note that not all properties are needed in every case. For example, an observation with ExpMeterMode: 'monitor' will not need values for ExpMeterBin and ExpMeterThreshold . Example On Sky Science OB This is an example of what the text file form of an OB might look like. The file is a yaml format which resolves in to a python dict with keys for \"Target\", \"Calibrations\" and \"Observations\" (not all are required). The \"Target\" entry is a dict with the various Target Properties . The \"Calibrations\" entry (if present) is a list of dictionaries, each with the various Calibration Properties . Similarly, the \"Observations\" entry is a list of dictionaries, each with the various Observation Properties . The example below has a Target, no Calibrations, and a single Observaton: Target : TargetName : HR 4710 GaiaID : DR3 5859393710380907776 twoMASSID : J12231377 - 6737534 Parallax : 19.730 RadialVelocity : 33.910 Gmag : 6.11 Jmag : 4.97 Teff : 4750 RA : 12 : 23 : 11.79 Dec : - 67 : 37 : 49.47 Equinox : J2000 PMRA : - 11.258 PMDEC : 0.256 Epoch : 2016.00 DRA : 0.000 DDEC : 0.000 Observations : - Object : test1 nExp : 1 ExpTime : 60 TriggerCaHK : True TriggerGreen : True TriggerRed : True BlockSky : False ExpMeterMode : control AutoExpMeter : True ExpMeterBin : 1 ExpMeterThreshold : 10 TakeSimulCal : True AutoNDFilters : True","title":"Observing Blocks"},{"location":"buildingOBs/#building-observing-blocks-obs","text":"The basic unit of KPF nighttime operations is the Observing Block (OB). An OB describes a single visit to a science target and the observations made there. The data contained in the OB is a set of keyword-value pairs. Observers can create OBs in 3 ways: As text files which can be read in by the KPF software and executed. As a database entry by filling out an OB via the KPF-CC Web Form . Please note that the KPF-CC web form is not capable of recording all features of an OB, but should cover 90+% of use cases. Classical observers are also welcome to use the form. Building an OB \"live\" using the KPF OB GUI. The data in an OB can be divided in to three categories: Target : The OB will contain information about the target beyond what is in a typical Keck Star List entry in order to flow that information to the FITS header and the data reduction pipeline (DRP). The target section is only needed if the OB has observations (i.e. it is not purely a calibration OB). Here is a description of all Target Properties . Calibrations : An OB can contain calibrations, these are not typically used by the observer (slewcals are handled separately). Here is a description of all Calibration Properties . The Calibrations section of an ON is a list of Calibration entries. Observations : Finally, the OB will contain a list of observations to be made of the target. For typical KPF observers, this will only have one entry, but multiple entries are supported. Each entry describes a set of exposures on the target and contains the information on how those exposures should be executed. Here is a description of all Observation Properties . The Observations section of an ON is a list of Observation entries. Note that not all properties are needed in every case. For example, an observation with ExpMeterMode: 'monitor' will not need values for ExpMeterBin and ExpMeterThreshold .","title":"Building Observing Blocks (OBs)"},{"location":"buildingOBs/#example-on-sky-science-ob","text":"This is an example of what the text file form of an OB might look like. The file is a yaml format which resolves in to a python dict with keys for \"Target\", \"Calibrations\" and \"Observations\" (not all are required). The \"Target\" entry is a dict with the various Target Properties . The \"Calibrations\" entry (if present) is a list of dictionaries, each with the various Calibration Properties . Similarly, the \"Observations\" entry is a list of dictionaries, each with the various Observation Properties . The example below has a Target, no Calibrations, and a single Observaton: Target : TargetName : HR 4710 GaiaID : DR3 5859393710380907776 twoMASSID : J12231377 - 6737534 Parallax : 19.730 RadialVelocity : 33.910 Gmag : 6.11 Jmag : 4.97 Teff : 4750 RA : 12 : 23 : 11.79 Dec : - 67 : 37 : 49.47 Equinox : J2000 PMRA : - 11.258 PMDEC : 0.256 Epoch : 2016.00 DRA : 0.000 DDEC : 0.000 Observations : - Object : test1 nExp : 1 ExpTime : 60 TriggerCaHK : True TriggerGreen : True TriggerRed : True BlockSky : False ExpMeterMode : control AutoExpMeter : True ExpMeterBin : 1 ExpMeterThreshold : 10 TakeSimulCal : True AutoNDFilters : True","title":"Example On Sky Science OB"},{"location":"cahk/","text":"Calcium H&K Spectrometer A separate small spectrometer is used to monitor the Ca H & K lines for stellar activity that could mimic Doppler shifts. A major advantage of this approach is that the KPF spectrometer does not need to cover an increased bandpass blueward to 390 nm, and can stop at 443 nm (the Doppler information is reduced for G and K stars at bluer wavelengths owing to the significantly lower flux). This approach has important advantages with respect to optical coating bandpasses and efficiency, as well as the required detector size. The Calcium H & K spectrometer is a simple system (VPH-based with doublet lenses for collimator and camera), and is fiber fed via a UV-enhanced fiber (such as CeramOptec UVNS). Light will be injected into this fiber by the FIU, to captrue this light before major UV absorption losses occur within the long fiber run. Under normal conditions, the Ca H&K spectrometer is triggered simultaneously with the main science spectrograph and the data is packaged in to the L0 file with the rest of the science data for analysis by the DRP.","title":"Ca H&K Spectrograph"},{"location":"cahk/#calcium-hk-spectrometer","text":"A separate small spectrometer is used to monitor the Ca H & K lines for stellar activity that could mimic Doppler shifts. A major advantage of this approach is that the KPF spectrometer does not need to cover an increased bandpass blueward to 390 nm, and can stop at 443 nm (the Doppler information is reduced for G and K stars at bluer wavelengths owing to the significantly lower flux). This approach has important advantages with respect to optical coating bandpasses and efficiency, as well as the required detector size. The Calcium H & K spectrometer is a simple system (VPH-based with doublet lenses for collimator and camera), and is fiber fed via a UV-enhanced fiber (such as CeramOptec UVNS). Light will be injected into this fiber by the FIU, to captrue this light before major UV absorption losses occur within the long fiber run. Under normal conditions, the Ca H&K spectrometer is triggered simultaneously with the main science spectrograph and the data is packaged in to the L0 file with the rest of the science data for analysis by the DRP.","title":"Calcium H&amp;K Spectrometer"},{"location":"calbench/","text":"Calibration Bench The cal bench contains several calibration light sources and can inject light in to the simultaneous calibration fiber (one of the components of the pseudo slit) or to inject light to the FIU and thus illuminate the science and sky fibers with the chosen calibration lamp. Most of the calibration sources are located in the \"octagon\". A rotating fold mirror can direct light from one of 8 ports to the calibration fibers. The octagon light sources are: EtalonFiber : Light from a \"SuperK\" continuum source which has passed through the Etalon. BrdbandFiber : A broadband lamp. U_gold : A UNe arc lamp U_daily : A UNe arc lamp Th_daily : A ThAr arc lamp Th_gold : A ThAr arc lamp SoCal-CalFib : Light from the Solar Calibrator LFCFiber : Light from the Laser Frequency Comb (LFC) Etalon The KPF etalon is a thermally stable (~1 mK RMS) resonant cavity fed by an NKT SuperK EVO light source. The resulting line forest covers all of the KPF science passband. The Etalon spectrum evolves slowly with time, so it is not used for obsolte calibration, but it can be used to track the short time scale evolution of the instrument. Effectively \"filling in\" between absolute wavelength calibrators such as the LFC or the arc lamps. Broadband Lamp KPF takes relatively standard spectral flats using a broadband lamp. Because of the extreme requirements for PRV measurements, the flats must be extraordinarily high signal to noise and be taken daily to track any changes. Arc Lamps The arc lamps (ThAr and UNe) can be used for absolute wavelength calibration. Unlike the LFC, they do not have a regular spacing of lines, but they do provide lines in the bluest orders (see below). Two of each lamp are available in the octagon at any time. Laser Frequency Comb The LFC is the best calibrator due to the density of lines which allows a very precise measurement of the wavelength solution, but it is currently (early 2024) limited due to a lack of flux in the bluest orders. For those, the traditional Thorium and Uranium lamps provide absolute calibration.","title":"Calibration Bench"},{"location":"calbench/#calibration-bench","text":"The cal bench contains several calibration light sources and can inject light in to the simultaneous calibration fiber (one of the components of the pseudo slit) or to inject light to the FIU and thus illuminate the science and sky fibers with the chosen calibration lamp. Most of the calibration sources are located in the \"octagon\". A rotating fold mirror can direct light from one of 8 ports to the calibration fibers. The octagon light sources are: EtalonFiber : Light from a \"SuperK\" continuum source which has passed through the Etalon. BrdbandFiber : A broadband lamp. U_gold : A UNe arc lamp U_daily : A UNe arc lamp Th_daily : A ThAr arc lamp Th_gold : A ThAr arc lamp SoCal-CalFib : Light from the Solar Calibrator LFCFiber : Light from the Laser Frequency Comb (LFC)","title":"Calibration Bench"},{"location":"calbench/#etalon","text":"The KPF etalon is a thermally stable (~1 mK RMS) resonant cavity fed by an NKT SuperK EVO light source. The resulting line forest covers all of the KPF science passband. The Etalon spectrum evolves slowly with time, so it is not used for obsolte calibration, but it can be used to track the short time scale evolution of the instrument. Effectively \"filling in\" between absolute wavelength calibrators such as the LFC or the arc lamps.","title":"Etalon"},{"location":"calbench/#broadband-lamp","text":"KPF takes relatively standard spectral flats using a broadband lamp. Because of the extreme requirements for PRV measurements, the flats must be extraordinarily high signal to noise and be taken daily to track any changes.","title":"Broadband Lamp"},{"location":"calbench/#arc-lamps","text":"The arc lamps (ThAr and UNe) can be used for absolute wavelength calibration. Unlike the LFC, they do not have a regular spacing of lines, but they do provide lines in the bluest orders (see below). Two of each lamp are available in the octagon at any time.","title":"Arc Lamps"},{"location":"calbench/#laser-frequency-comb","text":"The LFC is the best calibrator due to the density of lines which allows a very precise measurement of the wavelength solution, but it is currently (early 2024) limited due to a lack of flux in the bluest orders. For those, the traditional Thorium and Uranium lamps provide absolute calibration.","title":"Laser Frequency Comb"},{"location":"calibrations/","text":"Calibrations KPF observers do not need to take afternoon cals because the calibration system is automatic (driven by cron jobs). This is important to PRV science as to get the best RVs, the instrument and its daily cycles need to be characterized, so we want to sample the calibrations in a systematic and repeatable way each day. The calibration schedule is a trade off between several factors. Because we want the calibrations to happen at a consistent time each day, we start the daily schedule based on the latest sunrise and the earliest sunset of the year. The calibrations can be broadly divided in to several categories described in the Types of Calibrations section below. The Daily Calibration Schedule Each day, the calibrations described below are executed. The needs of KPF are such that each day is filled as much as possible by calibrations. The diagram below shows what that schedule looks like over the course of a year as the sunrise and sunset times evolve with the seasons. This figure shows how the KPF calibration schedule interacts with the nighttime schedule over the course of a year (the 23A & B semesters in this case). The various lines show how daily events such as sunrise and sunset evolve in UT time. The lines are labeled on the left side of the plot. The shaded regions are the approximate duration of the scheduled calibrations. Even if no KPF observations are scheduled, the calibrations occupy 816 minutes (more than 13.5 hours) each day, or about 57% of the day. The gaps in this schedule are driven the desire to avoid having calibrations in progress when someone might be starting to operate the instrument: near sunset and at each of the quarter night boundaries. Types of Calibrations Wavelength Calibrations Wavelength calibrations are the most critical daily calibration. Absolute wavelength calibrations use the laser frequency comb (LFC) or one of the hollow cathode lamps (ThAr or UNe). The etalon is also used for wavelength calibration, but in a slightly different way. The etalon spectrum is not fixed to absolute wavelengths as the LFC and the Thorium and Uranium lamps are, but it has the advantage of being far more robust. The positions of the etalon lines can evolve slowly with time, but on short (<1 day) timescales they are stable. Thus the etalon calibration frames can be used to track the evolution of the instrument over daily timescales (anchored by the morning and afternoon wavelength cals). Thus it is valuable to have etalon observations taken periodically throughout the day and night. Broadband Flats KPF takes relatively standard spectral flats using a broadband lamp. Because of the extreme requirements for PRV measurements, the flats must be extraordinarily high signal to noise and be taken daily to track any changes. Biases and Darks KPF takes biases and darks like other instruments. We try to schedule these in to the lamp warmup time built in to other calibrations, so they end up being spread out throughout the day during other calibration OBs. Other Calibrations We currently also take two other calibrations: a set of biases for the Exposure Meter every day and a set of CRED2 guide camera biases a couple times per week. Overnight Etalon In addition to the calibrations taken during daytime, we have scheduled four long calibration sequences to happen overnight. The start times are chosen so that they should not be in progress when an observer might be starting use of the instrument (e.g. at a quarter night boundary). The scheduled cals will not begin during observations because the kpfStartOfNight script sets the kpfconfig.ALLOWSCHEDULEDCALS keyword to \u201cNo\u201d and the script to run the overnight calibrations respects that keyword. If for some reason, they are running when an observer needs to being observing, the cals can be stopped using the standard tools to halt a script in progress (e.g. the \u201cRequest Script Stop\u201d button in the OB GUI).","title":"Daytime Calibrations"},{"location":"calibrations/#calibrations","text":"KPF observers do not need to take afternoon cals because the calibration system is automatic (driven by cron jobs). This is important to PRV science as to get the best RVs, the instrument and its daily cycles need to be characterized, so we want to sample the calibrations in a systematic and repeatable way each day. The calibration schedule is a trade off between several factors. Because we want the calibrations to happen at a consistent time each day, we start the daily schedule based on the latest sunrise and the earliest sunset of the year. The calibrations can be broadly divided in to several categories described in the Types of Calibrations section below.","title":"Calibrations"},{"location":"calibrations/#the-daily-calibration-schedule","text":"Each day, the calibrations described below are executed. The needs of KPF are such that each day is filled as much as possible by calibrations. The diagram below shows what that schedule looks like over the course of a year as the sunrise and sunset times evolve with the seasons. This figure shows how the KPF calibration schedule interacts with the nighttime schedule over the course of a year (the 23A & B semesters in this case). The various lines show how daily events such as sunrise and sunset evolve in UT time. The lines are labeled on the left side of the plot. The shaded regions are the approximate duration of the scheduled calibrations. Even if no KPF observations are scheduled, the calibrations occupy 816 minutes (more than 13.5 hours) each day, or about 57% of the day. The gaps in this schedule are driven the desire to avoid having calibrations in progress when someone might be starting to operate the instrument: near sunset and at each of the quarter night boundaries.","title":"The Daily Calibration Schedule"},{"location":"calibrations/#types-of-calibrations","text":"","title":"Types of Calibrations"},{"location":"calibrations/#wavelength-calibrations","text":"Wavelength calibrations are the most critical daily calibration. Absolute wavelength calibrations use the laser frequency comb (LFC) or one of the hollow cathode lamps (ThAr or UNe). The etalon is also used for wavelength calibration, but in a slightly different way. The etalon spectrum is not fixed to absolute wavelengths as the LFC and the Thorium and Uranium lamps are, but it has the advantage of being far more robust. The positions of the etalon lines can evolve slowly with time, but on short (<1 day) timescales they are stable. Thus the etalon calibration frames can be used to track the evolution of the instrument over daily timescales (anchored by the morning and afternoon wavelength cals). Thus it is valuable to have etalon observations taken periodically throughout the day and night.","title":"Wavelength Calibrations"},{"location":"calibrations/#broadband-flats","text":"KPF takes relatively standard spectral flats using a broadband lamp. Because of the extreme requirements for PRV measurements, the flats must be extraordinarily high signal to noise and be taken daily to track any changes.","title":"Broadband Flats"},{"location":"calibrations/#biases-and-darks","text":"KPF takes biases and darks like other instruments. We try to schedule these in to the lamp warmup time built in to other calibrations, so they end up being spread out throughout the day during other calibration OBs.","title":"Biases and Darks"},{"location":"calibrations/#other-calibrations","text":"We currently also take two other calibrations: a set of biases for the Exposure Meter every day and a set of CRED2 guide camera biases a couple times per week.","title":"Other Calibrations"},{"location":"calibrations/#overnight-etalon","text":"In addition to the calibrations taken during daytime, we have scheduled four long calibration sequences to happen overnight. The start times are chosen so that they should not be in progress when an observer might be starting use of the instrument (e.g. at a quarter night boundary). The scheduled cals will not begin during observations because the kpfStartOfNight script sets the kpfconfig.ALLOWSCHEDULEDCALS keyword to \u201cNo\u201d and the script to run the overnight calibrations respects that keyword. If for some reason, they are running when an observer needs to being observing, the cals can be stopped using the standard tools to halt a script in progress (e.g. the \u201cRequest Script Stop\u201d button in the OB GUI).","title":"Overnight Etalon"},{"location":"communitycadence/","text":"KPF Community Cadence A system for cadenced queue observations is being developed for KPF. As of the 2025A semester, proposers can select the \"KPF-CC\" instrument instead of \"KPF\" in their proposal cover sheet which indicates their interest is joining the community cadence program. Observers wishing to observe classically with KPF, should still select the \"KPF\" instrument on their proposal coversheet. This includes fixed time observations such as those which are scheduled to coincide with transits or other similar phenomenal. Starting in the 2025B semester, KPF-CC programs will need to complete a KPF-CC web form in which they will specify the detailed Observing Blocks and scheduling parameters for their targets. This information will be used by the KPF-CC scheduling program to generate the observing schedule which will be executed by the KPF-CC queue observers (primarily members of the California Planet Search team). Note that the web form must be filled out at the time of proposal submission, so that scheduling feasibility can be established prior to the semester schedule being determined. If you have questions or want more detail about the KPF-CC program, please see their FAQ document .","title":"Community Cadence (KPF-CC)"},{"location":"communitycadence/#kpf-community-cadence","text":"A system for cadenced queue observations is being developed for KPF. As of the 2025A semester, proposers can select the \"KPF-CC\" instrument instead of \"KPF\" in their proposal cover sheet which indicates their interest is joining the community cadence program. Observers wishing to observe classically with KPF, should still select the \"KPF\" instrument on their proposal coversheet. This includes fixed time observations such as those which are scheduled to coincide with transits or other similar phenomenal. Starting in the 2025B semester, KPF-CC programs will need to complete a KPF-CC web form in which they will specify the detailed Observing Blocks and scheduling parameters for their targets. This information will be used by the KPF-CC scheduling program to generate the observing schedule which will be executed by the KPF-CC queue observers (primarily members of the California Planet Search team). Note that the web form must be filled out at the time of proposal submission, so that scheduling feasibility can be established prior to the semester schedule being determined. If you have questions or want more detail about the KPF-CC program, please see their FAQ document .","title":"KPF Community Cadence"},{"location":"computers/","text":"KPF Computers kpf (aka vm-kpf ) is a virtual machine at the summit. It runs the VNC sessions which observers use to interact with the instrument and runs most of the GUIs in those VNCs. kpfserver is the instrument host on which most of the critical dispatchers and keyword services run. kpffiuserver performs a similar function to kpfserver for the FIU and Ca H&K spectrometer in the (physically-separated) AO room. kpfbuild is the build host where files are installed and built. When ready they are deployed using a script to each of the run hosts ( kpfserver , kpffiuserver , and kpf ). kpfetalon is a machine in the basement which handles telemetry from the Etalon thermal controllers and sensors. tc-su-kpfetalon is a small windows machine connected to the NKT SuperK light source for the etalon. It is used when we need to run the NKT software to start up the light source. Data Storage Most KPF data is stored on /sdata1701 on kpfserver which other computers a WMKO cross-mount as /s/sdata1701 . Subdirectories within /sdata1701 are for the assigned account, e.g. kpfeng or kpf1 . Then there are date-coded directories, which correspond to the date of the start of the night (i.e. 2024jun21 is the night of June 21 Hawaii time, but data taken during the second half will be written there even though it is technically June 22 at the moment the data is taken). The date directories change at 2pm HST. An example data directory is /s/sdata1701/kpfeng/2023jul11 . Network KPF is controlled by computers and devices that are behind the WMKO firewall. Most KPF devices (e.g., vacuum controllers) are on a private network behind kpfserver, which has separate network cards for the WMKO network and the private KPF network.","title":"Computers"},{"location":"computers/#kpf-computers","text":"kpf (aka vm-kpf ) is a virtual machine at the summit. It runs the VNC sessions which observers use to interact with the instrument and runs most of the GUIs in those VNCs. kpfserver is the instrument host on which most of the critical dispatchers and keyword services run. kpffiuserver performs a similar function to kpfserver for the FIU and Ca H&K spectrometer in the (physically-separated) AO room. kpfbuild is the build host where files are installed and built. When ready they are deployed using a script to each of the run hosts ( kpfserver , kpffiuserver , and kpf ). kpfetalon is a machine in the basement which handles telemetry from the Etalon thermal controllers and sensors. tc-su-kpfetalon is a small windows machine connected to the NKT SuperK light source for the etalon. It is used when we need to run the NKT software to start up the light source.","title":"KPF Computers"},{"location":"computers/#data-storage","text":"Most KPF data is stored on /sdata1701 on kpfserver which other computers a WMKO cross-mount as /s/sdata1701 . Subdirectories within /sdata1701 are for the assigned account, e.g. kpfeng or kpf1 . Then there are date-coded directories, which correspond to the date of the start of the night (i.e. 2024jun21 is the night of June 21 Hawaii time, but data taken during the second half will be written there even though it is technically June 22 at the moment the data is taken). The date directories change at 2pm HST. An example data directory is /s/sdata1701/kpfeng/2023jul11 .","title":"Data Storage"},{"location":"computers/#network","text":"KPF is controlled by computers and devices that are behind the WMKO firewall. Most KPF devices (e.g., vacuum controllers) are on a private network behind kpfserver, which has separate network cards for the WMKO network and the private KPF network.","title":"Network"},{"location":"dataflow/","text":"Data Flow An idealized vision for the KPF data flow. This is still a work in progress. Raw Data Because KPF contains many detectors, but they are all synchronized in time, the raw data is immediately combined in to a \"Level 0\" (L0) multi-extension FITS file by the kpfassemble dispatcher. Most users will want to use that L0 data for analysis or inspection. Each detector writes data to a separate output directory and kpfassemble will collect them from these to generate the L0 file. This is a relatively quick process, typically the L0 file is written a few seconds after the component raw data are available on disk. As mentioned on the detectors page, the Green and Red detectors have 32 bit ADCs and thus the pixel data do not fall on the usual 0-65535 range you may be used to. L0 Data The L0 data is a multi extension FITS file consisting of the following HDUs: HDU # HDU Name Notes 0 PRIMARY Header only, no image data 1 GREEN_AMP1 Green image data 2 GREEN_AMP2 Green image data 3 RED_AMP1 Red image data 4 RED_AMP2 Red image data 5 CA_HK Ca H&K image data 6 EXPMETER_SCI Table of processed exposure meter spectra 7 EXPMETER_SKY Table of processed exposure meter spectra 8 GUIDER_AVG The average guider image over the duration of the exposure 9 GUIDER_CUBE_ORIGINS Table of telemetry from the tip tilt system 10 TELEMETRY Table of instrument telemetry This can change depending on the composition of the science observation. For example, if the Ca H&K detector was not triggered, that extension would not be used. A guide to examining the L0 data can be found on this page in the documentation for the KPF DRP. Keck Observatory Archive (KOA) The L0 data are immediately sent to KOA for archiving. Observers can \"subscribe\" to the L0 data via KOA's Real Time Ingestion (RTI) interface. Data Reduction The KPF Data Reduction Pipeline was built and delivered by the KPF Instrument Team and is an important part of obtaining the desired performance from the instrument. While Keck plan's to eventually run the DRP locally and provide quick look products (QLP), L1, and L2 data to observers as part of the KOA RTI interface, the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. As a result, data for programs which have partnered with CPS are available through their instance of the DRP which is run on the CPS Team's hardware. Observers who are not part of CPS should contact their Keck SA to arrange for access to reduced data products.","title":"Data Flow"},{"location":"dataflow/#data-flow","text":"An idealized vision for the KPF data flow. This is still a work in progress.","title":"Data Flow"},{"location":"dataflow/#raw-data","text":"Because KPF contains many detectors, but they are all synchronized in time, the raw data is immediately combined in to a \"Level 0\" (L0) multi-extension FITS file by the kpfassemble dispatcher. Most users will want to use that L0 data for analysis or inspection. Each detector writes data to a separate output directory and kpfassemble will collect them from these to generate the L0 file. This is a relatively quick process, typically the L0 file is written a few seconds after the component raw data are available on disk. As mentioned on the detectors page, the Green and Red detectors have 32 bit ADCs and thus the pixel data do not fall on the usual 0-65535 range you may be used to.","title":"Raw Data"},{"location":"dataflow/#l0-data","text":"The L0 data is a multi extension FITS file consisting of the following HDUs: HDU # HDU Name Notes 0 PRIMARY Header only, no image data 1 GREEN_AMP1 Green image data 2 GREEN_AMP2 Green image data 3 RED_AMP1 Red image data 4 RED_AMP2 Red image data 5 CA_HK Ca H&K image data 6 EXPMETER_SCI Table of processed exposure meter spectra 7 EXPMETER_SKY Table of processed exposure meter spectra 8 GUIDER_AVG The average guider image over the duration of the exposure 9 GUIDER_CUBE_ORIGINS Table of telemetry from the tip tilt system 10 TELEMETRY Table of instrument telemetry This can change depending on the composition of the science observation. For example, if the Ca H&K detector was not triggered, that extension would not be used. A guide to examining the L0 data can be found on this page in the documentation for the KPF DRP.","title":"L0 Data"},{"location":"dataflow/#keck-observatory-archive-koa","text":"The L0 data are immediately sent to KOA for archiving. Observers can \"subscribe\" to the L0 data via KOA's Real Time Ingestion (RTI) interface.","title":"Keck Observatory Archive (KOA)"},{"location":"dataflow/#data-reduction","text":"The KPF Data Reduction Pipeline was built and delivered by the KPF Instrument Team and is an important part of obtaining the desired performance from the instrument. While Keck plan's to eventually run the DRP locally and provide quick look products (QLP), L1, and L2 data to observers as part of the KOA RTI interface, the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. As a result, data for programs which have partnered with CPS are available through their instance of the DRP which is run on the CPS Team's hardware. Observers who are not part of CPS should contact their Keck SA to arrange for access to reduced data products.","title":"Data Reduction"},{"location":"detectors/","text":"Overview and Exposure Timing KPF utilizes 5 detectors during normal science operations. Two science detectors (green and red) sit on the main spectrograph bench in the facility basement and record the science spectrum which is used to calculate radial velocities. The Ca H&K Spectrograph is an independant optical system fed by a short fiber which runs from the FIU to a nearby echelle spectrograph which contains the third science detector. The exposure meter is another independent spectrograph which sits in the basement and contains the forth science detector. The fifth detector used during science operations is the CRED2 in the FIU and obtains fast frame rate images used to run the tip tilt system. Because precision radial velocity measurements require exquisite timing, the red and green detectors must have their exposures synced up. To do this, KPF uses a timed shutter on their common light path (before the dichroic splits the light). This is the \"Scrambler Timed Shutter\". As a result, the red and green cameras are not triggered independently. Instead the KPF software takes a single set of exposure parameters and triggers each camera to begin an exposure, then opens and closes timed shutters to ensure simultaneity where needed. In addition, the Scrambler Timed Shutter, also gates the light going to the exposure meter to ensure that its sensitivity to light is simultaneous to the red and green detectors. The Ca H&K spectrograph has its own, separate timed shutter as it is on a completely independent light path to the other detectors. Science Detector Specifications Parameter Green CCD Red CCD Ca H&K CCD Readout Time 47 s 47 s 1 s Read Noise AMP1: 4.0 e- AMP2: 4.9 e- AMP1: 4.1 e- AMP2: 4.2 e- Format 4080x4080 4080x4080 windowed to 1024x255 Gain ~5 e-/ADU ~5 e-/ADU 5.26 e-/ADU Data Format 32 bit 32 bit 16 bit Saturation ~2.1 x 10^9 ADU (~150 ke-) ~2.1 x 10^9 ADU (~150 ke-) 65,536 ADU (344 ke-) Note that the Green and Red science detectors have 32 bit readouts instead of the more common 16 bit (which the Ca H&K detector uses). This means that the values of the raw image pixels are not in the usual 0-65535 range for CCDs, but are instead much larger. To convert to the more usual range we are used to, divide by 2^16 (65536) to get ADU values in that range.","title":"Detectors"},{"location":"detectors/#overview-and-exposure-timing","text":"KPF utilizes 5 detectors during normal science operations. Two science detectors (green and red) sit on the main spectrograph bench in the facility basement and record the science spectrum which is used to calculate radial velocities. The Ca H&K Spectrograph is an independant optical system fed by a short fiber which runs from the FIU to a nearby echelle spectrograph which contains the third science detector. The exposure meter is another independent spectrograph which sits in the basement and contains the forth science detector. The fifth detector used during science operations is the CRED2 in the FIU and obtains fast frame rate images used to run the tip tilt system. Because precision radial velocity measurements require exquisite timing, the red and green detectors must have their exposures synced up. To do this, KPF uses a timed shutter on their common light path (before the dichroic splits the light). This is the \"Scrambler Timed Shutter\". As a result, the red and green cameras are not triggered independently. Instead the KPF software takes a single set of exposure parameters and triggers each camera to begin an exposure, then opens and closes timed shutters to ensure simultaneity where needed. In addition, the Scrambler Timed Shutter, also gates the light going to the exposure meter to ensure that its sensitivity to light is simultaneous to the red and green detectors. The Ca H&K spectrograph has its own, separate timed shutter as it is on a completely independent light path to the other detectors.","title":"Overview and Exposure Timing"},{"location":"detectors/#science-detector-specifications","text":"Parameter Green CCD Red CCD Ca H&K CCD Readout Time 47 s 47 s 1 s Read Noise AMP1: 4.0 e- AMP2: 4.9 e- AMP1: 4.1 e- AMP2: 4.2 e- Format 4080x4080 4080x4080 windowed to 1024x255 Gain ~5 e-/ADU ~5 e-/ADU 5.26 e-/ADU Data Format 32 bit 32 bit 16 bit Saturation ~2.1 x 10^9 ADU (~150 ke-) ~2.1 x 10^9 ADU (~150 ke-) 65,536 ADU (344 ke-) Note that the Green and Red science detectors have 32 bit readouts instead of the more common 16 bit (which the Ca H&K detector uses). This means that the values of the raw image pixels are not in the usual 0-65535 range for CCDs, but are instead much larger. To convert to the more usual range we are used to, divide by 2^16 (65536) to get ADU values in that range.","title":"Science Detector Specifications"},{"location":"expmetertermination/","text":"Exposure Meter Termination KPF contains an exposure meter which can measure the flux weighted midpoint of an exposure. This can also be used to terminate a science exposure once a desired signal level is reached. To do this the system will track the flux measured in the exposure meter spectra binned in to 4 passbands, each about 100nm wide, centered on 498.125nm, 604.375nm, 710.625nm, and 816.875nm respectively. To use exposure meter termination, the observer sets ExpMeterMode: control in the Observations section of the OB and then chooses one wavelength band to trigger on (using the ExpMeterBin value) and then chooses the target flux (in Mphotons/A at peak of blaze via the ExpMeterThreshold value) in the resulting science spectrum that is desired. The system will convert the target value for the science spectrum in to a total ADU count for the exposure meter in that particular bandpass and when that threshold is surpassed, the exposure will stop. Regardless of whether that exposure meter threshold is passed, the exposure will stop when the nominal exposure time is reached. Thus when using exposure meter termination, the ExpTime parameter should be thought of as the maximum allowed exposure time. For example, an OB with the following values: ExpTime: 300 ExpMeterMode: control ExpMeterBin: 604.375 ExpMeterThreshold: 10 will terminate when the exposure meter flux reaches a value which should result in approximately 10,000,000 photons/A signal in the resulting science spectrum at about 604nm or when the total exposure time reaches 300 seconds, whichever comes first. Signal to Noise A very approximate signal to noise estimate is to take the ExpMeterThreshold value (again this is in Mphotons/A), take the square root, and multiply by 120: SNR ~ 120*ExpMeterThreshold^0.5 This roughly predicts the DRP derived SNR values in the reduced data. The figure below shows the SNR values (reported by the DRP in various wavelengths) plotted against the ExpMeterThreshold value (Mphotons/A). Note that there is some scatter in the plot below, in part due to a mismatch between the exposure meter termination wavelength bins and the wavelength of the SNR measurement from the DRP.","title":"Exposure Meter Termination"},{"location":"expmetertermination/#exposure-meter-termination","text":"KPF contains an exposure meter which can measure the flux weighted midpoint of an exposure. This can also be used to terminate a science exposure once a desired signal level is reached. To do this the system will track the flux measured in the exposure meter spectra binned in to 4 passbands, each about 100nm wide, centered on 498.125nm, 604.375nm, 710.625nm, and 816.875nm respectively. To use exposure meter termination, the observer sets ExpMeterMode: control in the Observations section of the OB and then chooses one wavelength band to trigger on (using the ExpMeterBin value) and then chooses the target flux (in Mphotons/A at peak of blaze via the ExpMeterThreshold value) in the resulting science spectrum that is desired. The system will convert the target value for the science spectrum in to a total ADU count for the exposure meter in that particular bandpass and when that threshold is surpassed, the exposure will stop. Regardless of whether that exposure meter threshold is passed, the exposure will stop when the nominal exposure time is reached. Thus when using exposure meter termination, the ExpTime parameter should be thought of as the maximum allowed exposure time. For example, an OB with the following values: ExpTime: 300 ExpMeterMode: control ExpMeterBin: 604.375 ExpMeterThreshold: 10 will terminate when the exposure meter flux reaches a value which should result in approximately 10,000,000 photons/A signal in the resulting science spectrum at about 604nm or when the total exposure time reaches 300 seconds, whichever comes first.","title":"Exposure Meter Termination"},{"location":"expmetertermination/#signal-to-noise","text":"A very approximate signal to noise estimate is to take the ExpMeterThreshold value (again this is in Mphotons/A), take the square root, and multiply by 120: SNR ~ 120*ExpMeterThreshold^0.5 This roughly predicts the DRP derived SNR values in the reduced data. The figure below shows the SNR values (reported by the DRP in various wavelengths) plotted against the ExpMeterThreshold value (Mphotons/A). Note that there is some scatter in the plot below, in part due to a mismatch between the exposure meter termination wavelength bins and the wavelength of the SNR measurement from the DRP.","title":"Signal to Noise"},{"location":"exposuremeter/","text":"Exposure Meter An accurate measurement of the time of the flux-weighted midpoint of each exposure is essential to correct for the barycentric velocity of the Earth. During an exposure, a small fraction of the light within the spectrometer is diverted to a separate, low-resolution spectrometer that records the flux time series for all wavelengths across the main spectrometer bandpass. This system accurately tracks the photon arrival times in the parent spectrometer, allowing for precise determination of flux-weighted exposure mid-points as a function of wavelength. The optical design of the exposure meter is a prism-based spectrometer with a resolving power of approximately 100. The exposure meter accepts light from two fibers; one collecting light from the otherwise unused outboard slices of the science fiber at the spectrometer reformatter entrance, and a sky fiber from the fiber injection unit on the telescope. The optical design is shown in the following figure. Optical design of the KPF Exposure Meter","title":"Exposure Meter"},{"location":"exposuremeter/#exposure-meter","text":"An accurate measurement of the time of the flux-weighted midpoint of each exposure is essential to correct for the barycentric velocity of the Earth. During an exposure, a small fraction of the light within the spectrometer is diverted to a separate, low-resolution spectrometer that records the flux time series for all wavelengths across the main spectrometer bandpass. This system accurately tracks the photon arrival times in the parent spectrometer, allowing for precise determination of flux-weighted exposure mid-points as a function of wavelength. The optical design of the exposure meter is a prism-based spectrometer with a resolving power of approximately 100. The exposure meter accepts light from two fibers; one collecting light from the otherwise unused outboard slices of the science fiber at the spectrometer reformatter entrance, and a sky fiber from the fiber injection unit on the telescope. The optical design is shown in the following figure. Optical design of the KPF Exposure Meter","title":"Exposure Meter"},{"location":"fastreadmode/","text":"Fast Read Mode The Green and Red science detectors can operate in a fast readout mode. This reduces the readout time to 16 seconds (and significantly increases the read noise), however changing the readout modes induces a temperature change at the detectors which can impact PRV measurements. As a result, fast read mode observations should be limited to those instances where it is critical to the science (e.g. seismology or other high cadence observations of a single target) and which are scheduled such that the mode change will not have overly negative impact on other science that night. Fast read mode is not appropriate for long term cadenced RV measurements as the two read modes have different systematic offsets and so RV measurements of the same target taken in different modes can not be easily combined. If you are interested in utilizing fast read mode, please contact kpf_info well ahead of your run. Fast read mode may not be available in all cases due to the impact on other scheduled observations. If it is available for your run, the Keck SA will schedule when the mode is changed and when fast read mode calibrations (primarily biases) can be taken. Our goal will be to minimize the number of changes of the read mode. After a mode change in either direction, the system needs time to stabilize before precision RVs are possible. We have estimated this stabilization time to be about 20 minutes. Because KPF is expected to operate in normal read mode and be available for precision RVs and fast read mode is the aberration, when this 20 minute wait time is needed during the night (i.e. the mode change does not happen well before or after the observing window), then all instances of this 20 minute window should be considered part of the fast read mode program. As a result, if the read mode is normal for observations at the beginning the night, then is switched to fast, then back to normal for observations at the end of the night. Both 20 minute wait times (40 minutes total) are overhead which are considered part of the fast read mode program. Details The KPF main spectrometer CCDs can be operated in two read modes: normal and fast. The main difference is the time to read the CCDs, which is 47 sec in normal-read mode and 16 sec in fast-read mode. In general, KPF observations should be taken in normal-read mode unless there is a highly compelling reason to operate in fast-read mode. The fast-read mode is only offered for KPF observations where the speed will aid in resolving fast astrophysical phenomena (e.g., seismology) or for cases where short exposure times are required to avoid saturation and the efficiency is significantly improved by also reading the CCDs quickly (e.g., observing a very bright star during a planetary transit). This applies to sequences of exposures ranging from 1 hour to 1 night in duration. The fast-read mode should not be used to improve the efficiency of individual exposure or short sequences of exposures, which comprise the vast majority of KPF observations. The motivation for this strategy is that changing between the two modes imparts a ~10 mK temperature transient to the CCDs, which shift and stretch at the nanometer level in response. These perturbations violate the operating requirements of maintaining 1 mK rms temperature stability of the CCDs and lead to systematic errors in Doppler measurements on short timescales (< 20-30 min). On longer timescales, the CCDs appear to relax back to their original state, but this has not been measured at the sub-30 cm/s level. Out of conservatism, KPF is toggled between read modes as infrequently as possible. Automated daily calibration sequences are taken in the normal-read mode and are used in the KPF Data Reduction Pipeline (DRP) to process spectra taken with both read modes. Radial velocities measured from KPF spectra in the two modes are offset; users cannot combine RVs from the two modes in a time series. On the other hand, RVs measured from spectra taken in the fast-read mode during a single night (which are processed with a common set of calibrations) have high Doppler stability over that night-long timescale; this is the main use case for the fast-read mode. Some additional tradeoffs to consider are the increased read noise and the charge transfer inefficiency (CTI) in fast-read mode. As listed in the table below, the read noise (measured in rms noise per CCD pixel) is 1.5-2X higher in fast-read mode. This limits the utility of this mode for faint sources, which have higher Poisson noise per CCD pixel in the source spectrum. In fast-read mode, the CCDs are read out using four amplifiers at a higher clock speed (instead of two amplifiers at a slower speed). This strategy brings one amplifier on the Green CCD into play that has ~100x higher CTI than the others. CTI smears the spectrum along the direction of the CCD rows (leaving a trail of charge along pixels as they are clocked). As a result, stellar lines in the affected quadrant are smeared in the dispersion direction. The intensity of the effect depends on the number of electrons in each pixel (i.e., the SNR of the spectrum), making this effect very difficult to calibrate for precise RV measurements. When computing RVs for fast-read mode spectra, the KPF DRP ignores portions of the spectrum in the affected quadrant. This increases the RV uncertainties in the fast-read mode and adds an additional RV zero-point offset between measurements in the two modes. Fast spectroscopy to measure changes in line intensity (not line shape or center) can still be accomplished using spectra from the affected quadrant. Parameter Normal Read Mode Fast Read Mode Readout Time 47 s 16 s Read Noise Green: 4.0, 4.9 e- Red: 4.1, 4.2 e- Green: 8.2, 9.7, 8.6, 6.9 e- Red: 6.0, 5.8, 8.2, 6.6 e- Charge Transfer One green amp has ~100x higher CTI Use Cases Most KPF observations, including cadence RPV measurements and general spectroscopy Sequences of short exposures whose duration is 1 hour to 1 night.","title":"Fast Read Mode"},{"location":"fastreadmode/#fast-read-mode","text":"The Green and Red science detectors can operate in a fast readout mode. This reduces the readout time to 16 seconds (and significantly increases the read noise), however changing the readout modes induces a temperature change at the detectors which can impact PRV measurements. As a result, fast read mode observations should be limited to those instances where it is critical to the science (e.g. seismology or other high cadence observations of a single target) and which are scheduled such that the mode change will not have overly negative impact on other science that night. Fast read mode is not appropriate for long term cadenced RV measurements as the two read modes have different systematic offsets and so RV measurements of the same target taken in different modes can not be easily combined. If you are interested in utilizing fast read mode, please contact kpf_info well ahead of your run. Fast read mode may not be available in all cases due to the impact on other scheduled observations. If it is available for your run, the Keck SA will schedule when the mode is changed and when fast read mode calibrations (primarily biases) can be taken. Our goal will be to minimize the number of changes of the read mode. After a mode change in either direction, the system needs time to stabilize before precision RVs are possible. We have estimated this stabilization time to be about 20 minutes. Because KPF is expected to operate in normal read mode and be available for precision RVs and fast read mode is the aberration, when this 20 minute wait time is needed during the night (i.e. the mode change does not happen well before or after the observing window), then all instances of this 20 minute window should be considered part of the fast read mode program. As a result, if the read mode is normal for observations at the beginning the night, then is switched to fast, then back to normal for observations at the end of the night. Both 20 minute wait times (40 minutes total) are overhead which are considered part of the fast read mode program.","title":"Fast Read Mode"},{"location":"fastreadmode/#details","text":"The KPF main spectrometer CCDs can be operated in two read modes: normal and fast. The main difference is the time to read the CCDs, which is 47 sec in normal-read mode and 16 sec in fast-read mode. In general, KPF observations should be taken in normal-read mode unless there is a highly compelling reason to operate in fast-read mode. The fast-read mode is only offered for KPF observations where the speed will aid in resolving fast astrophysical phenomena (e.g., seismology) or for cases where short exposure times are required to avoid saturation and the efficiency is significantly improved by also reading the CCDs quickly (e.g., observing a very bright star during a planetary transit). This applies to sequences of exposures ranging from 1 hour to 1 night in duration. The fast-read mode should not be used to improve the efficiency of individual exposure or short sequences of exposures, which comprise the vast majority of KPF observations. The motivation for this strategy is that changing between the two modes imparts a ~10 mK temperature transient to the CCDs, which shift and stretch at the nanometer level in response. These perturbations violate the operating requirements of maintaining 1 mK rms temperature stability of the CCDs and lead to systematic errors in Doppler measurements on short timescales (< 20-30 min). On longer timescales, the CCDs appear to relax back to their original state, but this has not been measured at the sub-30 cm/s level. Out of conservatism, KPF is toggled between read modes as infrequently as possible. Automated daily calibration sequences are taken in the normal-read mode and are used in the KPF Data Reduction Pipeline (DRP) to process spectra taken with both read modes. Radial velocities measured from KPF spectra in the two modes are offset; users cannot combine RVs from the two modes in a time series. On the other hand, RVs measured from spectra taken in the fast-read mode during a single night (which are processed with a common set of calibrations) have high Doppler stability over that night-long timescale; this is the main use case for the fast-read mode. Some additional tradeoffs to consider are the increased read noise and the charge transfer inefficiency (CTI) in fast-read mode. As listed in the table below, the read noise (measured in rms noise per CCD pixel) is 1.5-2X higher in fast-read mode. This limits the utility of this mode for faint sources, which have higher Poisson noise per CCD pixel in the source spectrum. In fast-read mode, the CCDs are read out using four amplifiers at a higher clock speed (instead of two amplifiers at a slower speed). This strategy brings one amplifier on the Green CCD into play that has ~100x higher CTI than the others. CTI smears the spectrum along the direction of the CCD rows (leaving a trail of charge along pixels as they are clocked). As a result, stellar lines in the affected quadrant are smeared in the dispersion direction. The intensity of the effect depends on the number of electrons in each pixel (i.e., the SNR of the spectrum), making this effect very difficult to calibrate for precise RV measurements. When computing RVs for fast-read mode spectra, the KPF DRP ignores portions of the spectrum in the affected quadrant. This increases the RV uncertainties in the fast-read mode and adds an additional RV zero-point offset between measurements in the two modes. Fast spectroscopy to measure changes in line intensity (not line shape or center) can still be accomplished using spectra from the affected quadrant. Parameter Normal Read Mode Fast Read Mode Readout Time 47 s 16 s Read Noise Green: 4.0, 4.9 e- Red: 4.1, 4.2 e- Green: 8.2, 9.7, 8.6, 6.9 e- Red: 6.0, 5.8, 8.2, 6.6 e- Charge Transfer One green amp has ~100x higher CTI Use Cases Most KPF observations, including cadence RPV measurements and general spectroscopy Sequences of short exposures whose duration is 1 hour to 1 night.","title":"Details"},{"location":"fiu/","text":"Fiber Injection Unit (FIU) The Fiber Injection Unit (FIU) sits on the Keck I AO bench ahead of AO correction. The unit's primary role is to feed telescope light to the science, sky, and Ca H&K fibers. The unit utilizes a pair of dichroics to send light to the relevant subsystems: Wavelength Range Subsystem Notes 382-402 nm Ca H&K Spectrograph Includes two fibers (science and sky) 445-870 nm Science Spectrograph Includes two fibers (science and sky) 950-1200 nm Guide Camera Used for acquisition and fast tip tilt correction The FIU can also be configured in a mode which takes light from the calibration bench in the basement and injects it in to the science and sky fibers. Atmospheric Dispersion Correctors In addition, the FIU contains atmospheric dispersion correction (ADC) systems for both the science and Ca H&K wavelengths. Science ADC For the science arm, a pair of prisms are rotated to provide dispersion correction based on the telescope position. The ADCs are designed to keep all the science wavelengths within 50 mas. The ADC corrects atmospheric dispersion at that full 50 mas specification down to an elevation of 30 degrees. The prisms reach their maximum correction power at an elevation of 25 degrees, beyond that, their correction power is fixed and no longer increases as the elevation decreases. Ca H&K ADC For the Ca H&K arm, the fiber is on a two axis stage and is translated in such as way as to place the fiber under the correct wavelengths of light. The total wavelength range in this arm is small enough that only the differential position between this arm and the science and guide arms is corrected, there is no correction of the dispersion over the narrow wavelength range of the Ca H&K arm. FIU Layout The FIU layout when in science mode. Light from the telescope is directed to the FIU off of a tip tilt mirror located on the PCU stage. The FIU layout when in calibration mode. The calibration fibers are illuminated and a fold mirror is moved in to place to direct their light on to the science fiber. Fiber Viewing Cameras Both the science arm and the Ca H&K arm have fiber viewing cameras (FVCs) for imaging the fiber tip. These are only useful in an engineering context as it takes a very bright (roughly 1st magnitude) star to be visible because the FVCs are looking through the dichroics (and the ADC prisms in the science arm). This drastically reduced the amount of light to the FVCs and makes the images hard to interpret due to reflections and ghost images.","title":"FIU"},{"location":"fiu/#fiber-injection-unit-fiu","text":"The Fiber Injection Unit (FIU) sits on the Keck I AO bench ahead of AO correction. The unit's primary role is to feed telescope light to the science, sky, and Ca H&K fibers. The unit utilizes a pair of dichroics to send light to the relevant subsystems: Wavelength Range Subsystem Notes 382-402 nm Ca H&K Spectrograph Includes two fibers (science and sky) 445-870 nm Science Spectrograph Includes two fibers (science and sky) 950-1200 nm Guide Camera Used for acquisition and fast tip tilt correction The FIU can also be configured in a mode which takes light from the calibration bench in the basement and injects it in to the science and sky fibers.","title":"Fiber Injection Unit (FIU)"},{"location":"fiu/#atmospheric-dispersion-correctors","text":"In addition, the FIU contains atmospheric dispersion correction (ADC) systems for both the science and Ca H&K wavelengths.","title":"Atmospheric Dispersion Correctors"},{"location":"fiu/#science-adc","text":"For the science arm, a pair of prisms are rotated to provide dispersion correction based on the telescope position. The ADCs are designed to keep all the science wavelengths within 50 mas. The ADC corrects atmospheric dispersion at that full 50 mas specification down to an elevation of 30 degrees. The prisms reach their maximum correction power at an elevation of 25 degrees, beyond that, their correction power is fixed and no longer increases as the elevation decreases.","title":"Science ADC"},{"location":"fiu/#ca-hk-adc","text":"For the Ca H&K arm, the fiber is on a two axis stage and is translated in such as way as to place the fiber under the correct wavelengths of light. The total wavelength range in this arm is small enough that only the differential position between this arm and the science and guide arms is corrected, there is no correction of the dispersion over the narrow wavelength range of the Ca H&K arm.","title":"Ca H&amp;K ADC"},{"location":"fiu/#fiu-layout","text":"The FIU layout when in science mode. Light from the telescope is directed to the FIU off of a tip tilt mirror located on the PCU stage. The FIU layout when in calibration mode. The calibration fibers are illuminated and a fold mirror is moved in to place to direct their light on to the science fiber.","title":"FIU Layout"},{"location":"fiu/#fiber-viewing-cameras","text":"Both the science arm and the Ca H&K arm have fiber viewing cameras (FVCs) for imaging the fiber tip. These are only useful in an engineering context as it takes a very bright (roughly 1st magnitude) star to be visible because the FVCs are looking through the dichroics (and the ADC prisms in the science arm). This drastically reduced the amount of light to the FVCs and makes the images hard to interpret due to reflections and ghost images.","title":"Fiber Viewing Cameras"},{"location":"guider/","text":"Guider The KPF guide camera views the science field, but behind a long pass dichroic which sends light blueward of about 950nm to the science and Ca H&K fibers. As a result, the guide camera was chosen to be a \"short wave IR\" camera utilizing an InGaS detector. Camera Model First Light CRED2 Pixel Scale 0.056 arcsec/pix Field of View 35 x 28 arcseconds Frame Rate up to 400 Hz (100 Hz recommended) Passband 950-1200 nm (0.95-1.2 microns) Gain Settings high, medium, low Note that while the camera can operate at 400 Hz, the practical limit for operations is around 100-150 Hz due to tip tilt system limitations. Rather than using traditional telescope guiding, the guide camera takes images at high frame rates and sends corrections to a fast tip tilt mirror situated just outside the FIU. We recommend running the system at 100 Hz for optimum performance. The system will offload corrections from the tip tilt mirror to the telescope drive system periodically as needed to keep the tip tilt mirror within its optimum range of travel. The OAs use a separate GUI for controlling the KPF tip tilt system (not the usual Magiq interface used on other instruments). The OAs can run Magiq in \"centroid only\" mode which will provide FWHM and flux feedback to the observer in the normal Magiq display.","title":"Guider"},{"location":"guider/#guider","text":"The KPF guide camera views the science field, but behind a long pass dichroic which sends light blueward of about 950nm to the science and Ca H&K fibers. As a result, the guide camera was chosen to be a \"short wave IR\" camera utilizing an InGaS detector. Camera Model First Light CRED2 Pixel Scale 0.056 arcsec/pix Field of View 35 x 28 arcseconds Frame Rate up to 400 Hz (100 Hz recommended) Passband 950-1200 nm (0.95-1.2 microns) Gain Settings high, medium, low Note that while the camera can operate at 400 Hz, the practical limit for operations is around 100-150 Hz due to tip tilt system limitations. Rather than using traditional telescope guiding, the guide camera takes images at high frame rates and sends corrections to a fast tip tilt mirror situated just outside the FIU. We recommend running the system at 100 Hz for optimum performance. The system will offload corrections from the tip tilt mirror to the telescope drive system periodically as needed to keep the tip tilt mirror within its optimum range of travel. The OAs use a separate GUI for controlling the KPF tip tilt system (not the usual Magiq interface used on other instruments). The OAs can run Magiq in \"centroid only\" mode which will provide FWHM and flux feedback to the observer in the normal Magiq display.","title":"Guider"},{"location":"kpfdrp/","text":"Data Reduction Pipeline WMKO automatically delivers KPF L0 data products to the Keck Observatory Archive (KOA) for distribution to observers. We plan to distribute L1 and L2 data products as well, but the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. Observers not affiliated with the KPF build team or with the California Planet Search (CPS) should contact their Staff Astronomer about access to reduced data products. Advanced users who would like to run the DRP locally can find the KPF DRP on GitHub and the documentation can be found on ReadTheDocs . Level Definitions Level Description L0 Raw spectra packaged with other instrument data (see Data Format for details) L1 1-d, wavelength calibrated spectra ( KPF DRP page on L1 data format ) L2 RVs, multiple activity indicators ( KPF DRP page on L2 data format )","title":"Data Reduction"},{"location":"kpfdrp/#data-reduction-pipeline","text":"WMKO automatically delivers KPF L0 data products to the Keck Observatory Archive (KOA) for distribution to observers. We plan to distribute L1 and L2 data products as well, but the KPF DRP is still under active development by the KPF science team, so the Keck deployment of the DRP is on hold until there are less frequent changes for us to track. Observers not affiliated with the KPF build team or with the California Planet Search (CPS) should contact their Staff Astronomer about access to reduced data products. Advanced users who would like to run the DRP locally can find the KPF DRP on GitHub and the documentation can be found on ReadTheDocs .","title":"Data Reduction Pipeline"},{"location":"kpfdrp/#level-definitions","text":"Level Description L0 Raw spectra packaged with other instrument data (see Data Format for details) L1 1-d, wavelength calibrated spectra ( KPF DRP page on L1 data format ) L2 RVs, multiple activity indicators ( KPF DRP page on L2 data format )","title":"Level Definitions"},{"location":"nighttimecalibrations/","text":"Nighttime Calibrations To monitor the instrumental drift, KPF needs calibrations taken throughout the night. There are two different calibrations that can be taken and each has advantages and disadvantages. As we fully characterize the instrument and as the DRP evolves, our recommendations for how best to run nighttime calibrations may change, so check back here for updates. Recommended Strategy The current recommendation is to take a slew cal roughly every hour or so. There is a \"Time Since Cal\" readout in the upper right of the OB GUI. When the time since the last calibration exceeds 1 hour, the readout will turn orange. At 2 hours, it will turn red. This is only a recommendation, so the decision of when to take a slew cal is up to the observer. See also the Observing Procedures page. What is a Slew Cal? Slew cals are a particular calibration (a single Etalon calibration exposure) which is intended to be taken during a long telescope slew. The best way to execute this is to click the \"Execute OB with Slew Cal\" button after loading the next desired OB and asking the OA to begin slewing to the target. You should let the OA know you are running a slew cal as this will close the FIU hatch and direct Etalon light through the FIU which means that they will no longer see the sky on the guider during the calibration (which takes about 2 minutes). Directing the calibration light through the FIU means that we will be illuminating the science, sky, and simulcal fibers (all 5 traces) with calibration light. Because the slew cal happens during the slew to a target, it is optimally performed with a science OB so that the guider can be configured for the science target. This is another case where executing a science OB before the slew has completed is the most efficient observing strategy. What are Simultaneous Calibrations (SimulCals)? Simultaneous Calibration (simulcal) is when the calibration trace (one of the 5 traces on the main science detectors) is illuminated with calibration light (usually the etalon). This can be done during science observations, but there are a number of caveats and potential pitfalls. The main concern when using simulcals is to get the appropriate calibration flux. Because the science exposure time changes depending on the target, the brightness of the light injected in to the simulcal fiber must be modulated to find an appropriate flux. This is accomplished with two filter wheels in the calibration bench which have neutral density (ND) filters. Too little simulcal flux is problematic because it makes the calibration less useful, but too much simulcal flux is worse. Even tiny amounts of scattered light or the far wings of an overly bright simulcal PSF can impact the science traces and bias the RV measurements. Because of this, we have built an automatic system for choosing the ND filters appropriate for the observation. This is a complex system because it must account for the color of the star as well as the brightness. To use this system, the star must be compatible with the KPF exposure time calculator which means the star must have a Teff between 2700 and 6600 Kelvin. Outside of that range, the automatic ND filter configuration is not available.","title":"Nighttime Calibrations"},{"location":"nighttimecalibrations/#nighttime-calibrations","text":"To monitor the instrumental drift, KPF needs calibrations taken throughout the night. There are two different calibrations that can be taken and each has advantages and disadvantages. As we fully characterize the instrument and as the DRP evolves, our recommendations for how best to run nighttime calibrations may change, so check back here for updates.","title":"Nighttime Calibrations"},{"location":"nighttimecalibrations/#recommended-strategy","text":"The current recommendation is to take a slew cal roughly every hour or so. There is a \"Time Since Cal\" readout in the upper right of the OB GUI. When the time since the last calibration exceeds 1 hour, the readout will turn orange. At 2 hours, it will turn red. This is only a recommendation, so the decision of when to take a slew cal is up to the observer. See also the Observing Procedures page.","title":"Recommended Strategy"},{"location":"nighttimecalibrations/#what-is-a-slew-cal","text":"Slew cals are a particular calibration (a single Etalon calibration exposure) which is intended to be taken during a long telescope slew. The best way to execute this is to click the \"Execute OB with Slew Cal\" button after loading the next desired OB and asking the OA to begin slewing to the target. You should let the OA know you are running a slew cal as this will close the FIU hatch and direct Etalon light through the FIU which means that they will no longer see the sky on the guider during the calibration (which takes about 2 minutes). Directing the calibration light through the FIU means that we will be illuminating the science, sky, and simulcal fibers (all 5 traces) with calibration light. Because the slew cal happens during the slew to a target, it is optimally performed with a science OB so that the guider can be configured for the science target. This is another case where executing a science OB before the slew has completed is the most efficient observing strategy.","title":"What is a Slew Cal?"},{"location":"nighttimecalibrations/#what-are-simultaneous-calibrations-simulcals","text":"Simultaneous Calibration (simulcal) is when the calibration trace (one of the 5 traces on the main science detectors) is illuminated with calibration light (usually the etalon). This can be done during science observations, but there are a number of caveats and potential pitfalls. The main concern when using simulcals is to get the appropriate calibration flux. Because the science exposure time changes depending on the target, the brightness of the light injected in to the simulcal fiber must be modulated to find an appropriate flux. This is accomplished with two filter wheels in the calibration bench which have neutral density (ND) filters. Too little simulcal flux is problematic because it makes the calibration less useful, but too much simulcal flux is worse. Even tiny amounts of scattered light or the far wings of an overly bright simulcal PSF can impact the science traces and bias the RV measurements. Because of this, we have built an automatic system for choosing the ND filters appropriate for the observation. This is a complex system because it must account for the color of the star as well as the brightness. To use this system, the star must be compatible with the KPF exposure time calculator which means the star must have a Teff between 2700 and 6600 Kelvin. Outside of that range, the automatic ND filter configuration is not available.","title":"What are Simultaneous Calibrations (SimulCals)?"},{"location":"observingprocedures/","text":"Quick Reference Beginning of the Night Performing Observations Switching Programs on a Split Night Bad Weather Beginning of the Night Wait for Dome to Open The Observing Assistant (OA) is not permitted to open the dome until after sunset. Please be patient while the shutter opens and the OA checks the initial telescope pointing. Run Start of Night KPF needs to be configured properly at the start of the night. There is a procedure which should be run only after the Observing Assistant (OA) has selected KPF as the instrument and after automated afternoon calibrations are complete. The selected instrument (\"INST\") can be seen in the lower left corner of the FACSUM window . It is important that this not be run while other instruments are observing. To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will: Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Configure the tip tilt loop gain to its default setting Set data output directory Set observers from telescope schedule Load your OBs in the KPF OB GUI In the KPF OB GUI, from the \"OB List\" menu, choose a method to load OBs for the night. Depending on your program, this may mean loading a schedule for KPF-CC (Community Cadence), loading OBs from the database for a classical program, or opening OB files on disk. This should populate the \"Observing Block List\" are of the GUI and will send these targets to the Magiq sar list (which will also be visible in the observer Magiq GUI). Slew to the Vicinity of Your First Target When ready to move the telescope, the OA will ask you for your first target and load the coordinates from Magiq. They will select a bright star near your target and will attempt to acquire that in the guider, then will double-check the accuracy of pointing by acquiring one or two additional stars from the SAO or GSC catalogs. To monitor the guider images, use the Magiq Observer UI which is available from Telescope GUIs --> MAGIQ Guider UI in the FVWM background menu if it is not already up. Focus the Telescope The OA will run the telescope focus procedure (typically Autofoc) near your science field. On some nights, they will opt for the Mira focus procedure which takes slightly longer but is needed to calibrate the secondary mirror tilt. Performing Observations Execute Your OB Executing an OB is as simple as selecting it in the \"Observing Block List\" in the KPF OB GUI and clicking the \"Execute Selected OB\" button (or \"Execute with SlewCal\"). This will highlight the target in Magiq so that the OA can begin slewing the telescope. The GUI will first prompt the observers to confirm the OB execution. Once confirmed, an xterm will launch and prompt the observers with addtional information if and when needed, so watch the contents of this xterm. Executing the OB will not start an exposure immediately. The system will first configure the instrument and will then prompt the observer to confirm once the OA has acquired the target. While configuring the instrument, the OB will provide information on how to set the gain and frames per second on the guider. Because of this, it is important to execute the OB during the slew and before the OA acquires the target, so they have the right exposure parameters to see the target on the guider. The log lines which show up in the xterm with the running OB contain useful information. In general, lines with INFO are attempting to explain what the instrument is doing. Lines with WARNING are indicating that a minor problem has occurred, but the system is handling it -- these lines are purely informational, no action is needed on the part of the observer in response. Lines with ERROR indicate a serious problems which may require user intervention. Slew Cals KPF has the option of taking a \"slew cal\" immediately prior to a science observation. This is a way to make use of the time spent slewing from one target to another. If an OB is executed with a slew cal (using the \"Execute OB with Slew Cal\" button in the OB GUI), then the FIU will transition to calibration mode (the FIU hatch will close and calibration light will be directed to the science and sky fibers), and a calibration exposure will be taken. This will obscure the sky during calibration, so the OA will not be able to see the target until the slew cal is done. This process takes around 2 minutes and so fits nicely in to long slews. An alternative to a slew cal is a simultaneous calibration (simulcal). To use this enable the TakeSimulCal option in the OB or on the OB GUI and either manually set the ND filters to apply to the calibration light or enable the AutoNDFilters option. See the nighttime calibrations page for more info on both the slew cal and simulcal options. Stopping Scripts or Exposures Important : If you wish to halt an OB during execution, do NOT hit Control-c in the terminal. Use the \"Request Script STOP\" button instead. The KPF scripts have checkpoints in them which are places where the script can cleanly exit and perform important cleanup operations. The \"STOP Exposure and Script\" button does the same thing, but it will also terminate an exposure in progress. Known Issues There is a known failure mode for KPF called a \"start state error\". What happens is some sort of communication failure between the kpfexpose control software, the galil hardware which handles the timing and signaling of the detectors and shutters, and the Archon detector controllers. The result is that one of the green or red detectors does not begin the exposure properly and that detector's data will be useless. The kpf.spectrograph.StartExposure script will automatically detect this situation, terminate the bad exposure after a few seconds, and start a new one all without user intervention. This will generate several WARNING level log messages, but the user does not need to take action as the correction happens automatically. Another known failure mode which can generate WARNING level log messages is a failure of the FIU to transition in to a new mode (i.e. \"Observing\" or \"Calibration\"). The kpf.fiu.ConfigureFIU and kpf.fiu.WaitForConfigureFIU scripts will automatically retry several times before giving up and erroring out. As with the start state error above, no user action is needed, but you will see WARNING level log messages to let you know what is happening. Switching Programs on a Split Night On a KPF/KPF split night, before starting the second KPF program, run KPF Control Menu --> Set Program ID and Observers from the background menu (or kpfSetObserverFromSchedule from the command line on any KPF machine). Enter the program ID at the terminal prompt. The script will then set program ID and observers for the second KPF program, based on the telescope schedule. If you wish to set the observer names and program ID manually (i.e. without querying the telescope schedule), you can use the kpfSetProgram and kpfSetObserver scripts from the command line. For example: kpfSetProgram K123 will set program ID \"K123\" and kpfSetObserver \"E.E. Barnard, S.W. Burnham\" will set the observer name to \"E.E. Barnard, S.W. Burnham\". Note that observer names should be enclosed in quotes to handle spaces in the list of names. Bad Weather If the weather is so bad that no observing is taking place and there doesn't seem to be an immediate likelihood of observing, then we recommend that the observer runs the end of night procedure ( KPF Control Menu --> Run End of Night Script ). The main advantage of this is that running End of Night will re-enable the automatic scheduled calibrations which happen 4 times per night when KPF is not on sky. This means that the instrumental drift will be tracked with no action required by the observer (i.e. running slew cals). If one of these calibration scripts is in progress and observing should resume, use the \"Request Script STOP\" as described above. After that, run the Start of Night script just as you would at the beginning of the night (among other things it disables the autmatic scheduled calibrations).","title":"Observing Procedures"},{"location":"observingprocedures/#quick-reference","text":"Beginning of the Night Performing Observations Switching Programs on a Split Night Bad Weather","title":"Quick Reference"},{"location":"observingprocedures/#beginning-of-the-night","text":"","title":"Beginning of the Night"},{"location":"observingprocedures/#wait-for-dome-to-open","text":"The Observing Assistant (OA) is not permitted to open the dome until after sunset. Please be patient while the shutter opens and the OA checks the initial telescope pointing.","title":"Wait for Dome to Open"},{"location":"observingprocedures/#run-start-of-night","text":"KPF needs to be configured properly at the start of the night. There is a procedure which should be run only after the Observing Assistant (OA) has selected KPF as the instrument and after automated afternoon calibrations are complete. The selected instrument (\"INST\") can be seen in the lower left corner of the FACSUM window . It is important that this not be run while other instruments are observing. To configure KPF for observing, run KPF Control Menu --> Run Start of Night Script from the background menu (or kpfStartOfNight from the command line on any KPF machine). This will: Disable automated calibrations Configure the FIU to the observing mode Open the science and sky source select shutters Configure the AO Bench. Including positioning the PCU stage and opening the AO hatch. Configure DCS for KPF by setting dcs.ROTDEST=0 and dcs.ROTMODE=stationary Configure the tip tilt loop gain to its default setting Set data output directory Set observers from telescope schedule","title":"Run Start of Night"},{"location":"observingprocedures/#load-your-obs-in-the-kpf-ob-gui","text":"In the KPF OB GUI, from the \"OB List\" menu, choose a method to load OBs for the night. Depending on your program, this may mean loading a schedule for KPF-CC (Community Cadence), loading OBs from the database for a classical program, or opening OB files on disk. This should populate the \"Observing Block List\" are of the GUI and will send these targets to the Magiq sar list (which will also be visible in the observer Magiq GUI).","title":"Load your OBs in the KPF OB GUI"},{"location":"observingprocedures/#slew-to-the-vicinity-of-your-first-target","text":"When ready to move the telescope, the OA will ask you for your first target and load the coordinates from Magiq. They will select a bright star near your target and will attempt to acquire that in the guider, then will double-check the accuracy of pointing by acquiring one or two additional stars from the SAO or GSC catalogs. To monitor the guider images, use the Magiq Observer UI which is available from Telescope GUIs --> MAGIQ Guider UI in the FVWM background menu if it is not already up.","title":"Slew to the Vicinity of Your First Target"},{"location":"observingprocedures/#focus-the-telescope","text":"The OA will run the telescope focus procedure (typically Autofoc) near your science field. On some nights, they will opt for the Mira focus procedure which takes slightly longer but is needed to calibrate the secondary mirror tilt.","title":"Focus the Telescope"},{"location":"observingprocedures/#performing-observations","text":"","title":"Performing Observations"},{"location":"observingprocedures/#execute-your-ob","text":"Executing an OB is as simple as selecting it in the \"Observing Block List\" in the KPF OB GUI and clicking the \"Execute Selected OB\" button (or \"Execute with SlewCal\"). This will highlight the target in Magiq so that the OA can begin slewing the telescope. The GUI will first prompt the observers to confirm the OB execution. Once confirmed, an xterm will launch and prompt the observers with addtional information if and when needed, so watch the contents of this xterm. Executing the OB will not start an exposure immediately. The system will first configure the instrument and will then prompt the observer to confirm once the OA has acquired the target. While configuring the instrument, the OB will provide information on how to set the gain and frames per second on the guider. Because of this, it is important to execute the OB during the slew and before the OA acquires the target, so they have the right exposure parameters to see the target on the guider. The log lines which show up in the xterm with the running OB contain useful information. In general, lines with INFO are attempting to explain what the instrument is doing. Lines with WARNING are indicating that a minor problem has occurred, but the system is handling it -- these lines are purely informational, no action is needed on the part of the observer in response. Lines with ERROR indicate a serious problems which may require user intervention.","title":"Execute Your OB"},{"location":"observingprocedures/#slew-cals","text":"KPF has the option of taking a \"slew cal\" immediately prior to a science observation. This is a way to make use of the time spent slewing from one target to another. If an OB is executed with a slew cal (using the \"Execute OB with Slew Cal\" button in the OB GUI), then the FIU will transition to calibration mode (the FIU hatch will close and calibration light will be directed to the science and sky fibers), and a calibration exposure will be taken. This will obscure the sky during calibration, so the OA will not be able to see the target until the slew cal is done. This process takes around 2 minutes and so fits nicely in to long slews. An alternative to a slew cal is a simultaneous calibration (simulcal). To use this enable the TakeSimulCal option in the OB or on the OB GUI and either manually set the ND filters to apply to the calibration light or enable the AutoNDFilters option. See the nighttime calibrations page for more info on both the slew cal and simulcal options.","title":"Slew Cals"},{"location":"observingprocedures/#stopping-scripts-or-exposures","text":"Important : If you wish to halt an OB during execution, do NOT hit Control-c in the terminal. Use the \"Request Script STOP\" button instead. The KPF scripts have checkpoints in them which are places where the script can cleanly exit and perform important cleanup operations. The \"STOP Exposure and Script\" button does the same thing, but it will also terminate an exposure in progress.","title":"Stopping Scripts or Exposures"},{"location":"observingprocedures/#known-issues","text":"There is a known failure mode for KPF called a \"start state error\". What happens is some sort of communication failure between the kpfexpose control software, the galil hardware which handles the timing and signaling of the detectors and shutters, and the Archon detector controllers. The result is that one of the green or red detectors does not begin the exposure properly and that detector's data will be useless. The kpf.spectrograph.StartExposure script will automatically detect this situation, terminate the bad exposure after a few seconds, and start a new one all without user intervention. This will generate several WARNING level log messages, but the user does not need to take action as the correction happens automatically. Another known failure mode which can generate WARNING level log messages is a failure of the FIU to transition in to a new mode (i.e. \"Observing\" or \"Calibration\"). The kpf.fiu.ConfigureFIU and kpf.fiu.WaitForConfigureFIU scripts will automatically retry several times before giving up and erroring out. As with the start state error above, no user action is needed, but you will see WARNING level log messages to let you know what is happening.","title":"Known Issues"},{"location":"observingprocedures/#switching-programs-on-a-split-night","text":"On a KPF/KPF split night, before starting the second KPF program, run KPF Control Menu --> Set Program ID and Observers from the background menu (or kpfSetObserverFromSchedule from the command line on any KPF machine). Enter the program ID at the terminal prompt. The script will then set program ID and observers for the second KPF program, based on the telescope schedule. If you wish to set the observer names and program ID manually (i.e. without querying the telescope schedule), you can use the kpfSetProgram and kpfSetObserver scripts from the command line. For example: kpfSetProgram K123 will set program ID \"K123\" and kpfSetObserver \"E.E. Barnard, S.W. Burnham\" will set the observer name to \"E.E. Barnard, S.W. Burnham\". Note that observer names should be enclosed in quotes to handle spaces in the list of names.","title":"Switching Programs on a Split Night"},{"location":"observingprocedures/#bad-weather","text":"If the weather is so bad that no observing is taking place and there doesn't seem to be an immediate likelihood of observing, then we recommend that the observer runs the end of night procedure ( KPF Control Menu --> Run End of Night Script ). The main advantage of this is that running End of Night will re-enable the automatic scheduled calibrations which happen 4 times per night when KPF is not on sky. This means that the instrumental drift will be tracked with no action required by the observer (i.e. running slew cals). If one of these calibration scripts is in progress and observing should resume, use the \"Request Script STOP\" as described above. After that, run the Start of Night script just as you would at the beginning of the night (among other things it disables the autmatic scheduled calibrations).","title":"Bad Weather"},{"location":"references/","text":"Referencing KPF The suggested instrument paper to use when referencing KPF is currently Gibson et al. (2024) . Additional KPF Instrument Papers \"System Design of the Keck Planet Finder\" Gibson et al. (2024) . \"A fiber injection unit for the Keck Planet Finder: opto-mechanical design\" Lilley et al. (2022) \"Keck Planet Finder: design updates\" Gibson et al. (2020) \"A optical fiber double scrambler and mechanical agitator system for the Keck planet finder spectrograph\" Sirk et al (2018) \"Keck Planet Finder: preliminary design\" Gibson et al. (2018) \"Keck Planet Finder: Zerodur optical bench mechanical design\" Smith et al. (2018) \"A comprehensive radial velocity error budget for next generation Doppler spectrometers\" Halverson et al. 2016 \"KPF: Keck Planet Finder\" Gibson et al. 2016","title":"Acknowledging KPF"},{"location":"references/#referencing-kpf","text":"The suggested instrument paper to use when referencing KPF is currently Gibson et al. (2024) .","title":"Referencing KPF"},{"location":"references/#additional-kpf-instrument-papers","text":"\"System Design of the Keck Planet Finder\" Gibson et al. (2024) . \"A fiber injection unit for the Keck Planet Finder: opto-mechanical design\" Lilley et al. (2022) \"Keck Planet Finder: design updates\" Gibson et al. (2020) \"A optical fiber double scrambler and mechanical agitator system for the Keck planet finder spectrograph\" Sirk et al (2018) \"Keck Planet Finder: preliminary design\" Gibson et al. (2018) \"Keck Planet Finder: Zerodur optical bench mechanical design\" Smith et al. (2018) \"A comprehensive radial velocity error budget for next generation Doppler spectrometers\" Halverson et al. 2016 \"KPF: Keck Planet Finder\" Gibson et al. 2016","title":"Additional KPF Instrument Papers"},{"location":"sensitivity/","text":"Spectrograph Sensitivity For sensitivity estimates, please see the KPF exposure time calculator written by the instrument team. More information is available on the KPF Exposure Time (and RV Precision) Calculator page or go directly to GitHub to download the exposure time calculator software . Acquiring Faint Targets We use J-band magnitude as a rough guide for the guider sensitivity, but it is important to keep in mind that this is not a perfect match to the guider passband (950-1200 nm). That said, we have acquired a J=17.0 (V=18.05) quasar using the guider with FPS=0.1 (10 second individual frame exposures). It was not a strong detection: the target was just visible by eye in the images, but the guide system struggled to lock on to it. Another test acquisition on a J=16.7 (V=17.6) object was correspondingly a bit easier. We believe this performance can be improved substantially by using sky subtraction. This is possible currently, but is a slow manual process to configure. On the second test target above (J=16.7, V=17.6), we got reasonable signal using 0.25 FPS (4 second exposures) while using sky subtraction. We are planning to script this process to make it easier and to integrate sky subtraction in to the OA's GUI for controlling the tip tilt, but the timeline for that is still TBD. If you need to acquire very faint targets (J > 16), please reach out to your SA ahead of time to discuss strategies.","title":"Sensitivity"},{"location":"sensitivity/#spectrograph-sensitivity","text":"For sensitivity estimates, please see the KPF exposure time calculator written by the instrument team. More information is available on the KPF Exposure Time (and RV Precision) Calculator page or go directly to GitHub to download the exposure time calculator software .","title":"Spectrograph Sensitivity"},{"location":"sensitivity/#acquiring-faint-targets","text":"We use J-band magnitude as a rough guide for the guider sensitivity, but it is important to keep in mind that this is not a perfect match to the guider passband (950-1200 nm). That said, we have acquired a J=17.0 (V=18.05) quasar using the guider with FPS=0.1 (10 second individual frame exposures). It was not a strong detection: the target was just visible by eye in the images, but the guide system struggled to lock on to it. Another test acquisition on a J=16.7 (V=17.6) object was correspondingly a bit easier. We believe this performance can be improved substantially by using sky subtraction. This is possible currently, but is a slow manual process to configure. On the second test target above (J=16.7, V=17.6), we got reasonable signal using 0.25 FPS (4 second exposures) while using sky subtraction. We are planning to script this process to make it easier and to integrate sky subtraction in to the OA's GUI for controlling the tip tilt, but the timeline for that is still TBD. If you need to acquire very faint targets (J > 16), please reach out to your SA ahead of time to discuss strategies.","title":"Acquiring Faint Targets"},{"location":"socal/","text":"Solar Calibrator (SoCal) The KPF Solar Calibrator (SoCal) is installed on the roof of the support building between the Keck I and Keck II domes. It consists of an EKO Sun Tracker inside an enclosure designed to protect it from strong winds and falling ice. The EKO tracker carries a pyrheliometer to measure solar intensity (used to confirm that we are on the Sun and the sky is clear) and a solar collector which feeds full disk solar light in to a fiber optic which carries it to two locations in the Calibration Bench in the basement where it can be fed in to the KPF instrument.","title":"Solar Calibrator"},{"location":"socal/#solar-calibrator-socal","text":"The KPF Solar Calibrator (SoCal) is installed on the roof of the support building between the Keck I and Keck II domes. It consists of an EKO Sun Tracker inside an enclosure designed to protect it from strong winds and falling ice. The EKO tracker carries a pyrheliometer to measure solar intensity (used to confirm that we are on the Sun and the sky is clear) and a solar collector which feeds full disk solar light in to a fiber optic which carries it to two locations in the Calibration Bench in the basement where it can be fed in to the KPF instrument.","title":"Solar Calibrator (SoCal)"},{"location":"spectrograph/","text":"Spectrometer Optical Design The baseline KPF spectrometer design is shown in the following figure. Light enters the core spectrometer following the fiber image reformatter, at the focal point of the primary collimator mirror (traditionally this would be the location of the spectrometer slit). The f/8 beam diverges past this point and then strikes the primary collimator mirror (an off-axis paraboloid). Upon reflection, the now collimated 200 mm diameter light beam travels to the echelle grating, located one primary collimator focal length away from the primary collimator. After diffraction by the echelle, the diverging monochromatic beams reflect from the primary collimator a second time. Because the echelle grating is rotated slightly out of plane (the echelle gamma angle), the dispersed light does not return along the same path, and the pre- and post-diffraction beams are separated. Therefore, after reflecting from the collimator the second time, the dispersed light does not return to the entrance slit, but forms an intermediate focus to the side of the echelle. Just before the intermediate focus, a flat mirror is employed to fold the beam, to make the spectrometer footprint more compact. Layout of the spectrograph on the optical bench. After the fold mirror reflection, the light rays go through the intermediate focus, and then the diverging monochromatic beams are collimated by the secondary collimator mirror (an off-axis paraboloid). The monochromatic beam diameter here is 160 mm, owing to the secondary collimator having a focal length 0.8x that of the primary collimator. The converging monochromatic beams next encounter a dichroic beamsplitter, where wavelengths blueward of 593 nm are reflected, and wavelengths redward of 593 nm are transmitted. After reflection, the green channel monochromatic beams continue to converge towards the white pupil, where the cross-dispersion grism (grating prism) is located. This disperser consists of a shallow apex angle prism bonded to a volume phase holographic (VPH) grating. Following the grism, the light enters the camera, which then focuses the spectrum onto the CCD detector. A summary of various spectrometer parameters is given the the following table. A brief summary table of KPF instrument properties. VPH Grating Overview As described above, the main spectrometer employs VPH-based grisms for cross-dispersion. In order to provide sufficient cross dispersion, the green channel VPH grating was produced with a line density of 800 lines per mm and the red channel VPH with 450 lines per mm. A summary of the KPF VPH grating specifications are shown in the table below. Both gratings were produced by Kaiser Optical Systems (KOSI). A brief summary table of KPF's VPH grating properties. A preliminary set of diffraction efficiency measurements was conducted by KOSI at a few locations across the clear aperture for each KPF grating. These data were re-measured and confirmed at SSL using the measurement test equipment and procedures developed by the DESI project. Overall, we were able to confirm KOSI's measurements and saw a slight (2-4%) increase in diffraction efficiency. The optimum angle of incidence (AOI) for each grating were both chosen away from their design AOI due to gains in diffraction efficiency at the \"blue\" end (green grating) and \"red\" end (red grating) of the KPF passband. For the green grating, we chose an AOI of -29.5 degree which incrased the overall band average efficiency from 86.4 degree to 87.7 degree. This increased the blue end efficiency from 77.6% to 84.6%. For the red grating, we chose an AOI of -25.4 degree which slightly increased the overall band average efficiency from 87.7% to 88.6%. This increased the red end efficiency from 82.7% to 89.6%. The following figure shows the SSL measured efficiency of the two KPF VPH gratings over the spectrometer's passband. With the changing of the AOI in each grating, we have seen significant gains (approximately 25%) in diffraction efficiency vs. the production minimum specification at both ends of the spectrometer passband. Overall these grating exceeded our production minimum specification by >5% across at all wavelengths with the noted gains at the \"blue\" and \"red\" ends of the KPF spectrometer passband. Plot of the VPH grating efficiency as a function of wavelength.","title":"Spectrograph"},{"location":"spectrograph/#spectrometer-optical-design","text":"The baseline KPF spectrometer design is shown in the following figure. Light enters the core spectrometer following the fiber image reformatter, at the focal point of the primary collimator mirror (traditionally this would be the location of the spectrometer slit). The f/8 beam diverges past this point and then strikes the primary collimator mirror (an off-axis paraboloid). Upon reflection, the now collimated 200 mm diameter light beam travels to the echelle grating, located one primary collimator focal length away from the primary collimator. After diffraction by the echelle, the diverging monochromatic beams reflect from the primary collimator a second time. Because the echelle grating is rotated slightly out of plane (the echelle gamma angle), the dispersed light does not return along the same path, and the pre- and post-diffraction beams are separated. Therefore, after reflecting from the collimator the second time, the dispersed light does not return to the entrance slit, but forms an intermediate focus to the side of the echelle. Just before the intermediate focus, a flat mirror is employed to fold the beam, to make the spectrometer footprint more compact. Layout of the spectrograph on the optical bench. After the fold mirror reflection, the light rays go through the intermediate focus, and then the diverging monochromatic beams are collimated by the secondary collimator mirror (an off-axis paraboloid). The monochromatic beam diameter here is 160 mm, owing to the secondary collimator having a focal length 0.8x that of the primary collimator. The converging monochromatic beams next encounter a dichroic beamsplitter, where wavelengths blueward of 593 nm are reflected, and wavelengths redward of 593 nm are transmitted. After reflection, the green channel monochromatic beams continue to converge towards the white pupil, where the cross-dispersion grism (grating prism) is located. This disperser consists of a shallow apex angle prism bonded to a volume phase holographic (VPH) grating. Following the grism, the light enters the camera, which then focuses the spectrum onto the CCD detector. A summary of various spectrometer parameters is given the the following table. A brief summary table of KPF instrument properties.","title":"Spectrometer Optical Design"},{"location":"spectrograph/#vph-grating-overview","text":"As described above, the main spectrometer employs VPH-based grisms for cross-dispersion. In order to provide sufficient cross dispersion, the green channel VPH grating was produced with a line density of 800 lines per mm and the red channel VPH with 450 lines per mm. A summary of the KPF VPH grating specifications are shown in the table below. Both gratings were produced by Kaiser Optical Systems (KOSI). A brief summary table of KPF's VPH grating properties. A preliminary set of diffraction efficiency measurements was conducted by KOSI at a few locations across the clear aperture for each KPF grating. These data were re-measured and confirmed at SSL using the measurement test equipment and procedures developed by the DESI project. Overall, we were able to confirm KOSI's measurements and saw a slight (2-4%) increase in diffraction efficiency. The optimum angle of incidence (AOI) for each grating were both chosen away from their design AOI due to gains in diffraction efficiency at the \"blue\" end (green grating) and \"red\" end (red grating) of the KPF passband. For the green grating, we chose an AOI of -29.5 degree which incrased the overall band average efficiency from 86.4 degree to 87.7 degree. This increased the blue end efficiency from 77.6% to 84.6%. For the red grating, we chose an AOI of -25.4 degree which slightly increased the overall band average efficiency from 87.7% to 88.6%. This increased the red end efficiency from 82.7% to 89.6%. The following figure shows the SSL measured efficiency of the two KPF VPH gratings over the spectrometer's passband. With the changing of the AOI in each grating, we have seen significant gains (approximately 25%) in diffraction efficiency vs. the production minimum specification at both ends of the spectrometer passband. Overall these grating exceeded our production minimum specification by >5% across at all wavelengths with the noted gains at the \"blue\" and \"red\" ends of the KPF spectrometer passband. Plot of the VPH grating efficiency as a function of wavelength.","title":"VPH Grating Overview"},{"location":"status/","text":"Instrument Status Current and Past Announcements 2025 August: 26A Stability Announcement 2023 September: Keck Science Meeting presentation Status Summary by Subsystem This is an attempt to summarize the status of various sub-systems of the instrument. Each sub-system name is color coded to indicate the status at a glance: green means functioning normally, orange means mostly normal, but with some caveats or minor issues, and red means the sub-system is compromised in some way. Last Status Update: 2025-10-22 Detector Noise : Starting in November of 2024, additional pattern noise has been present on the detectors. We have been working on eliminating the spurious nose, but we have been unable to completely remove it. As of late-October 2025 the read noise on the Green side remains elevated (~10 electrons), while the red side is near our nominal target (~4.4 electrons). LFC : We are evaluating the reliability of the LFC after recent service. Initial indications look prominsing on reliability, though the bluest flux (below ~490 nm) is not consistent. Etalon : Operational. Detector Cooling Systems : Both detectors are now cooled with closed cycle refrigerators (CCRs). The green side CCR has problems and has very little overhead on maintaining temperature and has quasi-periodic deviations which affect the detector. Red side is performing well. Detector Errors : The red and green detectors suffer from occasional \u201cstart state errors\u201d in which the affected detector remains in the start phase and does not produce a useful exposure. The observing scripts detect this, abort the current exposure (with read out) and start a fresh exposure on both cameras. No action is necessary on the part of the observer. The occurrence rate is such that around one in every 180 exposures is affected by one of the two detectors experiencing this error. Ca H&K Detector : The CA H&K detector is operational. Exposure Meter Terminated Exposures : Operational. Tip Tilt Corrections : The tip tilt axis are currently correcting as expected. Double Star Observations : Operational. Simultaneous Calibration (SimulCal) : Simultaneous calibrations are supported. Nod to Sky Observations : For observations which need a sky measurement other than the built in sky fibers, nodding away to a sky position can be accomplished manually by running separate OBs for the target and sky and asking the OA to offset the telescope as appropriate. We plan to build a separate Nod To Sky observing mode which will accomplish this within a single OB, but that is not yet available. Off Target Guiding : Not yet commissioned. Currently, the tip tilt system must be able to detect the science target in order to position it on the fiber.","title":"Instrument Status"},{"location":"status/#instrument-status","text":"","title":"Instrument Status"},{"location":"status/#current-and-past-announcements","text":"2025 August: 26A Stability Announcement 2023 September: Keck Science Meeting presentation","title":"Current and Past Announcements"},{"location":"status/#status-summary-by-subsystem","text":"This is an attempt to summarize the status of various sub-systems of the instrument. Each sub-system name is color coded to indicate the status at a glance: green means functioning normally, orange means mostly normal, but with some caveats or minor issues, and red means the sub-system is compromised in some way. Last Status Update: 2025-10-22 Detector Noise : Starting in November of 2024, additional pattern noise has been present on the detectors. We have been working on eliminating the spurious nose, but we have been unable to completely remove it. As of late-October 2025 the read noise on the Green side remains elevated (~10 electrons), while the red side is near our nominal target (~4.4 electrons). LFC : We are evaluating the reliability of the LFC after recent service. Initial indications look prominsing on reliability, though the bluest flux (below ~490 nm) is not consistent. Etalon : Operational. Detector Cooling Systems : Both detectors are now cooled with closed cycle refrigerators (CCRs). The green side CCR has problems and has very little overhead on maintaining temperature and has quasi-periodic deviations which affect the detector. Red side is performing well. Detector Errors : The red and green detectors suffer from occasional \u201cstart state errors\u201d in which the affected detector remains in the start phase and does not produce a useful exposure. The observing scripts detect this, abort the current exposure (with read out) and start a fresh exposure on both cameras. No action is necessary on the part of the observer. The occurrence rate is such that around one in every 180 exposures is affected by one of the two detectors experiencing this error. Ca H&K Detector : The CA H&K detector is operational. Exposure Meter Terminated Exposures : Operational. Tip Tilt Corrections : The tip tilt axis are currently correcting as expected. Double Star Observations : Operational. Simultaneous Calibration (SimulCal) : Simultaneous calibrations are supported. Nod to Sky Observations : For observations which need a sky measurement other than the built in sky fibers, nodding away to a sky position can be accomplished manually by running separate OBs for the target and sky and asking the OA to offset the telescope as appropriate. We plan to build a separate Nod To Sky observing mode which will accomplish this within a single OB, but that is not yet available. Off Target Guiding : Not yet commissioned. Currently, the tip tilt system must be able to detect the science target in order to position it on the fiber.","title":"Status Summary by Subsystem"},{"location":"tiptilt/","text":"Tip Tilt Correction System The KPF tip tilt system takes fast (e.g. 100 FPS) subframe images from the KPF CRED2 guide camera in order to control the fast tip tilt mirror which directs light in to the KPF FIU. This fast tip tilt system maintains the stellar position on the science fiber. This is critical not for reasons of maximizing flux in to the spectrograph (though that is a side benefit), but to optimize the radial velocity measurement by keeping the illumination pattern on the fiber tip stable. Even after fiber scrambling and agitation, if the star\u2019s position on the fiber entrance fiber shifts, that can manifest as a small shift of the spectrum on the detector which would be interpreted as a radial velocity change. Thus we need to position the star on the fiber, and then hold it in a consistent place during observations and make that position consistent from observation to observation. The tip tilt mirror is a fold mirror which sits on the PCU stage on the Keck I AO bench. The mirror folds the light in to the KPF FIU and is controlled in tip and tilt by a piezo stage built by nPoint. The nominal spec for tip tilt performance is to position of the star within 50mas of the target position and then maintain that position at an RMS fo 50mas or better. The software which controls the tip tilt stage is built in to the kpffiu and kpfguide KTL keyword services.","title":"Tip Tilt Sysyem"},{"location":"tiptilt/#tip-tilt-correction-system","text":"The KPF tip tilt system takes fast (e.g. 100 FPS) subframe images from the KPF CRED2 guide camera in order to control the fast tip tilt mirror which directs light in to the KPF FIU. This fast tip tilt system maintains the stellar position on the science fiber. This is critical not for reasons of maximizing flux in to the spectrograph (though that is a side benefit), but to optimize the radial velocity measurement by keeping the illumination pattern on the fiber tip stable. Even after fiber scrambling and agitation, if the star\u2019s position on the fiber entrance fiber shifts, that can manifest as a small shift of the spectrum on the detector which would be interpreted as a radial velocity change. Thus we need to position the star on the fiber, and then hold it in a consistent place during observations and make that position consistent from observation to observation. The tip tilt mirror is a fold mirror which sits on the PCU stage on the Keck I AO bench. The mirror folds the light in to the KPF FIU and is controlled in tip and tilt by a piezo stage built by nPoint. The nominal spec for tip tilt performance is to position of the star within 50mas of the target position and then maintain that position at an RMS fo 50mas or better. The software which controls the tip tilt stage is built in to the kpffiu and kpfguide KTL keyword services.","title":"Tip Tilt Correction System"},{"location":"tiptiltinstructions/","text":"Tip Tilt Instructions for OAs Table of Contents TL:DR Procedure Tip Tilt System Overview Tip Tilt GUI GUI Layout Camera Controls Tab Object Detection Tab Sky Subtraction Tab Offset Guiding Tab Settings Tab Tip Tilt Control and Telemetry Image Display Instrument Status Status Bar Star Detection Algorithm Deblending Multiple Stars TL:DR Procedure Set the gain and FPS values for the guide camera. Acquire the star to the KPF PO using magiq. In the KPF Tip Tilt GUI, turn on the tip tilt loops. Verify normal operation of the loops (this should just require a momentary glance at the various indicators): Make sure the science target has been indentified. It should have a circle around it and a label in the image display part of the GUI. Check that an object has been selected in \"Object Choice\". Check that the Peak Flux is sufficient (the value will be color coded to help you). If needed, adjust the gain and FPS. Check that the Tip Tilt Error is decreasing over time in the plot. This indicates that the star is being moved to the target pixel. Check the \"Tip Tilt RMS\" value is around 50 mas or better. If the target is faint or there are heavy clouds or bad seeing, it may not be able to reach this, but under normal conditions we should at least be in the ballpark. If there are multiple stars in the field of view, ensure that the corect target is selected and that the stars are not blended. Each detected star will have its own OBJECTn label in the image display: make sure this is centered on the star . Inform the observer that the tip tilt loops are engaged and they can begin exposing. Troubleshooting the TL:DR Procedure If the system is not seeing the target star, adjust the \"Detect SNR\" and/or \"Detect Area\" values under the Object Detection tab in the GUI (see Star Detection Algorithm section below for details). If the system seems to be having trouble identifying stars, toggle the loops on and off (this is primarily for the Calculation loop). Doing this will cause the algorithm to re-identify the stars and may resolve ID confusion caused when stars are moving rapidly in the field. Check that there are no red indicators in the status bar at the bottom of the Tip Tilt GUI. These indicate that something substantial is wrong. Which indicator it is will tell you which keyword or dispatcher is in a bad state. Tip Tilt System Overview The KPF tip tilt system takes fast (e.g. 100 FPS) subframe images from the KPF CRED2 guide camera in order to control the fast tip tilt mirror which directs light in to the KPF FIU. This fast tip tilt system maintains the stellar position on the science fiber. This is critical not for reasons of maximizing flux in to the spectrograph (though that is a side benefit), but to optimize the radial velocity measurement. Even after fiber scrambling and agitation, if the star\u2019s position on the fiber entrance fiber shifts, that can manifest as a small shift of the spectrum on the detector which would be interpreted as a radial velocity change. Thus we need to position the star on the fiber, and then hold it in a consistent place during observations and make that position consistent from observation to observation. Tip Tilt Loops There are several components to the tip tilt loops. Controls for toggling them on and off together and individually are provided in the Tip Tilt Control and Telemetry section of the Tip Tilt GUI. The important pieces are: Calculation : The calculations are the part of the algorithm which is examining images from the guide camera, detecting and identifying objects, and calculating the relevant tip tilt commands. This can be toggled on and off using the underlying kpfguide.TIPTILT_CALC keyword. Note that once calculations are turned on the system is attempting to cross identify stars from image to image and maintain a consistent identity. One of the things it uses to do this is knowledge of the average positions of stars in recent images. Thus, if the stars are moved dramatically (e.g. by Magiq), it may confuse the IDs. If you think this might be the case, restarting calculations will force a fresh identification phase. Control : The control component takes the output of the calculations loop and sends commands to the tip tilt mirror. As long as the motions needed are within range of the tip tilt mirror, this will close the loops and should yield a stable star position. This can be toggled on and off using the underlying kpfguide.TIPTILT_CONTROL keyword. Offload : If the motion of the star carries it toward the edfe of the tip tilt mirror's range of motion, the system will \"offload\" some of that movement to the telescope (akin to a normal guiding command). Enabling offloads allows those commands to go to the telescope. This can be toggled on and off using the underlying kpfguide.OFFLOAD keyword. The kpfguide.OFFLOAD keyword will also attempt examine the telescope control system ( dcs ) to determine if offloads should be sent. This permissive is based primarily on whether KPF is the selected instrument, if not, the instrument should not be sending offloads to the telescope. The kpfguide.OFFLOAD_DCS keyword indicated whether KPF is permitted to offload and it must be \"Yes\" in order for offloads to be enabled. Tip Tilt GUI To start the GUI, open a terminal as any kpf user (e.g. kpfeng) on the kpf machine and type: TTGUI_v2 . For dark mode, add the -d option to the command. A screenshot of the Tip Tilt GUI. The Tip Tilt GUI may also be opened for observers in \"monitor\" mode, in which case none of the controls are active, but the telemetry and image display can be seen. To do this, use the TTGUI_v2 --monitor terminal command as above or select KPF Control Menu -> Subcomponents -> Start Tip Tilt GUI from the FVWM menu in a KPF VNC session. GUI Layout The top section of the GUI (beneath the \"File\" and \"Troubleshooting\" menus), is a small tabbed interface with various controls and options. See the sections below on each tab. Beneath the tabbed section is a region titled \"Tip Tilt Control and Telemetry\" this section contains control for the tip tilt loops and telemetry about the tip tilt performance. See the Tip Tilt Control and Telemetry section below for details. Beneath that is a region titled \"Image Display\" which shows the latest Magiq image cropped to the region which the tip tilt system is using (a subframe of the whole field). It also contains the tool for choosing which object in the field to guide on and controls for the image display stretch and cut. See the Image Display section below for details. Beneath that is a region titled \"Instrument Status\" which contains a very brief summary of what the instrument is doing at the moment. See the Instrument Status section below for details. The very bottom of the GUI is the status bar which will be empty if everything is in a working state for observing. See the Status Bar section below for details. Camera Controls Tab A screenshot of the Tip Tilt GUI's Camera Controls tab. When the observer executes an OB (which they should do during the slew, but they may forget or not be ready, so check if you are unsure), then the target star's J band magnitude will be populated in this GUI. This will also update the \"Recommended Gain & FPS\" values. If you wish to accept these recommendations, simply click the \"Set\" button. The recommendations will be color coded green if they match the current values or orange if they do not match. The pulldown to the left of the \"Set\" button will add in some amount of extinction (in magnitudes) to the estimated values. If you have clouds, you can put in some value for the extinction and the estimate will account for the clouds. The right hand section of the tab shows the current Gain & FPS values. You may set them here using the pulldown menus. You can set these values on the command line by modifying the relevant keywords: kpgduide.GAIN , and kpfguide.FPS . Object Detection Tab A screenshot of the Tip Tilt GUI's Object Detection tab. This is where you can set the object detection and deblending parameters discussed in the Star Detection Algorithm section below. The pulldowns will set the requested value. You can set these values on the command line by modifying the relevant keywords: kpgduide.OBJECT_INTENSITY , kpfguide.OBJECT_AREA , and kpfguide.OBJECT_DBCONT . Sky Subtraction Tab A screenshot of the Tip Tilt GUI's Sky Subtraction tab. Detection of faint targets when the gain is high and the FPS is low (of order 2 FPS or less) might be enhanced by subtracting the sky background. To do this, once the target has been acquired to the KPF PO, click the \"Obtain Sky Frame\" button. The telescope will offset by the amounts specified in the Sky Offset East and North fields, take a set of images there, and use that for sky subtraction. This will not necessarily increase the flux value, but may improve object detection because the background will be smoother and less noisy. The \"Reset Sky Frame\" button will reset the subtraction file to default (a bias frame). Any time the camera gain or FPS are changed, the sky frame will be reset to default. Offset Guiding Tab Not currently implemented. Settings Tab A screenshot of the Tip Tilt GUI's Settings tab. The options here control various settings for the kpfguide algorithms. The \"X Axis\" and \"Y Axis\" settings allow you to bypass the tip tilt mirror and control the star position only using offloads to the telescope (conceptually similar to normal Magiq guiding). These values should be \"Mirror\" unless there is a problem with the tip tilt system. The \"DAR\" setting determines whether the target pixel for the star is modified to account for differential atmospheric refraction (DAR) between the guide wavelengths (950-1200nm) and the science wavelengths (centered on 550nm). This should be set to \"Yes\" under normal observing conditions. The \"Tip Tilt ROI Size\" can be adjusted using the pulldown. The default value of 128 pix is recommended, but in bad seeing conditions, going to larget frames may help, but processing the extra pixels might slow down the tip tilt calculations, so keep an eye on the \"Tip Tilt FPS\" value and make sure it does not stay below the camera FPS value. Tip Tilt Control and Telemetry This section of the GUI is how the tip tilt loops are opened and closed. The \"Tip Tilt On/Off\" button will likely be the primary interface as it toggles all of the components off the system on and off together, but the checkboxes to the right allow each to be toggled individually. Note that the \"Offloads\" checkbox will be color coded red when kpfguide.OFFLOAD_DCS is \"No\". The \"Tip Tilt Phase\" is meant to summarise whether the system has fully controlled the star's position to the point where the observers can begin exposing. It will begin in \"Identifying\", then move to \"Acquiring\" once a star has been identified and is being moved to the target pixel, and finally reach \"Tracking\" when the star is in position. These stages are based on the position error of the star and so may not be a perfect guide, but should be useful under normal conditions. The \"Tip Tilt FPS\" value shown in the GUI is the rate at which frames are being processed by the tip tilt algorithm and should be compared to the gude camera FPS. The \"Tip Tilt FPS\" value will likely bounce around a bit, but it should stay somewhere in the range of the camera FPS (within maybe 10%). If it is much less than the camera FPS, then the tip tilt system is not keeping up with the images coming in. The GUI will color code this value with orange and red values when it deviated from the camera FPS by more than some threshold amount. The \"Tip Tilt RMS\" value shown indicates how much the stellar position varies from frame to frame. This is different than the \"Tip Tilt Error\" (used in the plot below). The RMS is a measure of the frame to frame variation while the error is the average offset between the star and the target pixel. The error should drop to <<1 pixel under good conditions as the average star position is driven to the target pixel, but as the star bounces around from frame to frame due to seeing, the RMS value will be larger than zero. Our design goal is for the RMS value to be <50 mas (<1 pixel). The \"Peak Flux\" value is the brightness (in ADU) of the brightest pixel in the star as measured by the star detection algorithm. This is a good, but imperfect indication of whether the star is saturated in the guider image. Some bad pixels are always bright and if one of them is included in the star detection then the value of that one bad pixel will affect this reading, so you should use some discretion when inspecting this value. We have plans to implement a bad pixel mask which should mitigate this, but that is not complete and will require some care to make sure it does not affect the high speed calculations in the tip tilt loops. The guide camera is 14-bit, so it saturates at a value of 16,384. We perform a bias subtraction, so in practice this value is more like 14,000 counts. Saturation is not a deal breaker for using the tip tilt system. Mild saturation of only a few pixels in the core of the star will not drastically degrade the tip tilt performance, so it is better to saturate a bit than to try to run the FPS up to extremely high values where the calculations can not keep up. The \"Total Flux\" value is the sum of all pixel values with the detected star. This is an alternate indicator of the star's brightness, but does not directly indicate whether the star saturates the camera. The \"Tip Tilt Error\" plot is the left hand plot in the GUI. This is the offset (in pixels) between the stars's average position and the target pixel. When you first turn on the loops, you should see this start at a high value (a few pixels) and drop rapidly to near 0. The \"Flux\" plot is the right hand plot in the GUI. It plots the total flux in the star over time. The behavior of this is a useful indicator of clouds. Image Display The image display section shows a cropped version of the Magiq image (cropped to the region the tip tilt algorithm is using). It is important to remember that this image is not the same as what the tip tilt system is using for its calculations! This is an average of frames over the Magiq exposure time, so you have a higher SNR in this image than you do in the individual frames going in to the tip tilt calculations. The filename displayed and the timestamp at which the file was updated are also shown near the top. Mousing over the image will read out the pixel position and value of the pixel under the cursor just below the image and next to the X and Y position of the target pixel the algorithm is trying to steer the star to (this value is updated by DAR and so will change). The image will show an overlayed circle and label with the object's name (\"OBJECT1, OBJECT2, or OBJECT3\") and the percentage value next to the label is the fraction of frames in which is object is detected. If this is much less than 100%, you should probably adjust the detection parameters or adjust the sensitivity of the guider (i.e. increase gain or lower the FPS). To the right of the image is the \"Object Choice\" box. In the case where multiple objects are detected, you will need to choose one of them to be the target. Use the pulldown to choose which one you want to drive to the target pixel. Below this is a plot showing where the tip tilt mirror is within its range. The range is indicated by the green area. Points will be drawn and fade out over time to indicate the motion of the tip tilt mirror. Finally there are two selectors for \"Image Cut\" and \"Image Scaling\", these affect the image display, so feel free to adjust as you see fit. Instrument Status There is a small section here summarizing the instrument status. It shows whether there is a script running which is a good indicator of whether data is being taken. The \"Exposure Status\" value shows whether the detectors are exposing, reading out, etc. The \"FIU Mode\" is a good guide as to whether you should expect to be seeing light from the sky on the guider images (e.g. if it is in \"Calibration\" mode, we are taking a cal exposure and you are probably seeing cal fibers, not the sky). Finally, the \"Object\" value is the string the observer has used to name the target. Status Bar The very bottom of the GUI is a status bar. It will be empty under normal operating conditions, but will contain red indicators when there is a problem that will likely halt operation of the tip tilt system. For example, in the screenshot below several errors are shown: A screenshot of the Tip Tilt GUI's Status Bar with several errors. Status bar errors which can show up include: CONTINUOUS : This indicates that the guide camera is not exposing. SAVE : This indicates that the guide camera is not saving files. TTXSRV : This indicates that the tip tilt mirror X axis is not in servo mode and thus will not correct properly. TTYSRV : This indicates that the tip tilt mirror Y axis is not in servo mode and thus will not correct properly. DAR Disabled : This indicates that the DAR is not enabled. kpfguide1 : This indicates that there is a likely problem with the kpfguide1 dispatcher and a restart is likely required. kpfguide2 : This indicates that there is a likely problem with the kpfguide2 dispatcher and a restart is likely required. kpfguide3 : This indicates that there is a likely problem with the kpfguide3 dispatcher and a restart is likely required. Star Detection Algorithm The kpfguide software uses Source Extractor via the SEP Python Library for star detection. The \"Detect SNR\" and \"Detect Area\" values in the GUI correspond to the thresh and minarea parameters of sep.extract and to kpfguide.OBJECT_INTENSITY and kpfguide.OBJECT_AREA keyword respectively. The way the algorithm detects stars is to look for adjacent clusters of pixels with values above \"Detect SNR\". If that cluster is larger than \"Detect Area\" pixels, then it is a star. Both parameters are critical in determining whether a star will be detected. Having a large \"Detect Area\" means that faint stars will often not have enough bright pixels to be considered a detection. Similarly, a large \"Detect SNR\" might mean that not enough pixels are bright enough so too few pixels will be detections to be considered a star. On faint targets, both parameters may need to come down if only the very core of the star has significant signal in it. If you're having trouble in good seeing, make sure that \"Detect Area\" is not too large for the seeing. Based on experience, starting with values of 5-7 for \"Detect SNR\" and 80-100 for \"Detect Area\" are reasonable. Deblending Multiple Stars Deblending is a term that comes from Source Extractor. It can be both perilous and useful. Early in the system\u2019s use, we were still using the default deblending contrast of 0.005, which meant that it took only a small dip in flux (0.5%) for two adjacent maxima to be considered two different objects. In practice, this meant that a single star would deblend in to multiple stars due to speckles moving about. As a result, the \u201cstar\u201d would appear to shift to one side or the other leading to sudden large corrections which would then be reversed a frame or two later when the speckles had shifted and the star was no longer deblended. This could affect several percent of all guide frames (in other words, the star was being jolted around by spurious detections several times per second). Of course, in situation where there are actually blended stars this is a useful tool. Double stars can be separated and a particular guide target chosen using this system. Based on our experience so far, leaving deblending contrast at 1.0 for most targets is the right choice. This demands that the valley between adjacent peaks be as deep as the highest peak (i.e. it goes to 0), so it turns deblending off. Since most targets are isolated stars with no close neighbors of similar brightness, this avoids the problem of tracking on speckles. If a double star is the target, decreasing the deblending contrast until it is reliably separates is the best strategy. Use the overlays in the image display to ensure that the target star has its own label and that label is centered properly on the star. If the label is not centered on the star, it might be blended with the companion which is puslling the \"center\" off toward the companion -- this is what we mean by blended stars. If the stars are blended, they must be deblended for KPF to accurately place one properly on the fiber. If the centroid is biased because the stars are not deblended you will end up with an RV effect due to the positioning of the star on the fiber being incorrect. The deblend contrast can be run down at 0.005 or lower to pull out a faint companion. Note that this is the contrast between the bright star and the faint \"gap\" between companions, so large contrast is not unexpected if the companion star is a few magnitudes fainter than the primary. For example, if the deblend contrast is 0.01 that is 5 magnitudes of contrast 2.5*log(0.01) , but that's not an unreasonable contrast for the gap if the companion star is just 2 or 3 magnitudes fainter than the primary. Also, because the algorithm is doing deblending, not trying to detect the companion as a separate object, we don't need to worry about the primary being too bright -- it is ok to saturate the primary to get the companion. Of course, a widely separated double star may be seen as two stars by the system if there is a \u201cgap\u201d between the two stars where the signal in the pixels is lower than the detection threshold. In this case, no deblending is necessary. Finally, if the star the observers are trying to acquire is too challenging and you are unable to make it work, you can ask the observer to click the \"Collect Guider Image Cube\" button on their OB GUI. This will save a brief sequence of guider images which can be analyzed offline to find out the best way to acquire that particular star (email the KPF SA to let them know to look at it). This does not help for the immediate observation, but will allow us to find the right solution for the next time this target or a similar one is observed.","title":"Tip Tilt Instructions for OAs"},{"location":"tiptiltinstructions/#tip-tilt-instructions-for-oas","text":"","title":"Tip Tilt Instructions for OAs"},{"location":"tiptiltinstructions/#table-of-contents","text":"TL:DR Procedure Tip Tilt System Overview Tip Tilt GUI GUI Layout Camera Controls Tab Object Detection Tab Sky Subtraction Tab Offset Guiding Tab Settings Tab Tip Tilt Control and Telemetry Image Display Instrument Status Status Bar Star Detection Algorithm Deblending Multiple Stars","title":"Table of Contents"},{"location":"tiptiltinstructions/#tldr-procedure","text":"Set the gain and FPS values for the guide camera. Acquire the star to the KPF PO using magiq. In the KPF Tip Tilt GUI, turn on the tip tilt loops. Verify normal operation of the loops (this should just require a momentary glance at the various indicators): Make sure the science target has been indentified. It should have a circle around it and a label in the image display part of the GUI. Check that an object has been selected in \"Object Choice\". Check that the Peak Flux is sufficient (the value will be color coded to help you). If needed, adjust the gain and FPS. Check that the Tip Tilt Error is decreasing over time in the plot. This indicates that the star is being moved to the target pixel. Check the \"Tip Tilt RMS\" value is around 50 mas or better. If the target is faint or there are heavy clouds or bad seeing, it may not be able to reach this, but under normal conditions we should at least be in the ballpark. If there are multiple stars in the field of view, ensure that the corect target is selected and that the stars are not blended. Each detected star will have its own OBJECTn label in the image display: make sure this is centered on the star . Inform the observer that the tip tilt loops are engaged and they can begin exposing.","title":"TL:DR Procedure"},{"location":"tiptiltinstructions/#troubleshooting-the-tldr-procedure","text":"If the system is not seeing the target star, adjust the \"Detect SNR\" and/or \"Detect Area\" values under the Object Detection tab in the GUI (see Star Detection Algorithm section below for details). If the system seems to be having trouble identifying stars, toggle the loops on and off (this is primarily for the Calculation loop). Doing this will cause the algorithm to re-identify the stars and may resolve ID confusion caused when stars are moving rapidly in the field. Check that there are no red indicators in the status bar at the bottom of the Tip Tilt GUI. These indicate that something substantial is wrong. Which indicator it is will tell you which keyword or dispatcher is in a bad state.","title":"Troubleshooting the TL:DR Procedure"},{"location":"tiptiltinstructions/#tip-tilt-system-overview","text":"The KPF tip tilt system takes fast (e.g. 100 FPS) subframe images from the KPF CRED2 guide camera in order to control the fast tip tilt mirror which directs light in to the KPF FIU. This fast tip tilt system maintains the stellar position on the science fiber. This is critical not for reasons of maximizing flux in to the spectrograph (though that is a side benefit), but to optimize the radial velocity measurement. Even after fiber scrambling and agitation, if the star\u2019s position on the fiber entrance fiber shifts, that can manifest as a small shift of the spectrum on the detector which would be interpreted as a radial velocity change. Thus we need to position the star on the fiber, and then hold it in a consistent place during observations and make that position consistent from observation to observation.","title":"Tip Tilt System Overview"},{"location":"tiptiltinstructions/#tip-tilt-loops","text":"There are several components to the tip tilt loops. Controls for toggling them on and off together and individually are provided in the Tip Tilt Control and Telemetry section of the Tip Tilt GUI. The important pieces are: Calculation : The calculations are the part of the algorithm which is examining images from the guide camera, detecting and identifying objects, and calculating the relevant tip tilt commands. This can be toggled on and off using the underlying kpfguide.TIPTILT_CALC keyword. Note that once calculations are turned on the system is attempting to cross identify stars from image to image and maintain a consistent identity. One of the things it uses to do this is knowledge of the average positions of stars in recent images. Thus, if the stars are moved dramatically (e.g. by Magiq), it may confuse the IDs. If you think this might be the case, restarting calculations will force a fresh identification phase. Control : The control component takes the output of the calculations loop and sends commands to the tip tilt mirror. As long as the motions needed are within range of the tip tilt mirror, this will close the loops and should yield a stable star position. This can be toggled on and off using the underlying kpfguide.TIPTILT_CONTROL keyword. Offload : If the motion of the star carries it toward the edfe of the tip tilt mirror's range of motion, the system will \"offload\" some of that movement to the telescope (akin to a normal guiding command). Enabling offloads allows those commands to go to the telescope. This can be toggled on and off using the underlying kpfguide.OFFLOAD keyword. The kpfguide.OFFLOAD keyword will also attempt examine the telescope control system ( dcs ) to determine if offloads should be sent. This permissive is based primarily on whether KPF is the selected instrument, if not, the instrument should not be sending offloads to the telescope. The kpfguide.OFFLOAD_DCS keyword indicated whether KPF is permitted to offload and it must be \"Yes\" in order for offloads to be enabled.","title":"Tip Tilt Loops"},{"location":"tiptiltinstructions/#tip-tilt-gui","text":"To start the GUI, open a terminal as any kpf user (e.g. kpfeng) on the kpf machine and type: TTGUI_v2 . For dark mode, add the -d option to the command. A screenshot of the Tip Tilt GUI. The Tip Tilt GUI may also be opened for observers in \"monitor\" mode, in which case none of the controls are active, but the telemetry and image display can be seen. To do this, use the TTGUI_v2 --monitor terminal command as above or select KPF Control Menu -> Subcomponents -> Start Tip Tilt GUI from the FVWM menu in a KPF VNC session.","title":"Tip Tilt GUI"},{"location":"tiptiltinstructions/#gui-layout","text":"The top section of the GUI (beneath the \"File\" and \"Troubleshooting\" menus), is a small tabbed interface with various controls and options. See the sections below on each tab. Beneath the tabbed section is a region titled \"Tip Tilt Control and Telemetry\" this section contains control for the tip tilt loops and telemetry about the tip tilt performance. See the Tip Tilt Control and Telemetry section below for details. Beneath that is a region titled \"Image Display\" which shows the latest Magiq image cropped to the region which the tip tilt system is using (a subframe of the whole field). It also contains the tool for choosing which object in the field to guide on and controls for the image display stretch and cut. See the Image Display section below for details. Beneath that is a region titled \"Instrument Status\" which contains a very brief summary of what the instrument is doing at the moment. See the Instrument Status section below for details. The very bottom of the GUI is the status bar which will be empty if everything is in a working state for observing. See the Status Bar section below for details.","title":"GUI Layout"},{"location":"tiptiltinstructions/#camera-controls-tab","text":"A screenshot of the Tip Tilt GUI's Camera Controls tab. When the observer executes an OB (which they should do during the slew, but they may forget or not be ready, so check if you are unsure), then the target star's J band magnitude will be populated in this GUI. This will also update the \"Recommended Gain & FPS\" values. If you wish to accept these recommendations, simply click the \"Set\" button. The recommendations will be color coded green if they match the current values or orange if they do not match. The pulldown to the left of the \"Set\" button will add in some amount of extinction (in magnitudes) to the estimated values. If you have clouds, you can put in some value for the extinction and the estimate will account for the clouds. The right hand section of the tab shows the current Gain & FPS values. You may set them here using the pulldown menus. You can set these values on the command line by modifying the relevant keywords: kpgduide.GAIN , and kpfguide.FPS .","title":"Camera Controls Tab"},{"location":"tiptiltinstructions/#object-detection-tab","text":"A screenshot of the Tip Tilt GUI's Object Detection tab. This is where you can set the object detection and deblending parameters discussed in the Star Detection Algorithm section below. The pulldowns will set the requested value. You can set these values on the command line by modifying the relevant keywords: kpgduide.OBJECT_INTENSITY , kpfguide.OBJECT_AREA , and kpfguide.OBJECT_DBCONT .","title":"Object Detection Tab"},{"location":"tiptiltinstructions/#sky-subtraction-tab","text":"A screenshot of the Tip Tilt GUI's Sky Subtraction tab. Detection of faint targets when the gain is high and the FPS is low (of order 2 FPS or less) might be enhanced by subtracting the sky background. To do this, once the target has been acquired to the KPF PO, click the \"Obtain Sky Frame\" button. The telescope will offset by the amounts specified in the Sky Offset East and North fields, take a set of images there, and use that for sky subtraction. This will not necessarily increase the flux value, but may improve object detection because the background will be smoother and less noisy. The \"Reset Sky Frame\" button will reset the subtraction file to default (a bias frame). Any time the camera gain or FPS are changed, the sky frame will be reset to default.","title":"Sky Subtraction Tab"},{"location":"tiptiltinstructions/#offset-guiding-tab","text":"Not currently implemented.","title":"Offset Guiding Tab"},{"location":"tiptiltinstructions/#settings-tab","text":"A screenshot of the Tip Tilt GUI's Settings tab. The options here control various settings for the kpfguide algorithms. The \"X Axis\" and \"Y Axis\" settings allow you to bypass the tip tilt mirror and control the star position only using offloads to the telescope (conceptually similar to normal Magiq guiding). These values should be \"Mirror\" unless there is a problem with the tip tilt system. The \"DAR\" setting determines whether the target pixel for the star is modified to account for differential atmospheric refraction (DAR) between the guide wavelengths (950-1200nm) and the science wavelengths (centered on 550nm). This should be set to \"Yes\" under normal observing conditions. The \"Tip Tilt ROI Size\" can be adjusted using the pulldown. The default value of 128 pix is recommended, but in bad seeing conditions, going to larget frames may help, but processing the extra pixels might slow down the tip tilt calculations, so keep an eye on the \"Tip Tilt FPS\" value and make sure it does not stay below the camera FPS value.","title":"Settings Tab"},{"location":"tiptiltinstructions/#tip-tilt-control-and-telemetry","text":"This section of the GUI is how the tip tilt loops are opened and closed. The \"Tip Tilt On/Off\" button will likely be the primary interface as it toggles all of the components off the system on and off together, but the checkboxes to the right allow each to be toggled individually. Note that the \"Offloads\" checkbox will be color coded red when kpfguide.OFFLOAD_DCS is \"No\". The \"Tip Tilt Phase\" is meant to summarise whether the system has fully controlled the star's position to the point where the observers can begin exposing. It will begin in \"Identifying\", then move to \"Acquiring\" once a star has been identified and is being moved to the target pixel, and finally reach \"Tracking\" when the star is in position. These stages are based on the position error of the star and so may not be a perfect guide, but should be useful under normal conditions. The \"Tip Tilt FPS\" value shown in the GUI is the rate at which frames are being processed by the tip tilt algorithm and should be compared to the gude camera FPS. The \"Tip Tilt FPS\" value will likely bounce around a bit, but it should stay somewhere in the range of the camera FPS (within maybe 10%). If it is much less than the camera FPS, then the tip tilt system is not keeping up with the images coming in. The GUI will color code this value with orange and red values when it deviated from the camera FPS by more than some threshold amount. The \"Tip Tilt RMS\" value shown indicates how much the stellar position varies from frame to frame. This is different than the \"Tip Tilt Error\" (used in the plot below). The RMS is a measure of the frame to frame variation while the error is the average offset between the star and the target pixel. The error should drop to <<1 pixel under good conditions as the average star position is driven to the target pixel, but as the star bounces around from frame to frame due to seeing, the RMS value will be larger than zero. Our design goal is for the RMS value to be <50 mas (<1 pixel). The \"Peak Flux\" value is the brightness (in ADU) of the brightest pixel in the star as measured by the star detection algorithm. This is a good, but imperfect indication of whether the star is saturated in the guider image. Some bad pixels are always bright and if one of them is included in the star detection then the value of that one bad pixel will affect this reading, so you should use some discretion when inspecting this value. We have plans to implement a bad pixel mask which should mitigate this, but that is not complete and will require some care to make sure it does not affect the high speed calculations in the tip tilt loops. The guide camera is 14-bit, so it saturates at a value of 16,384. We perform a bias subtraction, so in practice this value is more like 14,000 counts. Saturation is not a deal breaker for using the tip tilt system. Mild saturation of only a few pixels in the core of the star will not drastically degrade the tip tilt performance, so it is better to saturate a bit than to try to run the FPS up to extremely high values where the calculations can not keep up. The \"Total Flux\" value is the sum of all pixel values with the detected star. This is an alternate indicator of the star's brightness, but does not directly indicate whether the star saturates the camera. The \"Tip Tilt Error\" plot is the left hand plot in the GUI. This is the offset (in pixels) between the stars's average position and the target pixel. When you first turn on the loops, you should see this start at a high value (a few pixels) and drop rapidly to near 0. The \"Flux\" plot is the right hand plot in the GUI. It plots the total flux in the star over time. The behavior of this is a useful indicator of clouds.","title":"Tip Tilt Control and Telemetry"},{"location":"tiptiltinstructions/#image-display","text":"The image display section shows a cropped version of the Magiq image (cropped to the region the tip tilt algorithm is using). It is important to remember that this image is not the same as what the tip tilt system is using for its calculations! This is an average of frames over the Magiq exposure time, so you have a higher SNR in this image than you do in the individual frames going in to the tip tilt calculations. The filename displayed and the timestamp at which the file was updated are also shown near the top. Mousing over the image will read out the pixel position and value of the pixel under the cursor just below the image and next to the X and Y position of the target pixel the algorithm is trying to steer the star to (this value is updated by DAR and so will change). The image will show an overlayed circle and label with the object's name (\"OBJECT1, OBJECT2, or OBJECT3\") and the percentage value next to the label is the fraction of frames in which is object is detected. If this is much less than 100%, you should probably adjust the detection parameters or adjust the sensitivity of the guider (i.e. increase gain or lower the FPS). To the right of the image is the \"Object Choice\" box. In the case where multiple objects are detected, you will need to choose one of them to be the target. Use the pulldown to choose which one you want to drive to the target pixel. Below this is a plot showing where the tip tilt mirror is within its range. The range is indicated by the green area. Points will be drawn and fade out over time to indicate the motion of the tip tilt mirror. Finally there are two selectors for \"Image Cut\" and \"Image Scaling\", these affect the image display, so feel free to adjust as you see fit.","title":"Image Display"},{"location":"tiptiltinstructions/#instrument-status","text":"There is a small section here summarizing the instrument status. It shows whether there is a script running which is a good indicator of whether data is being taken. The \"Exposure Status\" value shows whether the detectors are exposing, reading out, etc. The \"FIU Mode\" is a good guide as to whether you should expect to be seeing light from the sky on the guider images (e.g. if it is in \"Calibration\" mode, we are taking a cal exposure and you are probably seeing cal fibers, not the sky). Finally, the \"Object\" value is the string the observer has used to name the target.","title":"Instrument Status"},{"location":"tiptiltinstructions/#status-bar","text":"The very bottom of the GUI is a status bar. It will be empty under normal operating conditions, but will contain red indicators when there is a problem that will likely halt operation of the tip tilt system. For example, in the screenshot below several errors are shown: A screenshot of the Tip Tilt GUI's Status Bar with several errors. Status bar errors which can show up include: CONTINUOUS : This indicates that the guide camera is not exposing. SAVE : This indicates that the guide camera is not saving files. TTXSRV : This indicates that the tip tilt mirror X axis is not in servo mode and thus will not correct properly. TTYSRV : This indicates that the tip tilt mirror Y axis is not in servo mode and thus will not correct properly. DAR Disabled : This indicates that the DAR is not enabled. kpfguide1 : This indicates that there is a likely problem with the kpfguide1 dispatcher and a restart is likely required. kpfguide2 : This indicates that there is a likely problem with the kpfguide2 dispatcher and a restart is likely required. kpfguide3 : This indicates that there is a likely problem with the kpfguide3 dispatcher and a restart is likely required.","title":"Status Bar"},{"location":"tiptiltinstructions/#star-detection-algorithm","text":"The kpfguide software uses Source Extractor via the SEP Python Library for star detection. The \"Detect SNR\" and \"Detect Area\" values in the GUI correspond to the thresh and minarea parameters of sep.extract and to kpfguide.OBJECT_INTENSITY and kpfguide.OBJECT_AREA keyword respectively. The way the algorithm detects stars is to look for adjacent clusters of pixels with values above \"Detect SNR\". If that cluster is larger than \"Detect Area\" pixels, then it is a star. Both parameters are critical in determining whether a star will be detected. Having a large \"Detect Area\" means that faint stars will often not have enough bright pixels to be considered a detection. Similarly, a large \"Detect SNR\" might mean that not enough pixels are bright enough so too few pixels will be detections to be considered a star. On faint targets, both parameters may need to come down if only the very core of the star has significant signal in it. If you're having trouble in good seeing, make sure that \"Detect Area\" is not too large for the seeing. Based on experience, starting with values of 5-7 for \"Detect SNR\" and 80-100 for \"Detect Area\" are reasonable.","title":"Star Detection Algorithm"},{"location":"tiptiltinstructions/#deblending-multiple-stars","text":"Deblending is a term that comes from Source Extractor. It can be both perilous and useful. Early in the system\u2019s use, we were still using the default deblending contrast of 0.005, which meant that it took only a small dip in flux (0.5%) for two adjacent maxima to be considered two different objects. In practice, this meant that a single star would deblend in to multiple stars due to speckles moving about. As a result, the \u201cstar\u201d would appear to shift to one side or the other leading to sudden large corrections which would then be reversed a frame or two later when the speckles had shifted and the star was no longer deblended. This could affect several percent of all guide frames (in other words, the star was being jolted around by spurious detections several times per second). Of course, in situation where there are actually blended stars this is a useful tool. Double stars can be separated and a particular guide target chosen using this system. Based on our experience so far, leaving deblending contrast at 1.0 for most targets is the right choice. This demands that the valley between adjacent peaks be as deep as the highest peak (i.e. it goes to 0), so it turns deblending off. Since most targets are isolated stars with no close neighbors of similar brightness, this avoids the problem of tracking on speckles. If a double star is the target, decreasing the deblending contrast until it is reliably separates is the best strategy. Use the overlays in the image display to ensure that the target star has its own label and that label is centered properly on the star. If the label is not centered on the star, it might be blended with the companion which is puslling the \"center\" off toward the companion -- this is what we mean by blended stars. If the stars are blended, they must be deblended for KPF to accurately place one properly on the fiber. If the centroid is biased because the stars are not deblended you will end up with an RV effect due to the positioning of the star on the fiber being incorrect. The deblend contrast can be run down at 0.005 or lower to pull out a faint companion. Note that this is the contrast between the bright star and the faint \"gap\" between companions, so large contrast is not unexpected if the companion star is a few magnitudes fainter than the primary. For example, if the deblend contrast is 0.01 that is 5 magnitudes of contrast 2.5*log(0.01) , but that's not an unreasonable contrast for the gap if the companion star is just 2 or 3 magnitudes fainter than the primary. Also, because the algorithm is doing deblending, not trying to detect the companion as a separate object, we don't need to worry about the primary being too bright -- it is ok to saturate the primary to get the companion. Of course, a widely separated double star may be seen as two stars by the system if there is a \u201cgap\u201d between the two stars where the signal in the pixels is lower than the detection threshold. In this case, no deblending is necessary. Finally, if the star the observers are trying to acquire is too challenging and you are unable to make it work, you can ask the observer to click the \"Collect Guider Image Cube\" button on their OB GUI. This will save a brief sequence of guider images which can be analyzed offline to find out the best way to acquire that particular star (email the KPF SA to let them know to look at it). This does not help for the immediate observation, but will allow us to find the right solution for the next time this target or a similar one is observed.","title":"Deblending Multiple Stars"},{"location":"troubleshooting/","text":"Troubleshooting Table of Contents General Principles Log File Locations Scripts Existing Script is Running Agitator Use is Disabled Calibrations Calibration Source is Not Working SlewCal or Simultaneous Calibration Source is Wrong Etalon Light Source is Off Guider Target is not Visible in Guider FIU FIU Mode Change Fails Tip Tilt Performance is Poor Detectors kpfexpose.EXPOSE is not Ready Detector Refuses to be Triggered Detector Fails to Trigger Without Error Green or Red CCDPOWER Fails to turn on Ca HK Detector Stuck Exposure Meter in Error State L0 File Generation Deprecated L0 files Agitator Agitator Sounds Wrong or Speed is Wrong Vacuum Vacuum Chamber Vacuum Levels Rising SoCal Enclosure Lid Does not Move 1 Enclosure Lid Does not Move 2 General Principles DO NOT use control-c to stop a script, this can leave the instrument in an unsafe state. Use kpfconfig.SCRIPTSTOP to request a stop (also available as a button in the KPF OB GUI). Log File Locations Relevant log files for KPF are located in the following locations: Services and dispatchers write their logs to the /usr/local/kroot/var/log directory on the server on which they run . Most services run on kpfserver, but FIU related services run on kpffiuserver for example. A shortcut to that directory is available on the command line: cdlog The KPF Translator writes logs to the data disk: /s/sdata1701/KPFTranslator_logs A shortcut to that directory is available on the command line: cdtlog Within that directory, all KPF translator log lines are written to: KPFTranslator.log Also within that directory are date directories such as 2023jul01 which contain logs which are written by high level scripts such as RunOB . The log lines in these files are duplicates of what is in the KPFTranslator.log file in the directory above, but are duplicated here for easier searching and examination. It is also an easy way to see what high level scripts were run on a particular night. The command line interface for all of the translators writes to the date directories in /s/sdata1701/KPFTranslator_logs in a cli_logs subdirectory of the date. For example: /s/sdata1701/KPFTranslator_logs/2023jul01/cli_logs/cli_interface.log The KPF OB GUI writes logs to the data disk in /s/sdata1701/KPFTranslator_logs/OB_GUI.log Scripts Existing Script is Running Symptom : A script fails on the command line with a message similar to: kpf . FailedPreCondition : Failed PreCondition : Existing script RunCalOB . py ( 3303940 ) is running . If the offending script is not running ( PID not listed in ps ) then the script keywords can be cleared by running : reset_script_keywords or invoking it from the FVWM background menu : KPF Trouble Recovery --> Reset script keywords This may sometimes be seen at night if a scheduled calibration happens to be running when the science observer is trying to control the instrument (e.g. running the start of night script or running an observation). Observing takes precedence over calibrations, so if this is the case, the calibration can be stopped as described below. Problem : The keywords used to track whether a script is running indicate that another script is currently using the system. Solution 1 : Another script is running and needs to be stopped If another script is running and you need to terminate it in order to start something else, you should use the kpfconfig.SCRIPTSTOP keyword. You can do this by setting the SCRIPTSTOP keyword to \u201cYes\u201d either on the command line: modify -s kpfconfig SCRIPTSTOP=Yes or via the KPF OB GUI\u2019s STOP button which performs the same action. Setting SCRIPTSTOP to \u201cYes\u201d will request that the running script terminate in an orderly fashion. This may take several minutes depending on when the running script reaches a sensible breakpoint. It is important to use SCRIPTSTOP to halt a script (instead of hitting ctrl-c) because cleanup actions will be performed after a SCRIPTSTOP (e.g. turning off laps to preserve their lifetime). One of the things which can delay the running script terminating is a long exposure in progress. You can halt an exposure in progress by requesting kpfexpose to end the current exposure: modify -s kpfexpose EXPOSE=End Once the exposure is complete and has read out, most scripts will then check SCRIPTSTOP and begin the termination and cleanup steps. Solution 2 : No other scripts are running Sometimes the script keywords will be set as if a script is running, but the script has crashed and is not actually running. In this case, other scripts will be blocked until the script keywords are cleared. This can be done from the FWWM background menu using the KPF Trouble Recovery --> Reset script keywords entry or from the command line by invoking reset_script_keywords . Agitator Use is Disabled Symptom : When executing the start of night script, the log shows a warning such as: 2023-05-06 00:22:27,449 WARNING: Agitator use is disabled for tonight Problem : This means that the kpfconfig.USEAGITATOR keyword is set to \u201cNo\u201d. This keyword is meant to indicate the mechanism\u2019s health. A WMKO staff member will set this keyword to No if the agitator mechanism is not functional for some reason. Solution : The agitator can be reenabled by simply setting the keyword to \u201cYes\u201d. This should only be done by WMKO staff and should only be done if the agitator is fully functional. A broken or misbehaving agitator mechanism presents a significant danger to the science fibers. Calibrations Calibration Source is Not Working Symptom : A calibration set is run, but does not take data for a lamp. Problem : The lamp may be disabled in kpfconfig. The log may contain a line similar to: 2023-05-06 00:22:27,449 WARNING: Cal source EtalonFiber is disabled Solution : The cal source has likely been disabled for a reason. Reenabling it should only be done by WMKO staff with knowledge of why it was disabled in the first place. SlewCal or Simultaneous Calibration Source is Wrong Symptom : With the simultaneous calibration source (which is printed to the start of night log) or the slew cal source (visible in the OB GUI) are not the desired value. Problem : These two sources are set from the same place and are always kept to the same value using the kpfconfig.SIMULCALSOURCE keyword. Solution : This value should only be changed by WMKO staff . The choice of calibration source is influenced by our desire to maintain the lifetime of the various lamps and calibration sources and by the need for warmup times on certain sources. This is not something the user should adjust, contact a WMKO Staff Astronomer if you feel it is set incorrectly. Etalon Light Source is Off Symptom : There is no light visible from the etalon in spectra. This can be confirmed visually looking at the fibers coming from the SuperK light source which feeds the etalon. Under normal conditions, glow can be seen at some fiber interfaces. Problem : The Super-K light source is off or otherwise incapacitated. Solution : Note: A safety issue is that the super-K puts out considerable power, including in the infrared. The optical output is connected to the etalon so this won\u2019t be a problem. But one shouldn\u2019t disconnect that fiber and look into the beam. It is exceptionally bright in the optical so this is probably obvious, but I mention it just in case. Check that the SuperK is powered on at the PDU (port M7 available via the Power GUI, or gshow -s kpfpower OUTLET_M7 ). If the system is powered on, check that the interlock lights are green as seen in the photo below. The interlock is just two very thin wires that I twisted together. Check that the key is in the On position (see photo below). If these indicate that the status is ok, then the SuperK may need to be powered on from software. There is currently no keyword based client for this and this must be done from a Windows machine running the NKT Control software. There is a small Windows machine ( tc-su-kpfetalon or 10.104.10.157 ) connected via USB which is accessible via VNC. VNC in as user kpfeng. Once connected via VNC, the Control software should be available on the desktop. Start that and connect to the device. Once connected, the system should look like the screenshot below when in an operational state. The power on the light, use the \u201cEmission ON/OFF\u201d button. Guider Target is not Visible in Guider Symptom : The observer\u2019s target is not visible on the guider after slewing there. This could be due to one of several problems. Often this is related to the small field of view (FoV) of the guider which is approximately 30x40 arc seconds. Problem 1 : Telescope pointing The telescope pointing is off (Ca or Ce is wrong) or the star is a high proper motion star and is not at the expected coordinates. Solution 1 : The OA should check a nearby, bright pointing star. If it centers up nicely, this suggests that either the coordinates of the target are wrong (or simply not corrected for proper motions). The star may be just off the edge of the field, so the OA can check by making a few small telescope moves to probe the area just off the edge of the field. Problem 2 : Guider sensitivity The star is too faint for the current guider camera settings or the extinction from clouds has made the star too faint to detect. Solution 2 : If it is not already, increase the guider camera\u2019s gain setting to high and see if the star appears. This can be accomplished either in the tip tilt GUI or via command line: kpfSetGuiderGain high . If the target star is faint in J band magnitude (e.g. Jmag > 12) (Note that 2MASS is a good source to determine expected J magnitude), then the guider may need to have the frames per second (FPS) value lowered to increase sensitivity. If conditions are good (i.e. little or no extinction from clouds), then there is a tool which can set reasonable guesses for the guider gain and FPS based on the J magnitude of the star. For example: kpfPredictGuiderParameters 13.2 (for Jmag=13.2) will set both guider gain and FPS. If there is substantial extinction from clouds, the user may need to manually configure the guider parameters. This is best done by editing the observing block. In the KPF OB GUI, this can be accomplished by setting the GuiderMode to manual, and setting the gain and FPS below (see screenshot). Alternatively the observer may set these manually using the command line tools kpfSetGuiderGain and kpfSetGuiderFPS , but if an OB is executed it will overwrite the previous values, so to use the new values for science, they must be copied to the OB prior to execution. Problem 3 : Light is not reaching the guide camera The light is not reaching the guide camera due to an obstruction. Solution 3 : Look at the FIU GUI to see if there is an obstruction. Possible culprits include: * The AO hatch is closed: check keywords or FIU GUI. The hatch can be opened using the command line kpfControlAOHatch open or from the FVWM menu: KPF Utilities -> Open AO Hatch * The FIU hatch is closed: check keywords or FIU GUI. The hatch can be opened using the command line kpfControlHatch open or from the FVWM menu: KPF Utilities -> Open FIU Hatch * The FIU is in the wrong mode: check keywords or FIU GUI. The FIU may be in calibration mode or in an unknown state, either of which can result in the calibration fold mirror blocking the light. The mode can be set using the command line kpfConfigureFIU Observing or from the FVWM menu: KPF Utilities -> Set FIU Mode to Observing FIU FIU Mode Change Fails Symptom : The FIU failed to reach destination mode ( kpffiu.MODE ) after repeated attempts. One possible error code which you might see is: decode_write_response_event(): MODE (on behalf of MODE): ERR_WRITE_SW_ERROR (-5401) There was an error in the device-specific write routine for this keyword: check the log files Problem : One possible reason for this is that the fold mirror is in a limit switch. To establish if this is the case: gshow -s kpffiu FOLDLIM FOLDLIM = Positive Solution : Reset and home the fold mirror stage modify -s kpffiu FOLDCAL=Reset modify -s kpffiu FOLDCAL=Homed Then either set FOLDNAM to the destination or set MODE to the desired destination. Tip Tilt Performance is Poor Symptom : Tip tilt performance is poor. The star is moving a lot on the guider, perhaps primarily in either the X or Y pixel direction. Problem : One possibility is that the XY stage is failing. The symptom is that the stage has lost range and can not reach the commanded position. To determine if this is the case, stop observing and stop the tip tilt loops and: Watch the kpffiu TTXVAX and TTYVAX keywords (e.g. via an xshow). Command one of the axis to someplace near the nominal limit and watch to see if the keyword value reached the location it was commanded to go. The X stage should be able to go from -15 to +15 and the Y stage should be able to go -20 to +20 (they actually can access a bit more, but this is a reasonable amount to test). For example: modify -s kpffiu TTXVAX=-15 (note where the keyword actually goes) modify -s kpffiu TTXVAX=15 (note where the keyword actually goes) modify -s kpffiu TTYVAX=-20 (note where the keyword actually goes) modify -s kpffiu TTYVAX=20 (note where the keyword actually goes) If one or more of the above tests falls far short of the destination, then we need to tell the software not to use that part of the range. It is worth repeating the test above to see if you get consistent results. If the results are not consistent, then the procedure below will be of limited utility. Solution : There are several components to this fix and it is important to understand what each does, so that you can perform the fix properly. The section below explains how the keywords are used, then we will discuss how to set them. Understanding Tip Tilt Keywords The kpffiu service handles commands to the tip tilt stage. TTXVAX and TTYVAX report the position of the stage in arc seconds of tilt. This is tilt of the stage, not movement of the star on the focal plane. TTXRAW and TTYRAW are the position of the stage in raw encoder counts. TTXRON and TTYRON define the home position of the stage for the stage controller in raw encoder counts. The kpfguide service handles the control loop used to decide where to command the stage to go. TIPTILT_HOME defines the (x, y) coordinates of the home position in arc seconds of motion of the stage. This is where the stage will be positioned if no tip tilt moves are needed \u2013 it is the center of the stage motion. TIPTILT_XRANGE and TIPTILT_YRANGE define the maximum range of motion which the guide system should use during observing (in units of arc seconds of stage motion). This is the half width of the range, so the stage can go from the home position - range to home position + range. The combination of kpfguide.TIPTILT_HOME and kpffiu.TT{x,y}RON define the center of motion of the stage and we want those to be in agreement. Unfortunately, these are in different units, so we need to keep that in mind and ensure they are consistent when we set new values. Once the center position is defined, the system uses kpfguide.TIPTILT_{x,y}RANGE to decide how far to push the tip tilt mirror before offloading to the telescope. Setting Up the Tip Tilt Center Position and Limits Above we discovered the limits (in TT{x,y}VAX units) where the stage seems to be able to go. Use those values to determine the home position (center point between the limits) and the range (distance from home to one limit). Use those calculated values to set kpfguide.TIPTILT_HOME and kpfguide.TIPTILT_{x,y}RANGE . Now move the stage to the home position by setting kpffiu.TT{x,y}VAX and read off the kpffiu.TT{x,y}RAW value. Update the kpffiu.TT{x,y}RON strings with that value, maintaining the proper formatting: |{raw value}|0|Home. There is an experimental script to do the above steps, but you must manually verify that the results look reasonble. Run kpfMeasureTipTiltMirrorRange and it will print out a set of modify commands for you to run (it does not execute them itself). Check the logic and math, the script is experimental! Note that if the script finds a limit which is unexpected (i.e. less range than nominal), it will set up the above keywords to a range 1 arc second smaller than where the limit is. It adds this safety margin to the kpfguide.TIPTILT_{x,y}RANGE keywords, so if you calculate something slightly different than the script, this may be why. Detectors kpfexpose.EXPOSE is not Ready Symptom : The kpfexpose.EXPOSE keyword is reporting an unexpected state such as reporting \"InProgress\" even though the exposure should have finished or is reporting \"Error\". If kpfexpose.EXPOSE is not ready, it will not allow users to take new exposures which is how this will likely manifest. Problem : One of the detectors may not be in a normal state. Use the EXPLAINNR keyword to determine which detector is blocking kpfexpose.EXPOSE from becoming \"Ready\". For example, if kpfexpose.EXPLAINNR is reporting \"hk:ACQPHASE=wait\", that indicates that the CaHK detector is not in the Ready phase. The detailed solution will depend on which camera and what is causing the blockage. Solution 1 : Reset the Red or Green detector If either the Red or Green camera is the problem as reported by kpfexpose.EXPLAINNR or by the relevant camera's EXPSTATE keyword, the setting the particular camera's EXPOSE keyword to \"Reset\" may resolve things (e.g. modify -s kpfgreen EXPOSE=Reset ). Solution 2 : Abort Ca HK Exposure If the Ca HK detector appears to be the problem (e.g. kpfexpose.EXPLAINNR value is \"hk:ACQPHASE=wait\"), then aborting the exposure in progress may free up the Ca HK detector. To do so run: modify -s kpf_hk EXPOSE=abort Solution 3 : Restart the relevant keyword service or dispatchers If the above has not helped, restarting the service may free things up. Possible services to restart include kpfexpose , kpfgreen , kpfred , kpf_hk . It is suggested that you only restart the service if there is some indication that it is the source of the problem (either from kpfexpose.EXPLAINNR or from the service's EXPSTATE for example). Detector Refuses to be Triggered Symptom : When running an OB, or invoking command line scripts, a particular detector is not set to be triggered even though it is requested. Problem : The detector may be disabled in kpfconfig . The log may contain a line similar to: 2023-05-06 00:22:27,449 WARNING: Green detector is not enabled Solution : The detector has likely been disabled for a reason. Reenabling it should only be done by WMKO staff with knowledge of why it was disabled in the first place. Detector Fails to Trigger Without Error Symptom : The detector is not exposing and not producing output files, but kpfexpose is unaware of the problem and takes exposures as normal triggering all selected cameras. Problem : Something is stuck in the dispatcher code for driving the Archon (this only applies to red and green detectors). Solution : Restart dispatcher 0 on the affected detector: kpf restart kpfgreen0 Green or Red CCDPOWER Fails to turn on Symptom : When trying to power up the detector by setting the CCDPOWER keyword to \u201cOn\u201d, the keyword does not successfully transition to on. The stderr file for the relevant camerad process (e.g. gcamerad.stderr ) contains statements like: (Archon::Interface::archon_cmd) ERROR: Archon controller returned error processing command: POWERON Problem : There is something wrong in the ACF file for the Archon. Solution : Resend the ACF file by either modifying the appropriate ACF keyword or using the kpfSetReadModeNormal or kpfSetReadModeFast scripts. Ca HK Detector Stuck Symptom : The HK detector is stuck in the exposing state. or The kpfexpose.EXPOSE status is stuck and kpfexpose.EXPLAINNR is \"hk:ACQPHASE=wait\". Problem : Some combination of hardware and software is stuck. Solution : Abort the existing HK exposure: modify -s kpf_hk expose=abort (alternatively, the same action is available via the FWWM menu under KPF Troubleshooting Menu -> KPF Trouble Recovery \u2192 Reset Ca HK Detector ). Then restart the kpf_hk service: kpf restart kpf_hk Take test exposures to see if the system has recovered. If the system is still stuck, power cycle the Andor Camera, and the HK Galil on power strip J, ports 1, 2, and 5, then restart kpf_hk again. This can be accomplished in one step using: kpfPowerCycleCaHK (alternatively the same tool is available via the FWWM menu under KPF Troubleshooting Menu -> KPF Trouble Recovery -> Power Cycle Ca HK Detector ). If the detector is still not responsive, check the log files on kpffiuserver . If the kpf_hk.stderr file contains lines like this after a restart of the kpf_hk service: open () failed : No such file or directory Failed to configure camera : init failure , using path = \"/usr/local/etc/andor\" : DRV_VXDNOTINSTALLED Then it means that the USB connection is unhappy for some reason. The recovery is to ask for a reboot of kpffiuserver . This will require restarting the kpffiu service as well. Exposure Meter in Error State Symptom : The exposure meter is in an error state: kpf_expmeter.EXPSTATE=Error Problem : Something in the SBIG CCD control software is unhappy. Solution 1 : First, try resetting the exposure meter detector: modify -s kpf_expmeter EXPOSE=Reset Check the status: gshow -s kpf_expmeter EXPSTATE should become \u201cReady\u201d. Solution 2 : If the above solution fails to recover the system, power cycle the camera on power port L3. Then do kpf restart kpf_expmeter . This is equivalent to kpf restart kpf_expmeter1 (exposure meter camera) and kpf restart kpf_expmeter2 (exposure meter DRP). Sometimes kpf_expmeter2 is stuck in a busy state after a kpf_expmeter1 restart. Both kpf_expmeter1 and kpf_expmeter2 need to be ready before kpfexpose can trigger new exposures. You may need to set the TOP , LEFT , WIDTH , and HEIGHT keywords after restarting the software. The values are: [ kpfeng@kpfserver ] ~ > gshow - s kpf_expmeter LEFT TOP WIDTH HEIGHT LEFT = 1 TOP = 0 WIDTH = 651 HEIGHT = 300 The correct values are checked in testAll , so you can always run that to verify values are ok. L0 File Generation Deprecated L0 files L0 files are generated by gathering the \u201csub-FITS\u201d files from the Green, Red, CaHK, EM, and guide cameras, processing some of them (EM and guide camera), adding telemetry drawn from KTL keywords and the sub-FITS headers to the new L0 FITS header, and writing the L0 file. This process happens automatically by using keywords to notify a dispatcher that a recent exposure is ready for L0 file creation. If this dispatcher is stopped or dies, it can be restarted with the command kpf restart assemble . If L0 files need to be generated manually (e.g., because the dispatcher stopped or L0 files need to be regenerated), it can be done with the command l0_assemble --outdir path NNNNN MMMMM where path is the directory where the L0 files should be written (e.g., /sdata1701/kpfeng/DATE/L0 ), NNNNN is the first FRAMENO (a header keyword for Green and Red FITS images and an index which is incremented with each exposure; e.g. 33015 ), and MMMMM is the last FRAMENO in a range of files (e.g., 33020 ). The final argument is optional if only one L0 file needs to be generated. L0 files may be deprecated when switching to fast-readout mode. The observers may find broken L1/L2 files, and the L0 files are missing green/red/CaHK components. If L0 files needed to be regenerated, it is better to write to a new directory (e.g., /sdata1701/kpfeng/DATE/new_L0 ), and inform Jeff Mader so he can ingest the new L0 files to Keck Observatory Archive. Agitator Agitator Sounds Wrong or Speed is Wrong Symptom : The agitator is not working as expected. This is usually seen in the agitator speed value (see screenshots) or by listening to the sounds. This is a plot of what the kpfmot.AGITSPD keyword value looks like as the agitator is cycled on during exposures. It goes to a negative value of a few thousand during operation. This is an example of a bad agitator speed behavior. It goes positive for one data point, then back to zero. You can listen to the agitator mechanism via the \u201cKPF crypt M5075\u201d camera on the facility camera list (note this is an internal web page at Keck). In normal operation the agitator makes a regular (roughly 1-2 Hz) mechanical oscillation sound. When the bad behavior above occurred it was either silent (note there is background fan noise on that camera) or would make a single mechanical \u201ccachunk\u201d sound, then stop. Problem : The motor is not initialized properly. Solution : Initialize using: modify -s kpfmot agitmod=pos modify -s kpfmot agitini=no This leaves the system in Halt mode. Initialize using: modify -s kpfmot agitmod=pos modify -s kpfmot agitini=yes Note: if the ini command fails with: Error setting agitini: agitini: ERR_STST_COND_TIMEOUT (-5239) StdStage condition did not become true within the time limit try restarting the dispatcher (kpf restart kpfmot) in order to get it to release the thread lock on communications and they to initialize again. Vacuum Vacuum Chamber Vacuum Levels Rising Symptom : Vacuum levels in the chamber are rising, but the vacuum levels at the pump are falling. These are kpfvac.VCH_HIVAC and kpfvac.VCART_HIVAC keywords respectively. This might manifest as a \u201cvac chamber trouble\u201d alert from kpfmon. Problem : The gate valve between the vacuum chamber and the pump has closed. The gate valve is currently (late 2023) not instrumented and is controlled by compressed air from the facility. As long as facility compressed air is working, the valve is open and the pump should be keeping the vacuum chamber at good vacuum levels. If the gate valve closes, it is presumably because compressed air has failed. Below is a Grafana plot showing that as chamber pressure was rising, vac cart pressure was falling. This is the signature of the gate valve being closed. In this example, the gate valve closed at about 14:12 local time and was opened again around 15:15 local time. Solution : SoCal Enclosure Lid Does not Move 1 Symptom : Enclosure will not move. It may begin moving, then stop and reverse. Problem : Enclosure motor is hitting an overcurrent limit. To verify this is the problem, log in to the dome controller from kpfeng@kpfserver: ssh socal This connects to the Raspberry Pi controller in the dome enclosure. The username and IP address has configured in the ~/.ssh/config file on kpfserver (you can ssh manually using pi@192.168.23.244 ) and the SSH key for kpfserver has been installed on the Pi, so it should not ask for a password, but if it does, the password in in the usual showpasswords location. View the dome log file in the ~/dome.log and look for errors which indicate the nature of the problem. The ~/grep_for_dome_error script will exclude many of the noisy, not useful lines in the dome.log file and help with examining the log. Solution : If the log file indicates overcurrent on the motors is the issue. Ensure the mechanisms are clear of obstruction and reasonably well balanced (it doesn\u2019t need to be perfect). Enclosure Lid Does not Move 2 Symptom : Enclosure will not move. It may begin moving, then stop and reverse. Problem : Enclosure motor is not getting current. To verify this is the problem, log in to the dome controller from kpfeng@kpfserver: ssh socal This connects to the Raspberry Pi controller in the dome enclosure. The username and IP address has configured in the ~/.ssh/config file on kpfserver (you can ssh manually using pi@192.168.23.244 ) and the SSH key for kpfserver has been installed on the Pi, so it should not ask for a password, but if it does, the password in in the usual showpasswords location. View the dome log file in the ~/dome.log and look for errors similar to: 2024 - 07 - 09 19 : 09 : 37 , 752 WARNING Operation timed out ( 35.0 secs ), max measured motor current : 0.0 A . The ~/grep_for_dome_error script will exclude many of the noisy, not useful lines in the dome.log file and help with examining the log. Solution : Reboot the controller (raspberry pi): sudo reboot and restart the kpfsocal3 dispatcher: kpf restart kpfsocal3 . Multiple reboots may be required.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#table-of-contents","text":"General Principles Log File Locations Scripts Existing Script is Running Agitator Use is Disabled Calibrations Calibration Source is Not Working SlewCal or Simultaneous Calibration Source is Wrong Etalon Light Source is Off Guider Target is not Visible in Guider FIU FIU Mode Change Fails Tip Tilt Performance is Poor Detectors kpfexpose.EXPOSE is not Ready Detector Refuses to be Triggered Detector Fails to Trigger Without Error Green or Red CCDPOWER Fails to turn on Ca HK Detector Stuck Exposure Meter in Error State L0 File Generation Deprecated L0 files Agitator Agitator Sounds Wrong or Speed is Wrong Vacuum Vacuum Chamber Vacuum Levels Rising SoCal Enclosure Lid Does not Move 1 Enclosure Lid Does not Move 2","title":"Table of Contents"},{"location":"troubleshooting/#general-principles","text":"DO NOT use control-c to stop a script, this can leave the instrument in an unsafe state. Use kpfconfig.SCRIPTSTOP to request a stop (also available as a button in the KPF OB GUI).","title":"General Principles"},{"location":"troubleshooting/#log-file-locations","text":"Relevant log files for KPF are located in the following locations: Services and dispatchers write their logs to the /usr/local/kroot/var/log directory on the server on which they run . Most services run on kpfserver, but FIU related services run on kpffiuserver for example. A shortcut to that directory is available on the command line: cdlog The KPF Translator writes logs to the data disk: /s/sdata1701/KPFTranslator_logs A shortcut to that directory is available on the command line: cdtlog Within that directory, all KPF translator log lines are written to: KPFTranslator.log Also within that directory are date directories such as 2023jul01 which contain logs which are written by high level scripts such as RunOB . The log lines in these files are duplicates of what is in the KPFTranslator.log file in the directory above, but are duplicated here for easier searching and examination. It is also an easy way to see what high level scripts were run on a particular night. The command line interface for all of the translators writes to the date directories in /s/sdata1701/KPFTranslator_logs in a cli_logs subdirectory of the date. For example: /s/sdata1701/KPFTranslator_logs/2023jul01/cli_logs/cli_interface.log The KPF OB GUI writes logs to the data disk in /s/sdata1701/KPFTranslator_logs/OB_GUI.log","title":"Log File Locations"},{"location":"troubleshooting/#scripts","text":"","title":"Scripts"},{"location":"troubleshooting/#existing-script-is-running","text":"Symptom : A script fails on the command line with a message similar to: kpf . FailedPreCondition : Failed PreCondition : Existing script RunCalOB . py ( 3303940 ) is running . If the offending script is not running ( PID not listed in ps ) then the script keywords can be cleared by running : reset_script_keywords or invoking it from the FVWM background menu : KPF Trouble Recovery --> Reset script keywords This may sometimes be seen at night if a scheduled calibration happens to be running when the science observer is trying to control the instrument (e.g. running the start of night script or running an observation). Observing takes precedence over calibrations, so if this is the case, the calibration can be stopped as described below. Problem : The keywords used to track whether a script is running indicate that another script is currently using the system. Solution 1 : Another script is running and needs to be stopped If another script is running and you need to terminate it in order to start something else, you should use the kpfconfig.SCRIPTSTOP keyword. You can do this by setting the SCRIPTSTOP keyword to \u201cYes\u201d either on the command line: modify -s kpfconfig SCRIPTSTOP=Yes or via the KPF OB GUI\u2019s STOP button which performs the same action. Setting SCRIPTSTOP to \u201cYes\u201d will request that the running script terminate in an orderly fashion. This may take several minutes depending on when the running script reaches a sensible breakpoint. It is important to use SCRIPTSTOP to halt a script (instead of hitting ctrl-c) because cleanup actions will be performed after a SCRIPTSTOP (e.g. turning off laps to preserve their lifetime). One of the things which can delay the running script terminating is a long exposure in progress. You can halt an exposure in progress by requesting kpfexpose to end the current exposure: modify -s kpfexpose EXPOSE=End Once the exposure is complete and has read out, most scripts will then check SCRIPTSTOP and begin the termination and cleanup steps. Solution 2 : No other scripts are running Sometimes the script keywords will be set as if a script is running, but the script has crashed and is not actually running. In this case, other scripts will be blocked until the script keywords are cleared. This can be done from the FWWM background menu using the KPF Trouble Recovery --> Reset script keywords entry or from the command line by invoking reset_script_keywords .","title":"Existing Script is Running"},{"location":"troubleshooting/#agitator-use-is-disabled","text":"Symptom : When executing the start of night script, the log shows a warning such as: 2023-05-06 00:22:27,449 WARNING: Agitator use is disabled for tonight Problem : This means that the kpfconfig.USEAGITATOR keyword is set to \u201cNo\u201d. This keyword is meant to indicate the mechanism\u2019s health. A WMKO staff member will set this keyword to No if the agitator mechanism is not functional for some reason. Solution : The agitator can be reenabled by simply setting the keyword to \u201cYes\u201d. This should only be done by WMKO staff and should only be done if the agitator is fully functional. A broken or misbehaving agitator mechanism presents a significant danger to the science fibers.","title":"Agitator Use is Disabled"},{"location":"troubleshooting/#calibrations","text":"","title":"Calibrations"},{"location":"troubleshooting/#calibration-source-is-not-working","text":"Symptom : A calibration set is run, but does not take data for a lamp. Problem : The lamp may be disabled in kpfconfig. The log may contain a line similar to: 2023-05-06 00:22:27,449 WARNING: Cal source EtalonFiber is disabled Solution : The cal source has likely been disabled for a reason. Reenabling it should only be done by WMKO staff with knowledge of why it was disabled in the first place.","title":"Calibration Source is Not Working"},{"location":"troubleshooting/#slewcal-or-simultaneous-calibration-source-is-wrong","text":"Symptom : With the simultaneous calibration source (which is printed to the start of night log) or the slew cal source (visible in the OB GUI) are not the desired value. Problem : These two sources are set from the same place and are always kept to the same value using the kpfconfig.SIMULCALSOURCE keyword. Solution : This value should only be changed by WMKO staff . The choice of calibration source is influenced by our desire to maintain the lifetime of the various lamps and calibration sources and by the need for warmup times on certain sources. This is not something the user should adjust, contact a WMKO Staff Astronomer if you feel it is set incorrectly.","title":"SlewCal or Simultaneous Calibration Source is Wrong"},{"location":"troubleshooting/#etalon-light-source-is-off","text":"Symptom : There is no light visible from the etalon in spectra. This can be confirmed visually looking at the fibers coming from the SuperK light source which feeds the etalon. Under normal conditions, glow can be seen at some fiber interfaces. Problem : The Super-K light source is off or otherwise incapacitated. Solution : Note: A safety issue is that the super-K puts out considerable power, including in the infrared. The optical output is connected to the etalon so this won\u2019t be a problem. But one shouldn\u2019t disconnect that fiber and look into the beam. It is exceptionally bright in the optical so this is probably obvious, but I mention it just in case. Check that the SuperK is powered on at the PDU (port M7 available via the Power GUI, or gshow -s kpfpower OUTLET_M7 ). If the system is powered on, check that the interlock lights are green as seen in the photo below. The interlock is just two very thin wires that I twisted together. Check that the key is in the On position (see photo below). If these indicate that the status is ok, then the SuperK may need to be powered on from software. There is currently no keyword based client for this and this must be done from a Windows machine running the NKT Control software. There is a small Windows machine ( tc-su-kpfetalon or 10.104.10.157 ) connected via USB which is accessible via VNC. VNC in as user kpfeng. Once connected via VNC, the Control software should be available on the desktop. Start that and connect to the device. Once connected, the system should look like the screenshot below when in an operational state. The power on the light, use the \u201cEmission ON/OFF\u201d button.","title":"Etalon Light Source is Off"},{"location":"troubleshooting/#guider","text":"","title":"Guider"},{"location":"troubleshooting/#target-is-not-visible-in-guider","text":"Symptom : The observer\u2019s target is not visible on the guider after slewing there. This could be due to one of several problems. Often this is related to the small field of view (FoV) of the guider which is approximately 30x40 arc seconds. Problem 1 : Telescope pointing The telescope pointing is off (Ca or Ce is wrong) or the star is a high proper motion star and is not at the expected coordinates. Solution 1 : The OA should check a nearby, bright pointing star. If it centers up nicely, this suggests that either the coordinates of the target are wrong (or simply not corrected for proper motions). The star may be just off the edge of the field, so the OA can check by making a few small telescope moves to probe the area just off the edge of the field. Problem 2 : Guider sensitivity The star is too faint for the current guider camera settings or the extinction from clouds has made the star too faint to detect. Solution 2 : If it is not already, increase the guider camera\u2019s gain setting to high and see if the star appears. This can be accomplished either in the tip tilt GUI or via command line: kpfSetGuiderGain high . If the target star is faint in J band magnitude (e.g. Jmag > 12) (Note that 2MASS is a good source to determine expected J magnitude), then the guider may need to have the frames per second (FPS) value lowered to increase sensitivity. If conditions are good (i.e. little or no extinction from clouds), then there is a tool which can set reasonable guesses for the guider gain and FPS based on the J magnitude of the star. For example: kpfPredictGuiderParameters 13.2 (for Jmag=13.2) will set both guider gain and FPS. If there is substantial extinction from clouds, the user may need to manually configure the guider parameters. This is best done by editing the observing block. In the KPF OB GUI, this can be accomplished by setting the GuiderMode to manual, and setting the gain and FPS below (see screenshot). Alternatively the observer may set these manually using the command line tools kpfSetGuiderGain and kpfSetGuiderFPS , but if an OB is executed it will overwrite the previous values, so to use the new values for science, they must be copied to the OB prior to execution. Problem 3 : Light is not reaching the guide camera The light is not reaching the guide camera due to an obstruction. Solution 3 : Look at the FIU GUI to see if there is an obstruction. Possible culprits include: * The AO hatch is closed: check keywords or FIU GUI. The hatch can be opened using the command line kpfControlAOHatch open or from the FVWM menu: KPF Utilities -> Open AO Hatch * The FIU hatch is closed: check keywords or FIU GUI. The hatch can be opened using the command line kpfControlHatch open or from the FVWM menu: KPF Utilities -> Open FIU Hatch * The FIU is in the wrong mode: check keywords or FIU GUI. The FIU may be in calibration mode or in an unknown state, either of which can result in the calibration fold mirror blocking the light. The mode can be set using the command line kpfConfigureFIU Observing or from the FVWM menu: KPF Utilities -> Set FIU Mode to Observing","title":"Target is not Visible in Guider"},{"location":"troubleshooting/#fiu","text":"","title":"FIU"},{"location":"troubleshooting/#fiu-mode-change-fails","text":"Symptom : The FIU failed to reach destination mode ( kpffiu.MODE ) after repeated attempts. One possible error code which you might see is: decode_write_response_event(): MODE (on behalf of MODE): ERR_WRITE_SW_ERROR (-5401) There was an error in the device-specific write routine for this keyword: check the log files Problem : One possible reason for this is that the fold mirror is in a limit switch. To establish if this is the case: gshow -s kpffiu FOLDLIM FOLDLIM = Positive Solution : Reset and home the fold mirror stage modify -s kpffiu FOLDCAL=Reset modify -s kpffiu FOLDCAL=Homed Then either set FOLDNAM to the destination or set MODE to the desired destination.","title":"FIU Mode Change Fails"},{"location":"troubleshooting/#tip-tilt-performance-is-poor","text":"Symptom : Tip tilt performance is poor. The star is moving a lot on the guider, perhaps primarily in either the X or Y pixel direction. Problem : One possibility is that the XY stage is failing. The symptom is that the stage has lost range and can not reach the commanded position. To determine if this is the case, stop observing and stop the tip tilt loops and: Watch the kpffiu TTXVAX and TTYVAX keywords (e.g. via an xshow). Command one of the axis to someplace near the nominal limit and watch to see if the keyword value reached the location it was commanded to go. The X stage should be able to go from -15 to +15 and the Y stage should be able to go -20 to +20 (they actually can access a bit more, but this is a reasonable amount to test). For example: modify -s kpffiu TTXVAX=-15 (note where the keyword actually goes) modify -s kpffiu TTXVAX=15 (note where the keyword actually goes) modify -s kpffiu TTYVAX=-20 (note where the keyword actually goes) modify -s kpffiu TTYVAX=20 (note where the keyword actually goes) If one or more of the above tests falls far short of the destination, then we need to tell the software not to use that part of the range. It is worth repeating the test above to see if you get consistent results. If the results are not consistent, then the procedure below will be of limited utility. Solution : There are several components to this fix and it is important to understand what each does, so that you can perform the fix properly. The section below explains how the keywords are used, then we will discuss how to set them. Understanding Tip Tilt Keywords The kpffiu service handles commands to the tip tilt stage. TTXVAX and TTYVAX report the position of the stage in arc seconds of tilt. This is tilt of the stage, not movement of the star on the focal plane. TTXRAW and TTYRAW are the position of the stage in raw encoder counts. TTXRON and TTYRON define the home position of the stage for the stage controller in raw encoder counts. The kpfguide service handles the control loop used to decide where to command the stage to go. TIPTILT_HOME defines the (x, y) coordinates of the home position in arc seconds of motion of the stage. This is where the stage will be positioned if no tip tilt moves are needed \u2013 it is the center of the stage motion. TIPTILT_XRANGE and TIPTILT_YRANGE define the maximum range of motion which the guide system should use during observing (in units of arc seconds of stage motion). This is the half width of the range, so the stage can go from the home position - range to home position + range. The combination of kpfguide.TIPTILT_HOME and kpffiu.TT{x,y}RON define the center of motion of the stage and we want those to be in agreement. Unfortunately, these are in different units, so we need to keep that in mind and ensure they are consistent when we set new values. Once the center position is defined, the system uses kpfguide.TIPTILT_{x,y}RANGE to decide how far to push the tip tilt mirror before offloading to the telescope. Setting Up the Tip Tilt Center Position and Limits Above we discovered the limits (in TT{x,y}VAX units) where the stage seems to be able to go. Use those values to determine the home position (center point between the limits) and the range (distance from home to one limit). Use those calculated values to set kpfguide.TIPTILT_HOME and kpfguide.TIPTILT_{x,y}RANGE . Now move the stage to the home position by setting kpffiu.TT{x,y}VAX and read off the kpffiu.TT{x,y}RAW value. Update the kpffiu.TT{x,y}RON strings with that value, maintaining the proper formatting: |{raw value}|0|Home. There is an experimental script to do the above steps, but you must manually verify that the results look reasonble. Run kpfMeasureTipTiltMirrorRange and it will print out a set of modify commands for you to run (it does not execute them itself). Check the logic and math, the script is experimental! Note that if the script finds a limit which is unexpected (i.e. less range than nominal), it will set up the above keywords to a range 1 arc second smaller than where the limit is. It adds this safety margin to the kpfguide.TIPTILT_{x,y}RANGE keywords, so if you calculate something slightly different than the script, this may be why.","title":"Tip Tilt Performance is Poor"},{"location":"troubleshooting/#detectors","text":"","title":"Detectors"},{"location":"troubleshooting/#kpfexposeexpose-is-not-ready","text":"Symptom : The kpfexpose.EXPOSE keyword is reporting an unexpected state such as reporting \"InProgress\" even though the exposure should have finished or is reporting \"Error\". If kpfexpose.EXPOSE is not ready, it will not allow users to take new exposures which is how this will likely manifest. Problem : One of the detectors may not be in a normal state. Use the EXPLAINNR keyword to determine which detector is blocking kpfexpose.EXPOSE from becoming \"Ready\". For example, if kpfexpose.EXPLAINNR is reporting \"hk:ACQPHASE=wait\", that indicates that the CaHK detector is not in the Ready phase. The detailed solution will depend on which camera and what is causing the blockage. Solution 1 : Reset the Red or Green detector If either the Red or Green camera is the problem as reported by kpfexpose.EXPLAINNR or by the relevant camera's EXPSTATE keyword, the setting the particular camera's EXPOSE keyword to \"Reset\" may resolve things (e.g. modify -s kpfgreen EXPOSE=Reset ). Solution 2 : Abort Ca HK Exposure If the Ca HK detector appears to be the problem (e.g. kpfexpose.EXPLAINNR value is \"hk:ACQPHASE=wait\"), then aborting the exposure in progress may free up the Ca HK detector. To do so run: modify -s kpf_hk EXPOSE=abort Solution 3 : Restart the relevant keyword service or dispatchers If the above has not helped, restarting the service may free things up. Possible services to restart include kpfexpose , kpfgreen , kpfred , kpf_hk . It is suggested that you only restart the service if there is some indication that it is the source of the problem (either from kpfexpose.EXPLAINNR or from the service's EXPSTATE for example).","title":"kpfexpose.EXPOSE is not Ready"},{"location":"troubleshooting/#detector-refuses-to-be-triggered","text":"Symptom : When running an OB, or invoking command line scripts, a particular detector is not set to be triggered even though it is requested. Problem : The detector may be disabled in kpfconfig . The log may contain a line similar to: 2023-05-06 00:22:27,449 WARNING: Green detector is not enabled Solution : The detector has likely been disabled for a reason. Reenabling it should only be done by WMKO staff with knowledge of why it was disabled in the first place.","title":"Detector Refuses to be Triggered"},{"location":"troubleshooting/#detector-fails-to-trigger-without-error","text":"Symptom : The detector is not exposing and not producing output files, but kpfexpose is unaware of the problem and takes exposures as normal triggering all selected cameras. Problem : Something is stuck in the dispatcher code for driving the Archon (this only applies to red and green detectors). Solution : Restart dispatcher 0 on the affected detector: kpf restart kpfgreen0","title":"Detector Fails to Trigger Without Error"},{"location":"troubleshooting/#green-or-red-ccdpower-fails-to-turn-on","text":"Symptom : When trying to power up the detector by setting the CCDPOWER keyword to \u201cOn\u201d, the keyword does not successfully transition to on. The stderr file for the relevant camerad process (e.g. gcamerad.stderr ) contains statements like: (Archon::Interface::archon_cmd) ERROR: Archon controller returned error processing command: POWERON Problem : There is something wrong in the ACF file for the Archon. Solution : Resend the ACF file by either modifying the appropriate ACF keyword or using the kpfSetReadModeNormal or kpfSetReadModeFast scripts.","title":"Green or Red CCDPOWER Fails to turn on"},{"location":"troubleshooting/#ca-hk-detector-stuck","text":"Symptom : The HK detector is stuck in the exposing state. or The kpfexpose.EXPOSE status is stuck and kpfexpose.EXPLAINNR is \"hk:ACQPHASE=wait\". Problem : Some combination of hardware and software is stuck. Solution : Abort the existing HK exposure: modify -s kpf_hk expose=abort (alternatively, the same action is available via the FWWM menu under KPF Troubleshooting Menu -> KPF Trouble Recovery \u2192 Reset Ca HK Detector ). Then restart the kpf_hk service: kpf restart kpf_hk Take test exposures to see if the system has recovered. If the system is still stuck, power cycle the Andor Camera, and the HK Galil on power strip J, ports 1, 2, and 5, then restart kpf_hk again. This can be accomplished in one step using: kpfPowerCycleCaHK (alternatively the same tool is available via the FWWM menu under KPF Troubleshooting Menu -> KPF Trouble Recovery -> Power Cycle Ca HK Detector ). If the detector is still not responsive, check the log files on kpffiuserver . If the kpf_hk.stderr file contains lines like this after a restart of the kpf_hk service: open () failed : No such file or directory Failed to configure camera : init failure , using path = \"/usr/local/etc/andor\" : DRV_VXDNOTINSTALLED Then it means that the USB connection is unhappy for some reason. The recovery is to ask for a reboot of kpffiuserver . This will require restarting the kpffiu service as well.","title":"Ca HK Detector Stuck"},{"location":"troubleshooting/#exposure-meter-in-error-state","text":"Symptom : The exposure meter is in an error state: kpf_expmeter.EXPSTATE=Error Problem : Something in the SBIG CCD control software is unhappy. Solution 1 : First, try resetting the exposure meter detector: modify -s kpf_expmeter EXPOSE=Reset Check the status: gshow -s kpf_expmeter EXPSTATE should become \u201cReady\u201d. Solution 2 : If the above solution fails to recover the system, power cycle the camera on power port L3. Then do kpf restart kpf_expmeter . This is equivalent to kpf restart kpf_expmeter1 (exposure meter camera) and kpf restart kpf_expmeter2 (exposure meter DRP). Sometimes kpf_expmeter2 is stuck in a busy state after a kpf_expmeter1 restart. Both kpf_expmeter1 and kpf_expmeter2 need to be ready before kpfexpose can trigger new exposures. You may need to set the TOP , LEFT , WIDTH , and HEIGHT keywords after restarting the software. The values are: [ kpfeng@kpfserver ] ~ > gshow - s kpf_expmeter LEFT TOP WIDTH HEIGHT LEFT = 1 TOP = 0 WIDTH = 651 HEIGHT = 300 The correct values are checked in testAll , so you can always run that to verify values are ok.","title":"Exposure Meter in Error State"},{"location":"troubleshooting/#l0-file-generation","text":"","title":"L0 File Generation"},{"location":"troubleshooting/#deprecated-l0-files","text":"L0 files are generated by gathering the \u201csub-FITS\u201d files from the Green, Red, CaHK, EM, and guide cameras, processing some of them (EM and guide camera), adding telemetry drawn from KTL keywords and the sub-FITS headers to the new L0 FITS header, and writing the L0 file. This process happens automatically by using keywords to notify a dispatcher that a recent exposure is ready for L0 file creation. If this dispatcher is stopped or dies, it can be restarted with the command kpf restart assemble . If L0 files need to be generated manually (e.g., because the dispatcher stopped or L0 files need to be regenerated), it can be done with the command l0_assemble --outdir path NNNNN MMMMM where path is the directory where the L0 files should be written (e.g., /sdata1701/kpfeng/DATE/L0 ), NNNNN is the first FRAMENO (a header keyword for Green and Red FITS images and an index which is incremented with each exposure; e.g. 33015 ), and MMMMM is the last FRAMENO in a range of files (e.g., 33020 ). The final argument is optional if only one L0 file needs to be generated. L0 files may be deprecated when switching to fast-readout mode. The observers may find broken L1/L2 files, and the L0 files are missing green/red/CaHK components. If L0 files needed to be regenerated, it is better to write to a new directory (e.g., /sdata1701/kpfeng/DATE/new_L0 ), and inform Jeff Mader so he can ingest the new L0 files to Keck Observatory Archive.","title":"Deprecated L0 files"},{"location":"troubleshooting/#agitator","text":"","title":"Agitator"},{"location":"troubleshooting/#agitator-sounds-wrong-or-speed-is-wrong","text":"Symptom : The agitator is not working as expected. This is usually seen in the agitator speed value (see screenshots) or by listening to the sounds. This is a plot of what the kpfmot.AGITSPD keyword value looks like as the agitator is cycled on during exposures. It goes to a negative value of a few thousand during operation. This is an example of a bad agitator speed behavior. It goes positive for one data point, then back to zero. You can listen to the agitator mechanism via the \u201cKPF crypt M5075\u201d camera on the facility camera list (note this is an internal web page at Keck). In normal operation the agitator makes a regular (roughly 1-2 Hz) mechanical oscillation sound. When the bad behavior above occurred it was either silent (note there is background fan noise on that camera) or would make a single mechanical \u201ccachunk\u201d sound, then stop. Problem : The motor is not initialized properly. Solution : Initialize using: modify -s kpfmot agitmod=pos modify -s kpfmot agitini=no This leaves the system in Halt mode. Initialize using: modify -s kpfmot agitmod=pos modify -s kpfmot agitini=yes Note: if the ini command fails with: Error setting agitini: agitini: ERR_STST_COND_TIMEOUT (-5239) StdStage condition did not become true within the time limit try restarting the dispatcher (kpf restart kpfmot) in order to get it to release the thread lock on communications and they to initialize again.","title":"Agitator Sounds Wrong or Speed is Wrong"},{"location":"troubleshooting/#vacuum","text":"","title":"Vacuum"},{"location":"troubleshooting/#vacuum-chamber-vacuum-levels-rising","text":"Symptom : Vacuum levels in the chamber are rising, but the vacuum levels at the pump are falling. These are kpfvac.VCH_HIVAC and kpfvac.VCART_HIVAC keywords respectively. This might manifest as a \u201cvac chamber trouble\u201d alert from kpfmon. Problem : The gate valve between the vacuum chamber and the pump has closed. The gate valve is currently (late 2023) not instrumented and is controlled by compressed air from the facility. As long as facility compressed air is working, the valve is open and the pump should be keeping the vacuum chamber at good vacuum levels. If the gate valve closes, it is presumably because compressed air has failed. Below is a Grafana plot showing that as chamber pressure was rising, vac cart pressure was falling. This is the signature of the gate valve being closed. In this example, the gate valve closed at about 14:12 local time and was opened again around 15:15 local time. Solution :","title":"Vacuum Chamber Vacuum Levels Rising"},{"location":"troubleshooting/#socal","text":"","title":"SoCal"},{"location":"troubleshooting/#enclosure-lid-does-not-move-1","text":"Symptom : Enclosure will not move. It may begin moving, then stop and reverse. Problem : Enclosure motor is hitting an overcurrent limit. To verify this is the problem, log in to the dome controller from kpfeng@kpfserver: ssh socal This connects to the Raspberry Pi controller in the dome enclosure. The username and IP address has configured in the ~/.ssh/config file on kpfserver (you can ssh manually using pi@192.168.23.244 ) and the SSH key for kpfserver has been installed on the Pi, so it should not ask for a password, but if it does, the password in in the usual showpasswords location. View the dome log file in the ~/dome.log and look for errors which indicate the nature of the problem. The ~/grep_for_dome_error script will exclude many of the noisy, not useful lines in the dome.log file and help with examining the log. Solution : If the log file indicates overcurrent on the motors is the issue. Ensure the mechanisms are clear of obstruction and reasonably well balanced (it doesn\u2019t need to be perfect).","title":"Enclosure Lid Does not Move 1"},{"location":"troubleshooting/#enclosure-lid-does-not-move-2","text":"Symptom : Enclosure will not move. It may begin moving, then stop and reverse. Problem : Enclosure motor is not getting current. To verify this is the problem, log in to the dome controller from kpfeng@kpfserver: ssh socal This connects to the Raspberry Pi controller in the dome enclosure. The username and IP address has configured in the ~/.ssh/config file on kpfserver (you can ssh manually using pi@192.168.23.244 ) and the SSH key for kpfserver has been installed on the Pi, so it should not ask for a password, but if it does, the password in in the usual showpasswords location. View the dome log file in the ~/dome.log and look for errors similar to: 2024 - 07 - 09 19 : 09 : 37 , 752 WARNING Operation timed out ( 35.0 secs ), max measured motor current : 0.0 A . The ~/grep_for_dome_error script will exclude many of the noisy, not useful lines in the dome.log file and help with examining the log. Solution : Reboot the controller (raspberry pi): sudo reboot and restart the kpfsocal3 dispatcher: kpf restart kpfsocal3 . Multiple reboots may be required.","title":"Enclosure Lid Does not Move 2"},{"location":"scripts/AddTarget/","text":"AddTarget Bases: KPFFunction Add the specified target to the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to add. ra ( str ) \u2013 The right ascension of the target. dec ( str ) \u2013 The declination of the target. frame ( str ) \u2013 The frame (e.g. J2000) DRA ( float ) \u2013 The RA differential tracking rate (as per the keck star list documentation) [optional]. DDEC ( float ) \u2013 The DEC differential tracking rate (as per the keck star list documentation) [optional]. options ( str ) \u2013 The option string as documented in the Magiq API. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/AddTarget.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class AddTarget ( KPFFunction ): '''Add the specified target to the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to add. ra (str): The right ascension of the target. dec (str): The declination of the target. frame (str): The frame (e.g. J2000) DRA (float): The RA differential tracking rate (as per the keck star list documentation) [optional]. DDEC (float): The DEC differential tracking rate (as per the keck star list documentation) [optional]. options (str): The option string as documented in the Magiq API. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): # target=Target&ra=12:34:56&dec=11:22:33&frame=2000&options=a=1 b=2 c=3 params = { 'target' : args . get ( 'TargetName' ), 'ra' : args . get ( 'RA' ), 'dec' : args . get ( 'Dec' ), 'frame' : '2000' if args . get ( 'Equinox' ) == 'J2000' else args . get ( 'Equinox' ), 'options' : '' , } if abs ( args . get ( 'DRA' , 0 )) > 0.001 : params [ 'options' ] += f \"DRA= { args . get ( 'DRA' ) } \" if abs ( args . get ( 'DDEC' , 0 )) > 0.001 : params [ 'options' ] += f \"DRA= { args . get ( 'DDEC' ) } \" log . info ( f 'Running Magiq addTarget command { params . get ( \"target\" ) } ' ) result = magiq_server_command ( 'addTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass","title":"AddTarget"},{"location":"scripts/AddTarget/#addtarget","text":"Bases: KPFFunction Add the specified target to the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to add. ra ( str ) \u2013 The right ascension of the target. dec ( str ) \u2013 The declination of the target. frame ( str ) \u2013 The frame (e.g. J2000) DRA ( float ) \u2013 The RA differential tracking rate (as per the keck star list documentation) [optional]. DDEC ( float ) \u2013 The DEC differential tracking rate (as per the keck star list documentation) [optional]. options ( str ) \u2013 The option string as documented in the Magiq API. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/AddTarget.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class AddTarget ( KPFFunction ): '''Add the specified target to the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to add. ra (str): The right ascension of the target. dec (str): The declination of the target. frame (str): The frame (e.g. J2000) DRA (float): The RA differential tracking rate (as per the keck star list documentation) [optional]. DDEC (float): The DEC differential tracking rate (as per the keck star list documentation) [optional]. options (str): The option string as documented in the Magiq API. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): # target=Target&ra=12:34:56&dec=11:22:33&frame=2000&options=a=1 b=2 c=3 params = { 'target' : args . get ( 'TargetName' ), 'ra' : args . get ( 'RA' ), 'dec' : args . get ( 'Dec' ), 'frame' : '2000' if args . get ( 'Equinox' ) == 'J2000' else args . get ( 'Equinox' ), 'options' : '' , } if abs ( args . get ( 'DRA' , 0 )) > 0.001 : params [ 'options' ] += f \"DRA= { args . get ( 'DRA' ) } \" if abs ( args . get ( 'DDEC' , 0 )) > 0.001 : params [ 'options' ] += f \"DRA= { args . get ( 'DDEC' ) } \" log . info ( f 'Running Magiq addTarget command { params . get ( \"target\" ) } ' ) result = magiq_server_command ( 'addTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass","title":"AddTarget"},{"location":"scripts/AnalyzeGridSearch/","text":"AnalyzeGridSearch Bases: KPFTranslatorFunction Description Tool to analyze engineering data taken by the engineering.GridSearch or engineering.Run2DGridSearch scripts. Parameters None Source code in kpf/engineering/analysis/AnalyzeGridSearch.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 class AnalyzeGridSearch ( KPFTranslatorFunction ): '''# Description Tool to analyze engineering data taken by the `engineering.GridSearch` or `engineering.Run2DGridSearch` scripts. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for logfile in args . get ( 'logfile' ): analyze_grid_search ( logfile , fiber = args . get ( 'fiber' ), model_seeing = args . get ( 'seeing' ), xfit = args . get ( 'xfit' ), yfit = args . get ( 'yfit' ), generate_cred2 = args . get ( 'cred2' ), ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfile' , type = str , nargs = '*' , help = \"The logfile or files of the grid search runs to analyze\" ) ## add flags parser . add_argument ( \"--cred2\" , dest = \"cred2\" , default = False , action = \"store_true\" , help = \"Generate CRED2 plots? (default = False)\" ) ## add options parser . add_argument ( \"--fiber\" , dest = \"fiber\" , type = str , default = 'Science' , help = \"The fiber being examined (Science, Sky, or EMSky).\" ) parser . add_argument ( \"--seeing\" , dest = \"seeing\" , type = str , choices = [ '0.5' , '0.7' , '0.9' ], default = '0.7' , help = \"The seeing model to overlay on the fiber coupling plot.\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"AnalyzeGridSearch"},{"location":"scripts/AnalyzeGridSearch/#analyzegridsearch","text":"Bases: KPFTranslatorFunction","title":"AnalyzeGridSearch"},{"location":"scripts/AnalyzeGridSearch/#kpf.engineering.analysis.AnalyzeGridSearch.AnalyzeGridSearch--description","text":"Tool to analyze engineering data taken by the engineering.GridSearch or engineering.Run2DGridSearch scripts.","title":"Description"},{"location":"scripts/AnalyzeGridSearch/#kpf.engineering.analysis.AnalyzeGridSearch.AnalyzeGridSearch--parameters","text":"None Source code in kpf/engineering/analysis/AnalyzeGridSearch.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 class AnalyzeGridSearch ( KPFTranslatorFunction ): '''# Description Tool to analyze engineering data taken by the `engineering.GridSearch` or `engineering.Run2DGridSearch` scripts. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): for logfile in args . get ( 'logfile' ): analyze_grid_search ( logfile , fiber = args . get ( 'fiber' ), model_seeing = args . get ( 'seeing' ), xfit = args . get ( 'xfit' ), yfit = args . get ( 'yfit' ), generate_cred2 = args . get ( 'cred2' ), ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfile' , type = str , nargs = '*' , help = \"The logfile or files of the grid search runs to analyze\" ) ## add flags parser . add_argument ( \"--cred2\" , dest = \"cred2\" , default = False , action = \"store_true\" , help = \"Generate CRED2 plots? (default = False)\" ) ## add options parser . add_argument ( \"--fiber\" , dest = \"fiber\" , type = str , default = 'Science' , help = \"The fiber being examined (Science, Sky, or EMSky).\" ) parser . add_argument ( \"--seeing\" , dest = \"seeing\" , type = str , choices = [ '0.5' , '0.7' , '0.9' ], default = '0.7' , help = \"The seeing model to overlay on the fiber coupling plot.\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/AnalyzeTipTiltPerformance/","text":"AnalyzeTipTiltPerformance Bases: KPFTranslatorFunction Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. Parameters None Source code in kpf/engineering/analysis/AnalyzeTipTiltPerformance.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 class AnalyzeTipTiltPerformance ( KPFTranslatorFunction ): '''# Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): viewer_command = find_viewer_command ( args ) for file in args . get ( 'files' ): file = Path ( file ) . expanduser () if file . exists () is False : log . error ( f \"Could not find file { args . get ( 'file' ) } \" ) plotfile = Path ( str ( file . name ) . replace ( '.fits' , '.png' )) plot_tiptilt_stats ( file , plotfile = plotfile , start = args . get ( 'start' , None ), end = args . get ( 'end' , None ), snr = args . get ( 'snr' , None ), minarea = args . get ( 'minarea' , None ), deblend_nthresh = args . get ( 'deblend_nthresh' , None ), deblend_cont = args . get ( 'deblend_cont' , None ), ) if viewer_command is not None : log . info ( f \"Opening { plotfile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { plotfile } \" ]) if args . get ( 'gif' ) is True : giffile = Path ( str ( file . name ) . replace ( '.fits' , '.gif' )) generate_cube_gif ( file , giffile ) if viewer_command is not None : log . info ( f \"Opening { giffile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { giffile } \" ]) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , type = str , nargs = '*' , help = \"The FITS files to analyze\" ) parser . add_argument ( \"-g\" , \"--gif\" , dest = \"gif\" , default = False , action = \"store_true\" , help = \"Generate the animated GIF of frames (computationally expensive)\" ) parser . add_argument ( \"--view\" , dest = \"view\" , default = False , action = \"store_true\" , help = \"Open a viewer once the file is generated\" ) parser . add_argument ( \"--start\" , dest = \"start\" , type = float , help = \"Zoom the plot in to this start time (in seconds).\" ) parser . add_argument ( \"--end\" , dest = \"end\" , type = float , help = \"Zoom the plot in to this end time (in seconds).\" ) parser . add_argument ( \"--snr\" , dest = \"snr\" , type = float , help = \"Run source extractor again with this SNR threshold\" ) parser . add_argument ( \"--minarea\" , dest = \"minarea\" , type = float , help = \"Run source extractor again with this minarea parameter\" ) parser . add_argument ( \"--deblend_nthresh\" , dest = \"deblend_nthresh\" , type = float , help = \"Run source extractor again with this deblend_nthresh\" ) parser . add_argument ( \"--deblend_cont\" , dest = \"deblend_cont\" , type = float , help = \"Run source extractor again with this deblend_cont parameter\" ) return super () . add_cmdline_args ( parser , cfg )","title":"AnalyzeTipTiltPerformance"},{"location":"scripts/AnalyzeTipTiltPerformance/#analyzetiptiltperformance","text":"Bases: KPFTranslatorFunction","title":"AnalyzeTipTiltPerformance"},{"location":"scripts/AnalyzeTipTiltPerformance/#kpf.engineering.analysis.AnalyzeTipTiltPerformance.AnalyzeTipTiltPerformance--description","text":"Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file.","title":"Description"},{"location":"scripts/AnalyzeTipTiltPerformance/#kpf.engineering.analysis.AnalyzeTipTiltPerformance.AnalyzeTipTiltPerformance--parameters","text":"None Source code in kpf/engineering/analysis/AnalyzeTipTiltPerformance.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 class AnalyzeTipTiltPerformance ( KPFTranslatorFunction ): '''# Description Generates a plot analyzing tip tilt performance for a single observation. Can take as input either an L0 file, in which case it will strip out the guider extension for use, or a guider \"cube\" file. # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): viewer_command = find_viewer_command ( args ) for file in args . get ( 'files' ): file = Path ( file ) . expanduser () if file . exists () is False : log . error ( f \"Could not find file { args . get ( 'file' ) } \" ) plotfile = Path ( str ( file . name ) . replace ( '.fits' , '.png' )) plot_tiptilt_stats ( file , plotfile = plotfile , start = args . get ( 'start' , None ), end = args . get ( 'end' , None ), snr = args . get ( 'snr' , None ), minarea = args . get ( 'minarea' , None ), deblend_nthresh = args . get ( 'deblend_nthresh' , None ), deblend_cont = args . get ( 'deblend_cont' , None ), ) if viewer_command is not None : log . info ( f \"Opening { plotfile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { plotfile } \" ]) if args . get ( 'gif' ) is True : giffile = Path ( str ( file . name ) . replace ( '.fits' , '.gif' )) generate_cube_gif ( file , giffile ) if viewer_command is not None : log . info ( f \"Opening { giffile } using { viewer_command } \" ) proc = subprocess . Popen ([ viewer_command , f \" { giffile } \" ]) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'files' , type = str , nargs = '*' , help = \"The FITS files to analyze\" ) parser . add_argument ( \"-g\" , \"--gif\" , dest = \"gif\" , default = False , action = \"store_true\" , help = \"Generate the animated GIF of frames (computationally expensive)\" ) parser . add_argument ( \"--view\" , dest = \"view\" , default = False , action = \"store_true\" , help = \"Open a viewer once the file is generated\" ) parser . add_argument ( \"--start\" , dest = \"start\" , type = float , help = \"Zoom the plot in to this start time (in seconds).\" ) parser . add_argument ( \"--end\" , dest = \"end\" , type = float , help = \"Zoom the plot in to this end time (in seconds).\" ) parser . add_argument ( \"--snr\" , dest = \"snr\" , type = float , help = \"Run source extractor again with this SNR threshold\" ) parser . add_argument ( \"--minarea\" , dest = \"minarea\" , type = float , help = \"Run source extractor again with this minarea parameter\" ) parser . add_argument ( \"--deblend_nthresh\" , dest = \"deblend_nthresh\" , type = float , help = \"Run source extractor again with this deblend_nthresh\" ) parser . add_argument ( \"--deblend_cont\" , dest = \"deblend_cont\" , type = float , help = \"Run source extractor again with this deblend_cont parameter\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/BuildCalOB/","text":"BuildCalOB Bases: KPFFunction From a set of standard prescriptions, build the described calibration OB. Given a list of input strings, parse them in to variations of the standard calibrations and create an OB for them. The input string format is [CalSource],[Object],[nExp],[keywords] . The first 3 entries are required while the keywords section is optional. Any unspecified values default to match the same CalSource entry in the example OB file in this repo at kpf/ObservingBlocks/exampleOBs/Calibration.yaml . For example, and input of EtalonFiber,slewcal,5 will generate an OB which takes 5 etalon frames with the object name of \"slewcal\". No keywords are provided, so all other elements of the OB are the default values (e.g. the exposure time and ND filters). The keywords can be used to modify those default values in the OB. For example, if the input is: [CalSource],[Object],[nExp],[keywords],IntensityMonitor=True then the resulting OB will have the IntensityMonitor value set to True rather than the default of False and [CalSource],[Object],[nExp],[keywords],ExpTime=30 will result in an OB with 30 second exposure times instead of the default of 40 seconds. Multiple inputs can be given to create multi-calibration OBs, either as a list in python or on the command line. For example: kpfdo BuildCalOB Dark,autocal-dark,1,ExpTime=1200 EtalonFiber,autocal-etalon-all-midday,3,IntensityMonitor=True BrdbandFiber,autocal-flat-all,95,IntensityMonitor=True will generate an OB with three calibrations: a 1200 second dark, 3 Etalon frames, and 95 flat field frames. Parameters: calinputs ( list of strings ) \u2013 Input strings as described above. estimate ( bool ) \u2013 Generate the OB, run the EstimateOBDuration tool, and print the results to screen. save ( string ) \u2013 Save resulting OB to the specified file. overwrite ( bool ) \u2013 Overwrite output file if it exists? execute ( bool ) \u2013 Execute the resulting OB? Functions Called: EstimateOBDuration RunOB Source code in kpf/utils/BuildCalOB.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class BuildCalOB ( KPFFunction ): '''From a set of standard prescriptions, build the described calibration OB. Given a list of input strings, parse them in to variations of the standard calibrations and create an OB for them. The input string format is `[CalSource],[Object],[nExp],[keywords]`. The first 3 entries are required while the keywords section is optional. Any unspecified values default to match the same CalSource entry in the example OB file in this repo at `kpf/ObservingBlocks/exampleOBs/Calibration.yaml`. For example, and input of `EtalonFiber,slewcal,5` will generate an OB which takes 5 etalon frames with the object name of \"slewcal\". No keywords are provided, so all other elements of the OB are the default values (e.g. the exposure time and ND filters). The keywords can be used to modify those default values in the OB. For example, if the input is: `[CalSource],[Object],[nExp],[keywords],IntensityMonitor=True` then the resulting OB will have the `IntensityMonitor` value set to True rather than the default of False and `[CalSource],[Object],[nExp],[keywords],ExpTime=30` will result in an OB with 30 second exposure times instead of the default of 40 seconds. Multiple inputs can be given to create multi-calibration OBs, either as a list in python or on the command line. For example: `kpfdo BuildCalOB Dark,autocal-dark,1,ExpTime=1200 EtalonFiber,autocal-etalon-all-midday,3,IntensityMonitor=True BrdbandFiber,autocal-flat-all,95,IntensityMonitor=True` will generate an OB with three calibrations: a 1200 second dark, 3 Etalon frames, and 95 flat field frames. Args: calinputs (list of strings): Input strings as described above. estimate (bool): Generate the OB, run the `EstimateOBDuration` tool, and print the results to screen. save (string): Save resulting OB to the specified file. overwrite (bool): Overwrite output file if it exists? execute (bool): Execute the resulting OB? Functions Called: - `EstimateOBDuration` - `RunOB` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Build dict of example calibrations example_cal_file = Path ( __file__ ) . parent . parent / 'ObservingBlocks' / 'exampleOBs' / 'Calibrations.yaml' if example_cal_file . exists () != True : print ( f 'Failed to open { example_cal_file : s } ' ) return example_OB = ObservingBlock ( example_cal_file ) example_cals = {} for cal in example_OB . Calibrations : if cal . CalSource not in example_cals . keys (): example_cals [ str ( cal . CalSource )] = cal # Build fresh OB OB = ObservingBlock ({}) for calinput in args . get ( 'calinputs' ): calspec = calinput . split ( ',' ) # [CalSource],[Object],[nExp],**kwargs example = example_cals . get ( calspec [ 0 ], None ) if example is None : print ( f 'Unable to find example calibrations for { calspec [ 0 ] } ' ) else : cal = copy . deepcopy ( example ) cal . set ( 'Object' , calspec [ 1 ]) cal . set ( 'nExp' , int ( calspec [ 2 ])) if len ( calspec ) > 3 : kwargs = calspec [ 3 :] for kwarg in kwargs : key , value = kwarg . split ( '=' ) if key in [ 'Exptime' ]: cal . set ( key , float ( value )) elif key in [ 'TriggerCaHK' , 'TriggerGreen' , 'TriggerRed' , 'IntensityMonitor' , 'OpenScienceShutter' , 'OpenSkyShutter' , 'TakeSimulCal' ]: cal . set ( key , bool ( value )) else : cal . set ( key , value ) OB . Calibrations . append ( cal ) if args . get ( 'save' , '' ) not in [ '' , None ]: OB . write_to ( args . get ( 'save' ), overwrite = args . get ( 'overwrite' , False )) if args . get ( 'estimate' , False ) or args . get ( 'execute' , False ): cal_strings = [ str ( cal ) for cal in OB . Calibrations ] cal_string = ',' . join ( cal_strings ) print ( f \"# { cal_string } \" ) duration = EstimateOBDuration . execute ({ 'verbose' : True }, OB = OB ) if args . get ( 'execute' , False ): RunOB . execute ({}, OB = OB ) return OB @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'calinputs' , nargs = '*' , help = \"Calibrations to take in the form \" ) parser . add_argument ( \"-v\" , \"-t\" , \"--time\" , \"--estimate\" , dest = \"estimate\" , default = False , action = \"store_true\" , help = \"Estimate the execution time for this OB?\" ) parser . add_argument ( \"-s\" , \"--save\" , dest = \"save\" , type = str , default = '' , help = \"Save resulting OB to the specified file.\" ) parser . add_argument ( \"-o\" , \"--overwrite\" , dest = \"overwrite\" , default = False , action = \"store_true\" , help = \"Overwrite output file if it exists?\" ) parser . add_argument ( \"--execute\" , dest = \"execute\" , default = False , action = \"store_true\" , help = \"Execute the resulting OB?\" ) return super () . add_cmdline_args ( parser )","title":"BuildCalOB"},{"location":"scripts/BuildCalOB/#buildcalob","text":"Bases: KPFFunction From a set of standard prescriptions, build the described calibration OB. Given a list of input strings, parse them in to variations of the standard calibrations and create an OB for them. The input string format is [CalSource],[Object],[nExp],[keywords] . The first 3 entries are required while the keywords section is optional. Any unspecified values default to match the same CalSource entry in the example OB file in this repo at kpf/ObservingBlocks/exampleOBs/Calibration.yaml . For example, and input of EtalonFiber,slewcal,5 will generate an OB which takes 5 etalon frames with the object name of \"slewcal\". No keywords are provided, so all other elements of the OB are the default values (e.g. the exposure time and ND filters). The keywords can be used to modify those default values in the OB. For example, if the input is: [CalSource],[Object],[nExp],[keywords],IntensityMonitor=True then the resulting OB will have the IntensityMonitor value set to True rather than the default of False and [CalSource],[Object],[nExp],[keywords],ExpTime=30 will result in an OB with 30 second exposure times instead of the default of 40 seconds. Multiple inputs can be given to create multi-calibration OBs, either as a list in python or on the command line. For example: kpfdo BuildCalOB Dark,autocal-dark,1,ExpTime=1200 EtalonFiber,autocal-etalon-all-midday,3,IntensityMonitor=True BrdbandFiber,autocal-flat-all,95,IntensityMonitor=True will generate an OB with three calibrations: a 1200 second dark, 3 Etalon frames, and 95 flat field frames. Parameters: calinputs ( list of strings ) \u2013 Input strings as described above. estimate ( bool ) \u2013 Generate the OB, run the EstimateOBDuration tool, and print the results to screen. save ( string ) \u2013 Save resulting OB to the specified file. overwrite ( bool ) \u2013 Overwrite output file if it exists? execute ( bool ) \u2013 Execute the resulting OB? Functions Called: EstimateOBDuration RunOB Source code in kpf/utils/BuildCalOB.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class BuildCalOB ( KPFFunction ): '''From a set of standard prescriptions, build the described calibration OB. Given a list of input strings, parse them in to variations of the standard calibrations and create an OB for them. The input string format is `[CalSource],[Object],[nExp],[keywords]`. The first 3 entries are required while the keywords section is optional. Any unspecified values default to match the same CalSource entry in the example OB file in this repo at `kpf/ObservingBlocks/exampleOBs/Calibration.yaml`. For example, and input of `EtalonFiber,slewcal,5` will generate an OB which takes 5 etalon frames with the object name of \"slewcal\". No keywords are provided, so all other elements of the OB are the default values (e.g. the exposure time and ND filters). The keywords can be used to modify those default values in the OB. For example, if the input is: `[CalSource],[Object],[nExp],[keywords],IntensityMonitor=True` then the resulting OB will have the `IntensityMonitor` value set to True rather than the default of False and `[CalSource],[Object],[nExp],[keywords],ExpTime=30` will result in an OB with 30 second exposure times instead of the default of 40 seconds. Multiple inputs can be given to create multi-calibration OBs, either as a list in python or on the command line. For example: `kpfdo BuildCalOB Dark,autocal-dark,1,ExpTime=1200 EtalonFiber,autocal-etalon-all-midday,3,IntensityMonitor=True BrdbandFiber,autocal-flat-all,95,IntensityMonitor=True` will generate an OB with three calibrations: a 1200 second dark, 3 Etalon frames, and 95 flat field frames. Args: calinputs (list of strings): Input strings as described above. estimate (bool): Generate the OB, run the `EstimateOBDuration` tool, and print the results to screen. save (string): Save resulting OB to the specified file. overwrite (bool): Overwrite output file if it exists? execute (bool): Execute the resulting OB? Functions Called: - `EstimateOBDuration` - `RunOB` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Build dict of example calibrations example_cal_file = Path ( __file__ ) . parent . parent / 'ObservingBlocks' / 'exampleOBs' / 'Calibrations.yaml' if example_cal_file . exists () != True : print ( f 'Failed to open { example_cal_file : s } ' ) return example_OB = ObservingBlock ( example_cal_file ) example_cals = {} for cal in example_OB . Calibrations : if cal . CalSource not in example_cals . keys (): example_cals [ str ( cal . CalSource )] = cal # Build fresh OB OB = ObservingBlock ({}) for calinput in args . get ( 'calinputs' ): calspec = calinput . split ( ',' ) # [CalSource],[Object],[nExp],**kwargs example = example_cals . get ( calspec [ 0 ], None ) if example is None : print ( f 'Unable to find example calibrations for { calspec [ 0 ] } ' ) else : cal = copy . deepcopy ( example ) cal . set ( 'Object' , calspec [ 1 ]) cal . set ( 'nExp' , int ( calspec [ 2 ])) if len ( calspec ) > 3 : kwargs = calspec [ 3 :] for kwarg in kwargs : key , value = kwarg . split ( '=' ) if key in [ 'Exptime' ]: cal . set ( key , float ( value )) elif key in [ 'TriggerCaHK' , 'TriggerGreen' , 'TriggerRed' , 'IntensityMonitor' , 'OpenScienceShutter' , 'OpenSkyShutter' , 'TakeSimulCal' ]: cal . set ( key , bool ( value )) else : cal . set ( key , value ) OB . Calibrations . append ( cal ) if args . get ( 'save' , '' ) not in [ '' , None ]: OB . write_to ( args . get ( 'save' ), overwrite = args . get ( 'overwrite' , False )) if args . get ( 'estimate' , False ) or args . get ( 'execute' , False ): cal_strings = [ str ( cal ) for cal in OB . Calibrations ] cal_string = ',' . join ( cal_strings ) print ( f \"# { cal_string } \" ) duration = EstimateOBDuration . execute ({ 'verbose' : True }, OB = OB ) if args . get ( 'execute' , False ): RunOB . execute ({}, OB = OB ) return OB @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'calinputs' , nargs = '*' , help = \"Calibrations to take in the form \" ) parser . add_argument ( \"-v\" , \"-t\" , \"--time\" , \"--estimate\" , dest = \"estimate\" , default = False , action = \"store_true\" , help = \"Estimate the execution time for this OB?\" ) parser . add_argument ( \"-s\" , \"--save\" , dest = \"save\" , type = str , default = '' , help = \"Save resulting OB to the specified file.\" ) parser . add_argument ( \"-o\" , \"--overwrite\" , dest = \"overwrite\" , default = False , action = \"store_true\" , help = \"Overwrite output file if it exists?\" ) parser . add_argument ( \"--execute\" , dest = \"execute\" , default = False , action = \"store_true\" , help = \"Execute the resulting OB?\" ) return super () . add_cmdline_args ( parser )","title":"BuildCalOB"},{"location":"scripts/BuildMasterBias/","text":"BuildMasterBias Bases: KPFFunction Combine a set of bias files to make a master bias. Parameters: files ( list ) \u2013 A list of files to combine. output ( str ) \u2013 The output combined filename to write. KTL Keywords Used: kpf_expmeter.BIAS_FILE Source code in kpf/expmeter/BuildMasterBias.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BuildMasterBias ( KPFFunction ): '''Combine a set of bias files to make a master bias. Args: files (list): A list of files to combine. output (str): The output combined filename to write. KTL Keywords Used: - `kpf_expmeter.BIAS_FILE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'files' , allowed_types = [ list ]) @classmethod def perform ( cls , args ): biasfiles = [ Path ( biasfile ) for biasfile in args . get ( 'files' )] log . debug ( f \"Combining { len ( biasfiles ) } bias frames:\" ) biases = [] timestamps = [] for biasfile in biasfiles : log . debug ( f \" { biasfile . name } \" ) this_bias = CCDData . read ( biasfile , unit = \"adu\" ) biases . append ( this_bias ) timestamps . append ( this_bias [ 0 ] . header . get ( 'DATE-BEG' )) combiner = ccdproc . Combiner ( biases ) combiner . sigma_clipping ( low_thresh = 5 , high_thresh = 5 ) combined_average = combiner . average_combine () for i , timestamp in enumerate ( timestamps ): combined_average [ 0 ] . header [ f 'DATEBEG { i : 02d } ' ] = ( timestamp , 'DATE-BEG of file {i:02d} ' ) utnow = datetime . utcnow () combined_average [ 0 ] . header [ 'DATEMADE' ] = ( utnow . isoformat (), 'UT timestamp of file creation' ) if args . get ( 'output' , None ) not in [ None , '' ]: outputfile = Path ( args . get ( 'output' )) . expanduser () else : match_fn = re . match ( '([\\w\\d_]+)(\\d {6} )\\.(\\d {3} )\\.fits' , biasfiles [ 0 ] . name ) if match_fn is not None : frameno = match_fn . group ( 2 ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { frameno } .fits' ) else : now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { now_str } .fits' ) log . info ( f \"Writing { outputfile } \" ) combined_average . write ( outputfile , overwrite = True ) if args . get ( 'update' , False ) is True : bias_file = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) bias_file . write ( f \" { outputfile } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'files' , nargs = '*' , help = \"The files to combine\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file?\" ) return super () . add_cmdline_args ( parser )","title":"BuildMasterBias"},{"location":"scripts/BuildMasterBias/#buildmasterbias","text":"Bases: KPFFunction Combine a set of bias files to make a master bias. Parameters: files ( list ) \u2013 A list of files to combine. output ( str ) \u2013 The output combined filename to write. KTL Keywords Used: kpf_expmeter.BIAS_FILE Source code in kpf/expmeter/BuildMasterBias.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BuildMasterBias ( KPFFunction ): '''Combine a set of bias files to make a master bias. Args: files (list): A list of files to combine. output (str): The output combined filename to write. KTL Keywords Used: - `kpf_expmeter.BIAS_FILE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'files' , allowed_types = [ list ]) @classmethod def perform ( cls , args ): biasfiles = [ Path ( biasfile ) for biasfile in args . get ( 'files' )] log . debug ( f \"Combining { len ( biasfiles ) } bias frames:\" ) biases = [] timestamps = [] for biasfile in biasfiles : log . debug ( f \" { biasfile . name } \" ) this_bias = CCDData . read ( biasfile , unit = \"adu\" ) biases . append ( this_bias ) timestamps . append ( this_bias [ 0 ] . header . get ( 'DATE-BEG' )) combiner = ccdproc . Combiner ( biases ) combiner . sigma_clipping ( low_thresh = 5 , high_thresh = 5 ) combined_average = combiner . average_combine () for i , timestamp in enumerate ( timestamps ): combined_average [ 0 ] . header [ f 'DATEBEG { i : 02d } ' ] = ( timestamp , 'DATE-BEG of file {i:02d} ' ) utnow = datetime . utcnow () combined_average [ 0 ] . header [ 'DATEMADE' ] = ( utnow . isoformat (), 'UT timestamp of file creation' ) if args . get ( 'output' , None ) not in [ None , '' ]: outputfile = Path ( args . get ( 'output' )) . expanduser () else : match_fn = re . match ( '([\\w\\d_]+)(\\d {6} )\\.(\\d {3} )\\.fits' , biasfiles [ 0 ] . name ) if match_fn is not None : frameno = match_fn . group ( 2 ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { frameno } .fits' ) else : now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) outputfile = Path ( f '/s/sdata1701/ExpMeterMasterFiles/MasterBias_ { now_str } .fits' ) log . info ( f \"Writing { outputfile } \" ) combined_average . write ( outputfile , overwrite = True ) if args . get ( 'update' , False ) is True : bias_file = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) bias_file . write ( f \" { outputfile } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'files' , nargs = '*' , help = \"The files to combine\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file?\" ) return super () . add_cmdline_args ( parser )","title":"BuildMasterBias"},{"location":"scripts/CalLampPower/","text":"CalLampPower Bases: KPFFunction Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate. Parameters: lamp ( str ) \u2013 Name of the lamp to control. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power ( str ) \u2013 Destination state for lamp power. Allowed Values: \"on\" or \"off\". KTL Keywords Used: kpflamps.BRDBANDFIBER kpflamps.U_GOLD kpflamps.U_DAILY kpflamps.TH_DAILY kpflamps.TH_GOLD kpflamps.FF_FIBER kpflamps.EXPMLED kpflamps.HKLED kpflamps.SCILED kpflamps.SKYLED Source code in kpf/calbench/CalLampPower.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CalLampPower ( KPFFunction ): '''Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. Args: lamp (str): Name of the lamp to control. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power (str): Destination state for lamp power. Allowed Values: \"on\" or \"off\". KTL Keywords Used: - `kpflamps.BRDBANDFIBER` - `kpflamps.U_GOLD` - `kpflamps.U_DAILY` - `kpflamps.TH_DAILY` - `kpflamps.TH_GOLD` - `kpflamps.FF_FIBER` - `kpflamps.EXPMLED` - `kpflamps.HKLED` - `kpflamps.SCILED` - `kpflamps.SKYLED` ''' @classmethod def pre_condition ( cls , args ): # Check lamp name lamp = standardize_lamp_name ( args . get ( 'lamp' , None )) if lamp is None : msg = f \"Could not standardize lamp name { args . get ( 'lamp' ) } \" raise FailedPreCondition ( msg ) # Check power check_input ( args , 'power' , allowed_values = [ 'on' , 'off' ]) @classmethod def perform ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) log . debug ( f \"Turning { pwr } { lamp } \" ) kpflamps = ktl . cache ( 'kpflamps' ) kpflamps [ lamp ] . write ( pwr ) @classmethod def post_condition ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) timeout = cfg . getfloat ( 'times' , 'lamp_timeout' , fallback = 1 ) success = ktl . waitFor ( f \"($kpflamps. { lamp } == { pwr } )\" , timeout = timeout ) if success is not True : kpflamps = ktl . cache ( 'kpflamps' ) raise FailedPostCondition ( kpflamps [ lamp ], pwr ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' , 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ], help = 'Which lamp to control?' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser )","title":"CalLampPower"},{"location":"scripts/CalLampPower/#callamppower","text":"Bases: KPFFunction Powers off one of the cal lamps via the kpflamps keyword service. Uses the lamp names from the OCTAGON when appropriate. Parameters: lamp ( str ) \u2013 Name of the lamp to control. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power ( str ) \u2013 Destination state for lamp power. Allowed Values: \"on\" or \"off\". KTL Keywords Used: kpflamps.BRDBANDFIBER kpflamps.U_GOLD kpflamps.U_DAILY kpflamps.TH_DAILY kpflamps.TH_GOLD kpflamps.FF_FIBER kpflamps.EXPMLED kpflamps.HKLED kpflamps.SCILED kpflamps.SKYLED Source code in kpf/calbench/CalLampPower.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class CalLampPower ( KPFFunction ): '''Powers off one of the cal lamps via the `kpflamps` keyword service. Uses the lamp names from the OCTAGON when appropriate. Args: lamp (str): Name of the lamp to control. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat, ExpMeterLED, CaHKLED, SciLED, SkyLED power (str): Destination state for lamp power. Allowed Values: \"on\" or \"off\". KTL Keywords Used: - `kpflamps.BRDBANDFIBER` - `kpflamps.U_GOLD` - `kpflamps.U_DAILY` - `kpflamps.TH_DAILY` - `kpflamps.TH_GOLD` - `kpflamps.FF_FIBER` - `kpflamps.EXPMLED` - `kpflamps.HKLED` - `kpflamps.SCILED` - `kpflamps.SKYLED` ''' @classmethod def pre_condition ( cls , args ): # Check lamp name lamp = standardize_lamp_name ( args . get ( 'lamp' , None )) if lamp is None : msg = f \"Could not standardize lamp name { args . get ( 'lamp' ) } \" raise FailedPreCondition ( msg ) # Check power check_input ( args , 'power' , allowed_values = [ 'on' , 'off' ]) @classmethod def perform ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) log . debug ( f \"Turning { pwr } { lamp } \" ) kpflamps = ktl . cache ( 'kpflamps' ) kpflamps [ lamp ] . write ( pwr ) @classmethod def post_condition ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'lamp' )) pwr = args . get ( 'power' ) timeout = cfg . getfloat ( 'times' , 'lamp_timeout' , fallback = 1 ) success = ktl . waitFor ( f \"($kpflamps. { lamp } == { pwr } )\" , timeout = timeout ) if success is not True : kpflamps = ktl . cache ( 'kpflamps' ) raise FailedPostCondition ( kpflamps [ lamp ], pwr ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' , 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ], help = 'Which lamp to control?' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser )","title":"CalLampPower"},{"location":"scripts/CheckAllowScheduledCals/","text":"CheckAllowScheduledCals Bases: KPFFunction Script to check if ALLOWSCHEDULEDCALS is yes and to send an email reminder if it is no. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS Source code in kpf/utils/CheckAllowScheduledCals.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CheckAllowScheduledCals ( KPFFunction ): '''Script to check if ALLOWSCHEDULEDCALS is yes and to send an email reminder if it is no. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read () == 'Yes' : print ( 'ALLOWSCHEDULEDCALS is \"Yes\"' ) else : print ( 'WARNING: ALLOWSCHEDULEDCALS is not \"Yes\"' ) try : msg = [ f 'KPF ALLOWSCHEDULEDCALS is not \"Yes\"' , f '' , f 'End of Night script may not have been run properly' , ] SendEmail . execute ({ 'Subject' : 'KPF ALLOWSCHEDULEDCALS is not \"Yes\"' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , argsKPFFunction ): pass","title":"CheckAllowScheduledCals"},{"location":"scripts/CheckAllowScheduledCals/#checkallowscheduledcals","text":"Bases: KPFFunction Script to check if ALLOWSCHEDULEDCALS is yes and to send an email reminder if it is no. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS Source code in kpf/utils/CheckAllowScheduledCals.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CheckAllowScheduledCals ( KPFFunction ): '''Script to check if ALLOWSCHEDULEDCALS is yes and to send an email reminder if it is no. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read () == 'Yes' : print ( 'ALLOWSCHEDULEDCALS is \"Yes\"' ) else : print ( 'WARNING: ALLOWSCHEDULEDCALS is not \"Yes\"' ) try : msg = [ f 'KPF ALLOWSCHEDULEDCALS is not \"Yes\"' , f '' , f 'End of Night script may not have been run properly' , ] SendEmail . execute ({ 'Subject' : 'KPF ALLOWSCHEDULEDCALS is not \"Yes\"' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , argsKPFFunction ): pass","title":"CheckAllowScheduledCals"},{"location":"scripts/CheckSoCalEnabled/","text":"CheckSoCalEnabled Bases: KPFFunction Script to check if SoCal is enabled and to send an email reminder if it is disabled. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/CheckSoCalEnabled.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CheckSoCalEnabled ( KPFFunction ): '''Script to check if SoCal is enabled and to send an email reminder if it is disabled. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) if CAN_OPEN . read ( binary = True ) == True : print ( 'CAN_OPEN is True' ) else : print ( 'WARNING: CAN_OPEN is not True' ) try : msg = [ f 'KPF SoCal CAN_OPEN is not True' , f '' , f 'SoCal is disabled.' , ] SendEmail . execute ({ 'Subject' : 'KPF SoCal CAN_OPEN is not True' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , args ): pass","title":"CheckSoCalEnabled"},{"location":"scripts/CheckSoCalEnabled/#checksocalenabled","text":"Bases: KPFFunction Script to check if SoCal is enabled and to send an email reminder if it is disabled. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/CheckSoCalEnabled.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CheckSoCalEnabled ( KPFFunction ): '''Script to check if SoCal is enabled and to send an email reminder if it is disabled. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) if CAN_OPEN . read ( binary = True ) == True : print ( 'CAN_OPEN is True' ) else : print ( 'WARNING: CAN_OPEN is not True' ) try : msg = [ f 'KPF SoCal CAN_OPEN is not True' , f '' , f 'SoCal is disabled.' , ] SendEmail . execute ({ 'Subject' : 'KPF SoCal CAN_OPEN is not True' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) @classmethod def post_condition ( cls , args ): pass","title":"CheckSoCalEnabled"},{"location":"scripts/CleanupAfterCalibrations/","text":"CleanupAfterCalibrations Bases: KPFScript Script which cleans up after OBs with calibrations. Turns off calibration lamps (if specified) Stops agitator motion Sets FIU to stowed (or to specified mode) Disables kpf_expmeter.USETHRESHOLD Clears target info from keywords Parameters: leave_lamps_on ( bool ) \u2013 Leave calibration lamps on when done? OB ( ObservingBlock ) \u2013 A valid observing block (OB). FIUdest ( string ) \u2013 Where to send the FIU (default = Stowed) KTL Keywords Used: kpfconfig.USEAGITATOR kpf_expmeter.USETHRESHOLD Functions Called: kpf.calbench.CalLampPower kpf.calbench.IsCalSourceEnabled kpf.calbench.SetLFCtoStandbyHigh kpf.fiu.ConfigureFIU kpf.spectrograph.SetObject kpf.spectrograph.StopAgitator kpf.spectrograph.WaitForL0File kpf.spectrograph.WaitForReady kpf.scripts.SetTargetInfo Source code in kpf/scripts/CleanupAfterCalibrations.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class CleanupAfterCalibrations ( KPFScript ): '''Script which cleans up after OBs with calibrations. - Turns off calibration lamps (if specified) - Stops agitator motion - Sets FIU to stowed (or to specified mode) - Disables kpf_expmeter.USETHRESHOLD - Clears target info from keywords Args: leave_lamps_on (bool): Leave calibration lamps on when done? OB (ObservingBlock): A valid observing block (OB). FIUdest (string): Where to send the FIU (default = Stowed) KTL Keywords Used: - `kpfconfig.USEAGITATOR` - `kpf_expmeter.USETHRESHOLD` Functions Called: - `kpf.calbench.CalLampPower` - `kpf.calbench.IsCalSourceEnabled` - `kpf.calbench.SetLFCtoStandbyHigh` - `kpf.fiu.ConfigureFIU` - `kpf.spectrograph.SetObject` - `kpf.spectrograph.StopAgitator` - `kpf.spectrograph.WaitForL0File` - `kpf.spectrograph.WaitForReady` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) calibrations = OB . Calibrations log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for i , calibration in enumerate ( calibrations ): log . debug ( f \"Calibration { i + 1 } / { len ( calibrations ) } \" ) for key in calibration . to_dict (): log . debug ( f \" { key } : { calibration . get ( key ) } \" ) log . info ( '-------------------------' ) SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) SCRIPTMSG . write ( '' ) # Power off lamps if args . get ( 'leave_lamps_on' , False ) == True : log . info ( 'Not turning lamps off because leave_lamps_on option was invoked' ) else : lamps = set ([ c . get ( 'CalSource' ) for c in calibrations ]) for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'off' }) if lamp == 'LFCFiber' : try : SetLFCtoStandbyHigh . execute ({}) except Exception as e : log . error ( 'SetLFCtoStandbyHigh failed' ) log . error ( e ) try : SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : f ' { e } ' }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) runagitator = ktl . cache ( 'kpfconfig' , 'USEAGITATOR' ) . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) FIUdest = args . get ( 'FIUdest' , 'Stowed' ) log . info ( f \"Sending FIU to { FIUdest } \" ) ConfigureFIU . execute ({ 'mode' : FIUdest }) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) USETHRESHOLD . write ( 'No' ) # Set OBJECT back to empty string # log.info('Waiting for readout to finish') # WaitForReady.execute({}) # SetObject.execute({'Object': ''}) # Clear target info SetTargetInfo . execute ({}) # Write L0 file name to log if can # WaitForL0File.execute({}) @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) return super () . add_cmdline_args ( parser )","title":"CleanupAfterCalibrations"},{"location":"scripts/CleanupAfterCalibrations/#cleanupaftercalibrations","text":"Bases: KPFScript Script which cleans up after OBs with calibrations. Turns off calibration lamps (if specified) Stops agitator motion Sets FIU to stowed (or to specified mode) Disables kpf_expmeter.USETHRESHOLD Clears target info from keywords Parameters: leave_lamps_on ( bool ) \u2013 Leave calibration lamps on when done? OB ( ObservingBlock ) \u2013 A valid observing block (OB). FIUdest ( string ) \u2013 Where to send the FIU (default = Stowed) KTL Keywords Used: kpfconfig.USEAGITATOR kpf_expmeter.USETHRESHOLD Functions Called: kpf.calbench.CalLampPower kpf.calbench.IsCalSourceEnabled kpf.calbench.SetLFCtoStandbyHigh kpf.fiu.ConfigureFIU kpf.spectrograph.SetObject kpf.spectrograph.StopAgitator kpf.spectrograph.WaitForL0File kpf.spectrograph.WaitForReady kpf.scripts.SetTargetInfo Source code in kpf/scripts/CleanupAfterCalibrations.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 class CleanupAfterCalibrations ( KPFScript ): '''Script which cleans up after OBs with calibrations. - Turns off calibration lamps (if specified) - Stops agitator motion - Sets FIU to stowed (or to specified mode) - Disables kpf_expmeter.USETHRESHOLD - Clears target info from keywords Args: leave_lamps_on (bool): Leave calibration lamps on when done? OB (ObservingBlock): A valid observing block (OB). FIUdest (string): Where to send the FIU (default = Stowed) KTL Keywords Used: - `kpfconfig.USEAGITATOR` - `kpf_expmeter.USETHRESHOLD` Functions Called: - `kpf.calbench.CalLampPower` - `kpf.calbench.IsCalSourceEnabled` - `kpf.calbench.SetLFCtoStandbyHigh` - `kpf.fiu.ConfigureFIU` - `kpf.spectrograph.SetObject` - `kpf.spectrograph.StopAgitator` - `kpf.spectrograph.WaitForL0File` - `kpf.spectrograph.WaitForReady` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) calibrations = OB . Calibrations log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for i , calibration in enumerate ( calibrations ): log . debug ( f \"Calibration { i + 1 } / { len ( calibrations ) } \" ) for key in calibration . to_dict (): log . debug ( f \" { key } : { calibration . get ( key ) } \" ) log . info ( '-------------------------' ) SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) SCRIPTMSG . write ( '' ) # Power off lamps if args . get ( 'leave_lamps_on' , False ) == True : log . info ( 'Not turning lamps off because leave_lamps_on option was invoked' ) else : lamps = set ([ c . get ( 'CalSource' ) for c in calibrations ]) for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'off' }) if lamp == 'LFCFiber' : try : SetLFCtoStandbyHigh . execute ({}) except Exception as e : log . error ( 'SetLFCtoStandbyHigh failed' ) log . error ( e ) try : SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : f ' { e } ' }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) runagitator = ktl . cache ( 'kpfconfig' , 'USEAGITATOR' ) . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) FIUdest = args . get ( 'FIUdest' , 'Stowed' ) log . info ( f \"Sending FIU to { FIUdest } \" ) ConfigureFIU . execute ({ 'mode' : FIUdest }) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) USETHRESHOLD . write ( 'No' ) # Set OBJECT back to empty string # log.info('Waiting for readout to finish') # WaitForReady.execute({}) # SetObject.execute({'Object': ''}) # Clear target info SetTargetInfo . execute ({}) # Write L0 file name to log if can # WaitForL0File.execute({}) @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the lamps on after cleanup phase?' ) return super () . add_cmdline_args ( parser )","title":"CleanupAfterCalibrations"},{"location":"scripts/CleanupAfterScience/","text":"CleanupAfterScience Bases: KPFScript Script which cleans up at the end of Science OBs. Stops agitator motion Disables kpf_expmeter.USETHRESHOLD Resets kpfguide.SKY_OFFSET to \"0 0\" Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). KTL Keywords Used: kpfconfig.USEAGITATOR kpf_expmeter.USETHRESHOLD kpfguide.SKY_OFFSET Functions Called: kpf.fiu.StopTipTilt kpf.spectrograph.StopAgitator kpf.scripts.SetTargetInfo Source code in kpf/scripts/CleanupAfterScience.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class CleanupAfterScience ( KPFScript ): '''Script which cleans up at the end of Science OBs. - Stops agitator motion - Disables kpf_expmeter.USETHRESHOLD - Resets kpfguide.SKY_OFFSET to \"0 0\" Args: OB (ObservingBlock): A valid observing block (OB). KTL Keywords Used: - `kpfconfig.USEAGITATOR` - `kpf_expmeter.USETHRESHOLD` - `kpfguide.SKY_OFFSET` Functions Called: - `kpf.fiu.StopTipTilt` - `kpf.spectrograph.StopAgitator` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) StopTipTilt . execute ({}) SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) SCRIPTMSG . write ( '' ) runagitator = ktl . cache ( 'kpfconfig' , 'USEAGITATOR' ) . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) USETHRESHOLD . write ( 'No' ) # Set SKY_OFFSET back to 0 0 log . debug ( 'Clearing kpfguide.SKY_OFFSET' ) sky_offset = ktl . cache ( 'kpfguide' , 'SKY_OFFSET' ) sky_offset . write ( '0 0' ) @classmethod def post_condition ( cls , args , OB = None ): pass","title":"CleanupAfterScience"},{"location":"scripts/CleanupAfterScience/#cleanupafterscience","text":"Bases: KPFScript Script which cleans up at the end of Science OBs. Stops agitator motion Disables kpf_expmeter.USETHRESHOLD Resets kpfguide.SKY_OFFSET to \"0 0\" Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). KTL Keywords Used: kpfconfig.USEAGITATOR kpf_expmeter.USETHRESHOLD kpfguide.SKY_OFFSET Functions Called: kpf.fiu.StopTipTilt kpf.spectrograph.StopAgitator kpf.scripts.SetTargetInfo Source code in kpf/scripts/CleanupAfterScience.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class CleanupAfterScience ( KPFScript ): '''Script which cleans up at the end of Science OBs. - Stops agitator motion - Disables kpf_expmeter.USETHRESHOLD - Resets kpfguide.SKY_OFFSET to \"0 0\" Args: OB (ObservingBlock): A valid observing block (OB). KTL Keywords Used: - `kpfconfig.USEAGITATOR` - `kpf_expmeter.USETHRESHOLD` - `kpfguide.SKY_OFFSET` Functions Called: - `kpf.fiu.StopTipTilt` - `kpf.spectrograph.StopAgitator` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) StopTipTilt . execute ({}) SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) SCRIPTMSG . write ( '' ) runagitator = ktl . cache ( 'kpfconfig' , 'USEAGITATOR' ) . read ( binary = True ) if runagitator is True : StopAgitator . execute ({}) # Turn off exposure meter controlled exposure log . debug ( 'Clearing kpf_expmeter.USETHRESHOLD' ) USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) USETHRESHOLD . write ( 'No' ) # Set SKY_OFFSET back to 0 0 log . debug ( 'Clearing kpfguide.SKY_OFFSET' ) sky_offset = ktl . cache ( 'kpfguide' , 'SKY_OFFSET' ) sky_offset . write ( '0 0' ) @classmethod def post_condition ( cls , args , OB = None ): pass","title":"CleanupAfterScience"},{"location":"scripts/CollectGuiderDarkCubes/","text":"CollectGuiderDarkCubes Bases: KPFFunction Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 Parameters: scheduled ( bool ) \u2013 Obey ALLOWSCHEDULEDCALS keyword KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfguide.OUTDIR kpfguide.SENSORSETP kpfguide.SENSORTEMP kpfguide.CONTINUOUS kpfguide.SUB_HIGH kpfguide.SUB_MEDIUM kpfguide.SUB_LOW Source code in kpf/guider/CollectGuiderDarkCubes.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 class CollectGuiderDarkCubes ( KPFFunction ): '''Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 Args: scheduled (bool): Obey ALLOWSCHEDULEDCALS keyword KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfguide.OUTDIR` - `kpfguide.SENSORSETP` - `kpfguide.SENSORTEMP` - `kpfguide.CONTINUOUS` - `kpfguide.SUB_HIGH` - `kpfguide.SUB_MEDIUM` - `kpfguide.SUB_LOW` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): output_file = Path ( '/s/sdata1701/CRED2DarkCubes/CRED2_dark_cubes.txt' ) OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) original_OUTDIR = OUTDIR . read () new_OUTDIR = str ( output_file . parent ) log . debug ( f 'Setting OUTDIR to { new_OUTDIR } ' ) OUTDIR . write ( new_OUTDIR ) SENSORSETP = ktl . cache ( 'kpfguide' , 'SENSORSETP' ) SENSORTEMP = ktl . cache ( 'kpfguide' , 'SENSORTEMP' ) CONTINUOUS = ktl . cache ( 'kpfguide' , 'CONTINUOUS' ) kpfguide = ktl . cache ( 'kpfguide' ) try : log . info ( 'Taking CRED2 dark cubes' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) log . info ( 'Cooling CRED2' ) SENSORSETP . write ( - 40 ) log . info ( 'Waiting up to 10 minutes for detector to reach set point' ) reached_temp = SENSORTEMP . waitFor ( \"<-39.9\" , timeout = 600 ) if reached_temp == False : log . error ( 'CRED2 failed to reach set point. Exiting.' ) SENSORSETP . write ( 0 ) return check_scriptstop () log . debug ( 'Waiting additional time for temperature to stabilize' ) time . sleep ( 60 ) # shim to give time to stabilize check_scriptstop () log . debug ( 'Closing source shutters' ) SetSourceSelectShutters . execute ({}) CONTINUOUS . write ( 'Active' ) SetGuiderFPS . execute ({ 'GuideFPS' : 100 }) for gain in [ 'high' , 'medium' , 'low' ]: log . info ( f 'Collecting { gain } gain cube' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : f . write ( f \" { gain : 12s } , { cube_file } \\n \" ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () for gain in [ 'high' , 'medium' , 'low' ]: sub_file = kpfguide [ f 'SUB_ { gain . upper () } ' ] . read () kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( '' ) log . info ( f 'Collecting { gain } gain cube without bias subtraction' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : gain_string = f ' { gain } _nosub' f . write ( f \" { gain_string : 12s } , { cube_file } \\n \" ) kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( sub_file ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () except Exception as e : log . error ( 'Error running CollectGuiderDarkCubes' ) log . debug ( e ) log . info ( 'Resetting CRED2 temperature set point to 0' ) SENSORSETP . write ( 0 ) log . debug ( f 'Setting OUTDIR to { original_OUTDIR } ' ) OUTDIR . write ( original_OUTDIR ) clear_script_keywords () @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"CollectGuiderDarkCubes"},{"location":"scripts/CollectGuiderDarkCubes/#collectguiderdarkcubes","text":"Bases: KPFFunction Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 Parameters: scheduled ( bool ) \u2013 Obey ALLOWSCHEDULEDCALS keyword KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfguide.OUTDIR kpfguide.SENSORSETP kpfguide.SENSORTEMP kpfguide.CONTINUOUS kpfguide.SUB_HIGH kpfguide.SUB_MEDIUM kpfguide.SUB_LOW Source code in kpf/guider/CollectGuiderDarkCubes.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 class CollectGuiderDarkCubes ( KPFFunction ): '''Obtains CRED2 \"trigger file\" data cubes under dark conditions at each of the three gain settings for the detector. Sequence: - Set FIU to Stowed - Set kpfguide.SENSORSETP = -40 - Wait for temperature to reach target - modify -s kpfexpose SRC_SHUTTERS='' - Set FPS = 100 - Set GAIN = High - Take 10s trigger cube - Set GAIN = High - Take 10s trigger cube - Set GAIN = Low - Take 10s trigger cube - Set kpfguide.SENSORSETP = 0 Args: scheduled (bool): Obey ALLOWSCHEDULEDCALS keyword KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfguide.OUTDIR` - `kpfguide.SENSORSETP` - `kpfguide.SENSORTEMP` - `kpfguide.CONTINUOUS` - `kpfguide.SUB_HIGH` - `kpfguide.SUB_MEDIUM` - `kpfguide.SUB_LOW` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): output_file = Path ( '/s/sdata1701/CRED2DarkCubes/CRED2_dark_cubes.txt' ) OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) original_OUTDIR = OUTDIR . read () new_OUTDIR = str ( output_file . parent ) log . debug ( f 'Setting OUTDIR to { new_OUTDIR } ' ) OUTDIR . write ( new_OUTDIR ) SENSORSETP = ktl . cache ( 'kpfguide' , 'SENSORSETP' ) SENSORTEMP = ktl . cache ( 'kpfguide' , 'SENSORTEMP' ) CONTINUOUS = ktl . cache ( 'kpfguide' , 'CONTINUOUS' ) kpfguide = ktl . cache ( 'kpfguide' ) try : log . info ( 'Taking CRED2 dark cubes' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' }) log . info ( 'Cooling CRED2' ) SENSORSETP . write ( - 40 ) log . info ( 'Waiting up to 10 minutes for detector to reach set point' ) reached_temp = SENSORTEMP . waitFor ( \"<-39.9\" , timeout = 600 ) if reached_temp == False : log . error ( 'CRED2 failed to reach set point. Exiting.' ) SENSORSETP . write ( 0 ) return check_scriptstop () log . debug ( 'Waiting additional time for temperature to stabilize' ) time . sleep ( 60 ) # shim to give time to stabilize check_scriptstop () log . debug ( 'Closing source shutters' ) SetSourceSelectShutters . execute ({}) CONTINUOUS . write ( 'Active' ) SetGuiderFPS . execute ({ 'GuideFPS' : 100 }) for gain in [ 'high' , 'medium' , 'low' ]: log . info ( f 'Collecting { gain } gain cube' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : f . write ( f \" { gain : 12s } , { cube_file } \\n \" ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () for gain in [ 'high' , 'medium' , 'low' ]: sub_file = kpfguide [ f 'SUB_ { gain . upper () } ' ] . read () kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( '' ) log . info ( f 'Collecting { gain } gain cube without bias subtraction' ) SetGuiderGain . execute ({ 'GuideCamGain' : gain }) cube_file = TakeGuiderCube . execute ({ 'duration' : 10 }) with open ( output_file , 'a' ) as f : gain_string = f ' { gain } _nosub' f . write ( f \" { gain_string : 12s } , { cube_file } \\n \" ) kpfguide [ f 'SUB_ { gain . upper () } ' ] . write ( sub_file ) check_scriptstop () time . sleep ( 30 ) # shim to give time to recover after writing cube check_scriptstop () except Exception as e : log . error ( 'Error running CollectGuiderDarkCubes' ) log . debug ( e ) log . info ( 'Resetting CRED2 temperature set point to 0' ) SENSORSETP . write ( 0 ) log . debug ( f 'Setting OUTDIR to { original_OUTDIR } ' ) OUTDIR . write ( original_OUTDIR ) clear_script_keywords () @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"CollectGuiderDarkCubes"},{"location":"scripts/ConfigureFIU/","text":"ConfigureFIU Bases: KPFFunction Set the FIU mode (kpffiu.MODE). If the wait option is fale this will retry the move if it fails with a configurable number of retries. Parameters: mode ( str ) \u2013 The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration wait ( bool ) \u2013 Wait for move to complete before returning? (default: True) KTL Keywords Used: kpffiu.MODE Functions Called: kpf.calbench.ConfigureFIUOnce kpf.calbench.WaitForConfigureFIU Source code in kpf/fiu/ConfigureFIU.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ConfigureFIU ( KPFFunction ): '''Set the FIU mode (kpffiu.MODE). If the wait option is fale this will retry the move if it fails with a configurable number of retries. Args: mode (str): The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration wait (bool): Wait for move to complete before returning? (default: True) KTL Keywords Used: - `kpffiu.MODE` Functions Called: - `kpf.calbench.ConfigureFIUOnce` - `kpf.calbench.WaitForConfigureFIU` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): dest = args . get ( 'mode' ) wait = args . get ( 'wait' , True ) log . info ( f \"Configuring FIU for { dest } \" ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : wait }) if wait == True : WaitForConfigureFIU . execute ({ 'mode' : dest }) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"ConfigureFIU"},{"location":"scripts/ConfigureFIU/#configurefiu","text":"Bases: KPFFunction Set the FIU mode (kpffiu.MODE). If the wait option is fale this will retry the move if it fails with a configurable number of retries. Parameters: mode ( str ) \u2013 The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration wait ( bool ) \u2013 Wait for move to complete before returning? (default: True) KTL Keywords Used: kpffiu.MODE Functions Called: kpf.calbench.ConfigureFIUOnce kpf.calbench.WaitForConfigureFIU Source code in kpf/fiu/ConfigureFIU.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ConfigureFIU ( KPFFunction ): '''Set the FIU mode (kpffiu.MODE). If the wait option is fale this will retry the move if it fails with a configurable number of retries. Args: mode (str): The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration wait (bool): Wait for move to complete before returning? (default: True) KTL Keywords Used: - `kpffiu.MODE` Functions Called: - `kpf.calbench.ConfigureFIUOnce` - `kpf.calbench.WaitForConfigureFIU` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( keyword . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): dest = args . get ( 'mode' ) wait = args . get ( 'wait' , True ) log . info ( f \"Configuring FIU for { dest } \" ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : wait }) if wait == True : WaitForConfigureFIU . execute ({ 'mode' : dest }) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"ConfigureFIU"},{"location":"scripts/ConfigureForAcquisition/","text":"ConfigureForAcquisition Bases: KPFScript Script which configures the instrument for Acquisition step. Sets target parameters Sets FIU mode Executes Slew Cal Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). KTL Keywords Used: kpfconfig.SIMULCALSOURCE Functions Called: kpf.calbench.SetCalSource kpf.fiu.ConfigureFIU kpf.scripts.SetTargetInfo Source code in kpf/scripts/ConfigureForAcquisition.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ConfigureForAcquisition ( KPFScript ): '''Script which configures the instrument for Acquisition step. - Sets target parameters - Sets FIU mode - Executes Slew Cal Args: OB (ObservingBlock): A valid observing block (OB). KTL Keywords Used: - `kpfconfig.SIMULCALSOURCE` Functions Called: - `kpf.calbench.SetCalSource` - `kpf.fiu.ConfigureFIU` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Set Octagon calsource = ktl . cache ( 'kpfconfig' , 'SIMULCALSOURCE' ) . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) # Set FIU Mode ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set Target Parameters from OB SetTargetInfo . execute ({}, OB = OB ) @classmethod def post_condition ( cls , args , OB = None ): pass","title":"ConfigureForAcquisition"},{"location":"scripts/ConfigureForAcquisition/#configureforacquisition","text":"Bases: KPFScript Script which configures the instrument for Acquisition step. Sets target parameters Sets FIU mode Executes Slew Cal Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). KTL Keywords Used: kpfconfig.SIMULCALSOURCE Functions Called: kpf.calbench.SetCalSource kpf.fiu.ConfigureFIU kpf.scripts.SetTargetInfo Source code in kpf/scripts/ConfigureForAcquisition.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class ConfigureForAcquisition ( KPFScript ): '''Script which configures the instrument for Acquisition step. - Sets target parameters - Sets FIU mode - Executes Slew Cal Args: OB (ObservingBlock): A valid observing block (OB). KTL Keywords Used: - `kpfconfig.SIMULCALSOURCE` Functions Called: - `kpf.calbench.SetCalSource` - `kpf.fiu.ConfigureFIU` - `kpf.scripts.SetTargetInfo` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Set Octagon calsource = ktl . cache ( 'kpfconfig' , 'SIMULCALSOURCE' ) . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) # Set FIU Mode ConfigureFIU . execute ({ 'mode' : 'Observing' , 'wait' : False }) # Set Target Parameters from OB SetTargetInfo . execute ({}, OB = OB ) @classmethod def post_condition ( cls , args , OB = None ): pass","title":"ConfigureForAcquisition"},{"location":"scripts/ConfigureForCalibrations/","text":"ConfigureForCalibrations Bases: KPFScript Script which configures the instrument for calibration exposures. Powers on requested calibration lamps Configures FIU to calibration mode Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). Functions Called: kpf.ObservingBlocks.ObservingBlock kpf.calbench.IsCalSourceEnabled kpf.calbench.CalLampPower kpf.fiu.ConfigureFIU Source code in kpf/scripts/ConfigureForCalibrations.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class ConfigureForCalibrations ( KPFScript ): '''Script which configures the instrument for calibration exposures. - Powers on requested calibration lamps - Configures FIU to calibration mode Args: OB (ObservingBlock): A valid observing block (OB). Functions Called: - `kpf.ObservingBlocks.ObservingBlock` - `kpf.calbench.IsCalSourceEnabled` - `kpf.calbench.CalLampPower` - `kpf.fiu.ConfigureFIU` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) calibrations = OB . Calibrations log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for i , calibration in enumerate ( calibrations ): log . debug ( f \"Calibration { i + 1 } / { len ( calibrations ) } \" ) for key in calibration . to_dict (): log . debug ( f \" { key } : { calibration . get ( key ) } \" ) log . info ( '-------------------------' ) check_scriptstop () # Power on needed lamps lamps = set ([ c . get ( 'CalSource' ) for c in calibrations ]) for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'on' }) # Set back illumination LEDs to off log . debug ( f \"Ensuring back illumination LEDs are off\" ) CalLampPower . execute ({ 'lamp' : 'ExpMeterLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'CaHKLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SciLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SkyLED' , 'power' : 'off' }) check_scriptstop () ConfigureFIU . execute ({ 'mode' : 'Calibration' }) StopTipTilt . execute ({}) check_scriptstop () @classmethod def post_condition ( cls , args , OB = None ): pass","title":"ConfigureForCalibrations"},{"location":"scripts/ConfigureForCalibrations/#configureforcalibrations","text":"Bases: KPFScript Script which configures the instrument for calibration exposures. Powers on requested calibration lamps Configures FIU to calibration mode Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). Functions Called: kpf.ObservingBlocks.ObservingBlock kpf.calbench.IsCalSourceEnabled kpf.calbench.CalLampPower kpf.fiu.ConfigureFIU Source code in kpf/scripts/ConfigureForCalibrations.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class ConfigureForCalibrations ( KPFScript ): '''Script which configures the instrument for calibration exposures. - Powers on requested calibration lamps - Configures FIU to calibration mode Args: OB (ObservingBlock): A valid observing block (OB). Functions Called: - `kpf.ObservingBlocks.ObservingBlock` - `kpf.calbench.IsCalSourceEnabled` - `kpf.calbench.CalLampPower` - `kpf.fiu.ConfigureFIU` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) calibrations = OB . Calibrations log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for i , calibration in enumerate ( calibrations ): log . debug ( f \"Calibration { i + 1 } / { len ( calibrations ) } \" ) for key in calibration . to_dict (): log . debug ( f \" { key } : { calibration . get ( key ) } \" ) log . info ( '-------------------------' ) check_scriptstop () # Power on needed lamps lamps = set ([ c . get ( 'CalSource' ) for c in calibrations ]) for lamp in lamps : if IsCalSourceEnabled . execute ({ 'CalSource' : lamp }) == True : if lamp in [ 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'BrdbandFiber' , 'WideFlat' ]: CalLampPower . execute ({ 'lamp' : lamp , 'power' : 'on' }) # Set back illumination LEDs to off log . debug ( f \"Ensuring back illumination LEDs are off\" ) CalLampPower . execute ({ 'lamp' : 'ExpMeterLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'CaHKLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SciLED' , 'power' : 'off' }) CalLampPower . execute ({ 'lamp' : 'SkyLED' , 'power' : 'off' }) check_scriptstop () ConfigureFIU . execute ({ 'mode' : 'Calibration' }) StopTipTilt . execute ({}) check_scriptstop () @classmethod def post_condition ( cls , args , OB = None ): pass","title":"ConfigureForCalibrations"},{"location":"scripts/ConfigureForScience/","text":"ConfigureForScience Bases: KPFFunction Script which configures the instrument for Science observations. Sets octagon / simulcal source Sets source select shutters Set triggered detectors Parameters: observation ( dict ) \u2013 A observation OB component in dictionary format (e.g. using the output of the .to_dict() method of a kpf.ObservingBlocks.Observation.Observation instance). KTL Keywords Used: kpfexpose.EXPOSE Functions Called: kpf.calbench.SetSimulCalSource kpf.guider.ConfirmGuiding kpf.spectrograph.SetSourceSelectShutters kpf.spectrograph.SetTriggeredDetectors kpf.spectrograph.WaitForReady kpf.telescope.EastNorth Source code in kpf/scripts/ConfigureForScience.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ConfigureForScience ( KPFFunction ): '''Script which configures the instrument for Science observations. - Sets octagon / simulcal source - Sets source select shutters - Set triggered detectors Args: observation (dict): A observation OB component in dictionary format (e.g. using the output of the `.to_dict()` method of a `kpf.ObservingBlocks.Observation.Observation` instance). KTL Keywords Used: - `kpfexpose.EXPOSE` Functions Called: - `kpf.calbench.SetSimulCalSource` - `kpf.guider.ConfirmGuiding` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.spectrograph.SetTriggeredDetectors` - `kpf.spectrograph.WaitForReady` - `kpf.telescope.EastNorth` ''' @classmethod def pre_condition ( cls , observation ): pass @classmethod def perform ( cls , observation ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Offset if requested # NodN = observation.get('NodN', 0) # NodE = observation.get('NodE', 0) # if abs(NodN) > 0.01 or abs(NodE) > 0.01: # EastNorth.execute(observation) check_scriptstop () # Confirm guiding ConfirmGuiding . execute ( observation ) check_scriptstop () # Set Octagon SetSimulCalSource . execute ({}) check_scriptstop () # Set source select shutters exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . debug ( f \"kpfexpose is Ready\" ) log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'OpenScienceShutter' : True , 'OpenSkyShutter' : not observation . get ( 'BlockSky' , False ), 'OpenSoCalSciShutter' : False , 'OpenSoCalCalShutter' : False , 'OpenCalSciSkyShutter' : False }) # Set Triggered Detectors observation [ 'TriggerGuide' ] = True SetTriggeredDetectors . execute ( observation ) check_scriptstop () @classmethod def post_condition ( cls , observation ): pass","title":"ConfigureForScience"},{"location":"scripts/ConfigureForScience/#configureforscience","text":"Bases: KPFFunction Script which configures the instrument for Science observations. Sets octagon / simulcal source Sets source select shutters Set triggered detectors Parameters: observation ( dict ) \u2013 A observation OB component in dictionary format (e.g. using the output of the .to_dict() method of a kpf.ObservingBlocks.Observation.Observation instance). KTL Keywords Used: kpfexpose.EXPOSE Functions Called: kpf.calbench.SetSimulCalSource kpf.guider.ConfirmGuiding kpf.spectrograph.SetSourceSelectShutters kpf.spectrograph.SetTriggeredDetectors kpf.spectrograph.WaitForReady kpf.telescope.EastNorth Source code in kpf/scripts/ConfigureForScience.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ConfigureForScience ( KPFFunction ): '''Script which configures the instrument for Science observations. - Sets octagon / simulcal source - Sets source select shutters - Set triggered detectors Args: observation (dict): A observation OB component in dictionary format (e.g. using the output of the `.to_dict()` method of a `kpf.ObservingBlocks.Observation.Observation` instance). KTL Keywords Used: - `kpfexpose.EXPOSE` Functions Called: - `kpf.calbench.SetSimulCalSource` - `kpf.guider.ConfirmGuiding` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.spectrograph.SetTriggeredDetectors` - `kpf.spectrograph.WaitForReady` - `kpf.telescope.EastNorth` ''' @classmethod def pre_condition ( cls , observation ): pass @classmethod def perform ( cls , observation ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) # Offset if requested # NodN = observation.get('NodN', 0) # NodE = observation.get('NodE', 0) # if abs(NodN) > 0.01 or abs(NodE) > 0.01: # EastNorth.execute(observation) check_scriptstop () # Confirm guiding ConfirmGuiding . execute ( observation ) check_scriptstop () # Set Octagon SetSimulCalSource . execute ({}) check_scriptstop () # Set source select shutters exposestatus = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) if exposestatus . read () != 'Ready' : log . info ( f \"Waiting for kpfexpose to be Ready\" ) WaitForReady . execute ({}) log . debug ( f \"kpfexpose is Ready\" ) log . info ( f \"Set Source Select Shutters\" ) SetSourceSelectShutters . execute ({ 'OpenScienceShutter' : True , 'OpenSkyShutter' : not observation . get ( 'BlockSky' , False ), 'OpenSoCalSciShutter' : False , 'OpenSoCalCalShutter' : False , 'OpenCalSciSkyShutter' : False }) # Set Triggered Detectors observation [ 'TriggerGuide' ] = True SetTriggeredDetectors . execute ( observation ) check_scriptstop () @classmethod def post_condition ( cls , observation ): pass","title":"ConfigureForScience"},{"location":"scripts/ControlAOHatch/","text":"ControlAOHatch Bases: KPFFunction Command the AO Hatch to open or close. Parameters: destination ( str ) \u2013 The destination position. Allowed Values: 'open' or 'close'. KTL Keywords Used: ao.AOHATCHCMD ao.AOHATCHSTS Source code in kpf/ao/ControlAOHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ControlAOHatch ( KPFFunction ): '''Command the AO Hatch to open or close. Args: destination (str): The destination position. Allowed Values: 'open' or 'close'. KTL Keywords Used: - `ao.AOHATCHCMD` - `ao.AOHATCHSTS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'destination' , allowed_values = [ 'close' , 'closed' , 'open' ]) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () aohatchcmd = ktl . cache ( 'ao' , 'aohatchcmd' ) log . debug ( f \"Setting AO Hatch to { destination } \" ) cmd = { 'close' : 1 , 'closed' : 1 , 'open' : 0 }[ destination ] aohatchcmd . write ( cmd ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () final_dest = { 'close' : 'closed' , 'closed' : 'closed' , 'open' : 'open' }[ destination ] aohatchsts = ktl . cache ( 'ao' , 'AOHATCHSTS' ) success = aohatchsts . waitfor ( f \"== ' { final_dest } '\" , timeout = 30 ) if success is not True : raise FailedToReachDestination ( aohatchsts . read (), final_dest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'close' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser )","title":"ControlAOHatch"},{"location":"scripts/ControlAOHatch/#controlaohatch","text":"Bases: KPFFunction Command the AO Hatch to open or close. Parameters: destination ( str ) \u2013 The destination position. Allowed Values: 'open' or 'close'. KTL Keywords Used: ao.AOHATCHCMD ao.AOHATCHSTS Source code in kpf/ao/ControlAOHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ControlAOHatch ( KPFFunction ): '''Command the AO Hatch to open or close. Args: destination (str): The destination position. Allowed Values: 'open' or 'close'. KTL Keywords Used: - `ao.AOHATCHCMD` - `ao.AOHATCHSTS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'destination' , allowed_values = [ 'close' , 'closed' , 'open' ]) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () aohatchcmd = ktl . cache ( 'ao' , 'aohatchcmd' ) log . debug ( f \"Setting AO Hatch to { destination } \" ) cmd = { 'close' : 1 , 'closed' : 1 , 'open' : 0 }[ destination ] aohatchcmd . write ( cmd ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () final_dest = { 'close' : 'closed' , 'closed' : 'closed' , 'open' : 'open' }[ destination ] aohatchsts = ktl . cache ( 'ao' , 'AOHATCHSTS' ) success = aohatchsts . waitfor ( f \"== ' { final_dest } '\" , timeout = 30 ) if success is not True : raise FailedToReachDestination ( aohatchsts . read (), final_dest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'close' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser )","title":"ControlAOHatch"},{"location":"scripts/ControlFoldMirror/","text":"ControlFoldMirror Bases: KPFFunction Insert or remove the FIU Cal Fold Mirror from the beam. Parameters: destination ( str ) \u2013 The desired FIU fold mirror position name. Allowed values: in, out wait ( bool ) \u2013 Wait for move to complete before returning? (default: True) KTL Keywords Used: kpffiu.FOLDNAM Source code in kpf/fiu/ControlFoldMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class ControlFoldMirror ( KPFFunction ): '''Insert or remove the FIU Cal Fold Mirror from the beam. Args: destination (str): The desired FIU fold mirror position name. Allowed values: in, out wait (bool): Wait for move to complete before returning? (default: True) KTL Keywords Used: - `kpffiu.FOLDNAM` ''' @classmethod def pre_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () if destination . lower () not in [ 'in' , 'out' ]: raise FailedPreCondition ( f \"Requested state { destination } is invalid\" ) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () FOLDNAM = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) FOLDNAM . write ( destination ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_fold_mirror_move_time' , fallback = 5 ) FOLDNAM = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) if FOLDNAM . waitFor ( f '== \" { destination } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( FOLDNAM . read (), destination ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'in' , 'out' ], help = 'Desired fold mirror position' ) return super () . add_cmdline_args ( parser )","title":"ControlFoldMirror"},{"location":"scripts/ControlFoldMirror/#controlfoldmirror","text":"Bases: KPFFunction Insert or remove the FIU Cal Fold Mirror from the beam. Parameters: destination ( str ) \u2013 The desired FIU fold mirror position name. Allowed values: in, out wait ( bool ) \u2013 Wait for move to complete before returning? (default: True) KTL Keywords Used: kpffiu.FOLDNAM Source code in kpf/fiu/ControlFoldMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class ControlFoldMirror ( KPFFunction ): '''Insert or remove the FIU Cal Fold Mirror from the beam. Args: destination (str): The desired FIU fold mirror position name. Allowed values: in, out wait (bool): Wait for move to complete before returning? (default: True) KTL Keywords Used: - `kpffiu.FOLDNAM` ''' @classmethod def pre_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () if destination . lower () not in [ 'in' , 'out' ]: raise FailedPreCondition ( f \"Requested state { destination } is invalid\" ) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () FOLDNAM = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) FOLDNAM . write ( destination ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_fold_mirror_move_time' , fallback = 5 ) FOLDNAM = ktl . cache ( 'kpffiu' , 'FOLDNAM' ) if FOLDNAM . waitFor ( f '== \" { destination } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( FOLDNAM . read (), destination ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'in' , 'out' ], help = 'Desired fold mirror position' ) return super () . add_cmdline_args ( parser )","title":"ControlFoldMirror"},{"location":"scripts/ControlHatch/","text":"ControlHatch Bases: KPFFunction Open or close the FIU hatch Parameters: destination ( str ) \u2013 The desired FIU hatch position name. Allowed values: closed, open KTL Keywords Used: kpffiu.HATCH Source code in kpf/fiu/ControlHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ControlHatch ( KPFFunction ): '''Open or close the FIU hatch Args: destination (str): The desired FIU hatch position name. Allowed values: closed, open KTL Keywords Used: - `kpffiu.HATCH` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'destination' , allowed_values = [ 'closed' , 'open' ]) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () HATCH = ktl . cache ( 'kpffiu' , 'HATCH' ) HATCH . write ( destination ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_hatch_move_time' , fallback = 1 ) HATCH = ktl . cache ( 'kpffiu' , 'HATCH' ) if HATCH . waitFor ( f '== \" { destination } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( HATCH . read (), destination ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'closed' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser )","title":"ControlHatch"},{"location":"scripts/ControlHatch/#controlhatch","text":"Bases: KPFFunction Open or close the FIU hatch Parameters: destination ( str ) \u2013 The desired FIU hatch position name. Allowed values: closed, open KTL Keywords Used: kpffiu.HATCH Source code in kpf/fiu/ControlHatch.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ControlHatch ( KPFFunction ): '''Open or close the FIU hatch Args: destination (str): The desired FIU hatch position name. Allowed values: closed, open KTL Keywords Used: - `kpffiu.HATCH` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'destination' , allowed_values = [ 'closed' , 'open' ]) @classmethod def perform ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () HATCH = ktl . cache ( 'kpffiu' , 'HATCH' ) HATCH . write ( destination ) @classmethod def post_condition ( cls , args ): destination = args . get ( 'destination' , '' ) . strip () timeout = cfg . getfloat ( 'times' , 'fiu_hatch_move_time' , fallback = 1 ) HATCH = ktl . cache ( 'kpffiu' , 'HATCH' ) if HATCH . waitFor ( f '== \" { destination } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( HATCH . read (), destination ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'destination' , type = str , choices = [ 'open' , 'closed' ], help = 'Desired hatch position' ) return super () . add_cmdline_args ( parser )","title":"ControlHatch"},{"location":"scripts/CountCameraErrors/","text":"CountCameraErrors Bases: KPFTranslatorFunction Description Parameters Source code in kpf/engineering/analysis/CountCameraErrors.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class CountCameraErrors ( KPFTranslatorFunction ): '''# Description # Parameters ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/KPFTranslator_logs/camera_errors.txt' ) if output_file . exists (): output_file . unlink () date = datetime . strptime ( '2023-06-01' , '%Y-%m- %d ' ) total_green_errors = 0 total_green_starts = 0 total_red_errors = 0 total_red_starts = 0 print ( f \"From { date . strftime ( '%Y-%m- %d ' ) } \" ) dates = [] green_errs = [] red_errs = [] green_starts = [] red_starts = [] with open ( output_file , 'w' ) as f : while date < datetime . utcnow () - timedelta ( days = 1 ): date_str = date . strftime ( '%Y-%m- %d ' ) ng_starts , nr_starts = count_start_state_instances ( date = date_str ) ng_errs , nr_errs = count_start_state_errors ( date = date_str ) dates . append ( date ) green_errs . append ( ng_errs ) red_errs . append ( nr_errs ) green_starts . append ( ng_starts ) red_starts . append ( nr_starts ) total_green_errors += ng_errs total_green_starts += ng_starts total_red_errors += nr_errs total_red_starts += nr_starts line = f \" { date_str } , { ng_errs } , { ng_starts } , { nr_errs } , { nr_starts } \" # print(line) f . write ( f \" { line } \\n \" ) date += timedelta ( days = 1 ) print ( f \"Through { date . strftime ( '%Y-%m- %d ' ) } \" ) green_error_rate = total_green_errors / total_green_starts print ( f \"Green error rate = { green_error_rate : .2% } ( { total_green_errors } / { total_green_starts } )\" ) red_error_rate = total_red_errors / total_red_starts print ( f \"Red error rate = { red_error_rate : .2% } ( { total_red_errors } / { total_red_starts } )\" ) plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . title ( f \"Number of start errors per day\" ) plt . bar ( dates , green_errs , color = 'g' , alpha = 0.5 , width = 0.4 , align = 'edge' ) plt . bar ( dates , red_errs , color = 'r' , alpha = 0.5 , width =- 0.4 , align = 'edge' ) plt . ylabel ( 'N Errors' ) plt . subplot ( 2 , 1 , 2 ) plt . title ( f \"Rate of start errors per day\" ) plt . plot ( dates , np . array ( green_errs ) / np . array ( green_starts ) * 100 , 'go-' ) plt . plot ( dates , np . array ( red_errs ) / np . array ( red_starts ) * 100 , 'ro-' ) plt . ylabel ( ' % E rrors' ) plt . xlabel ( 'Date' ) plt . grid () plt . show () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"CountCameraErrors"},{"location":"scripts/CountCameraErrors/#countcameraerrors","text":"Bases: KPFTranslatorFunction","title":"CountCameraErrors"},{"location":"scripts/CountCameraErrors/#kpf.engineering.analysis.CountCameraErrors.CountCameraErrors--description","text":"","title":"Description"},{"location":"scripts/CountCameraErrors/#kpf.engineering.analysis.CountCameraErrors.CountCameraErrors--parameters","text":"Source code in kpf/engineering/analysis/CountCameraErrors.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class CountCameraErrors ( KPFTranslatorFunction ): '''# Description # Parameters ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): output_file = Path ( '/s/sdata1701/KPFTranslator_logs/camera_errors.txt' ) if output_file . exists (): output_file . unlink () date = datetime . strptime ( '2023-06-01' , '%Y-%m- %d ' ) total_green_errors = 0 total_green_starts = 0 total_red_errors = 0 total_red_starts = 0 print ( f \"From { date . strftime ( '%Y-%m- %d ' ) } \" ) dates = [] green_errs = [] red_errs = [] green_starts = [] red_starts = [] with open ( output_file , 'w' ) as f : while date < datetime . utcnow () - timedelta ( days = 1 ): date_str = date . strftime ( '%Y-%m- %d ' ) ng_starts , nr_starts = count_start_state_instances ( date = date_str ) ng_errs , nr_errs = count_start_state_errors ( date = date_str ) dates . append ( date ) green_errs . append ( ng_errs ) red_errs . append ( nr_errs ) green_starts . append ( ng_starts ) red_starts . append ( nr_starts ) total_green_errors += ng_errs total_green_starts += ng_starts total_red_errors += nr_errs total_red_starts += nr_starts line = f \" { date_str } , { ng_errs } , { ng_starts } , { nr_errs } , { nr_starts } \" # print(line) f . write ( f \" { line } \\n \" ) date += timedelta ( days = 1 ) print ( f \"Through { date . strftime ( '%Y-%m- %d ' ) } \" ) green_error_rate = total_green_errors / total_green_starts print ( f \"Green error rate = { green_error_rate : .2% } ( { total_green_errors } / { total_green_starts } )\" ) red_error_rate = total_red_errors / total_red_starts print ( f \"Red error rate = { red_error_rate : .2% } ( { total_red_errors } / { total_red_starts } )\" ) plt . figure ( figsize = ( 12 , 8 )) plt . subplot ( 2 , 1 , 1 ) plt . title ( f \"Number of start errors per day\" ) plt . bar ( dates , green_errs , color = 'g' , alpha = 0.5 , width = 0.4 , align = 'edge' ) plt . bar ( dates , red_errs , color = 'r' , alpha = 0.5 , width =- 0.4 , align = 'edge' ) plt . ylabel ( 'N Errors' ) plt . subplot ( 2 , 1 , 2 ) plt . title ( f \"Rate of start errors per day\" ) plt . plot ( dates , np . array ( green_errs ) / np . array ( green_starts ) * 100 , 'go-' ) plt . plot ( dates , np . array ( red_errs ) / np . array ( red_starts ) * 100 , 'ro-' ) plt . ylabel ( ' % E rrors' ) plt . xlabel ( 'Date' ) plt . grid () plt . show () @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"Parameters"},{"location":"scripts/DisableSoCal/","text":"DisableSoCal Bases: KPFFunction Disables SoCal by setting kpfsocal.CAN_OPEN to No. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/DisableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DisableSoCal ( KPFFunction ): '''Disables SoCal by setting kpfsocal.CAN_OPEN to No. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 0' ) CAN_OPEN . write ( 0 ) @classmethod def post_condition ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 0' )","title":"DisableSoCal"},{"location":"scripts/DisableSoCal/#disablesocal","text":"Bases: KPFFunction Disables SoCal by setting kpfsocal.CAN_OPEN to No. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/DisableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class DisableSoCal ( KPFFunction ): '''Disables SoCal by setting kpfsocal.CAN_OPEN to No. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 0' ) CAN_OPEN . write ( 0 ) @classmethod def post_condition ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 0' )","title":"DisableSoCal"},{"location":"scripts/DisplayGuiderContinuous/","text":"DisplayGuiderContinuous Bases: KPFFunction Continuously display latest guider images to ds9 using xpaset . KTL Keywords Used: kpfguide.LASTFILE Source code in kpf/guider/DisplayGuiderContinuous.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class DisplayGuiderContinuous ( KPFFunction ): '''Continuously display latest guider images to ds9 using `xpaset`. KTL Keywords Used: - `kpfguide.LASTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): display_name = cfg . get ( 'display' , 'guider_xpa_target' , fallback = 'CRED2' ) lastfile = ktl . cache ( 'kpfguide' , 'LASTFILE' ) initial_lastfile = lastfile . read () while True : expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" is_there_a_newfile = ktl . waitFor ( expr , timeout = 10 ) if is_there_a_newfile is True : initial_lastfile = lastfile . read () print ( f \"Displaying { initial_lastfile } \" ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { initial_lastfile } \" , '<' , f \" { initial_lastfile } \" ] # log.debug(f\"Running: {' '.join(ds9cmd)}\") subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_cred2.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] # log.debug(f\"Running: {' '.join(overlaycmd)}\") subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args ): pass","title":"DisplayGuiderContinuous"},{"location":"scripts/DisplayGuiderContinuous/#displayguidercontinuous","text":"Bases: KPFFunction Continuously display latest guider images to ds9 using xpaset . KTL Keywords Used: kpfguide.LASTFILE Source code in kpf/guider/DisplayGuiderContinuous.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class DisplayGuiderContinuous ( KPFFunction ): '''Continuously display latest guider images to ds9 using `xpaset`. KTL Keywords Used: - `kpfguide.LASTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): display_name = cfg . get ( 'display' , 'guider_xpa_target' , fallback = 'CRED2' ) lastfile = ktl . cache ( 'kpfguide' , 'LASTFILE' ) initial_lastfile = lastfile . read () while True : expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" is_there_a_newfile = ktl . waitFor ( expr , timeout = 10 ) if is_there_a_newfile is True : initial_lastfile = lastfile . read () print ( f \"Displaying { initial_lastfile } \" ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { initial_lastfile } \" , '<' , f \" { initial_lastfile } \" ] # log.debug(f\"Running: {' '.join(ds9cmd)}\") subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_cred2.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] # log.debug(f\"Running: {' '.join(overlaycmd)}\") subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args ): pass","title":"DisplayGuiderContinuous"},{"location":"scripts/EastNorth/","text":"EastNorth Bases: KPFFunction Move the telescope a given distance in arcseconds East and/or North. Parameters: East ( float ) \u2013 Distance to move the telescope East in arcseconds. North ( float ) \u2013 Distance to move the telescope North in arcseconds. KTL Keywords Used: dcs.RAOFF dcs.DECOFF dcs.REL2CURR dcs.AXESTAT Source code in kpf/telescope/EastNorth.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class EastNorth ( KPFFunction ): '''Move the telescope a given distance in arcseconds East and/or North. Args: East (float): Distance to move the telescope East in arcseconds. North (float): Distance to move the telescope North in arcseconds. KTL Keywords Used: - `dcs.RAOFF` - `dcs.DECOFF` - `dcs.REL2CURR` - `dcs.AXESTAT` ''' @classmethod def pre_condition ( cls , args ): max_offset = cfg . getfloat ( 'telescope' , 'max_offset' , fallback = 900 ) check_input ( args , 'NodE' , allowed_types = [ int , float ], value_min =- max_offset , value_max = max_offset ) check_input ( args , 'NodN' , allowed_types = [ int , float ], value_min =- max_offset , value_max = max_offset ) @classmethod def perform ( cls , args ): dcsint = cfg . getint ( 'telescope' , 'telnr' , fallback = 1 ) dcs = ktl . cache ( f 'dcs { dcsint : 1d } ' ) if KPF_is_selected_instrument (): east = args . get ( 'NodE' , 0 ) north = args . get ( 'NodN' , 0 ) log . info ( f 'Ofsetting telescope: { east : .2f } { north : .2f } ' ) dcs [ 'RAOFF' ] . write ( east ) dcs [ 'DECOFF' ] . write ( north ) dcs [ 'REL2CURR' ] . write ( True ) else : INSTRUME = dcs [ 'INSTRUME' ] . read () log . error ( f 'Selected instrument is { INSTRUME } , not KPF. No telescope moves allowed.' ) @classmethod def post_condition ( cls , args ): if KPF_is_selected_instrument (): dcsint = cfg . getfloat ( 'telescope' , 'telnr' , fallback = 1 ) AXESTAT = ktl . cache ( f 'dcs { dcsint } ' , 'AXESTAT' ) tracking = AXESTAT . waitfor ( '==\"tracking\"' ) if tracking == False : raise FailedPostCondition ( 'dcs.AXESTAT did not return to \"tracking\"' , timeout = 20 ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'NodE' , type = float , help = \"Distance to move the telescope East in arcseconds\" ) parser . add_argument ( 'NodN' , type = float , help = \"Distance to move the telescope North in arcseconds\" ) return super () . add_cmdline_args ( parser )","title":"EastNorth"},{"location":"scripts/EastNorth/#eastnorth","text":"Bases: KPFFunction Move the telescope a given distance in arcseconds East and/or North. Parameters: East ( float ) \u2013 Distance to move the telescope East in arcseconds. North ( float ) \u2013 Distance to move the telescope North in arcseconds. KTL Keywords Used: dcs.RAOFF dcs.DECOFF dcs.REL2CURR dcs.AXESTAT Source code in kpf/telescope/EastNorth.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class EastNorth ( KPFFunction ): '''Move the telescope a given distance in arcseconds East and/or North. Args: East (float): Distance to move the telescope East in arcseconds. North (float): Distance to move the telescope North in arcseconds. KTL Keywords Used: - `dcs.RAOFF` - `dcs.DECOFF` - `dcs.REL2CURR` - `dcs.AXESTAT` ''' @classmethod def pre_condition ( cls , args ): max_offset = cfg . getfloat ( 'telescope' , 'max_offset' , fallback = 900 ) check_input ( args , 'NodE' , allowed_types = [ int , float ], value_min =- max_offset , value_max = max_offset ) check_input ( args , 'NodN' , allowed_types = [ int , float ], value_min =- max_offset , value_max = max_offset ) @classmethod def perform ( cls , args ): dcsint = cfg . getint ( 'telescope' , 'telnr' , fallback = 1 ) dcs = ktl . cache ( f 'dcs { dcsint : 1d } ' ) if KPF_is_selected_instrument (): east = args . get ( 'NodE' , 0 ) north = args . get ( 'NodN' , 0 ) log . info ( f 'Ofsetting telescope: { east : .2f } { north : .2f } ' ) dcs [ 'RAOFF' ] . write ( east ) dcs [ 'DECOFF' ] . write ( north ) dcs [ 'REL2CURR' ] . write ( True ) else : INSTRUME = dcs [ 'INSTRUME' ] . read () log . error ( f 'Selected instrument is { INSTRUME } , not KPF. No telescope moves allowed.' ) @classmethod def post_condition ( cls , args ): if KPF_is_selected_instrument (): dcsint = cfg . getfloat ( 'telescope' , 'telnr' , fallback = 1 ) AXESTAT = ktl . cache ( f 'dcs { dcsint } ' , 'AXESTAT' ) tracking = AXESTAT . waitfor ( '==\"tracking\"' ) if tracking == False : raise FailedPostCondition ( 'dcs.AXESTAT did not return to \"tracking\"' , timeout = 20 ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'NodE' , type = float , help = \"Distance to move the telescope East in arcseconds\" ) parser . add_argument ( 'NodN' , type = float , help = \"Distance to move the telescope North in arcseconds\" ) return super () . add_cmdline_args ( parser )","title":"EastNorth"},{"location":"scripts/EnableSoCal/","text":"EnableSoCal Bases: KPFFunction Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/EnableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class EnableSoCal ( KPFFunction ): '''Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 1' ) CAN_OPEN . write ( 1 ) @classmethod def post_condition ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 1' )","title":"EnableSoCal"},{"location":"scripts/EnableSoCal/#enablesocal","text":"Bases: KPFFunction Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. KTL Keywords Used: kpfsocal.CAN_OPEN Source code in kpf/socal/EnableSoCal.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class EnableSoCal ( KPFFunction ): '''Enables SoCal by setting kpfsocal.CAN_OPEN to Yes. KTL Keywords Used: - `kpfsocal.CAN_OPEN` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) log . info ( 'Setting kpfsocal.CAN_OPEN = 1' ) CAN_OPEN . write ( 1 ) @classmethod def post_condition ( cls , args ): CAN_OPEN = ktl . cache ( 'kpfsocal' , 'CAN_OPEN' ) success = CAN_OPEN . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.CAN_OPEN is not 1' )","title":"EnableSoCal"},{"location":"scripts/EndOfNight/","text":"EndOfNight Bases: KPFFunction Send KPF in to an end of night configuration. kpffiu.MODE = Stowed Power off FVCs Power off LED back illuminators close AO hatch HEPA on Send PCU to Home Parameters: AO ( bool ) \u2013 Close AO hatch, home PCU, and turn on HEPA? (default=True) KTL Keywords Used: kpfexpose.EXPOSE kpfconfig.SCRIPTNAME kpfconfig.SCRIPTPID kpfconfig.SCRIPTSTOP kpfconfig.SIMULCALSOURCE kpfconfig.ALLOWSCHEDULEDCALS Functions Called: kpf.ao.ControlAOHatch kpf.ao.TurnHepaOn kpf.ao.SendPCUtoHome kpf.fiu.ShutdownTipTilt kpf.fiu.ConfigureFIU kpf.fiu.WaitForConfigureFIU kpf.spectrograph.WaitForReady kpf.spectrograph.SetProgram kpf.spectrograph.SetObserver kpf.spectrograph.SetObject kpf.spectrograph.StopAgitator kpf.calbench.CalLampPower kpf.fvc.FVCPower kpf.fiu.StopTipTilt Source code in kpf/utils/EndOfNight.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class EndOfNight ( KPFFunction ): '''Send KPF in to an end of night configuration. - kpffiu.MODE = Stowed - Power off FVCs - Power off LED back illuminators - close AO hatch - HEPA on - Send PCU to Home Args: AO (bool): Close AO hatch, home PCU, and turn on HEPA? (default=True) KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfconfig.SCRIPTNAME` - `kpfconfig.SCRIPTPID` - `kpfconfig.SCRIPTSTOP` - `kpfconfig.SIMULCALSOURCE` - `kpfconfig.ALLOWSCHEDULEDCALS` Functions Called: - `kpf.ao.ControlAOHatch` - `kpf.ao.TurnHepaOn` - `kpf.ao.SendPCUtoHome` - `kpf.fiu.ShutdownTipTilt` - `kpf.fiu.ConfigureFIU` - `kpf.fiu.WaitForConfigureFIU` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetProgram` - `kpf.spectrograph.SetObserver` - `kpf.spectrograph.SetObject` - `kpf.spectrograph.StopAgitator` - `kpf.calbench.CalLampPower` - `kpf.fvc.FVCPower` - `kpf.fiu.StopTipTilt` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) script_running = scriptname not in [ '' , 'None' , None ] or pid >= 0 if script_running and args . get ( 'confirm' , False ) is True : log . error ( 'Non-interactive mode set and script is running' ) return if script_running : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running EndOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted End Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # Stop tip tilt and agitator StopTipTilt . execute ({}) StopAgitator . execute ({}) # Start FIU stow log . info ( 'Setting FIU mode to Stowed' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' , 'wait' : False }) # --------------------------------- # AO Shutdown # --------------------------------- if args . get ( 'AO' , True ) is True and args . get ( 'confirm' , False ) is False : msg = [ \"\" , \"--------------------------------------------------------------\" , \"Perform shutdown of AO? This will:\" , \" - Close the AO hatch\" , \" - Send the PCU to home\" , \"These steps should not be run if OSIRIS is in use.\" , \"\" , \"Do you wish to shutdown AO?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' , '' ]: log . debug ( 'User chose to shut down AO' ) log . info ( 'Closing AO Hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'closed' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) except Exception as e : log . error ( f \"Failure controlling AO hatch\" ) log . error ( e ) log . info ( 'Sending PCU stage to Home position' ) try : SendPCUtoHome . execute ({}) except Exception as e : log . error ( f \"Failure sending PCU to home\" ) log . error ( e ) # log.info('Turning on AO HEPA Filter System') # TurnHepaOn.execute({}) else : log . warning ( f 'User chose to skip AO shutdown' ) # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Power off FVCs for camera in [ 'SCI' , 'CAHK' , 'CAL' ]: FVCPower . execute ({ 'camera' : camera , 'power' : 'off' }) # Power off LEDs for LED in [ 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ]: CalLampPower . execute ({ 'lamp' : LED , 'power' : 'off' }) # Finish FIU shutdown WaitForConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Set PROGNAME log . info ( 'Clearing values for PROGNAME, OBSERVER, OBJECT' ) WaitForReady . execute ({}) SetProgram . execute ({ 'progname' : '' }) SetObserver . execute ({ 'observer' : '' }) SetObject . execute ({ 'Object' : '' }) # Power off Simulcal lamp calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'off' }) # Allow scheduled cals log . info ( 'Set ALLOWSCHEDULEDCALS to Yes' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) parser . add_argument ( \"--confirm\" , dest = \"confirm\" , default = False , action = \"store_true\" , help = \"Skip confirmation questions (script will be non interactive)?\" ) return super () . add_cmdline_args ( parser )","title":"EndOfNight"},{"location":"scripts/EndOfNight/#endofnight","text":"Bases: KPFFunction Send KPF in to an end of night configuration. kpffiu.MODE = Stowed Power off FVCs Power off LED back illuminators close AO hatch HEPA on Send PCU to Home Parameters: AO ( bool ) \u2013 Close AO hatch, home PCU, and turn on HEPA? (default=True) KTL Keywords Used: kpfexpose.EXPOSE kpfconfig.SCRIPTNAME kpfconfig.SCRIPTPID kpfconfig.SCRIPTSTOP kpfconfig.SIMULCALSOURCE kpfconfig.ALLOWSCHEDULEDCALS Functions Called: kpf.ao.ControlAOHatch kpf.ao.TurnHepaOn kpf.ao.SendPCUtoHome kpf.fiu.ShutdownTipTilt kpf.fiu.ConfigureFIU kpf.fiu.WaitForConfigureFIU kpf.spectrograph.WaitForReady kpf.spectrograph.SetProgram kpf.spectrograph.SetObserver kpf.spectrograph.SetObject kpf.spectrograph.StopAgitator kpf.calbench.CalLampPower kpf.fvc.FVCPower kpf.fiu.StopTipTilt Source code in kpf/utils/EndOfNight.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class EndOfNight ( KPFFunction ): '''Send KPF in to an end of night configuration. - kpffiu.MODE = Stowed - Power off FVCs - Power off LED back illuminators - close AO hatch - HEPA on - Send PCU to Home Args: AO (bool): Close AO hatch, home PCU, and turn on HEPA? (default=True) KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfconfig.SCRIPTNAME` - `kpfconfig.SCRIPTPID` - `kpfconfig.SCRIPTSTOP` - `kpfconfig.SIMULCALSOURCE` - `kpfconfig.ALLOWSCHEDULEDCALS` Functions Called: - `kpf.ao.ControlAOHatch` - `kpf.ao.TurnHepaOn` - `kpf.ao.SendPCUtoHome` - `kpf.fiu.ShutdownTipTilt` - `kpf.fiu.ConfigureFIU` - `kpf.fiu.WaitForConfigureFIU` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetProgram` - `kpf.spectrograph.SetObserver` - `kpf.spectrograph.SetObject` - `kpf.spectrograph.StopAgitator` - `kpf.calbench.CalLampPower` - `kpf.fvc.FVCPower` - `kpf.fiu.StopTipTilt` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) script_running = scriptname not in [ '' , 'None' , None ] or pid >= 0 if script_running and args . get ( 'confirm' , False ) is True : log . error ( 'Non-interactive mode set and script is running' ) return if script_running : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running EndOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted End Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # Stop tip tilt and agitator StopTipTilt . execute ({}) StopAgitator . execute ({}) # Start FIU stow log . info ( 'Setting FIU mode to Stowed' ) ConfigureFIU . execute ({ 'mode' : 'Stowed' , 'wait' : False }) # --------------------------------- # AO Shutdown # --------------------------------- if args . get ( 'AO' , True ) is True and args . get ( 'confirm' , False ) is False : msg = [ \"\" , \"--------------------------------------------------------------\" , \"Perform shutdown of AO? This will:\" , \" - Close the AO hatch\" , \" - Send the PCU to home\" , \"These steps should not be run if OSIRIS is in use.\" , \"\" , \"Do you wish to shutdown AO?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'y' , 'yes' , '' ]: log . debug ( 'User chose to shut down AO' ) log . info ( 'Closing AO Hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'closed' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) except Exception as e : log . error ( f \"Failure controlling AO hatch\" ) log . error ( e ) log . info ( 'Sending PCU stage to Home position' ) try : SendPCUtoHome . execute ({}) except Exception as e : log . error ( f \"Failure sending PCU to home\" ) log . error ( e ) # log.info('Turning on AO HEPA Filter System') # TurnHepaOn.execute({}) else : log . warning ( f 'User chose to skip AO shutdown' ) # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Power off FVCs for camera in [ 'SCI' , 'CAHK' , 'CAL' ]: FVCPower . execute ({ 'camera' : camera , 'power' : 'off' }) # Power off LEDs for LED in [ 'ExpMeterLED' , 'CaHKLED' , 'SciLED' , 'SkyLED' ]: CalLampPower . execute ({ 'lamp' : LED , 'power' : 'off' }) # Finish FIU shutdown WaitForConfigureFIU . execute ({ 'mode' : 'Stowed' }) # Set PROGNAME log . info ( 'Clearing values for PROGNAME, OBSERVER, OBJECT' ) WaitForReady . execute ({}) SetProgram . execute ({ 'progname' : '' }) SetObserver . execute ({ 'observer' : '' }) SetObject . execute ({ 'Object' : '' }) # Power off Simulcal lamp calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'off' }) # Allow scheduled cals log . info ( 'Set ALLOWSCHEDULEDCALS to Yes' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) parser . add_argument ( \"--confirm\" , dest = \"confirm\" , default = False , action = \"store_true\" , help = \"Skip confirmation questions (script will be non interactive)?\" ) return super () . add_cmdline_args ( parser )","title":"EndOfNight"},{"location":"scripts/EnterLowPowerMode/","text":"EnterLowPowerMode Bases: KPFFunction Set KPF to a low power mode. This is intended for use during power outages. This reduces power use in the AO electronics room. We do not currently recommend any changes in the basement due to the sensitivity of the spectrograph to thermal changes. Procedure: If a script is running exit or terminate it (depending on --force arg) Disable HK detector Stop HK cooling Power off HK systems: J1, J2, J5 Stop CRED2 exposures (CONTINUOUS and SAVE) Stop CRED2 cooling (if on) Power off CRED2 (K2, K3) KTL Keywords Used: kpfconfig.CA_HK_ENABLED kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% kpfpower.OUTLET_K2% kpfpower.OUTLET_K3% kpfmon.HKTEMPDIS kpfmon.ST_EXPOSE2DIS kpfmon.OUTLET_J1_OODIS kpfmon.OUTLET_J2_OODIS kpfmon.OUTLET_J5_OODIS kpfmon.OUTLET_K2_OODIS kpfmon.OUTLET_K3_OODIS kpf_hk.COOLING kpf_hk.EXPSTATE kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/scripts/EnterLowPowerMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class EnterLowPowerMode ( KPFFunction ): '''Set KPF to a low power mode. This is intended for use during power outages. This reduces power use in the AO electronics room. We do not currently recommend any changes in the basement due to the sensitivity of the spectrograph to thermal changes. Procedure: - If a script is running exit or terminate it (depending on --force arg) - Disable HK detector - Stop HK cooling - Power off HK systems: J1, J2, J5 - Stop CRED2 exposures (CONTINUOUS and SAVE) - Stop CRED2 cooling (if on) - Power off CRED2 (K2, K3) KTL Keywords Used: - `kpfconfig.CA_HK_ENABLED` - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` - `kpfpower.OUTLET_K2%` - `kpfpower.OUTLET_K3%` - `kpfmon.HKTEMPDIS` - `kpfmon.ST_EXPOSE2DIS` - `kpfmon.OUTLET_J1_OODIS` - `kpfmon.OUTLET_J2_OODIS` - `kpfmon.OUTLET_J5_OODIS` - `kpfmon.OUTLET_K2_OODIS` - `kpfmon.OUTLET_K3_OODIS` - `kpf_hk.COOLING` - `kpf_hk.EXPSTATE` - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CA_HK_ENABLED = ktl . cache ( 'kpfconfig' , 'CA_HK_ENABLED' ) kpfpower = ktl . cache ( 'kpfpower' ) kpfmon = ktl . cache ( 'kpfmon' ) log . warning ( 'Configuring KPF for Low Power Mode' ) # Power down Ca HK detector systems kpf_hk = ktl . cache ( 'kpf_hk' ) log . warning ( 'Disabling Ca HK detector' ) CA_HK_ENABLED . write ( 'No' ) log . warning ( 'Disabling HKTEMP alarm for next 24 hours' ) kpfmon [ 'HKTEMPDIS' ] . write ( '1 day hence' ) log . warning ( 'Disabling ST_EXPOSE2 alarm for next 24 hours' ) kpfmon [ 'ST_EXPOSE2DIS' ] . write ( '1 day hence' ) log . warning ( 'Turning Ca HK detector cooling off' ) kpf_hk [ 'COOLING' ] . write ( 'off' ) time . sleep ( 5 ) log . warning ( 'Powering off Ca HK detector systems' ) # Wait for HK ready to avoid confusing kpfexpose EXPLAIN% log . warning ( 'Waiting for kpf_hk.EXPSTATE = Ready' ) ready = kpf_hk [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) while ready == False : log . warning ( 'Asking for user input' ) print () print ( \"###############################################################\" ) print ( \" Continue waiting for hpf_hk.EXPSTATE=Ready or shut down now?\" ) print () print ( \" Wait (w) or Abort (a)? [w]\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: return else : log . debug ( 'Waiting for kpf_hk.EXPSTATE = Ready' ) ready = kpf_hk [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J1_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J1_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J1_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J1' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J2_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J2_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J2' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J5_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J5_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J5_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J5' ] . write ( 'Off' ) # Power down CRED2 detector systems kpfguide = ktl . cache ( 'kpfguide' ) log . warning ( 'Powering off CRED2 detector systems' ) kpfguide [ 'CONTINUOUS' ] . write ( 'Inactive' ) kpfguide [ 'SAVE' ] . write ( 'Inactive' ) time . sleep ( 5 ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_K2_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_K2_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_K2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K2' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_K3_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_K3_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_K3_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K3' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args ): pass","title":"EnterLowPowerMode"},{"location":"scripts/EnterLowPowerMode/#enterlowpowermode","text":"Bases: KPFFunction Set KPF to a low power mode. This is intended for use during power outages. This reduces power use in the AO electronics room. We do not currently recommend any changes in the basement due to the sensitivity of the spectrograph to thermal changes. Procedure: If a script is running exit or terminate it (depending on --force arg) Disable HK detector Stop HK cooling Power off HK systems: J1, J2, J5 Stop CRED2 exposures (CONTINUOUS and SAVE) Stop CRED2 cooling (if on) Power off CRED2 (K2, K3) KTL Keywords Used: kpfconfig.CA_HK_ENABLED kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% kpfpower.OUTLET_K2% kpfpower.OUTLET_K3% kpfmon.HKTEMPDIS kpfmon.ST_EXPOSE2DIS kpfmon.OUTLET_J1_OODIS kpfmon.OUTLET_J2_OODIS kpfmon.OUTLET_J5_OODIS kpfmon.OUTLET_K2_OODIS kpfmon.OUTLET_K3_OODIS kpf_hk.COOLING kpf_hk.EXPSTATE kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/scripts/EnterLowPowerMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class EnterLowPowerMode ( KPFFunction ): '''Set KPF to a low power mode. This is intended for use during power outages. This reduces power use in the AO electronics room. We do not currently recommend any changes in the basement due to the sensitivity of the spectrograph to thermal changes. Procedure: - If a script is running exit or terminate it (depending on --force arg) - Disable HK detector - Stop HK cooling - Power off HK systems: J1, J2, J5 - Stop CRED2 exposures (CONTINUOUS and SAVE) - Stop CRED2 cooling (if on) - Power off CRED2 (K2, K3) KTL Keywords Used: - `kpfconfig.CA_HK_ENABLED` - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` - `kpfpower.OUTLET_K2%` - `kpfpower.OUTLET_K3%` - `kpfmon.HKTEMPDIS` - `kpfmon.ST_EXPOSE2DIS` - `kpfmon.OUTLET_J1_OODIS` - `kpfmon.OUTLET_J2_OODIS` - `kpfmon.OUTLET_J5_OODIS` - `kpfmon.OUTLET_K2_OODIS` - `kpfmon.OUTLET_K3_OODIS` - `kpf_hk.COOLING` - `kpf_hk.EXPSTATE` - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): CA_HK_ENABLED = ktl . cache ( 'kpfconfig' , 'CA_HK_ENABLED' ) kpfpower = ktl . cache ( 'kpfpower' ) kpfmon = ktl . cache ( 'kpfmon' ) log . warning ( 'Configuring KPF for Low Power Mode' ) # Power down Ca HK detector systems kpf_hk = ktl . cache ( 'kpf_hk' ) log . warning ( 'Disabling Ca HK detector' ) CA_HK_ENABLED . write ( 'No' ) log . warning ( 'Disabling HKTEMP alarm for next 24 hours' ) kpfmon [ 'HKTEMPDIS' ] . write ( '1 day hence' ) log . warning ( 'Disabling ST_EXPOSE2 alarm for next 24 hours' ) kpfmon [ 'ST_EXPOSE2DIS' ] . write ( '1 day hence' ) log . warning ( 'Turning Ca HK detector cooling off' ) kpf_hk [ 'COOLING' ] . write ( 'off' ) time . sleep ( 5 ) log . warning ( 'Powering off Ca HK detector systems' ) # Wait for HK ready to avoid confusing kpfexpose EXPLAIN% log . warning ( 'Waiting for kpf_hk.EXPSTATE = Ready' ) ready = kpf_hk [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) while ready == False : log . warning ( 'Asking for user input' ) print () print ( \"###############################################################\" ) print ( \" Continue waiting for hpf_hk.EXPSTATE=Ready or shut down now?\" ) print () print ( \" Wait (w) or Abort (a)? [w]\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: return else : log . debug ( 'Waiting for kpf_hk.EXPSTATE = Ready' ) ready = kpf_hk [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J1_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J1_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J1_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J1' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J2_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J2_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J2' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_J5_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_J5_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_J5_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J5' ] . write ( 'Off' ) # Power down CRED2 detector systems kpfguide = ktl . cache ( 'kpfguide' ) log . warning ( 'Powering off CRED2 detector systems' ) kpfguide [ 'CONTINUOUS' ] . write ( 'Inactive' ) kpfguide [ 'SAVE' ] . write ( 'Inactive' ) time . sleep ( 5 ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_K2_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_K2_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_K2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K2' ] . write ( 'Off' ) log . warning ( f \"Disabling { kpfpower [ 'OUTLET_K3_NAME' ] . read () } alarm for next 24 hours\" ) kpfmon [ 'OUTLET_K3_OODIS' ] . write ( '1 day hence' ) log . warning ( f \"Powering off { kpfpower [ 'OUTLET_K3_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K3' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args ): pass","title":"EnterLowPowerMode"},{"location":"scripts/EstimateOBDuration/","text":"EstimateOBDuration Bases: KPFScript Estimate the duration of the input OB. Uses estimates of instrument configuration time, slew time, acquire time, and readout time and combines those with the information in the observing block to estimate how long it will take to execute the observing block. Parameters: fast ( bool ) \u2013 Estimate the duration assuming fast read mode? OB ( ObservingBlock ) \u2013 A valid observing block (OB). Functions Called: kpf.calbench.standardize_lamp_name Source code in kpf/scripts/EstimateOBDuration.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class EstimateOBDuration ( KPFScript ): '''Estimate the duration of the input OB. Uses estimates of instrument configuration time, slew time, acquire time, and readout time and combines those with the information in the observing block to estimate how long it will take to execute the observing block. Args: fast (bool): Estimate the duration assuming fast read mode? OB (ObservingBlock): A valid observing block (OB). Functions Called: - `kpf.calbench.standardize_lamp_name` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if OB is not None and type ( OB ) != ObservingBlock : OB = ObservingBlock ( OB ) fast = args . get ( 'fast' , False ) duration = 0 if OB . Calibrations is not None : duration += estimate_calibration_time ( OB . Calibrations , cfg , fast = fast ) if OB . Observations is not None : duration += estimate_observation_time ( OB . Observations , cfg , fast = fast ) if args . get ( 'verbose' , False ): decimal_minutes = duration / 60 hours = int ( np . floor ( decimal_minutes / 60 )) minutes = int ( np . ceil ( decimal_minutes % 60 )) print ( f \"# Estimated Duration = { hours : 02d } : { minutes : 02d } \" ) return duration / 60 @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--fast' , '--fastread' , dest = \"fast\" , default = False , action = \"store_true\" , help = 'Use fast readout mode times for estimate?' ) parser . add_argument ( '-v' , '--verbose' , dest = \"verbose\" , default = False , action = \"store_true\" , help = 'Be verbose and print to screen?' ) return super () . add_cmdline_args ( parser )","title":"EstimateOBDuration"},{"location":"scripts/EstimateOBDuration/#estimateobduration","text":"Bases: KPFScript Estimate the duration of the input OB. Uses estimates of instrument configuration time, slew time, acquire time, and readout time and combines those with the information in the observing block to estimate how long it will take to execute the observing block. Parameters: fast ( bool ) \u2013 Estimate the duration assuming fast read mode? OB ( ObservingBlock ) \u2013 A valid observing block (OB). Functions Called: kpf.calbench.standardize_lamp_name Source code in kpf/scripts/EstimateOBDuration.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 class EstimateOBDuration ( KPFScript ): '''Estimate the duration of the input OB. Uses estimates of instrument configuration time, slew time, acquire time, and readout time and combines those with the information in the observing block to estimate how long it will take to execute the observing block. Args: fast (bool): Estimate the duration assuming fast read mode? OB (ObservingBlock): A valid observing block (OB). Functions Called: - `kpf.calbench.standardize_lamp_name` ''' @classmethod def pre_condition ( cls , args , OB = None ): pass @classmethod def perform ( cls , args , OB = None ): if OB is not None and type ( OB ) != ObservingBlock : OB = ObservingBlock ( OB ) fast = args . get ( 'fast' , False ) duration = 0 if OB . Calibrations is not None : duration += estimate_calibration_time ( OB . Calibrations , cfg , fast = fast ) if OB . Observations is not None : duration += estimate_observation_time ( OB . Observations , cfg , fast = fast ) if args . get ( 'verbose' , False ): decimal_minutes = duration / 60 hours = int ( np . floor ( decimal_minutes / 60 )) minutes = int ( np . ceil ( decimal_minutes % 60 )) print ( f \"# Estimated Duration = { hours : 02d } : { minutes : 02d } \" ) return duration / 60 @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--fast' , '--fastread' , dest = \"fast\" , default = False , action = \"store_true\" , help = 'Use fast readout mode times for estimate?' ) parser . add_argument ( '-v' , '--verbose' , dest = \"verbose\" , default = False , action = \"store_true\" , help = 'Be verbose and print to screen?' ) return super () . add_cmdline_args ( parser )","title":"EstimateOBDuration"},{"location":"scripts/FVCPower/","text":"FVCPower Bases: KPFFunction Turn on or off the power for the specified FVC camera. Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL power ( str ) \u2013 The desired state. Allowed values: on or off KTL Keywords Used: kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/FVCPower.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class FVCPower ( KPFFunction ): '''Turn on or off the power for the specified FVC camera. Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL power (str): The desired state. Allowed values: on or off KTL Keywords Used: - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' ]) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) dest = args . get ( 'power' ) if powerkw . read () . lower () != dest . lower (): log . info ( f \"Turning { dest } { camera } FVC\" ) powerkw . write ( args . get ( 'power' )) shim = cfg . getfloat ( 'times' , 'fvc_command_timeshim' , fallback = 2 ) time . sleep ( shim ) @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 1 ) dest = args . get ( 'power' ) success = powerkw . waitFor ( f \"== ' { dest } '\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( powerkw . read (), dest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' ], help = 'The FVC camera' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser )","title":"FVCPower"},{"location":"scripts/FVCPower/#fvcpower","text":"Bases: KPFFunction Turn on or off the power for the specified FVC camera. Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL power ( str ) \u2013 The desired state. Allowed values: on or off KTL Keywords Used: kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/FVCPower.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class FVCPower ( KPFFunction ): '''Turn on or off the power for the specified FVC camera. Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL power (str): The desired state. Allowed values: on or off KTL Keywords Used: - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' ]) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) dest = args . get ( 'power' ) if powerkw . read () . lower () != dest . lower (): log . info ( f \"Turning { dest } { camera } FVC\" ) powerkw . write ( args . get ( 'power' )) shim = cfg . getfloat ( 'times' , 'fvc_command_timeshim' , fallback = 2 ) time . sleep ( shim ) @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 1 ) dest = args . get ( 'power' ) success = powerkw . waitFor ( f \"== ' { dest } '\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( powerkw . read (), dest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' ], help = 'The FVC camera' ) parser . add_argument ( 'power' , type = str , choices = [ 'on' , 'off' ], help = 'Desired power state: \"on\" or \"off\"' ) return super () . add_cmdline_args ( parser )","title":"FVCPower"},{"location":"scripts/Fit2DGridSearch/","text":"Fit2DGridSearch Bases: KPFTranslatorFunction Description Take two 1D grid search runs (one in X and one in Y) ... Parameters None Source code in kpf/engineering/analysis/Fit2DGridSearch.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class Fit2DGridSearch ( KPFTranslatorFunction ): '''# Description Take two 1D grid search runs (one in X and one in Y) ... # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # 20240718at140930_GridSearch.log # TipTilt20240718at140930_GridSearch.fits log_file_x = Path ( args . get ( 'logfileX' )) fgs_cube_fileX = log_file_x . parent / Path ( f 'TipTilt { log_file_x . stem } .fits' ) log_file_y = Path ( args . get ( 'logfileY' )) fgs_cube_fileY = log_file_y . parent / Path ( f 'TipTilt { log_file_y . stem } .fits' ) # Try to determine targname/comment try : with open ( log_file_x ) as FO : lines = FO . readlines () for line in lines [: 60 ]: m_comment = re . search ( \"comment: (.*)\" , line ) if m_comment is not None : comment = m_comment . groups ()[ 0 ] . strip ( ' \\n ' ) log . info ( f \" Log Comment: { comment } \" ) except : comment = '' fit_2D_fiber_center ( fgs_cube_fileX , fgs_cube_fileY , xcent = args . get ( 'xfit' ), ycent = args . get ( 'yfit' ), targname = comment ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfileX' , type = str , help = \"The GridSearch log file for the X pixel scan\" ) parser . add_argument ( 'logfileY' , type = str , help = \"The GridSearch log file for the Y pixel scan\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Fit2DGridSearch"},{"location":"scripts/Fit2DGridSearch/#fit2dgridsearch","text":"Bases: KPFTranslatorFunction","title":"Fit2DGridSearch"},{"location":"scripts/Fit2DGridSearch/#kpf.engineering.analysis.Fit2DGridSearch.Fit2DGridSearch--description","text":"Take two 1D grid search runs (one in X and one in Y) ...","title":"Description"},{"location":"scripts/Fit2DGridSearch/#kpf.engineering.analysis.Fit2DGridSearch.Fit2DGridSearch--parameters","text":"None Source code in kpf/engineering/analysis/Fit2DGridSearch.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class Fit2DGridSearch ( KPFTranslatorFunction ): '''# Description Take two 1D grid search runs (one in X and one in Y) ... # Parameters None ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): # 20240718at140930_GridSearch.log # TipTilt20240718at140930_GridSearch.fits log_file_x = Path ( args . get ( 'logfileX' )) fgs_cube_fileX = log_file_x . parent / Path ( f 'TipTilt { log_file_x . stem } .fits' ) log_file_y = Path ( args . get ( 'logfileY' )) fgs_cube_fileY = log_file_y . parent / Path ( f 'TipTilt { log_file_y . stem } .fits' ) # Try to determine targname/comment try : with open ( log_file_x ) as FO : lines = FO . readlines () for line in lines [: 60 ]: m_comment = re . search ( \"comment: (.*)\" , line ) if m_comment is not None : comment = m_comment . groups ()[ 0 ] . strip ( ' \\n ' ) log . info ( f \" Log Comment: { comment } \" ) except : comment = '' fit_2D_fiber_center ( fgs_cube_fileX , fgs_cube_fileY , xcent = args . get ( 'xfit' ), ycent = args . get ( 'yfit' ), targname = comment ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'logfileX' , type = str , help = \"The GridSearch log file for the X pixel scan\" ) parser . add_argument ( 'logfileY' , type = str , help = \"The GridSearch log file for the Y pixel scan\" ) parser . add_argument ( \"--xfit\" , dest = \"xfit\" , type = float , default = 335.5 , help = \"The X pixel position to use as the center when overlaying the model.\" ) parser . add_argument ( \"--yfit\" , dest = \"yfit\" , type = float , default = 258 , help = \"The X pixel position to use as the center when overlaying the model.\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Parameters"},{"location":"scripts/GetExecutionHistory/","text":"GetExecutionHistory Bases: KPFFunction Get one night's worth of history entries from the KPF-CC database API. Source code in kpf/observatoryAPIs/GetExecutionHistory.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GetExecutionHistory ( KPFFunction ): '''Get one night's worth of history entries from the KPF-CC database API. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): utdate = args . get ( 'utdate' , 'today' ) return getObservingBlockHistory ( utdate = utdate ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'utdate' , type = str , default = 'today' , help = 'The UT date to retrieve.' ) return super () . add_cmdline_args ( parser )","title":"GetExecutionHistory"},{"location":"scripts/GetExecutionHistory/#getexecutionhistory","text":"Bases: KPFFunction Get one night's worth of history entries from the KPF-CC database API. Source code in kpf/observatoryAPIs/GetExecutionHistory.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GetExecutionHistory ( KPFFunction ): '''Get one night's worth of history entries from the KPF-CC database API. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): utdate = args . get ( 'utdate' , 'today' ) return getObservingBlockHistory ( utdate = utdate ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'utdate' , type = str , default = 'today' , help = 'The UT date to retrieve.' ) return super () . add_cmdline_args ( parser )","title":"GetExecutionHistory"},{"location":"scripts/GetGaiaStars/","text":"GetGaiaStars Bases: KPFFunction Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. Parameters: file ( str ) \u2013 The file to retrieve stars for. Source code in kpf/guider/GetGaiaStars.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class GetGaiaStars ( KPFFunction ): '''Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. Args: file (str): The file to retrieve stars for. ''' @classmethod def pre_condition ( cls , args ): if Vizier is None : raise FailedPreCondition ( 'Unable to import astroquery.vizier' ) file = Path ( args . get ( 'file' , '/tmp/CRED2.fits' )) . expanduser () . absolute () if file . exists () is False : raise FailedPreCondition ( f 'Fould not find input file: { file } ' ) @classmethod def perform ( cls , args ): catalog_id = cfg . get ( 'stellar_catalog' , 'catalog_id' , fallback = 'I/345/gaia2' ) search_radius = cfg . getfloat ( 'stellar_catalog' , 'search_radius' , fallback = 28 ) ds9_color = cfg . get ( 'stellar_catalog' , 'ds9_color' , fallback = 'cyan' ) ds9_font = cfg . get ( 'stellar_catalog' , 'ds9_font' , fallback = 'helvetica 10 normal roman' ) requery_threshold = cfg . getfloat ( 'stellar_catalog' , 'requery_threshold' , fallback = 5 ) region_file = Path ( '~/.CRED2_auto_regions.reg' ) . expanduser () cntr_file = Path ( '~/.CRED2_auto_regions.cntr' ) . expanduser () file = Path ( args . get ( 'file' , './junk.fits' )) . expanduser () . absolute () # hdul = fits.open(file) header = fits . getheader ( file ) w = WCS ( header ) # cntr = w.pixel_to_world(hdul[0].data.shape[0]/2, hdul[0].data.shape[1]/2) cntr = w . pixel_to_world ( int ( header . get ( 'NAXIS2' )) / 2 , int ( header . get ( 'NAXIS1' )) / 2 ) if cntr_file . exists () is False : with open ( cntr_file , 'w' ) as FO : FO . write ( cntr . to_string ( 'hmsdms' , precision = 2 )) else : with open ( cntr_file , 'r' ) as FO : cntr_file_string = FO . readlines () file_cntr = SkyCoord ( cntr_file_string , unit = ( u . hourangle , u . deg ), frame = 'icrs' ) sep = file_cntr . separation ( cntr ) # If we're in a new position, query for a new catalog of stars and # write a new region file if sep [ 0 ] . to ( u . arcsec ) . value > requery_threshold : print ( f 'Querying for catalog: { cntr . to_string ( \"hmsdms\" , precision = 2 ) } ' ) gaia = Vizier . query_region ( cntr , radius = search_radius * u . arcsec , catalog = catalog_id )[ 0 ] regions = [ f '# Region file format: DS9 version 4.1' , f 'global color= { ds9_color } dashlist=8 3 width=1 font=\" { ds9_font } \"' , ] for star in gaia : sc = SkyCoord ( star [ 'RA_ICRS' ], star [ 'DE_ICRS' ], unit = ( u . deg , u . deg ), frame = 'icrs' ) coord_string = sc . to_string ( 'hmsdms' , sep = ':' , precision = 2 ) . replace ( ' ' , ',' ) newline = f \"circle( { coord_string } ,0.5 \\\" )\" # \\# text=\\{\"#\\}\" newline += \" # text={\" newline += f \" { star [ 'RPmag' ] : .1f } \" newline += \"}\" regions . append ( newline ) if region_file . exists (): region_file . unlink () with open ( region_file , 'w' ) as FO : for line in regions : FO . write ( line + ' \\n ' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'file' , type = str , help = 'The CRED2 file to retrieve stars for' ) return super () . add_cmdline_args ( parser )","title":"GetGaiaStars"},{"location":"scripts/GetGaiaStars/#getgaiastars","text":"Bases: KPFFunction Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. Parameters: file ( str ) \u2013 The file to retrieve stars for. Source code in kpf/guider/GetGaiaStars.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class GetGaiaStars ( KPFFunction ): '''Build a ds9 region file of Gaia catalog stars which ought to be present in the specified guider image. Args: file (str): The file to retrieve stars for. ''' @classmethod def pre_condition ( cls , args ): if Vizier is None : raise FailedPreCondition ( 'Unable to import astroquery.vizier' ) file = Path ( args . get ( 'file' , '/tmp/CRED2.fits' )) . expanduser () . absolute () if file . exists () is False : raise FailedPreCondition ( f 'Fould not find input file: { file } ' ) @classmethod def perform ( cls , args ): catalog_id = cfg . get ( 'stellar_catalog' , 'catalog_id' , fallback = 'I/345/gaia2' ) search_radius = cfg . getfloat ( 'stellar_catalog' , 'search_radius' , fallback = 28 ) ds9_color = cfg . get ( 'stellar_catalog' , 'ds9_color' , fallback = 'cyan' ) ds9_font = cfg . get ( 'stellar_catalog' , 'ds9_font' , fallback = 'helvetica 10 normal roman' ) requery_threshold = cfg . getfloat ( 'stellar_catalog' , 'requery_threshold' , fallback = 5 ) region_file = Path ( '~/.CRED2_auto_regions.reg' ) . expanduser () cntr_file = Path ( '~/.CRED2_auto_regions.cntr' ) . expanduser () file = Path ( args . get ( 'file' , './junk.fits' )) . expanduser () . absolute () # hdul = fits.open(file) header = fits . getheader ( file ) w = WCS ( header ) # cntr = w.pixel_to_world(hdul[0].data.shape[0]/2, hdul[0].data.shape[1]/2) cntr = w . pixel_to_world ( int ( header . get ( 'NAXIS2' )) / 2 , int ( header . get ( 'NAXIS1' )) / 2 ) if cntr_file . exists () is False : with open ( cntr_file , 'w' ) as FO : FO . write ( cntr . to_string ( 'hmsdms' , precision = 2 )) else : with open ( cntr_file , 'r' ) as FO : cntr_file_string = FO . readlines () file_cntr = SkyCoord ( cntr_file_string , unit = ( u . hourangle , u . deg ), frame = 'icrs' ) sep = file_cntr . separation ( cntr ) # If we're in a new position, query for a new catalog of stars and # write a new region file if sep [ 0 ] . to ( u . arcsec ) . value > requery_threshold : print ( f 'Querying for catalog: { cntr . to_string ( \"hmsdms\" , precision = 2 ) } ' ) gaia = Vizier . query_region ( cntr , radius = search_radius * u . arcsec , catalog = catalog_id )[ 0 ] regions = [ f '# Region file format: DS9 version 4.1' , f 'global color= { ds9_color } dashlist=8 3 width=1 font=\" { ds9_font } \"' , ] for star in gaia : sc = SkyCoord ( star [ 'RA_ICRS' ], star [ 'DE_ICRS' ], unit = ( u . deg , u . deg ), frame = 'icrs' ) coord_string = sc . to_string ( 'hmsdms' , sep = ':' , precision = 2 ) . replace ( ' ' , ',' ) newline = f \"circle( { coord_string } ,0.5 \\\" )\" # \\# text=\\{\"#\\}\" newline += \" # text={\" newline += f \" { star [ 'RPmag' ] : .1f } \" newline += \"}\" regions . append ( newline ) if region_file . exists (): region_file . unlink () with open ( region_file , 'w' ) as FO : for line in regions : FO . write ( line + ' \\n ' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'file' , type = str , help = 'The CRED2 file to retrieve stars for' ) return super () . add_cmdline_args ( parser )","title":"GetGaiaStars"},{"location":"scripts/GetKPFCCObservingBlocks/","text":"GetKPFCCObservingBlocks Bases: KPFFunction Get all the ObservingBlocks from all of the programs using the KPF-CC instrument on the current semester schedule. Functions Called: kpf.observatoryAPIs.GetScheduledPrograms kpf.observatoryAPIs.GetObservingBlocksByProgram Source code in kpf/observatoryAPIs/GetKPFCCObservingBlocks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class GetKPFCCObservingBlocks ( KPFFunction ): '''Get all the ObservingBlocks from all of the programs using the KPF-CC instrument on the current semester schedule. Functions Called: - `kpf.observatoryAPIs.GetScheduledPrograms` - `kpf.observatoryAPIs.GetObservingBlocksByProgram` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Getting OBs for all KPF-CC programs this semester' ) OBs = [] classical , cadence = GetScheduledPrograms . execute ({ 'semester' : 'current' }) progIDs = set ([ p [ 'ProjCode' ] for p in cadence ]) # Iterate of KPF-CC programIDs and retrieve their OBs from DB for i , progID in enumerate ( progIDs ): log . debug ( f 'Retrieving OBs for { progID } ' ) programOBs = GetObservingBlocksByProgram . execute ({ 'program' : progID }) OBs . extend ( programOBs ) log . info ( f 'Retrieved { len ( OBs ) } OBs in KPF-CC programs' ) # Save to files if requested if args . get ( 'save' , False ) == True : semester , start , end = get_semester_dates ( datetime . datetime . now ()) OBpath = Path ( '/s/sdata1701/OBs/KPFCC' ) / semester if OBpath . exists () is False : OBpath . mkdir ( mode = 0o777 ) log . info ( f 'Writing { len ( OBs ) } OBs to disk at: { OBpath } ' ) for OB in OBs : OBfile = OBpath / f \" { str ( OB . Target . TargetName ) . replace ( ' ' , '_' ) } .yaml\" log . debug ( f ' Writing: { OBfile . name } ' ) OB . write_to ( OBfile , overwrite = True ) else : return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--save' , dest = \"save\" , default = False , action = \"store_true\" , help = 'Save OBs to disk?' ) return super () . add_cmdline_args ( parser )","title":"GetKPFCCObservingBlocks"},{"location":"scripts/GetKPFCCObservingBlocks/#getkpfccobservingblocks","text":"Bases: KPFFunction Get all the ObservingBlocks from all of the programs using the KPF-CC instrument on the current semester schedule. Functions Called: kpf.observatoryAPIs.GetScheduledPrograms kpf.observatoryAPIs.GetObservingBlocksByProgram Source code in kpf/observatoryAPIs/GetKPFCCObservingBlocks.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class GetKPFCCObservingBlocks ( KPFFunction ): '''Get all the ObservingBlocks from all of the programs using the KPF-CC instrument on the current semester schedule. Functions Called: - `kpf.observatoryAPIs.GetScheduledPrograms` - `kpf.observatoryAPIs.GetObservingBlocksByProgram` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Getting OBs for all KPF-CC programs this semester' ) OBs = [] classical , cadence = GetScheduledPrograms . execute ({ 'semester' : 'current' }) progIDs = set ([ p [ 'ProjCode' ] for p in cadence ]) # Iterate of KPF-CC programIDs and retrieve their OBs from DB for i , progID in enumerate ( progIDs ): log . debug ( f 'Retrieving OBs for { progID } ' ) programOBs = GetObservingBlocksByProgram . execute ({ 'program' : progID }) OBs . extend ( programOBs ) log . info ( f 'Retrieved { len ( OBs ) } OBs in KPF-CC programs' ) # Save to files if requested if args . get ( 'save' , False ) == True : semester , start , end = get_semester_dates ( datetime . datetime . now ()) OBpath = Path ( '/s/sdata1701/OBs/KPFCC' ) / semester if OBpath . exists () is False : OBpath . mkdir ( mode = 0o777 ) log . info ( f 'Writing { len ( OBs ) } OBs to disk at: { OBpath } ' ) for OB in OBs : OBfile = OBpath / f \" { str ( OB . Target . TargetName ) . replace ( ' ' , '_' ) } .yaml\" log . debug ( f ' Writing: { OBfile . name } ' ) OB . write_to ( OBfile , overwrite = True ) else : return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--save' , dest = \"save\" , default = False , action = \"store_true\" , help = 'Save OBs to disk?' ) return super () . add_cmdline_args ( parser )","title":"GetKPFCCObservingBlocks"},{"location":"scripts/GetObservingBlocks/","text":"GetObservingBlocks Bases: KPFFunction Retrieve the OB associated with the given unique ID in the KPF-CC database. Source code in kpf/observatoryAPIs/GetObservingBlocks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class GetObservingBlocks ( KPFFunction ): '''Retrieve the OB associated with the given unique ID in the KPF-CC database. ''' @classmethod def pre_condition ( cls , args ): OBid = args . get ( 'OBid' , None ) if OBid is None : raise FailedPreCondition ( 'OBid must be provided' ) @classmethod def perform ( cls , args ): params = { 'id' : args . get ( 'OBid' , '' )} OBs = get_OBs_from_KPFCC_API ( params ) if args . get ( 'show_history' , False ): print ( f '# Observing History for { OBs [ 0 ] . summary () } ' ) for i , h in enumerate ( OBs [ 0 ] . History ): print ( f \"- Observer: { h . get ( 'observer' ) } (at { h . get ( 'timestamp' ) } )\" ) start_times = h . get ( 'exposure_start_times' , []) if len ( start_times ) > 0 : print ( f \" Start Times: { start_times } \" ) exposure_times = h . get ( 'exposure_times' , []) if len ( exposure_times ) > 0 : print ( f \" Exposure Times: { exposure_times } \" ) comment = h . get ( 'comment' , '' ) if len ( comment ) > 0 : print ( f \" Observer comment: { comment } \" ) return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'OBid' , type = str , help = 'The unique identifier for the OB to retrieve.' ) parser . add_argument ( '--history' , '--show_history' , dest = \"show_history\" , default = False , action = \"store_true\" , help = 'Print history to screen?' ) return super () . add_cmdline_args ( parser )","title":"GetObservingBlocks"},{"location":"scripts/GetObservingBlocks/#getobservingblocks","text":"Bases: KPFFunction Retrieve the OB associated with the given unique ID in the KPF-CC database. Source code in kpf/observatoryAPIs/GetObservingBlocks.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class GetObservingBlocks ( KPFFunction ): '''Retrieve the OB associated with the given unique ID in the KPF-CC database. ''' @classmethod def pre_condition ( cls , args ): OBid = args . get ( 'OBid' , None ) if OBid is None : raise FailedPreCondition ( 'OBid must be provided' ) @classmethod def perform ( cls , args ): params = { 'id' : args . get ( 'OBid' , '' )} OBs = get_OBs_from_KPFCC_API ( params ) if args . get ( 'show_history' , False ): print ( f '# Observing History for { OBs [ 0 ] . summary () } ' ) for i , h in enumerate ( OBs [ 0 ] . History ): print ( f \"- Observer: { h . get ( 'observer' ) } (at { h . get ( 'timestamp' ) } )\" ) start_times = h . get ( 'exposure_start_times' , []) if len ( start_times ) > 0 : print ( f \" Start Times: { start_times } \" ) exposure_times = h . get ( 'exposure_times' , []) if len ( exposure_times ) > 0 : print ( f \" Exposure Times: { exposure_times } \" ) comment = h . get ( 'comment' , '' ) if len ( comment ) > 0 : print ( f \" Observer comment: { comment } \" ) return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'OBid' , type = str , help = 'The unique identifier for the OB to retrieve.' ) parser . add_argument ( '--history' , '--show_history' , dest = \"show_history\" , default = False , action = \"store_true\" , help = 'Print history to screen?' ) return super () . add_cmdline_args ( parser )","title":"GetObservingBlocks"},{"location":"scripts/GetObservingBlocksByProgram/","text":"GetObservingBlocksByProgram Bases: KPFFunction Retrieve all OB associated with the given program ID in the KPF-CC database. Source code in kpf/observatoryAPIs/GetObservingBlocksByProgram.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class GetObservingBlocksByProgram ( KPFFunction ): '''Retrieve all OB associated with the given program ID in the KPF-CC database. ''' @classmethod def pre_condition ( cls , args ): program = args . get ( 'program' , None ) if program is None : raise FailedPreCondition ( 'Program must be provided' ) @classmethod def perform ( cls , args ): semester = args . get ( 'semester' , None ) if semester is None : now = datetime . datetime . now () semester , start , end = get_semester_dates ( now ) program = args . get ( 'program' , None ) if program is None : return params = { 'semid' : f \" { semester } _ { program } \" } OBs = get_OBs_from_KPFCC_API ( params ) return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'semester' , type = str , help = 'The semester for the associated program ID.' ) parser . add_argument ( 'program' , type = str , help = 'The program ID to retrieve OBs for.' ) return super () . add_cmdline_args ( parser )","title":"GetObservingBlocksByProgram"},{"location":"scripts/GetObservingBlocksByProgram/#getobservingblocksbyprogram","text":"Bases: KPFFunction Retrieve all OB associated with the given program ID in the KPF-CC database. Source code in kpf/observatoryAPIs/GetObservingBlocksByProgram.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class GetObservingBlocksByProgram ( KPFFunction ): '''Retrieve all OB associated with the given program ID in the KPF-CC database. ''' @classmethod def pre_condition ( cls , args ): program = args . get ( 'program' , None ) if program is None : raise FailedPreCondition ( 'Program must be provided' ) @classmethod def perform ( cls , args ): semester = args . get ( 'semester' , None ) if semester is None : now = datetime . datetime . now () semester , start , end = get_semester_dates ( now ) program = args . get ( 'program' , None ) if program is None : return params = { 'semid' : f \" { semester } _ { program } \" } OBs = get_OBs_from_KPFCC_API ( params ) return OBs @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'semester' , type = str , help = 'The semester for the associated program ID.' ) parser . add_argument ( 'program' , type = str , help = 'The program ID to retrieve OBs for.' ) return super () . add_cmdline_args ( parser )","title":"GetObservingBlocksByProgram"},{"location":"scripts/GetScheduledPrograms/","text":"GetScheduledPrograms Bases: KPFFunction Source code in kpf/observatoryAPIs/GetScheduledPrograms.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class GetScheduledPrograms ( KPFFunction ): ''' ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): '''Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. ''' utnow = datetime . datetime . utcnow () semester , semester_start , semester_end = get_semester_dates ( utnow ) if args . get ( 'semester' , None ) == 'current' : start = semester_start numdays = ( semester_end - start ) . days + 2 elif str ( args . get ( 'semester' , None )) in [ 'today' , 'tonight' ]: start = utnow - datetime . timedelta ( days = 1 ) numdays = 1 elif str ( args . get ( 'semester' , None ))[ 0 ] == '2' : semester , semester_start , semester_end = get_semester_dates ( args . get ( 'semester' )) start = semester_start numdays = ( semester_end - start ) . days + 2 else : # Pull programs from the rest of the semester start = utnow numdays = ( semester_end - start ) . days + 2 query = 'getSchedule' params = { 'date' : start . strftime ( '%Y-%m- %d ' ), 'numdays' : numdays , 'telnr' : args . get ( 'telnr' , 1 ), 'instrument' : 'KPF' } all_programs = query_observatoryAPI ( 'schedule' , query , params ) classical_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF' and p [ 'Semester' ] == semester ] cadence_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF-CC' and p [ 'Semester' ] == semester ] return classical_programs , cadence_programs @classmethod def post_condition ( cls , args ): pass perform ( args ) classmethod Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. Source code in kpf/observatoryAPIs/GetScheduledPrograms.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def perform ( cls , args ): '''Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. ''' utnow = datetime . datetime . utcnow () semester , semester_start , semester_end = get_semester_dates ( utnow ) if args . get ( 'semester' , None ) == 'current' : start = semester_start numdays = ( semester_end - start ) . days + 2 elif str ( args . get ( 'semester' , None )) in [ 'today' , 'tonight' ]: start = utnow - datetime . timedelta ( days = 1 ) numdays = 1 elif str ( args . get ( 'semester' , None ))[ 0 ] == '2' : semester , semester_start , semester_end = get_semester_dates ( args . get ( 'semester' )) start = semester_start numdays = ( semester_end - start ) . days + 2 else : # Pull programs from the rest of the semester start = utnow numdays = ( semester_end - start ) . days + 2 query = 'getSchedule' params = { 'date' : start . strftime ( '%Y-%m- %d ' ), 'numdays' : numdays , 'telnr' : args . get ( 'telnr' , 1 ), 'instrument' : 'KPF' } all_programs = query_observatoryAPI ( 'schedule' , query , params ) classical_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF' and p [ 'Semester' ] == semester ] cadence_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF-CC' and p [ 'Semester' ] == semester ] return classical_programs , cadence_programs","title":"GetScheduledPrograms"},{"location":"scripts/GetScheduledPrograms/#getscheduledprograms","text":"Bases: KPFFunction Source code in kpf/observatoryAPIs/GetScheduledPrograms.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class GetScheduledPrograms ( KPFFunction ): ''' ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): '''Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. ''' utnow = datetime . datetime . utcnow () semester , semester_start , semester_end = get_semester_dates ( utnow ) if args . get ( 'semester' , None ) == 'current' : start = semester_start numdays = ( semester_end - start ) . days + 2 elif str ( args . get ( 'semester' , None )) in [ 'today' , 'tonight' ]: start = utnow - datetime . timedelta ( days = 1 ) numdays = 1 elif str ( args . get ( 'semester' , None ))[ 0 ] == '2' : semester , semester_start , semester_end = get_semester_dates ( args . get ( 'semester' )) start = semester_start numdays = ( semester_end - start ) . days + 2 else : # Pull programs from the rest of the semester start = utnow numdays = ( semester_end - start ) . days + 2 query = 'getSchedule' params = { 'date' : start . strftime ( '%Y-%m- %d ' ), 'numdays' : numdays , 'telnr' : args . get ( 'telnr' , 1 ), 'instrument' : 'KPF' } all_programs = query_observatoryAPI ( 'schedule' , query , params ) classical_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF' and p [ 'Semester' ] == semester ] cadence_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF-CC' and p [ 'Semester' ] == semester ] return classical_programs , cadence_programs @classmethod def post_condition ( cls , args ): pass","title":"GetScheduledPrograms"},{"location":"scripts/GetScheduledPrograms/#kpf.observatoryAPIs.GetScheduledPrograms.GetScheduledPrograms.perform","text":"Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. Source code in kpf/observatoryAPIs/GetScheduledPrograms.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @classmethod def perform ( cls , args ): '''Returns list of dicts with the classical and cadence program info. If no args, returns everything remaining on this semester's schedule. If args contains a value for \"semester\" then that is either interpreted as the semester string (e.g. \"2025A\") or it can be \"current\" which instructs the code to use the current semester. ''' utnow = datetime . datetime . utcnow () semester , semester_start , semester_end = get_semester_dates ( utnow ) if args . get ( 'semester' , None ) == 'current' : start = semester_start numdays = ( semester_end - start ) . days + 2 elif str ( args . get ( 'semester' , None )) in [ 'today' , 'tonight' ]: start = utnow - datetime . timedelta ( days = 1 ) numdays = 1 elif str ( args . get ( 'semester' , None ))[ 0 ] == '2' : semester , semester_start , semester_end = get_semester_dates ( args . get ( 'semester' )) start = semester_start numdays = ( semester_end - start ) . days + 2 else : # Pull programs from the rest of the semester start = utnow numdays = ( semester_end - start ) . days + 2 query = 'getSchedule' params = { 'date' : start . strftime ( '%Y-%m- %d ' ), 'numdays' : numdays , 'telnr' : args . get ( 'telnr' , 1 ), 'instrument' : 'KPF' } all_programs = query_observatoryAPI ( 'schedule' , query , params ) classical_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF' and p [ 'Semester' ] == semester ] cadence_programs = [ p for p in all_programs if p [ 'Instrument' ] == 'KPF-CC' and p [ 'Semester' ] == semester ] return classical_programs , cadence_programs","title":"perform"},{"location":"scripts/GetTargetList/","text":"GetTargetList Bases: KPFFunction Retrieve the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Source code in kpf/magiq/GetTargetList.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GetTargetList ( KPFFunction ): '''Retrieve the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( f 'Running Magiq getTargetlist command' ) result = magiq_server_command ( 'getTargetlist' ) lines = result . split ( ' \\n ' ) target_names = [ line [: 16 ] . strip () for line in lines ] log . debug ( target_names ) return target_names , lines @classmethod def post_condition ( cls , args ): pass","title":"GetTargetList"},{"location":"scripts/GetTargetList/#gettargetlist","text":"Bases: KPFFunction Retrieve the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Source code in kpf/magiq/GetTargetList.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GetTargetList ( KPFFunction ): '''Retrieve the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( f 'Running Magiq getTargetlist command' ) result = magiq_server_command ( 'getTargetlist' ) lines = result . split ( ' \\n ' ) target_names = [ line [: 16 ] . strip () for line in lines ] log . debug ( target_names ) return target_names , lines @classmethod def post_condition ( cls , args ): pass","title":"GetTargetList"},{"location":"scripts/GetTelescopeRelease/","text":"GetTelescopeRelease Bases: KPFFunction Return a boolean indicating whether the telescope has been released. Note that this uses the schedule API which resets at local midnight, so if the current time is after midnight and before 8am, this assumes release. Source code in kpf/observatoryAPIs/GetTelescopeRelease.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class GetTelescopeRelease ( KPFFunction ): '''Return a boolean indicating whether the telescope has been released. Note that this uses the schedule API which resets at local midnight, so if the current time is after midnight and before 8am, this assumes release. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): utnow = datetime . datetime . utcnow () if utnow . hour >= 10 and utnow . hour < 18 : # log.debug(f'UT hour > 10 assume release') return True params = { 'telnr' : args . get ( 'telnr' , 1 )} result = query_observatoryAPI ( 'schedule' , 'getTelescopeReadyState' , params ) log . debug ( f 'getTelescopeReadyState returned { result } ' ) return result . get ( 'State' , '' ) == 'Ready' @classmethod def post_condition ( cls , args ): pass","title":"GetTelescopeRelease"},{"location":"scripts/GetTelescopeRelease/#gettelescoperelease","text":"Bases: KPFFunction Return a boolean indicating whether the telescope has been released. Note that this uses the schedule API which resets at local midnight, so if the current time is after midnight and before 8am, this assumes release. Source code in kpf/observatoryAPIs/GetTelescopeRelease.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class GetTelescopeRelease ( KPFFunction ): '''Return a boolean indicating whether the telescope has been released. Note that this uses the schedule API which resets at local midnight, so if the current time is after midnight and before 8am, this assumes release. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): utnow = datetime . datetime . utcnow () if utnow . hour >= 10 and utnow . hour < 18 : # log.debug(f'UT hour > 10 assume release') return True params = { 'telnr' : args . get ( 'telnr' , 1 )} result = query_observatoryAPI ( 'schedule' , 'getTelescopeReadyState' , params ) log . debug ( f 'getTelescopeReadyState returned { result } ' ) return result . get ( 'State' , '' ) == 'Ready' @classmethod def post_condition ( cls , args ): pass","title":"GetTelescopeRelease"},{"location":"scripts/GridSearch/","text":"GridSearch Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine. ARGS: None Source code in kpf/engineering/GridSearch.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 class GridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_grid' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.4' ) check_input ( OB , 'Grid' , allowed_values = [ 'TipTilt' , 'SciADC' ]) check_input ( OB , 'nx' ) check_input ( OB , 'ny' ) check_input ( OB , 'dx' ) check_input ( OB , 'dy' ) check_input ( OB , 'ExpMeter_exptime' ) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) for FVC in FVCs : if FVC not in [ 'SCI' , 'CAHK' , 'EXT' , '' ]: raise FailedPreCondition ( f \"FVC { FVC } not supported\" ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) grid = OB . get ( 'Grid' ) this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { grid }{ this_file_name } _images_ { now_str } .txt' ) fluxes_file = log_path / Path ( f ' { grid }{ this_file_name } _fluxes_ { now_str } .txt' ) images = Table ( names = ( 'file' , 'camera' , 'x' , 'y' ), dtype = ( 'a90' , 'a10' , 'f4' , 'f4' )) expmeter_flux = Table ( names = ( 'i' , 'j' , 'x' , 'y' , 'bck1' , 'bck2' , 'bck3' , 'bck4' , 'cur1' , 'cur2' , 'cur3' , 'cur4' , 'raw1' , 'raw2' , 'raw3' , 'raw4' , 'nimages' ), dtype = ( 'i4' , 'i4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'i4' )) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) nx = OB . get ( 'nx' ) ny = OB . get ( 'ny' ) dx = OB . get ( 'dx' ) dy = OB . get ( 'dy' ) xis = [ xi for xi in range ( int ( - nx / 2 ), int (( nx + 1 ) / 2 ), 1 )] yis = [ yi for yi in range ( int ( - ny / 2 ), int (( ny + 1 ) / 2 ), 1 )] xindicies = [ ind for ind in range ( nx )] yindicies = [ ind for ind in range ( ny )] xs = [ xi * dx for xi in xis ] ys = [ yi * dy for yi in yis ] # Set up guider (assume parameters set during acquisition of star) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Setting TRIGCUBE Inactive' ) kpfguide [ 'TRIGCUBE' ] . write ( 'Inactive' ) if grid == 'TipTilt' : log . info ( f \"DAR_ENABLE = { kpfguide [ 'DAR_ENABLE' ] . read () } \" ) dar_offset = kpfguide [ 'DAR_OFFSET' ] . read ( binary = True ) log . info ( f \"DAR_OFFSET = { dar_offset [ 0 ] : .2f } { dar_offset [ 1 ] : .2f } \" ) xpix0 , ypix0 = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix0 : .2f } , { ypix0 : .2f } \" ) basex , basey = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE is { basex : .2f } , { basey : .2f } \" ) # Pixel targets must be in absolute coordinates xs = [ basex + xpix for xpix in xs ] ys = [ basey + ypix for ypix in ys ] elif grid == 'SciADC' : kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) nominalx , nominaly = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) x0 = OB . get ( 'ADC1Position' ) if str ( x0 ) . lower () == 'nominal' : x0 = nominalx else : x0 = float ( OB . get ( 'ADC1Position' )) y0 = OB . get ( 'ADC2Position' ) if str ( y0 ) . lower () == 'nominal' : y0 = nominaly else : y0 = float ( OB . get ( 'ADC2Position' )) log . info ( f \"ADC starting position: { x0 : .1f } { y0 : .1f } \" ) # Apply reverse rotation if requested if OB . get ( 'ADC1Reverse' , False ) is True : x0 = - x0 if OB . get ( 'ADC2Reverse' , False ) is True : y0 = - y0 log . info ( f \"ADC reverse nominal position: { x0 : .1f } { y0 : .1f } \" ) # Apply flip if requested if OB . get ( 'ADC1Flip' , False ) is True : x0 += 180 if OB . get ( 'ADC2Flip' , False ) is True : y0 += 180 log . info ( f \"ADC flip nominal position: { x0 : .1f } { y0 : .1f } \" ) xs = [ x + x0 for x in xs ] ys = [ y + y0 for y in ys ] # Set up kpfexpose kpfexpose = ktl . cache ( 'kpfexpose' ) SetSourceSelectShutters . execute ( OB ) OB [ 'TimedShutter_Scrambler' ] = True OB [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) SetTimedShutters . execute ( OB ) SetTriggeredDetectors . execute ( OB ) total_exptime = OB . get ( 'TimeOnPosition' ) SetExpTime . execute ({ 'ExpTime' : total_exptime }) # Configure Exposure Meter kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) ExpMeter_exptime = OB . get ( 'ExpMeter_exptime' ) log . info ( f \"Setting kpf_expmeter.EXPOSURE = { ExpMeter_exptime : .2f } s\" ) kpf_expmeter [ 'EXPOSURE' ] . write ( ExpMeter_exptime ) # Set up FVCs kpffvc = ktl . cache ( 'kpffvc' ) for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and OB . get ( f ' { FVC } FVC_exptime' , None ) != None : exptime = OB . get ( f ' { FVC } FVC_exptime' ) log . info ( f \"Setting { FVC } FVC ExpTime = { exptime : .2f } s\" ) SetFVCExpTime . execute ({ 'camera' : FVC , 'exptime' : exptime }) for i in xindicies : yindicies . reverse () for j in yindicies : check_scriptstop () if grid == 'TipTilt' : ##------------------------------------------------------ ## Tip Tilt ##------------------------------------------------------ log . info ( f \"Adjusting CURRENT_BASE to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) max_move = 3 precisison = 0.01 current_base = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) current_cb = current_base . read ( binary = True ) delta_cb = ( xs [ i ] - current_cb [ 0 ], ys [ j ] - current_cb [ 1 ]) while abs ( delta_cb [ 0 ]) > precisison or abs ( delta_cb [ 1 ]) > precisison : # Calc X move new_X_target = current_cb [ 0 ] if abs ( delta_cb [ 0 ]) > precisison : move_sign_X = delta_cb [ 0 ] / abs ( delta_cb [ 0 ]) move_mag_X = min ([ max_move , abs ( delta_cb [ 0 ])]) new_X_target += move_sign_X * move_mag_X # Calc Y move new_Y_target = current_cb [ 1 ] if abs ( delta_cb [ 1 ]) > precisison : move_sign_Y = delta_cb [ 1 ] / abs ( delta_cb [ 1 ]) move_mag_Y = min ([ max_move , abs ( delta_cb [ 1 ])]) new_Y_target += move_sign_Y * move_mag_Y log . info ( f \" Setting CURRENT_BASE to { new_X_target : .2f } , { new_Y_target : .2f } \" ) SetTipTiltTargetPixel . execute ({ 'x' : new_X_target , 'y' : new_Y_target }) success = ktl . waitFor ( \"$kpfguide.TIPTILT_PHASE == 'Tracking'\" , timeout = 5 ) current_cb = current_base . read ( binary = True ) delta_cb = ( xs [ i ] - current_cb [ 0 ], ys [ j ] - current_cb [ 1 ]) xpix , ypix = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix : .2f } , { ypix : .2f } \" ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) log . info ( f \"Stopping tip tilt\" ) StopTipTilt . execute ({}) time . sleep ( 1 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) subprocess . call ([ 'kpf' , 'restart' , 'kpfguide2' ]) time . sleep ( 5 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) raise KPFException ( 'Lost Star' ) elif grid == 'SciADC' : ##------------------------------------------------------ ## Science ADC ##------------------------------------------------------ log . info ( f \"Offsetting to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) kpffiu [ 'ADC1VAL' ] . write ( xs [ i ]) kpffiu [ 'ADC2VAL' ] . write ( ys [ j ]) log . info ( f \"Absolute position: { xs [ i ] : .1f } { ys [ j ] : .1f } \" ) expr = '($kpffiu.ADC1STA == Ready) and ($kpffiu.ADC2STA == Ready)' success = ktl . waitFor ( expr , timeout = 2 * max ([ dx * nx , dy * ny ]) / 5 ) if success is not True : ADC1STA = kpffiu [ 'ADC1STA' ] . read () ADC2STA = kpffiu [ 'ADC2STA' ] . read () msg = f 'Timed out waiting for ADCs: ADC1STA= { ADC1STA } ADC2STA= { ADC2STA } ' raise KPFException ( msg ) WaitForReady . execute ({}) check_scriptstop () # Stop here if requested # Start Exposure Meter and Science Cameras kpfexpose [ 'OBJECT' ] . write ( f 'Grid search { xs [ i ] } , { ys [ j ] } ' ) log . info ( f \"Starting kpfexpose cameras\" ) StartExposure . execute ({}) # Begin timestamp for history retrieval begin = time . time () # Take CRED2 image if OB . get ( 'UseCRED2' , True ) is True : log . info ( 'Starting guider Trigger file' ) initial_last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () StartTriggerFile . execute ({}) # Start FVC Exposures initial_lastfile = {} failedFVCs = [] for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs : initial_lastfile [ FVC ] = kpffvc [ f \" { FVC } LASTFILE\" ] . read () log . debug ( f \" Initial lastfile for { FVC } = { initial_lastfile [ FVC ] } \" ) log . info ( f \" Starting { FVC } FVC exposure\" ) try : TakeFVCExposure . execute ({ 'camera' : FVC , 'wait' : False }) except : log . error ( 'Starting FVC image failed' ) failedFVCs . append ( FVC ) check_scriptstop () # Collect files for FVC exposures for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and FVC not in failedFVCs : log . info ( f \" Looking for output file for { FVC } \" ) expr = f '($kpffvc. { FVC } LASTFILE != \" { initial_lastfile [ FVC ] } \")' log . debug ( f \" Waiting for: { expr } \" ) if ktl . waitFor ( expr , timeout = 20 ) is False : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . error ( 'No new FVC file found' ) log . error ( f \" kpffvc. { FVC } LASTFILE = { lastfile } \" ) else : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . debug ( f \"Found { lastfile } \" ) row = { 'file' : lastfile , 'camera' : FVC , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) check_scriptstop () # Here's where we wait for the remainder of the TimeOnPosition log . info ( f \" Waiting for kpfexpose to be ready\" ) WaitForReady . execute ({}) # Collect CRED2 File if OB . get ( 'UseCRED2' , True ) is True : StopTriggerFile . execute ({}) WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_last_cube }) last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () row = { 'file' : last_cube , 'camera' : 'CRED2' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Stop Exposure Meter log . info ( f \" Waiting for ExpMeter to be Ready\" ) EMsuccess = ktl . waitFor ( '$kpf_expmeter.EXPSTATE == Ready' , timeout = 5 ) time . sleep ( 0.5 ) # Time shim because paranoia if EMsuccess is True : lastfile = kpf_expmeter [ 'FITSFILE' ] . read () else : lastfile = 'failed' log . debug ( f ' Done. FITSFILE= { lastfile } ' ) row = { 'file' : lastfile , 'camera' : 'ExpMeter' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) if EMsuccess is True : loutfile = kpf_expmeter [ 'LOUTFILE' ] . read () else : loutfile = 'failed' log . debug ( f ' Done. LOUTFILE= { loutfile } ' ) row = { 'file' : loutfile , 'camera' : 'ExpMeter_1Dspec' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Retrieve keyword history end = time . time () expmeter_data = { 'x' : xs [ i ], 'y' : ys [ j ], 'i' : i , 'j' : j , } log . info ( f \" Retrieving keyword history\" ) for counts_kw in [ 'CUR_COUNTS' , 'RAW_COUNTS' , 'BCK_COUNTS' ]: log . debug ( f \" Retrieving keyword history for { counts_kw } \" ) kws = { 'kpf_expmeter' : [ counts_kw ]} counts_history = keygrabber . retrieve ( kws , begin = begin , end = end ) # Extract counts and save to table (initial style output) fluxes = np . zeros (( len ( counts_history ) - 2 , 4 )) for k , entry in enumerate ( counts_history ): if k != 0 and k != len ( counts_history ) - 1 : value_floats = [ float ( v ) for v in entry [ 'ascvalue' ] . split ()] ts = datetime . fromtimestamp ( entry [ 'time' ]) . strftime ( '%Y-%m- %d %H:%M:%S' ) log . debug ( f \" { ts } : { value_floats } \" ) fluxes [ k - 1 ] = value_floats avg_fluxes = np . mean ( fluxes , axis = 0 ) expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 1\" ] = avg_fluxes [ 0 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 2\" ] = avg_fluxes [ 1 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 3\" ] = avg_fluxes [ 2 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 4\" ] = avg_fluxes [ 3 ] expmeter_data [ 'nimages' ] = len ( counts_history ) expmeter_flux . add_row ( expmeter_data ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if grid == 'TipTilt' : SetTipTiltTargetPixel . execute ({ 'x' : basex , 'y' : basey }) StopTipTilt . execute ({}) elif grid == 'SciADC' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) # kpffiu['ADCTRACK'].write('On') @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"GridSearch"},{"location":"scripts/GridSearch/#gridsearch","text":"Bases: KPFTranslatorFunction Executes an engineering grid search OB. This must have arguments as input, either from a file using the -f command line tool, or passed in from the execution engine.","title":"GridSearch"},{"location":"scripts/GridSearch/#kpf.engineering.GridSearch.GridSearch--args","text":"None Source code in kpf/engineering/GridSearch.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 class GridSearch ( KPFTranslatorFunction ): '''Executes an engineering grid search OB. This must have arguments as input, either from a file using the `-f` command line tool, or passed in from the execution engine. ARGS: ===== None ''' abortable = True @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_grid' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.4' ) check_input ( OB , 'Grid' , allowed_values = [ 'TipTilt' , 'SciADC' ]) check_input ( OB , 'nx' ) check_input ( OB , 'ny' ) check_input ( OB , 'dx' ) check_input ( OB , 'dy' ) check_input ( OB , 'ExpMeter_exptime' ) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) for FVC in FVCs : if FVC not in [ 'SCI' , 'CAHK' , 'EXT' , '' ]: raise FailedPreCondition ( f \"FVC { FVC } not supported\" ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) grid = OB . get ( 'Grid' ) this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { grid }{ this_file_name } _images_ { now_str } .txt' ) fluxes_file = log_path / Path ( f ' { grid }{ this_file_name } _fluxes_ { now_str } .txt' ) images = Table ( names = ( 'file' , 'camera' , 'x' , 'y' ), dtype = ( 'a90' , 'a10' , 'f4' , 'f4' )) expmeter_flux = Table ( names = ( 'i' , 'j' , 'x' , 'y' , 'bck1' , 'bck2' , 'bck3' , 'bck4' , 'cur1' , 'cur2' , 'cur3' , 'cur4' , 'raw1' , 'raw2' , 'raw3' , 'raw4' , 'nimages' ), dtype = ( 'i4' , 'i4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'f4' , 'i4' )) FVCs = OB . get ( 'FVCs' , '' ) . split ( ',' ) nx = OB . get ( 'nx' ) ny = OB . get ( 'ny' ) dx = OB . get ( 'dx' ) dy = OB . get ( 'dy' ) xis = [ xi for xi in range ( int ( - nx / 2 ), int (( nx + 1 ) / 2 ), 1 )] yis = [ yi for yi in range ( int ( - ny / 2 ), int (( ny + 1 ) / 2 ), 1 )] xindicies = [ ind for ind in range ( nx )] yindicies = [ ind for ind in range ( ny )] xs = [ xi * dx for xi in xis ] ys = [ yi * dy for yi in yis ] # Set up guider (assume parameters set during acquisition of star) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Setting TRIGCUBE Inactive' ) kpfguide [ 'TRIGCUBE' ] . write ( 'Inactive' ) if grid == 'TipTilt' : log . info ( f \"DAR_ENABLE = { kpfguide [ 'DAR_ENABLE' ] . read () } \" ) dar_offset = kpfguide [ 'DAR_OFFSET' ] . read ( binary = True ) log . info ( f \"DAR_OFFSET = { dar_offset [ 0 ] : .2f } { dar_offset [ 1 ] : .2f } \" ) xpix0 , ypix0 = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix0 : .2f } , { ypix0 : .2f } \" ) basex , basey = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) log . info ( f \"CURRENT_BASE is { basex : .2f } , { basey : .2f } \" ) # Pixel targets must be in absolute coordinates xs = [ basex + xpix for xpix in xs ] ys = [ basey + ypix for ypix in ys ] elif grid == 'SciADC' : kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) nominalx , nominaly = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) x0 = OB . get ( 'ADC1Position' ) if str ( x0 ) . lower () == 'nominal' : x0 = nominalx else : x0 = float ( OB . get ( 'ADC1Position' )) y0 = OB . get ( 'ADC2Position' ) if str ( y0 ) . lower () == 'nominal' : y0 = nominaly else : y0 = float ( OB . get ( 'ADC2Position' )) log . info ( f \"ADC starting position: { x0 : .1f } { y0 : .1f } \" ) # Apply reverse rotation if requested if OB . get ( 'ADC1Reverse' , False ) is True : x0 = - x0 if OB . get ( 'ADC2Reverse' , False ) is True : y0 = - y0 log . info ( f \"ADC reverse nominal position: { x0 : .1f } { y0 : .1f } \" ) # Apply flip if requested if OB . get ( 'ADC1Flip' , False ) is True : x0 += 180 if OB . get ( 'ADC2Flip' , False ) is True : y0 += 180 log . info ( f \"ADC flip nominal position: { x0 : .1f } { y0 : .1f } \" ) xs = [ x + x0 for x in xs ] ys = [ y + y0 for y in ys ] # Set up kpfexpose kpfexpose = ktl . cache ( 'kpfexpose' ) SetSourceSelectShutters . execute ( OB ) OB [ 'TimedShutter_Scrambler' ] = True OB [ 'TimedShutter_CaHK' ] = OB . get ( 'TriggerCaHK' , False ) SetTimedShutters . execute ( OB ) SetTriggeredDetectors . execute ( OB ) total_exptime = OB . get ( 'TimeOnPosition' ) SetExpTime . execute ({ 'ExpTime' : total_exptime }) # Configure Exposure Meter kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) ExpMeter_exptime = OB . get ( 'ExpMeter_exptime' ) log . info ( f \"Setting kpf_expmeter.EXPOSURE = { ExpMeter_exptime : .2f } s\" ) kpf_expmeter [ 'EXPOSURE' ] . write ( ExpMeter_exptime ) # Set up FVCs kpffvc = ktl . cache ( 'kpffvc' ) for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and OB . get ( f ' { FVC } FVC_exptime' , None ) != None : exptime = OB . get ( f ' { FVC } FVC_exptime' ) log . info ( f \"Setting { FVC } FVC ExpTime = { exptime : .2f } s\" ) SetFVCExpTime . execute ({ 'camera' : FVC , 'exptime' : exptime }) for i in xindicies : yindicies . reverse () for j in yindicies : check_scriptstop () if grid == 'TipTilt' : ##------------------------------------------------------ ## Tip Tilt ##------------------------------------------------------ log . info ( f \"Adjusting CURRENT_BASE to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) max_move = 3 precisison = 0.01 current_base = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) current_cb = current_base . read ( binary = True ) delta_cb = ( xs [ i ] - current_cb [ 0 ], ys [ j ] - current_cb [ 1 ]) while abs ( delta_cb [ 0 ]) > precisison or abs ( delta_cb [ 1 ]) > precisison : # Calc X move new_X_target = current_cb [ 0 ] if abs ( delta_cb [ 0 ]) > precisison : move_sign_X = delta_cb [ 0 ] / abs ( delta_cb [ 0 ]) move_mag_X = min ([ max_move , abs ( delta_cb [ 0 ])]) new_X_target += move_sign_X * move_mag_X # Calc Y move new_Y_target = current_cb [ 1 ] if abs ( delta_cb [ 1 ]) > precisison : move_sign_Y = delta_cb [ 1 ] / abs ( delta_cb [ 1 ]) move_mag_Y = min ([ max_move , abs ( delta_cb [ 1 ])]) new_Y_target += move_sign_Y * move_mag_Y log . info ( f \" Setting CURRENT_BASE to { new_X_target : .2f } , { new_Y_target : .2f } \" ) SetTipTiltTargetPixel . execute ({ 'x' : new_X_target , 'y' : new_Y_target }) success = ktl . waitFor ( \"$kpfguide.TIPTILT_PHASE == 'Tracking'\" , timeout = 5 ) current_cb = current_base . read ( binary = True ) delta_cb = ( xs [ i ] - current_cb [ 0 ], ys [ j ] - current_cb [ 1 ]) xpix , ypix = kpfguide [ 'PIX_TARGET' ] . read ( binary = True ) log . info ( f \"PIX_TARGET is { xpix : .2f } , { ypix : .2f } \" ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) log . info ( f \"Stopping tip tilt\" ) StopTipTilt . execute ({}) time . sleep ( 1 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) # Check for lost star obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) subprocess . call ([ 'kpf' , 'restart' , 'kpfguide2' ]) time . sleep ( 5 ) log . info ( f \"Starting tip tilt\" ) StartTipTilt . execute ({}) time . sleep ( 5 ) obj_choice = kpfguide [ 'OBJECT_CHOICE' ] . read () if obj_choice in [ None , 'None' ]: log . error ( f \" --> Lost star <--\" ) raise KPFException ( 'Lost Star' ) elif grid == 'SciADC' : ##------------------------------------------------------ ## Science ADC ##------------------------------------------------------ log . info ( f \"Offsetting to ( { xs [ i ] : .2f } , { ys [ j ] : .2f } ) ( { xis [ i ] } , { yis [ j ] } )\" ) kpffiu [ 'ADC1VAL' ] . write ( xs [ i ]) kpffiu [ 'ADC2VAL' ] . write ( ys [ j ]) log . info ( f \"Absolute position: { xs [ i ] : .1f } { ys [ j ] : .1f } \" ) expr = '($kpffiu.ADC1STA == Ready) and ($kpffiu.ADC2STA == Ready)' success = ktl . waitFor ( expr , timeout = 2 * max ([ dx * nx , dy * ny ]) / 5 ) if success is not True : ADC1STA = kpffiu [ 'ADC1STA' ] . read () ADC2STA = kpffiu [ 'ADC2STA' ] . read () msg = f 'Timed out waiting for ADCs: ADC1STA= { ADC1STA } ADC2STA= { ADC2STA } ' raise KPFException ( msg ) WaitForReady . execute ({}) check_scriptstop () # Stop here if requested # Start Exposure Meter and Science Cameras kpfexpose [ 'OBJECT' ] . write ( f 'Grid search { xs [ i ] } , { ys [ j ] } ' ) log . info ( f \"Starting kpfexpose cameras\" ) StartExposure . execute ({}) # Begin timestamp for history retrieval begin = time . time () # Take CRED2 image if OB . get ( 'UseCRED2' , True ) is True : log . info ( 'Starting guider Trigger file' ) initial_last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () StartTriggerFile . execute ({}) # Start FVC Exposures initial_lastfile = {} failedFVCs = [] for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs : initial_lastfile [ FVC ] = kpffvc [ f \" { FVC } LASTFILE\" ] . read () log . debug ( f \" Initial lastfile for { FVC } = { initial_lastfile [ FVC ] } \" ) log . info ( f \" Starting { FVC } FVC exposure\" ) try : TakeFVCExposure . execute ({ 'camera' : FVC , 'wait' : False }) except : log . error ( 'Starting FVC image failed' ) failedFVCs . append ( FVC ) check_scriptstop () # Collect files for FVC exposures for FVC in [ 'SCI' , 'CAHK' , 'EXT' ]: if FVC in FVCs and FVC not in failedFVCs : log . info ( f \" Looking for output file for { FVC } \" ) expr = f '($kpffvc. { FVC } LASTFILE != \" { initial_lastfile [ FVC ] } \")' log . debug ( f \" Waiting for: { expr } \" ) if ktl . waitFor ( expr , timeout = 20 ) is False : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . error ( 'No new FVC file found' ) log . error ( f \" kpffvc. { FVC } LASTFILE = { lastfile } \" ) else : lastfile = kpffvc [ f ' { FVC } LASTFILE' ] . read () log . debug ( f \"Found { lastfile } \" ) row = { 'file' : lastfile , 'camera' : FVC , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) check_scriptstop () # Here's where we wait for the remainder of the TimeOnPosition log . info ( f \" Waiting for kpfexpose to be ready\" ) WaitForReady . execute ({}) # Collect CRED2 File if OB . get ( 'UseCRED2' , True ) is True : StopTriggerFile . execute ({}) WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_last_cube }) last_cube = kpfguide [ 'LASTTRIGFILE' ] . read () row = { 'file' : last_cube , 'camera' : 'CRED2' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Stop Exposure Meter log . info ( f \" Waiting for ExpMeter to be Ready\" ) EMsuccess = ktl . waitFor ( '$kpf_expmeter.EXPSTATE == Ready' , timeout = 5 ) time . sleep ( 0.5 ) # Time shim because paranoia if EMsuccess is True : lastfile = kpf_expmeter [ 'FITSFILE' ] . read () else : lastfile = 'failed' log . debug ( f ' Done. FITSFILE= { lastfile } ' ) row = { 'file' : lastfile , 'camera' : 'ExpMeter' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) if EMsuccess is True : loutfile = kpf_expmeter [ 'LOUTFILE' ] . read () else : loutfile = 'failed' log . debug ( f ' Done. LOUTFILE= { loutfile } ' ) row = { 'file' : loutfile , 'camera' : 'ExpMeter_1Dspec' , 'x' : xs [ i ], 'y' : ys [ j ]} images . add_row ( row ) # Retrieve keyword history end = time . time () expmeter_data = { 'x' : xs [ i ], 'y' : ys [ j ], 'i' : i , 'j' : j , } log . info ( f \" Retrieving keyword history\" ) for counts_kw in [ 'CUR_COUNTS' , 'RAW_COUNTS' , 'BCK_COUNTS' ]: log . debug ( f \" Retrieving keyword history for { counts_kw } \" ) kws = { 'kpf_expmeter' : [ counts_kw ]} counts_history = keygrabber . retrieve ( kws , begin = begin , end = end ) # Extract counts and save to table (initial style output) fluxes = np . zeros (( len ( counts_history ) - 2 , 4 )) for k , entry in enumerate ( counts_history ): if k != 0 and k != len ( counts_history ) - 1 : value_floats = [ float ( v ) for v in entry [ 'ascvalue' ] . split ()] ts = datetime . fromtimestamp ( entry [ 'time' ]) . strftime ( '%Y-%m- %d %H:%M:%S' ) log . debug ( f \" { ts } : { value_floats } \" ) fluxes [ k - 1 ] = value_floats avg_fluxes = np . mean ( fluxes , axis = 0 ) expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 1\" ] = avg_fluxes [ 0 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 2\" ] = avg_fluxes [ 1 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 3\" ] = avg_fluxes [ 2 ] expmeter_data [ f \" { counts_kw [: 3 ] . lower () } 4\" ] = avg_fluxes [ 3 ] expmeter_data [ 'nimages' ] = len ( counts_history ) expmeter_flux . add_row ( expmeter_data ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) if fluxes_file . exists (): fluxes_file . unlink () expmeter_flux . write ( fluxes_file , format = 'ascii.csv' ) if grid == 'TipTilt' : SetTipTiltTargetPixel . execute ({ 'x' : basex , 'y' : basey }) StopTipTilt . execute ({}) elif grid == 'SciADC' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) # kpffiu['ADCTRACK'].write('On') @classmethod def post_condition ( cls , args , logger , cfg ): pass","title":"ARGS:"},{"location":"scripts/GuiderLastfile/","text":"GuiderLastfile Bases: KPFFunction Print the value of the kpfguide.LASTFILE keyword to STDOUT Parameters: wait ( bool ) \u2013 Return only after lastfile is updated? (default = False) KTL Keywords Used: kpfguide.LASTFILE Source code in kpf/guider/GuiderLastfile.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class GuiderLastfile ( KPFFunction ): '''Print the value of the kpfguide.LASTFILE keyword to STDOUT Args: wait (bool): Return only after lastfile is updated? (default = False) KTL Keywords Used: - `kpfguide.LASTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) if args . get ( 'wait' , True ) is True : exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) initial_lastfile = kpfguide [ 'LASTFILE' ] . read () timeout = cfg . getfloat ( 'times' , 'kpfguide_shim_time' , fallback = 0.01 ) expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) lastfile = kpfguide [ 'LASTFILE' ] . read () print ( lastfile ) return lastfile @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"GuiderLastfile"},{"location":"scripts/GuiderLastfile/#guiderlastfile","text":"Bases: KPFFunction Print the value of the kpfguide.LASTFILE keyword to STDOUT Parameters: wait ( bool ) \u2013 Return only after lastfile is updated? (default = False) KTL Keywords Used: kpfguide.LASTFILE Source code in kpf/guider/GuiderLastfile.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class GuiderLastfile ( KPFFunction ): '''Print the value of the kpfguide.LASTFILE keyword to STDOUT Args: wait (bool): Return only after lastfile is updated? (default = False) KTL Keywords Used: - `kpfguide.LASTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) if args . get ( 'wait' , True ) is True : exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) initial_lastfile = kpfguide [ 'LASTFILE' ] . read () timeout = cfg . getfloat ( 'times' , 'kpfguide_shim_time' , fallback = 0.01 ) expr = f \"($kpfguide.LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) lastfile = kpfguide [ 'LASTFILE' ] . read () print ( lastfile ) return lastfile @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"GuiderLastfile"},{"location":"scripts/GuiderOutdir/","text":"GuiderOutdir Bases: KPFFunction Print the value of the kpfguide.OUTDIR keyword to STDOUT KTL Keywords Used: kpfguide.OUTDIR Source code in kpf/guider/GuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GuiderOutdir ( KPFFunction ): '''Print the value of the kpfguide.OUTDIR keyword to STDOUT KTL Keywords Used: - `kpfguide.OUTDIR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) OUTDIR . monitor () print ( OUTDIR . ascii ) return OUTDIR . ascii @classmethod def post_condition ( cls , args ): pass","title":"GuiderOutdir"},{"location":"scripts/GuiderOutdir/#guideroutdir","text":"Bases: KPFFunction Print the value of the kpfguide.OUTDIR keyword to STDOUT KTL Keywords Used: kpfguide.OUTDIR Source code in kpf/guider/GuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class GuiderOutdir ( KPFFunction ): '''Print the value of the kpfguide.OUTDIR keyword to STDOUT KTL Keywords Used: - `kpfguide.OUTDIR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) OUTDIR . monitor () print ( OUTDIR . ascii ) return OUTDIR . ascii @classmethod def post_condition ( cls , args ): pass","title":"GuiderOutdir"},{"location":"scripts/ImageBackIlluminatedFibers/","text":"ImageBackIlluminatedFibers Bases: KPFTranslatorFunction Take images of the back illuminated fibers using the FVCs Source code in kpf/engineering/ImageBackIlluminatedFibers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ImageBackIlluminatedFibers ( KPFTranslatorFunction ): '''Take images of the back illuminated fibers using the FVCs ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/' ) images_file = log_path / Path ( f ' { this_file_name } _images.txt' ) hstnow = datetime . now () now_str = hstnow . strftime ( '%Y-%m- %d %H:%M:%S' ) LEDoutlets = { 'Science' : 'E7' , 'Sky' : 'E8' , 'CaHK' : 'J7' , 'ExpMeter' : 'H1' } LEDnames = { 'Science' : 'Science Back-Illumination LED' , 'Sky' : 'Sky Back-Illumination LED' , 'CaHK' : 'HK Back-Illumination LED' , 'ExpMeter' : 'Exp Meter Back Illum LED' } exptimes = { 'SCI' : { 'Science' : 0.1 , 'Sky' : 1 , 'ExpMeter' : 2 }, 'CAHK' : { 'CaHK' : 5 } } kpffvc = ktl . cache ( 'kpffvc' ) kpfpower = ktl . cache ( 'kpfpower' ) kpffiu = ktl . cache ( 'kpffiu' ) def take_back_illuminated_image ( camera , LEDname ): log . info ( f \"Taking back illuminated image of { LEDname } fiber with { camera } FVC\" ) camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () == 'Off' : FVCPower . execute ({ 'camera' : camera , 'power' : 'on' }) # Time shim to let FVC service connect to camera after power up time . sleep ( 10 ) # Set ADC to Null if camera == 'SCI' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) success1 = kpffiu [ 'ADC1NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'ADC2NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on science ADC' ) elif camera == 'CAHK' : kpffiu [ 'HKXNAM' ] . write ( 'Null' ) kpffiu [ 'HKYNAM' ] . write ( 'Null' ) success1 = kpffiu [ 'HKXNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'HKYNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on HK ADC' ) # Turn LED on outlet = LEDoutlets [ LEDname ] if LEDnames [ LEDname ] != kpfpower [ f \"OUTLET_ { outlet } _NAME\" ] . read (): raise KPFException ( f \"Expected outlet { outlet } to have name { LEDnames [ LEDname ] } \" ) log . debug ( 'Turning LED on' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'On' ) # Take FVC Image SetFVCExpTime . execute ({ 'camera' : camera , 'exptime' : exptimes [ camera ][ LEDname ]}) lastfile = TakeFVCExposure . execute ({ 'camera' : camera }) log . info ( f ' LASTFILE: { lastfile } ' ) log . debug ( 'Turning LED off' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'Off' ) # Append to images file if images_file . exists () is False : # Write header line header = f \"# HST date, camera, LED, file \\n \" with open ( images_file , 'w' ) as f : f . write ( header ) row = f \" { now_str } , { camera : 4s } , { LEDname : 8s } , { lastfile } \\n \" with open ( images_file , 'a' ) as f : f . write ( row ) if args . get ( 'SCI' , False ) is True : take_back_illuminated_image ( 'SCI' , 'Science' ) take_back_illuminated_image ( 'SCI' , 'Sky' ) take_back_illuminated_image ( 'SCI' , 'ExpMeter' ) if args . get ( 'CAHK' , False ) is True : take_back_illuminated_image ( 'CAHK' , 'CaHK' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , \"--SCI\" , dest = \"SCI\" , default = False , action = \"store_true\" , help = \"Image science and sky fibers with science FVC?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , \"--CAHK\" , dest = \"CAHK\" , default = False , action = \"store_true\" , help = \"Image CaHK fiber with CaHK FVC?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ImageBackIlluminatedFibers"},{"location":"scripts/ImageBackIlluminatedFibers/#imagebackilluminatedfibers","text":"Bases: KPFTranslatorFunction Take images of the back illuminated fibers using the FVCs Source code in kpf/engineering/ImageBackIlluminatedFibers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class ImageBackIlluminatedFibers ( KPFTranslatorFunction ): '''Take images of the back illuminated fibers using the FVCs ''' @classmethod def pre_condition ( cls , args , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/' ) images_file = log_path / Path ( f ' { this_file_name } _images.txt' ) hstnow = datetime . now () now_str = hstnow . strftime ( '%Y-%m- %d %H:%M:%S' ) LEDoutlets = { 'Science' : 'E7' , 'Sky' : 'E8' , 'CaHK' : 'J7' , 'ExpMeter' : 'H1' } LEDnames = { 'Science' : 'Science Back-Illumination LED' , 'Sky' : 'Sky Back-Illumination LED' , 'CaHK' : 'HK Back-Illumination LED' , 'ExpMeter' : 'Exp Meter Back Illum LED' } exptimes = { 'SCI' : { 'Science' : 0.1 , 'Sky' : 1 , 'ExpMeter' : 2 }, 'CAHK' : { 'CaHK' : 5 } } kpffvc = ktl . cache ( 'kpffvc' ) kpfpower = ktl . cache ( 'kpfpower' ) kpffiu = ktl . cache ( 'kpffiu' ) def take_back_illuminated_image ( camera , LEDname ): log . info ( f \"Taking back illuminated image of { LEDname } fiber with { camera } FVC\" ) camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () == 'Off' : FVCPower . execute ({ 'camera' : camera , 'power' : 'on' }) # Time shim to let FVC service connect to camera after power up time . sleep ( 10 ) # Set ADC to Null if camera == 'SCI' : kpffiu [ 'ADC1NAM' ] . write ( 'Null' ) kpffiu [ 'ADC2NAM' ] . write ( 'Null' ) success1 = kpffiu [ 'ADC1NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'ADC2NAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on science ADC' ) elif camera == 'CAHK' : kpffiu [ 'HKXNAM' ] . write ( 'Null' ) kpffiu [ 'HKYNAM' ] . write ( 'Null' ) success1 = kpffiu [ 'HKXNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) success2 = kpffiu [ 'HKYNAM' ] . waitFor ( \"=='Null'\" , timeout = 30 ) if success1 is False or success2 is False : raise KPFException ( 'Failed to reach Null position on HK ADC' ) # Turn LED on outlet = LEDoutlets [ LEDname ] if LEDnames [ LEDname ] != kpfpower [ f \"OUTLET_ { outlet } _NAME\" ] . read (): raise KPFException ( f \"Expected outlet { outlet } to have name { LEDnames [ LEDname ] } \" ) log . debug ( 'Turning LED on' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'On' ) # Take FVC Image SetFVCExpTime . execute ({ 'camera' : camera , 'exptime' : exptimes [ camera ][ LEDname ]}) lastfile = TakeFVCExposure . execute ({ 'camera' : camera }) log . info ( f ' LASTFILE: { lastfile } ' ) log . debug ( 'Turning LED off' ) kpfpower [ f \"OUTLET_ { outlet } \" ] . write ( 'Off' ) # Append to images file if images_file . exists () is False : # Write header line header = f \"# HST date, camera, LED, file \\n \" with open ( images_file , 'w' ) as f : f . write ( header ) row = f \" { now_str } , { camera : 4s } , { LEDname : 8s } , { lastfile } \\n \" with open ( images_file , 'a' ) as f : f . write ( row ) if args . get ( 'SCI' , False ) is True : take_back_illuminated_image ( 'SCI' , 'Science' ) take_back_illuminated_image ( 'SCI' , 'Sky' ) take_back_illuminated_image ( 'SCI' , 'ExpMeter' ) if args . get ( 'CAHK' , False ) is True : take_back_illuminated_image ( 'CAHK' , 'CaHK' ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , \"--SCI\" , dest = \"SCI\" , default = False , action = \"store_true\" , help = \"Image science and sky fibers with science FVC?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , \"--CAHK\" , dest = \"CAHK\" , default = False , action = \"store_true\" , help = \"Image CaHK fiber with CaHK FVC?\" ) return super () . add_cmdline_args ( parser , cfg )","title":"ImageBackIlluminatedFibers"},{"location":"scripts/InitializeTipTilt/","text":"InitializeTipTilt Bases: KPFFunction Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. KTL Keywords Used: kpfguide.TIPTILT_HOME kpffiu.TTXSRV kpffiu.TTYSRV kpffiu.TTXVAX kpffiu.TTYVAX Source code in kpf/fiu/InitializeTipTilt.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class InitializeTipTilt ( KPFFunction ): '''Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. KTL Keywords Used: - `kpfguide.TIPTILT_HOME` - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( f \"Initializing tip tilt mirror\" ) kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) kpffiu [ 'TTXSRV' ] . write ( 'closed' ) kpffiu [ 'TTYSRV' ] . write ( 'closed' ) time . sleep ( 1 ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) timeout = 1000 * movetime tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) if not ktl . waitFor ( '($kpffiu.TTXSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXSRV' ] . read (), 'closed' ) if not ktl . waitFor ( '($kpffiu.TTYSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYSRV' ] . read (), 'closed' ) expr = ( f '($kpffiu.TTXVAX >= { home [ 0 ] - tol } ) and ' \\ f '($kpffiu.TTXVAX <= { home [ 0 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), f \" { home [ 0 ] } \" ) expr = ( f '($kpffiu.TTYVAX >= { home [ 1 ] - tol } ) and ' \\ f '($kpffiu.TTYVAX <= { home [ 1 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), f \" { home [ 1 ] } \" )","title":"InitializeTipTilt"},{"location":"scripts/InitializeTipTilt/#initializetiptilt","text":"Bases: KPFFunction Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. KTL Keywords Used: kpfguide.TIPTILT_HOME kpffiu.TTXSRV kpffiu.TTYSRV kpffiu.TTXVAX kpffiu.TTYVAX Source code in kpf/fiu/InitializeTipTilt.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class InitializeTipTilt ( KPFFunction ): '''Initialize the tip tilt system by setting the control mode to closed loop and setting the target values in X and Y to 0. KTL Keywords Used: - `kpfguide.TIPTILT_HOME` - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( f \"Initializing tip tilt mirror\" ) kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) kpffiu [ 'TTXSRV' ] . write ( 'closed' ) kpffiu [ 'TTYSRV' ] . write ( 'closed' ) time . sleep ( 1 ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) timeout = 1000 * movetime tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) if not ktl . waitFor ( '($kpffiu.TTXSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXSRV' ] . read (), 'closed' ) if not ktl . waitFor ( '($kpffiu.TTYSRV == closed)' , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYSRV' ] . read (), 'closed' ) expr = ( f '($kpffiu.TTXVAX >= { home [ 0 ] - tol } ) and ' \\ f '($kpffiu.TTXVAX <= { home [ 0 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), f \" { home [ 0 ] } \" ) expr = ( f '($kpffiu.TTYVAX >= { home [ 1 ] - tol } ) and ' \\ f '($kpffiu.TTYVAX <= { home [ 1 ] + tol } )' ) if not ktl . waitFor ( expr , timeout = timeout ): raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), f \" { home [ 1 ] } \" )","title":"InitializeTipTilt"},{"location":"scripts/IsCalSourceEnabled/","text":"IsCalSourceEnabled Bases: KPFFunction Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. Parameters: CalSource ( str ) \u2013 Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Returns: \u2013 The return value. True for enabled, False for disabled. KTL Keywords Used: kpfcal.OCTAGON kpfconfig.BRDBANDFIBER_ENABLED kpfconfig.U_GOLD_ENABLED kpfconfig.U_DAILY_ENABLED kpfconfig.TH_DAILY_ENABLED kpfconfig.TH_GOLD_ENABLED kpfconfig.FF_FIBER_ENABLED kpfconfig.EXPMLED_ENABLED kpfconfig.HKLED_ENABLED kpfconfig.SCILED_ENABLED kpfconfig.SKYLED_ENABLED Source code in kpf/calbench/IsCalSourceEnabled.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class IsCalSourceEnabled ( KPFFunction ): '''Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. Args: CalSource (str): Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Returns: The return value. True for enabled, False for disabled. KTL Keywords Used: - `kpfcal.OCTAGON` - `kpfconfig.BRDBANDFIBER_ENABLED` - `kpfconfig.U_GOLD_ENABLED` - `kpfconfig.U_DAILY_ENABLED` - `kpfconfig.TH_DAILY_ENABLED` - `kpfconfig.TH_GOLD_ENABLED` - `kpfconfig.FF_FIBER_ENABLED` - `kpfconfig.EXPMLED_ENABLED` - `kpfconfig.HKLED_ENABLED` - `kpfconfig.SCILED_ENABLED` - `kpfconfig.SKYLED_ENABLED` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) allowed_values . append ( 'SoCal-SciSky' ) allowed_values . append ( 'WideFlat' ) allowed_values . append ( 'dark' ) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): calsource = args . get ( 'CalSource' ) if calsource in [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' ]: lamp_name = standardize_lamp_name ( calsource ) elif calsource in [ 'LFCFiber' , 'EtalonFiber' ]: lamp_name = calsource . upper () elif calsource in [ 'SoCal-CalFib' , 'SoCal-SciSky' ]: lamp_name = calsource . replace ( '-' , '_' ) . replace ( 'Sky' , 'FIB' ) elif calsource in [ 'dark' , 'Dark' ]: return True else : log . warning ( f \"IsCalSourceEnabled does not recognize ' { calsource } '\" ) return True lamp_enabledkw = ktl . cache ( 'kpfconfig' , f ' { lamp_name } _ENABLED' ) lamp_enabled = lamp_enabledkw . read ( binary = True ) if lamp_enabled is True : log . debug ( f \"Cal source { calsource } is enabled\" ) print ( f \"Cal source { calsource } is enabled\" ) else : log . warning ( f \"Cal source { calsource } is disabled\" ) return lamp_enabled @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'LFCFiber' , 'EtalonFiber' , 'SoCal-CalFib' , 'SoCal-SciSky' ], help = 'Which lamp to check?' ) return super () . add_cmdline_args ( parser )","title":"IsCalSourceEnabled"},{"location":"scripts/IsCalSourceEnabled/#iscalsourceenabled","text":"Bases: KPFFunction Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. Parameters: CalSource ( str ) \u2013 Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Returns: \u2013 The return value. True for enabled, False for disabled. KTL Keywords Used: kpfcal.OCTAGON kpfconfig.BRDBANDFIBER_ENABLED kpfconfig.U_GOLD_ENABLED kpfconfig.U_DAILY_ENABLED kpfconfig.TH_DAILY_ENABLED kpfconfig.TH_GOLD_ENABLED kpfconfig.FF_FIBER_ENABLED kpfconfig.EXPMLED_ENABLED kpfconfig.HKLED_ENABLED kpfconfig.SCILED_ENABLED kpfconfig.SKYLED_ENABLED Source code in kpf/calbench/IsCalSourceEnabled.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class IsCalSourceEnabled ( KPFFunction ): '''Return a boolean indicating whether the input CalSource is enabled as reported by the kpfconfig.%_ENABLED keywords. Args: CalSource (str): Which lamp to check? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber, SoCal-SciSky, WideFlat Returns: The return value. True for enabled, False for disabled. KTL Keywords Used: - `kpfcal.OCTAGON` - `kpfconfig.BRDBANDFIBER_ENABLED` - `kpfconfig.U_GOLD_ENABLED` - `kpfconfig.U_DAILY_ENABLED` - `kpfconfig.TH_DAILY_ENABLED` - `kpfconfig.TH_GOLD_ENABLED` - `kpfconfig.FF_FIBER_ENABLED` - `kpfconfig.EXPMLED_ENABLED` - `kpfconfig.HKLED_ENABLED` - `kpfconfig.SCILED_ENABLED` - `kpfconfig.SKYLED_ENABLED` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) allowed_values . append ( 'SoCal-SciSky' ) allowed_values . append ( 'WideFlat' ) allowed_values . append ( 'dark' ) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): calsource = args . get ( 'CalSource' ) if calsource in [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' ]: lamp_name = standardize_lamp_name ( calsource ) elif calsource in [ 'LFCFiber' , 'EtalonFiber' ]: lamp_name = calsource . upper () elif calsource in [ 'SoCal-CalFib' , 'SoCal-SciSky' ]: lamp_name = calsource . replace ( '-' , '_' ) . replace ( 'Sky' , 'FIB' ) elif calsource in [ 'dark' , 'Dark' ]: return True else : log . warning ( f \"IsCalSourceEnabled does not recognize ' { calsource } '\" ) return True lamp_enabledkw = ktl . cache ( 'kpfconfig' , f ' { lamp_name } _ENABLED' ) lamp_enabled = lamp_enabledkw . read ( binary = True ) if lamp_enabled is True : log . debug ( f \"Cal source { calsource } is enabled\" ) print ( f \"Cal source { calsource } is enabled\" ) else : log . warning ( f \"Cal source { calsource } is disabled\" ) return lamp_enabled @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'BrdbandFiber' , 'WideFlat' , 'Th_daily' , 'Th_gold' , 'U_daily' , 'U_gold' , 'LFCFiber' , 'EtalonFiber' , 'SoCal-CalFib' , 'SoCal-SciSky' ], help = 'Which lamp to check?' ) return super () . add_cmdline_args ( parser )","title":"IsCalSourceEnabled"},{"location":"scripts/IsSoCalClosed/","text":"IsSoCalClosed Bases: KPFFunction Returns True if SoCal enclsoure is closed. KTL Keywords Used: kpfsocal.ENCSTA Source code in kpf/socal/IsSoCalClosed.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalClosed ( KPFFunction ): '''Returns True if SoCal enclsoure is closed. KTL Keywords Used: - `kpfsocal.ENCSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) msg = { True : 'SoCal is Closed' , False : 'SoCal is NOT Closed' }[ is_closed ] print ( msg ) return is_closed @classmethod def post_condition ( cls , args ): pass","title":"IsSoCalClosed"},{"location":"scripts/IsSoCalClosed/#issocalclosed","text":"Bases: KPFFunction Returns True if SoCal enclsoure is closed. KTL Keywords Used: kpfsocal.ENCSTA Source code in kpf/socal/IsSoCalClosed.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalClosed ( KPFFunction ): '''Returns True if SoCal enclsoure is closed. KTL Keywords Used: - `kpfsocal.ENCSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) msg = { True : 'SoCal is Closed' , False : 'SoCal is NOT Closed' }[ is_closed ] print ( msg ) return is_closed @classmethod def post_condition ( cls , args ): pass","title":"IsSoCalClosed"},{"location":"scripts/IsSoCalOpen/","text":"IsSoCalOpen Bases: KPFFunction Returns True if SoCal enclsoure is open. KTL Keywords Used: kpfsocal.ENCSTA Source code in kpf/socal/IsSoCalOpen.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalOpen ( KPFFunction ): '''Returns True if SoCal enclsoure is open. KTL Keywords Used: - `kpfsocal.ENCSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_open = ENCSTA . waitFor ( \"==0\" , timeout = timeout ) msg = { True : 'SoCal is Open' , False : 'SoCal is NOT Open' }[ is_open ] print ( msg ) return is_open @classmethod def post_condition ( cls , args ): pass","title":"IsSoCalOpen"},{"location":"scripts/IsSoCalOpen/#issocalopen","text":"Bases: KPFFunction Returns True if SoCal enclsoure is open. KTL Keywords Used: kpfsocal.ENCSTA Source code in kpf/socal/IsSoCalOpen.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class IsSoCalOpen ( KPFFunction ): '''Returns True if SoCal enclsoure is open. KTL Keywords Used: - `kpfsocal.ENCSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_open = ENCSTA . waitFor ( \"==0\" , timeout = timeout ) msg = { True : 'SoCal is Open' , False : 'SoCal is NOT Open' }[ is_open ] print ( msg ) return is_open @classmethod def post_condition ( cls , args ): pass","title":"IsSoCalOpen"},{"location":"scripts/IsSoCalShutDown/","text":"IsSoCalShutDown Bases: KPFFunction Returns True if SoCal enclosure is closed and tracker is parked. KTL Keywords Used: kpfsocal.ENCSTA kpfsocal.EKOHOME Source code in kpf/socal/IsSoCalShutDown.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class IsSoCalShutDown ( KPFFunction ): '''Returns True if SoCal enclosure is closed and tracker is parked. KTL Keywords Used: - `kpfsocal.ENCSTA` - `kpfsocal.EKOHOME` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Enclosure timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) EKOHOME = ktl . cache ( 'kpfsocal' , 'EKOHOME' ) is_home = EKOHOME . waitFor ( \"==1\" , timeout = timeout ) closedstr = { True : '' , False : 'NOT ' }[ is_closed ] parkedstr = { True : '' , False : 'NOT ' }[ is_home ] msg = f 'SoCal is { closedstr } closed and is { parkedstr } parked' print ( msg ) shutdown = is_closed and is_home if not shutdown and args . get ( 'email' , False ) is True : try : url = 'http://192.168.78.70/camera/index.html#/video' msg += f ' \\n\\n SoCal status can be viewed using this camera: { url } ' SendEmail . execute ({ 'Subject' : f 'KPF SoCal is not shut down properly' , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) return shutdown @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if SoCal is not shut down?' ) return super () . add_cmdline_args ( parser )","title":"IsSoCalShutDown"},{"location":"scripts/IsSoCalShutDown/#issocalshutdown","text":"Bases: KPFFunction Returns True if SoCal enclosure is closed and tracker is parked. KTL Keywords Used: kpfsocal.ENCSTA kpfsocal.EKOHOME Source code in kpf/socal/IsSoCalShutDown.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class IsSoCalShutDown ( KPFFunction ): '''Returns True if SoCal enclosure is closed and tracker is parked. KTL Keywords Used: - `kpfsocal.ENCSTA` - `kpfsocal.EKOHOME` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Enclosure timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) ENCSTA = ktl . cache ( 'kpfsocal' , 'ENCSTA' ) is_closed = ENCSTA . waitFor ( \"==1\" , timeout = timeout ) EKOHOME = ktl . cache ( 'kpfsocal' , 'EKOHOME' ) is_home = EKOHOME . waitFor ( \"==1\" , timeout = timeout ) closedstr = { True : '' , False : 'NOT ' }[ is_closed ] parkedstr = { True : '' , False : 'NOT ' }[ is_home ] msg = f 'SoCal is { closedstr } closed and is { parkedstr } parked' print ( msg ) shutdown = is_closed and is_home if not shutdown and args . get ( 'email' , False ) is True : try : url = 'http://192.168.78.70/camera/index.html#/video' msg += f ' \\n\\n SoCal status can be viewed using this camera: { url } ' SendEmail . execute ({ 'Subject' : f 'KPF SoCal is not shut down properly' , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) return shutdown @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--email' , dest = \"email\" , default = False , action = \"store_true\" , help = 'Send email if SoCal is not shut down?' ) return super () . add_cmdline_args ( parser )","title":"IsSoCalShutDown"},{"location":"scripts/LockFIU/","text":"LockFIU Bases: KPFFunction Lock the FIU mechanisms Parameters: comment ( str ) \u2013 A comment (must not be empty) designating why the mechanisms are locked. KTL Keywords Used: kpffiu.ADC1LCK kpffiu.ADC2LCK kpffiu.FOLDLCK kpffiu.HKXLCK kpffiu.HKYLCK kpffiu.TTXLCK kpffiu.TTYLCK Source code in kpf/fiu/LockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class LockFIU ( KPFFunction ): '''Lock the FIU mechanisms Args: comment (str): A comment (must not be empty) designating why the mechanisms are locked. KTL Keywords Used: - `kpffiu.ADC1LCK` - `kpffiu.ADC2LCK` - `kpffiu.FOLDLCK` - `kpffiu.HKXLCK` - `kpffiu.HKYLCK` - `kpffiu.TTXLCK` - `kpffiu.TTYLCK` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): comment = args . get ( 'comment' , 'locked' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( comment ) kpffiu [ 'adc2lck' ] . write ( comment ) kpffiu [ 'foldlck' ] . write ( comment ) kpffiu [ 'hkxlck' ] . write ( comment ) kpffiu [ 'hkylck' ] . write ( comment ) kpffiu [ 'ttxlck' ] . write ( comment ) kpffiu [ 'ttylck' ] . write ( comment ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'comment' , type = str , help = 'Comment for lock keywords' ) return super () . add_cmdline_args ( parser )","title":"LockFIU"},{"location":"scripts/LockFIU/#lockfiu","text":"Bases: KPFFunction Lock the FIU mechanisms Parameters: comment ( str ) \u2013 A comment (must not be empty) designating why the mechanisms are locked. KTL Keywords Used: kpffiu.ADC1LCK kpffiu.ADC2LCK kpffiu.FOLDLCK kpffiu.HKXLCK kpffiu.HKYLCK kpffiu.TTXLCK kpffiu.TTYLCK Source code in kpf/fiu/LockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class LockFIU ( KPFFunction ): '''Lock the FIU mechanisms Args: comment (str): A comment (must not be empty) designating why the mechanisms are locked. KTL Keywords Used: - `kpffiu.ADC1LCK` - `kpffiu.ADC2LCK` - `kpffiu.FOLDLCK` - `kpffiu.HKXLCK` - `kpffiu.HKYLCK` - `kpffiu.TTXLCK` - `kpffiu.TTYLCK` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): comment = args . get ( 'comment' , 'locked' ) . strip () kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( comment ) kpffiu [ 'adc2lck' ] . write ( comment ) kpffiu [ 'foldlck' ] . write ( comment ) kpffiu [ 'hkxlck' ] . write ( comment ) kpffiu [ 'hkylck' ] . write ( comment ) kpffiu [ 'ttxlck' ] . write ( comment ) kpffiu [ 'ttylck' ] . write ( comment ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'comment' , type = str , help = 'Comment for lock keywords' ) return super () . add_cmdline_args ( parser )","title":"LockFIU"},{"location":"scripts/MeasureTipTiltMirrorRange/","text":"MeasureTipTiltMirrorRange Bases: KPFFunction Measure the range of the tip tilt mirror. Prints to screen the keyword modify commands to update the range parameters. KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX kpffiu.TTXMEX kpffiu.TTYMEX kpffiu.TTXMED kpffiu.TTYMED kpfguide.TIPTILT_HOME Functions Called: kpf.fiu.InitializeTipTilt kpf.fiu.ShutdownTipTilt Source code in kpf/fiu/MeasureTipTiltMirrorRange.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class MeasureTipTiltMirrorRange ( KPFFunction ): '''Measure the range of the tip tilt mirror. Prints to screen the keyword modify commands to update the range parameters. KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpffiu.TTXMEX` - `kpffiu.TTYMEX` - `kpffiu.TTXMED` - `kpffiu.TTYMED` - `kpfguide.TIPTILT_HOME` Functions Called: - `kpf.fiu.InitializeTipTilt` - `kpf.fiu.ShutdownTipTilt` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Measure tip tilt ranges log . info ( 'Beginning MeasureTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) sleeptime = 10 # Set by the 5 second time in the %MEX and %MEV keywords # Need to account for worst case tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) n = args . get ( 'repeats' ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) measured_range = {} axis = [ 'X' , 'Y' ] rawvals = {} update_ax = { 'X' : False , 'Y' : False } for i , ax in enumerate ( axis ): nominal_range = { 'X' : 15.9 , 'Y' : 24.6 }[ ax ] home = 0 measured_range [ ax ] = [ - nominal_range , nominal_range ] rawvals [ ax ] = [ None , None ] # Negative side commanded_position = home - nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 0 ] = new_limit # Positive side commanded_position = home + nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 1 ] = new_limit time . sleep ( sleeptime ) InitializeTipTilt . execute ({}) time . sleep ( sleeptime ) log . info ( f \"Measured X range: { measured_range [ 'X' ] } \" ) log . info ( f \"Measured Y range: { measured_range [ 'Y' ] } \" ) new_home = [ np . mean ( measured_range [ 'X' ]), np . mean ( measured_range [ 'Y' ])] current_home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True ) if np . isclose ( current_home [ 0 ], new_home [ 0 ]) and np . isclose ( current_home [ 1 ], new_home [ 1 ]): print ( f 'TIPTILT_HOME OK: gshow -s kpfguide TIPTILT_HOME matches { new_home } ' ) else : print ( f \"modify -s kpfguide TIPTILT_HOME=' { new_home [ 0 ] : .1f } { new_home [ 1 ] : .1f } '\" ) for i , ax in enumerate ( axis ): print () range = ( max ( measured_range [ ax ]) - min ( measured_range [ ax ])) / 2 print ( f \"modify -s kpfguide TIPTILT_ { ax } RANGE= { range : .1f } \" ) print ( f \" Sending { ax } to home\" ) kpffiu [ f 'TT { ax } VAX' ] . write ( new_home [ i ]) time . sleep ( sleeptime ) new_RON = kpffiu [ f 'TT { ax } MED' ] . read () print ( f \"modify -s kpffiu TT { ax } RON='| { new_RON } |0|Home'\" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--repeats' , type = int , default = 1 , help = \"The number of iterations to use in the calculation\" ) return super () . add_cmdline_args ( parser )","title":"MeasureTipTiltMirrorRange"},{"location":"scripts/MeasureTipTiltMirrorRange/#measuretiptiltmirrorrange","text":"Bases: KPFFunction Measure the range of the tip tilt mirror. Prints to screen the keyword modify commands to update the range parameters. KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX kpffiu.TTXMEX kpffiu.TTYMEX kpffiu.TTXMED kpffiu.TTYMED kpfguide.TIPTILT_HOME Functions Called: kpf.fiu.InitializeTipTilt kpf.fiu.ShutdownTipTilt Source code in kpf/fiu/MeasureTipTiltMirrorRange.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 class MeasureTipTiltMirrorRange ( KPFFunction ): '''Measure the range of the tip tilt mirror. Prints to screen the keyword modify commands to update the range parameters. KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpffiu.TTXMEX` - `kpffiu.TTYMEX` - `kpffiu.TTXMED` - `kpffiu.TTYMED` - `kpfguide.TIPTILT_HOME` Functions Called: - `kpf.fiu.InitializeTipTilt` - `kpf.fiu.ShutdownTipTilt` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Measure tip tilt ranges log . info ( 'Beginning MeasureTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) sleeptime = 10 # Set by the 5 second time in the %MEX and %MEV keywords # Need to account for worst case tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) n = args . get ( 'repeats' ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) measured_range = {} axis = [ 'X' , 'Y' ] rawvals = {} update_ax = { 'X' : False , 'Y' : False } for i , ax in enumerate ( axis ): nominal_range = { 'X' : 15.9 , 'Y' : 24.6 }[ ax ] home = 0 measured_range [ ax ] = [ - nominal_range , nominal_range ] rawvals [ ax ] = [ None , None ] # Negative side commanded_position = home - nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 0 ] = new_limit # Positive side commanded_position = home + nominal_range new_limit = find_new_limit ( ax , commanded_position , sleeptime = sleeptime , tol = tol , n = n ) if new_limit is not None : update_ax [ ax ] = True measured_range [ ax ][ 1 ] = new_limit time . sleep ( sleeptime ) InitializeTipTilt . execute ({}) time . sleep ( sleeptime ) log . info ( f \"Measured X range: { measured_range [ 'X' ] } \" ) log . info ( f \"Measured Y range: { measured_range [ 'Y' ] } \" ) new_home = [ np . mean ( measured_range [ 'X' ]), np . mean ( measured_range [ 'Y' ])] current_home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True ) if np . isclose ( current_home [ 0 ], new_home [ 0 ]) and np . isclose ( current_home [ 1 ], new_home [ 1 ]): print ( f 'TIPTILT_HOME OK: gshow -s kpfguide TIPTILT_HOME matches { new_home } ' ) else : print ( f \"modify -s kpfguide TIPTILT_HOME=' { new_home [ 0 ] : .1f } { new_home [ 1 ] : .1f } '\" ) for i , ax in enumerate ( axis ): print () range = ( max ( measured_range [ ax ]) - min ( measured_range [ ax ])) / 2 print ( f \"modify -s kpfguide TIPTILT_ { ax } RANGE= { range : .1f } \" ) print ( f \" Sending { ax } to home\" ) kpffiu [ f 'TT { ax } VAX' ] . write ( new_home [ i ]) time . sleep ( sleeptime ) new_RON = kpffiu [ f 'TT { ax } MED' ] . read () print ( f \"modify -s kpffiu TT { ax } RON='| { new_RON } |0|Home'\" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--repeats' , type = int , default = 1 , help = \"The number of iterations to use in the calculation\" ) return super () . add_cmdline_args ( parser )","title":"MeasureTipTiltMirrorRange"},{"location":"scripts/ParkSoCal/","text":"ParkSoCal Bases: KPFFunction Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. KTL Keywords Used: kpfsocal.ENCCMD kpfsocal.ENCSTA kpfsocal.EKOSLEW kpfsocal.EKOTARGALT kpfsocal.EKOTARGAZ kpfsocal.EKOMODE Source code in kpf/socal/ParkSoCal.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class ParkSoCal ( KPFFunction ): '''Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. KTL Keywords Used: - `kpfsocal.ENCCMD` - `kpfsocal.ENCSTA` - `kpfsocal.EKOSLEW` - `kpfsocal.EKOTARGALT` - `kpfsocal.EKOTARGAZ` - `kpfsocal.EKOMODE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): SoCalStopAutonomous . execute ({}) log . info ( 'Parking SoCal' ) kpfsocal = ktl . cache ( 'kpfsocal' ) kpfsocal [ 'ENCCMD' ] . write ( 'close' ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) kpfsocal [ 'EKOTARGALT' ] . write ( 0 ) kpfsocal [ 'EKOTARGAZ' ] . write ( 0 ) kpfsocal [ 'EKOMODE' ] . write ( 0 ) kpfsocal [ 'EKOSLEW' ] . write ( 1 ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) @classmethod def post_condition ( cls , args ): kpfsocal = ktl . cache ( 'kpfsocal' ) timeout = cfg . getfloat ( 'SoCal' , 'park_time' , fallback = 300 ) expr = '($kpfsocal.ENCSTA == 1) ' expr += 'and ($kpfsocal.EKOHOME == 1)' success = ktl . waitFor ( expr , timeout = timeout ) if success is False : raise FailedToReachDestination ( 'SoCal failed to park completely' )","title":"ParkSoCal"},{"location":"scripts/ParkSoCal/#parksocal","text":"Bases: KPFFunction Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. KTL Keywords Used: kpfsocal.ENCCMD kpfsocal.ENCSTA kpfsocal.EKOSLEW kpfsocal.EKOTARGALT kpfsocal.EKOTARGAZ kpfsocal.EKOMODE Source code in kpf/socal/ParkSoCal.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class ParkSoCal ( KPFFunction ): '''Parks SoCal. This includes setting AUTONOMOUS to \"Manual\", closing the enclosure, and parking the solar tracker. KTL Keywords Used: - `kpfsocal.ENCCMD` - `kpfsocal.ENCSTA` - `kpfsocal.EKOSLEW` - `kpfsocal.EKOTARGALT` - `kpfsocal.EKOTARGAZ` - `kpfsocal.EKOMODE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): SoCalStopAutonomous . execute ({}) log . info ( 'Parking SoCal' ) kpfsocal = ktl . cache ( 'kpfsocal' ) kpfsocal [ 'ENCCMD' ] . write ( 'close' ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) kpfsocal [ 'EKOTARGALT' ] . write ( 0 ) kpfsocal [ 'EKOTARGAZ' ] . write ( 0 ) kpfsocal [ 'EKOMODE' ] . write ( 0 ) kpfsocal [ 'EKOSLEW' ] . write ( 1 ) kpfsocal [ 'EKOSLEW' ] . write ( 0 ) @classmethod def post_condition ( cls , args ): kpfsocal = ktl . cache ( 'kpfsocal' ) timeout = cfg . getfloat ( 'SoCal' , 'park_time' , fallback = 300 ) expr = '($kpfsocal.ENCSTA == 1) ' expr += 'and ($kpfsocal.EKOHOME == 1)' success = ktl . waitFor ( expr , timeout = timeout ) if success is False : raise FailedToReachDestination ( 'SoCal failed to park completely' )","title":"ParkSoCal"},{"location":"scripts/PowerCycleCaHK/","text":"PowerCycleCaHK Bases: KPFFunction Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. KTL Keywords Used: kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% Scripts Called: - kpf start/stop/status/restart kpfexpose2 - kpf start/stop/status/restart kpf_hk Source code in kpf/cahk/PowerCycleCaHK.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class PowerCycleCaHK ( KPFFunction ): '''Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. KTL Keywords Used: - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` Scripts Called: -`kpf start/stop/status/restart kpfexpose2` -`kpf start/stop/status/restart kpf_hk` ''' @classmethod def pre_condition ( cls , args ): kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'Galil RIO (expose2)' ), ( 'J2' , 'Galil Output Bank (expose2)' ), ( 'J5' , 'Andor Newton (kpf_hk)' ), ] for outlet_id , outlet_name in outlets : name = kpfpower [ f 'OUTLET_ { outlet_id } _NAME' ] . read () if name . find ( outlet_name ) < 0 : raise FailedPreCondition ( f \"Outlet name: { outlet_id } != ' { outlet_name } '\" ) @classmethod def perform ( cls , args ): log . warning ( 'Stopping kpfexpose2 dispatcher' ) cmd = [ 'kpf' , 'stop' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpfexpose2 command appears to have failed\" ) time . sleep ( 2 ) log . warning ( 'Stopping kpf_hk keyword service' ) cmd = [ 'kpf' , 'stop' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpf_hk command appears to have failed\" ) time . sleep ( 2 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Power cycling the Ca HK detector system' ) kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J5' , 'Andor Newton PS' ), ( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ] for outlet_id , outlet_name in outlets : log . info ( f \"Powering off { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'Off' ) time . sleep ( 10 ) for outlet_id , outlet_name in outlets : log . info ( f \"Powering on { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'On' ) time . sleep ( 10 ) log . warning ( 'Restarting kpf_hk keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpf_hk command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Restarting kpfexpose2 keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpfexpose2 command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Resetting Ca HK' ) ResetCaHKDetector . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"PowerCycleCaHK"},{"location":"scripts/PowerCycleCaHK/#powercyclecahk","text":"Bases: KPFFunction Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. KTL Keywords Used: kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% Scripts Called: - kpf start/stop/status/restart kpfexpose2 - kpf start/stop/status/restart kpf_hk Source code in kpf/cahk/PowerCycleCaHK.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class PowerCycleCaHK ( KPFFunction ): '''Script which will power cycle the Ca HK detector control system and restart the services. Use as a last resort measure after other troubleshooting measures such as resetting the detector and restarting software have already failed. KTL Keywords Used: - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` Scripts Called: -`kpf start/stop/status/restart kpfexpose2` -`kpf start/stop/status/restart kpf_hk` ''' @classmethod def pre_condition ( cls , args ): kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J1' , 'Galil RIO (expose2)' ), ( 'J2' , 'Galil Output Bank (expose2)' ), ( 'J5' , 'Andor Newton (kpf_hk)' ), ] for outlet_id , outlet_name in outlets : name = kpfpower [ f 'OUTLET_ { outlet_id } _NAME' ] . read () if name . find ( outlet_name ) < 0 : raise FailedPreCondition ( f \"Outlet name: { outlet_id } != ' { outlet_name } '\" ) @classmethod def perform ( cls , args ): log . warning ( 'Stopping kpfexpose2 dispatcher' ) cmd = [ 'kpf' , 'stop' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpfexpose2 command appears to have failed\" ) time . sleep ( 2 ) log . warning ( 'Stopping kpf_hk keyword service' ) cmd = [ 'kpf' , 'stop' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf stop kpf_hk command appears to have failed\" ) time . sleep ( 2 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Power cycling the Ca HK detector system' ) kpfpower = ktl . cache ( 'kpfpower' ) outlets = [( 'J5' , 'Andor Newton PS' ), ( 'J1' , 'kpfexpose2 Galil RIO controller' ), ( 'J2' , 'kpfexpose2 Galil output bank' ), ] for outlet_id , outlet_name in outlets : log . info ( f \"Powering off { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'Off' ) time . sleep ( 10 ) for outlet_id , outlet_name in outlets : log . info ( f \"Powering on { outlet_id } : { outlet_name } \" ) kpfpower [ f 'OUTLET_ { outlet_id } ' ] . write ( 'On' ) time . sleep ( 10 ) log . warning ( 'Restarting kpf_hk keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpf_hk command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpf_hk' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Restarting kpfexpose2 keyword service' ) cmd = [ 'kpf' , 'restart' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) if result . returncode != 0 : raise FailedPostCondition ( f \"The kpf restart kpfexpose2 command appears to have failed\" ) time . sleep ( 10 ) # Get status response for log cmd = [ 'kpf' , 'status' , 'kpfexpose2' ] result = subprocess . run ( cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" args: { result . args } \" ) log . debug ( f \" rtncode: { result . returncode } \" ) log . debug ( f \" STDOUT: { result . stdout . decode () } \" ) log . debug ( f \" STDERR: { result . stderr . decode () } \" ) log . warning ( 'Resetting Ca HK' ) ResetCaHKDetector . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"PowerCycleCaHK"},{"location":"scripts/PredictExpMeterParameters/","text":"PredictExpMeterParameters Bases: KPFFunction Estimate the proper exposure meter exposure time given the stellar Gmag. Parameters: Gmag ( float ) \u2013 The Gaia g magnitude of the target. Source code in kpf/expmeter/PredictExpMeterParameters.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class PredictExpMeterParameters ( KPFFunction ): '''Estimate the proper exposure meter exposure time given the stellar Gmag. Args: Gmag (float): The Gaia g magnitude of the target. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Gmag = args . get ( 'Gmag' ) if Gmag < 4.0 : exptime = 0.5 elif Gmag < 9.0 : exptime = 1.0 elif Gmag < 11.0 : exptime = 2.0 elif Gmag < 13.0 : exptime = 4.0 elif Gmag < 15.0 : exptime = 8.0 else : exptime = 16.0 log . info ( f \"Predicted ExpMeterExpTime = { exptime : .1f } s\" ) return { 'ExpMeterExpTime' : exptime } @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The Gaia g magnitude of the target\" ) return super () . add_cmdline_args ( parser )","title":"PredictExpMeterParameters"},{"location":"scripts/PredictExpMeterParameters/#predictexpmeterparameters","text":"Bases: KPFFunction Estimate the proper exposure meter exposure time given the stellar Gmag. Parameters: Gmag ( float ) \u2013 The Gaia g magnitude of the target. Source code in kpf/expmeter/PredictExpMeterParameters.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class PredictExpMeterParameters ( KPFFunction ): '''Estimate the proper exposure meter exposure time given the stellar Gmag. Args: Gmag (float): The Gaia g magnitude of the target. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Gmag = args . get ( 'Gmag' ) if Gmag < 4.0 : exptime = 0.5 elif Gmag < 9.0 : exptime = 1.0 elif Gmag < 11.0 : exptime = 2.0 elif Gmag < 13.0 : exptime = 4.0 elif Gmag < 15.0 : exptime = 8.0 else : exptime = 16.0 log . info ( f \"Predicted ExpMeterExpTime = { exptime : .1f } s\" ) return { 'ExpMeterExpTime' : exptime } @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The Gaia g magnitude of the target\" ) return super () . add_cmdline_args ( parser )","title":"PredictExpMeterParameters"},{"location":"scripts/PredictFVCParameters/","text":"PredictFVCParameters Bases: KPFTranslatorFunction Estimate the exposure time given the stellar Gmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Parameters: Gmag ( float ) \u2013 The G magnitude of the target. Source code in kpf/fvc/PredictFVCParameters.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class PredictFVCParameters ( KPFTranslatorFunction ): '''Estimate the exposure time given the stellar Gmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Args: Gmag (float): The G magnitude of the target. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Gmag = args . get ( 'Gmag' ) delta_mag = 4 - Gmag flux_ratio = 10 ** ( delta_mag / 2.5 ) if flux_ratio > 10 : exptime = { 'SCI' : 0.1 , 'CAHK' : 1.5 } elif flux_ratio > 5 : exptime = { 'SCI' : 0.2 , 'CAHK' : 3 } elif flux_ratio > 2 : exptime = { 'SCI' : 0.5 , 'CAHK' : 8 } elif flux_ratio > 0.5 : exptime = { 'SCI' : 1 , 'CAHK' : 15 } elif flux_ratio > 0.2 : exptime = { 'SCI' : 5 , 'CAHK' : 15 } elif flux_ratio > 0.05 : exptime = { 'SCI' : 10 , 'CAHK' : 15 } result = { 'SCIFVC_exptime' : exptime [ 'SCI' ], 'CAHKFVC_exptime' : exptime [ 'CAHK' ]} print ( result ) if args . get ( 'set' , False ): SetFVCExpTime . execute ({ 'camera' : 'SCI' , 'exptime' : exptime [ 'SCI' ]}) SetFVCExpTime . execute ({ 'camera' : 'CAHK' , 'exptime' : exptime [ 'CAHK' ]}) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictFVCParameters"},{"location":"scripts/PredictFVCParameters/#predictfvcparameters","text":"Bases: KPFTranslatorFunction Estimate the exposure time given the stellar Gmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Parameters: Gmag ( float ) \u2013 The G magnitude of the target. Source code in kpf/fvc/PredictFVCParameters.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class PredictFVCParameters ( KPFTranslatorFunction ): '''Estimate the exposure time given the stellar Gmag and which camera. Based on scaling from a single, poorly measured data point: For Vmag ~ 4, the SCIFVC_exptime = 1 and CAHKFVC_exptime = 15 Args: Gmag (float): The G magnitude of the target. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Gmag = args . get ( 'Gmag' ) delta_mag = 4 - Gmag flux_ratio = 10 ** ( delta_mag / 2.5 ) if flux_ratio > 10 : exptime = { 'SCI' : 0.1 , 'CAHK' : 1.5 } elif flux_ratio > 5 : exptime = { 'SCI' : 0.2 , 'CAHK' : 3 } elif flux_ratio > 2 : exptime = { 'SCI' : 0.5 , 'CAHK' : 8 } elif flux_ratio > 0.5 : exptime = { 'SCI' : 1 , 'CAHK' : 15 } elif flux_ratio > 0.2 : exptime = { 'SCI' : 5 , 'CAHK' : 15 } elif flux_ratio > 0.05 : exptime = { 'SCI' : 10 , 'CAHK' : 15 } result = { 'SCIFVC_exptime' : exptime [ 'SCI' ], 'CAHKFVC_exptime' : exptime [ 'CAHK' ]} print ( result ) if args . get ( 'set' , False ): SetFVCExpTime . execute ({ 'camera' : 'SCI' , 'exptime' : exptime [ 'SCI' ]}) SetFVCExpTime . execute ({ 'camera' : 'CAHK' , 'exptime' : exptime [ 'CAHK' ]}) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictFVCParameters"},{"location":"scripts/PredictGuiderParameters/","text":"PredictGuiderParameters Bases: KPFFunction Estimate the proper gain and FPS given the stellar Jmag. Parameters: Jmag ( float ) \u2013 The J magnitude of the target. Functions Called: kpf.guider.SetGuiderGain kpf.guider.SetGuiderFPS Source code in kpf/guider/PredictGuiderParameters.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class PredictGuiderParameters ( KPFFunction ): '''Estimate the proper gain and FPS given the stellar Jmag. Args: Jmag (float): The J magnitude of the target. Functions Called: - `kpf.guider.SetGuiderGain` - `kpf.guider.SetGuiderFPS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Jmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Jmag = args . get ( 'Jmag' ) if Jmag < 5.5 : gain = 'Low' fps = 100 elif Jmag < 8.0 : gain = 'Medium' fps = 100 elif Jmag < 12.0 : gain = 'High' fps = 100 elif Jmag < 12.8 : gain = 'High' fps = 50 elif Jmag < 13.8 : gain = 'High' fps = 20 elif Jmag < 14.5 : gain = 'High' fps = 10 elif Jmag < 17.0 : gain = 'high' fps = 1 else : gain = 'high' fps = 1 log . info ( f \"Predicted GuideCamGain = { gain } \" ) log . info ( f \"Predicted GuideFPS = { fps : d } \" ) result = { 'GuideCamGain' : gain , 'GuideFPS' : fps } if args . get ( 'set' , False ): SetGuiderGain . execute ( result ) SetGuiderFPS . execute ( result ) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Jmag' , type = float , help = \"The J magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictGuiderParameters"},{"location":"scripts/PredictGuiderParameters/#predictguiderparameters","text":"Bases: KPFFunction Estimate the proper gain and FPS given the stellar Jmag. Parameters: Jmag ( float ) \u2013 The J magnitude of the target. Functions Called: kpf.guider.SetGuiderGain kpf.guider.SetGuiderFPS Source code in kpf/guider/PredictGuiderParameters.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class PredictGuiderParameters ( KPFFunction ): '''Estimate the proper gain and FPS given the stellar Jmag. Args: Jmag (float): The J magnitude of the target. Functions Called: - `kpf.guider.SetGuiderGain` - `kpf.guider.SetGuiderFPS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Jmag' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): Jmag = args . get ( 'Jmag' ) if Jmag < 5.5 : gain = 'Low' fps = 100 elif Jmag < 8.0 : gain = 'Medium' fps = 100 elif Jmag < 12.0 : gain = 'High' fps = 100 elif Jmag < 12.8 : gain = 'High' fps = 50 elif Jmag < 13.8 : gain = 'High' fps = 20 elif Jmag < 14.5 : gain = 'High' fps = 10 elif Jmag < 17.0 : gain = 'high' fps = 1 else : gain = 'high' fps = 1 log . info ( f \"Predicted GuideCamGain = { gain } \" ) log . info ( f \"Predicted GuideFPS = { fps : d } \" ) result = { 'GuideCamGain' : gain , 'GuideFPS' : fps } if args . get ( 'set' , False ): SetGuiderGain . execute ( result ) SetGuiderFPS . execute ( result ) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Jmag' , type = float , help = \"The J magnitude of the target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictGuiderParameters"},{"location":"scripts/PredictNDFilters/","text":"PredictNDFilters Bases: KPFFunction Predict which ND filters should be used for simultaneous calibrations. Parameters: Gmag ( float ) \u2013 The Gaia G magnitude of the target. Teff ( float ) \u2013 The effective temperature of the target. ExpTime ( float ) \u2013 The exposure time. set ( bool ) \u2013 Set these values or just calculate? Functions Called: kpf.calbench.SetND Source code in kpf/calbench/PredictNDFilters.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 class PredictNDFilters ( KPFFunction ): '''Predict which ND filters should be used for simultaneous calibrations. Args: Gmag (float): The Gaia G magnitude of the target. Teff (float): The effective temperature of the target. ExpTime (float): The exposure time. set (bool): Set these values or just calculate? Functions Called: - `kpf.calbench.SetND` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) check_input ( args , 'Teff' , allowed_types = [ int , float ]) check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): tick = datetime . datetime . now () gmag = args . get ( 'Gmag' ) teff = args . get ( 'Teff' ) log . debug ( 'Estimating Vmag from Gmag:' ) vmag = gmag - get_GminusV ( teff ) log . debug ( f ' Gmag= { gmag : .2f } --> Vmag= { vmag : .2f } ' ) obs_exp_time = args . get ( 'ExpTime' ) # Force values in to allowed ranges for KPF-etc if vmag > 19 : log . warning ( f \"Vmag = { vmag : .2f } is outside allowed range for ETC (1-19)\" ) vmag = 19 if vmag < 1 : log . warning ( f \"Vmag = { vmag : .2f } is outside allowed range for ETC (1-19)\" ) vmag = 1 if obs_exp_time > 3600 : log . warning ( f \"ExpTime = { obs_exp_time : .0f } is outside allowed range for ETC (1-3600)\" ) obs_exp_time = 3600 if obs_exp_time < 1 : log . warning ( f \"ExpTime = { obs_exp_time : .0f } is outside allowed range for ETC (1-3600)\" ) obs_exp_time = 1 if teff > 6600 : log . warning ( f \"Teff = { teff : .0f } is outside allowed range for ETC (2700-6600)\" ) teff = 6600 if teff < 2700 : log . warning ( f \"Teff = { teff : .0f } is outside allowed range for ETC (2700-6600)\" ) teff = 2700 # reference calibration file to scale up/down #cal_file = 'KP.20240529.80736.43_L1.fits' # reference etalon L1 file data_dir = Path ( __file__ ) . parent . parent . parent / 'data' cal_file = data_dir / 'KP.20251021.78007.91_L1.fits' # Filter wheel populations for both wheels # od_arr_scical = [0.1, 0.3, 0.5, 0.8, 1.0, 4.0] # od_arr_cal = [0.1, 1.0, 1.3, 2., 3., 4.] # od_arr_scical = [0.1, 1.0, 1.3, 2., 3., 4.] # od_arr_cal = [0.1, 0.3, 0.5, 0.8, 1.0, 4.0] ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) ND1POS_allowed_values = list ( ND1POS . _getEnumerators ()) if 'Unknown' in ND1POS_allowed_values : ND1POS_allowed_values . pop ( ND1POS_allowed_values . index ( 'Unknown' )) od_arr_scical = [ float ( pos [ 3 :]) for pos in ND1POS_allowed_values ] ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) ND2POS_allowed_values = list ( ND2POS . _getEnumerators ()) if 'Unknown' in ND2POS_allowed_values : ND2POS_allowed_values . pop ( ND2POS_allowed_values . index ( 'Unknown' )) od_arr_cal = [ float ( pos [ 3 :]) for pos in ND2POS_allowed_values ] od_vals_all , filter_configs_all = all_possible_sums_with_indices_sorted ( od_arr_scical , od_arr_cal ) od , nd_config = get_simulcal_od ( vmag , teff , obs_exp_time , cal_file , ref_wave = 5500 , od_values = od_vals_all , filter_configs = filter_configs_all ) result = { 'CalND1' : f 'OD { nd_config [ 0 ] } ' , 'CalND2' : f 'OD { nd_config [ 1 ] } ' } log . info ( f \"Predicted ND1 = { result [ 'CalND1' ] } \" ) log . info ( f \"Predicted ND2 = { result [ 'CalND2' ] } \" ) tock = datetime . datetime . now () elapsed = ( tock - tick ) . total_seconds () log . debug ( f 'ND filter calculation took { elapsed : .1f } s' ) if args . get ( 'set' , False ): SetND . execute ( result ) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The gaia G magnitude of the target\" ) parser . add_argument ( 'Teff' , type = float , help = \"The effective temperature of the target\" ) parser . add_argument ( 'ExpTime' , type = float , help = \"The exposure time on target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictNDFilters"},{"location":"scripts/PredictNDFilters/#predictndfilters","text":"Bases: KPFFunction Predict which ND filters should be used for simultaneous calibrations. Parameters: Gmag ( float ) \u2013 The Gaia G magnitude of the target. Teff ( float ) \u2013 The effective temperature of the target. ExpTime ( float ) \u2013 The exposure time. set ( bool ) \u2013 Set these values or just calculate? Functions Called: kpf.calbench.SetND Source code in kpf/calbench/PredictNDFilters.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 class PredictNDFilters ( KPFFunction ): '''Predict which ND filters should be used for simultaneous calibrations. Args: Gmag (float): The Gaia G magnitude of the target. Teff (float): The effective temperature of the target. ExpTime (float): The exposure time. set (bool): Set these values or just calculate? Functions Called: - `kpf.calbench.SetND` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'Gmag' , allowed_types = [ int , float ]) check_input ( args , 'Teff' , allowed_types = [ int , float ]) check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): tick = datetime . datetime . now () gmag = args . get ( 'Gmag' ) teff = args . get ( 'Teff' ) log . debug ( 'Estimating Vmag from Gmag:' ) vmag = gmag - get_GminusV ( teff ) log . debug ( f ' Gmag= { gmag : .2f } --> Vmag= { vmag : .2f } ' ) obs_exp_time = args . get ( 'ExpTime' ) # Force values in to allowed ranges for KPF-etc if vmag > 19 : log . warning ( f \"Vmag = { vmag : .2f } is outside allowed range for ETC (1-19)\" ) vmag = 19 if vmag < 1 : log . warning ( f \"Vmag = { vmag : .2f } is outside allowed range for ETC (1-19)\" ) vmag = 1 if obs_exp_time > 3600 : log . warning ( f \"ExpTime = { obs_exp_time : .0f } is outside allowed range for ETC (1-3600)\" ) obs_exp_time = 3600 if obs_exp_time < 1 : log . warning ( f \"ExpTime = { obs_exp_time : .0f } is outside allowed range for ETC (1-3600)\" ) obs_exp_time = 1 if teff > 6600 : log . warning ( f \"Teff = { teff : .0f } is outside allowed range for ETC (2700-6600)\" ) teff = 6600 if teff < 2700 : log . warning ( f \"Teff = { teff : .0f } is outside allowed range for ETC (2700-6600)\" ) teff = 2700 # reference calibration file to scale up/down #cal_file = 'KP.20240529.80736.43_L1.fits' # reference etalon L1 file data_dir = Path ( __file__ ) . parent . parent . parent / 'data' cal_file = data_dir / 'KP.20251021.78007.91_L1.fits' # Filter wheel populations for both wheels # od_arr_scical = [0.1, 0.3, 0.5, 0.8, 1.0, 4.0] # od_arr_cal = [0.1, 1.0, 1.3, 2., 3., 4.] # od_arr_scical = [0.1, 1.0, 1.3, 2., 3., 4.] # od_arr_cal = [0.1, 0.3, 0.5, 0.8, 1.0, 4.0] ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) ND1POS_allowed_values = list ( ND1POS . _getEnumerators ()) if 'Unknown' in ND1POS_allowed_values : ND1POS_allowed_values . pop ( ND1POS_allowed_values . index ( 'Unknown' )) od_arr_scical = [ float ( pos [ 3 :]) for pos in ND1POS_allowed_values ] ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) ND2POS_allowed_values = list ( ND2POS . _getEnumerators ()) if 'Unknown' in ND2POS_allowed_values : ND2POS_allowed_values . pop ( ND2POS_allowed_values . index ( 'Unknown' )) od_arr_cal = [ float ( pos [ 3 :]) for pos in ND2POS_allowed_values ] od_vals_all , filter_configs_all = all_possible_sums_with_indices_sorted ( od_arr_scical , od_arr_cal ) od , nd_config = get_simulcal_od ( vmag , teff , obs_exp_time , cal_file , ref_wave = 5500 , od_values = od_vals_all , filter_configs = filter_configs_all ) result = { 'CalND1' : f 'OD { nd_config [ 0 ] } ' , 'CalND2' : f 'OD { nd_config [ 1 ] } ' } log . info ( f \"Predicted ND1 = { result [ 'CalND1' ] } \" ) log . info ( f \"Predicted ND2 = { result [ 'CalND2' ] } \" ) tock = datetime . datetime . now () elapsed = ( tock - tick ) . total_seconds () log . debug ( f 'ND filter calculation took { elapsed : .1f } s' ) if args . get ( 'set' , False ): SetND . execute ( result ) return result @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Gmag' , type = float , help = \"The gaia G magnitude of the target\" ) parser . add_argument ( 'Teff' , type = float , help = \"The effective temperature of the target\" ) parser . add_argument ( 'ExpTime' , type = float , help = \"The exposure time on target\" ) parser . add_argument ( \"--set\" , dest = \"set\" , default = False , action = \"store_true\" , help = \"Set these values after calculating?\" ) return super () . add_cmdline_args ( parser )","title":"PredictNDFilters"},{"location":"scripts/QueryFastReadMode/","text":"QueryFastReadMode Bases: KPFFunction Returns True if both ACF files are consistent with fast read mode. Functions Called: kpf.spectrograph.QueryReadMode Source code in kpf/spectrograph/QueryFastReadMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class QueryFastReadMode ( KPFFunction ): '''Returns True if both ACF files are consistent with fast read mode. Functions Called: - `kpf.spectrograph.QueryReadMode` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) return ( green_mode == 'fast' ) and ( red_mode == 'fast' ) @classmethod def post_condition ( cls , args ): pass","title":"QueryFastReadMode"},{"location":"scripts/QueryFastReadMode/#queryfastreadmode","text":"Bases: KPFFunction Returns True if both ACF files are consistent with fast read mode. Functions Called: kpf.spectrograph.QueryReadMode Source code in kpf/spectrograph/QueryFastReadMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class QueryFastReadMode ( KPFFunction ): '''Returns True if both ACF files are consistent with fast read mode. Functions Called: - `kpf.spectrograph.QueryReadMode` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) return ( green_mode == 'fast' ) and ( red_mode == 'fast' ) @classmethod def post_condition ( cls , args ): pass","title":"QueryFastReadMode"},{"location":"scripts/QueryReadMode/","text":"QueryReadMode Bases: KPFFunction Returns string describing the read mode. KTL Keywords Used: kpfgreen.ACFFILE kpfred.ACFFILE Source code in kpf/spectrograph/QueryReadMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class QueryReadMode ( KPFFunction ): '''Returns string describing the read mode. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfred.ACFFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): modes = { 'green' : '' , 'red' : '' } for side in modes . keys (): normal_file = cfg . get ( 'acf_files' , f ' { side } _normal' ) fast_file = cfg . get ( 'acf_files' , f ' { side } _fast' ) ACFFILE = ktl . cache ( f 'kpf { side } ' , 'ACFFILE' ) ACFFILE . monitor () filename = Path ( ACFFILE . ascii ) . stem if filename == normal_file : modes [ side ] = 'normal' elif filename == fast_file : modes [ side ] = 'fast' else : modes [ side ] = 'unknown' log . debug ( f \"Green read mode: { modes [ 'green' ] } , Red read mode: { modes [ 'red' ] } \" ) print ( f \"Green read mode: { modes [ 'green' ] } \" ) print ( f \"Red read mode: { modes [ 'red' ] } \" ) return modes [ 'green' ], modes [ 'red' ] @classmethod def post_condition ( cls , args ): pass","title":"QueryReadMode"},{"location":"scripts/QueryReadMode/#queryreadmode","text":"Bases: KPFFunction Returns string describing the read mode. KTL Keywords Used: kpfgreen.ACFFILE kpfred.ACFFILE Source code in kpf/spectrograph/QueryReadMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class QueryReadMode ( KPFFunction ): '''Returns string describing the read mode. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfred.ACFFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): modes = { 'green' : '' , 'red' : '' } for side in modes . keys (): normal_file = cfg . get ( 'acf_files' , f ' { side } _normal' ) fast_file = cfg . get ( 'acf_files' , f ' { side } _fast' ) ACFFILE = ktl . cache ( f 'kpf { side } ' , 'ACFFILE' ) ACFFILE . monitor () filename = Path ( ACFFILE . ascii ) . stem if filename == normal_file : modes [ side ] = 'normal' elif filename == fast_file : modes [ side ] = 'fast' else : modes [ side ] = 'unknown' log . debug ( f \"Green read mode: { modes [ 'green' ] } , Red read mode: { modes [ 'red' ] } \" ) print ( f \"Green read mode: { modes [ 'green' ] } \" ) print ( f \"Red read mode: { modes [ 'red' ] } \" ) return modes [ 'green' ], modes [ 'red' ] @classmethod def post_condition ( cls , args ): pass","title":"QueryReadMode"},{"location":"scripts/RecoverDetectors/","text":"RecoverDetectors Bases: KPFFunction Try to examine the state of all detectors an run the appropriate recovery ARGS: None Source code in kpf/spectrograph/ResetDetectors.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class RecoverDetectors ( KPFFunction ): '''Try to examine the state of all detectors an run the appropriate recovery ARGS: ===== None ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . warning ( 'Attempting a detector recovery' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) kpfmon = ktl . cache ( 'kpfmon' ) camera_status = kpfmon [ 'CAMSTATESTA' ] . read () if camera_status == 'OK' : log . warning ( 'No camera error state detected by kpfmon' ) explainnr = ktl . cache ( 'kpfexpose' , 'EXPLAINNR' ) explainnr_str = explainnr . read () if explainnr_str . find ( 'hk:' ) >= 0 : log . warning ( 'kpfexpose.EXPLAINNR contains hk' ) ResetCaHKDetector . execute ({}) elif camera_status == 'ERROR' : if kpfmon [ 'G_STATESTA' ] . read () == 'ERROR' : ResetGreenDetector . execute ({}) if kpfmon [ 'R_STATESTA' ] . read () == 'ERROR' : ResetRedDetector . execute ({}) if kpfmon [ 'H_STATESTA' ] . read () == 'ERROR' : ResetCaHKDetector . execute ({}) if kpfmon [ 'E_STATESTA' ] . read () == 'ERROR' : ResetExpMeterDetector . execute ({}) else : log . warning ( f 'kpfmon.CAMSTATESTA= { camera_status } . No action taken.' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"RecoverDetectors"},{"location":"scripts/RecoverDetectors/#recoverdetectors","text":"Bases: KPFFunction Try to examine the state of all detectors an run the appropriate recovery","title":"RecoverDetectors"},{"location":"scripts/RecoverDetectors/#kpf.spectrograph.ResetDetectors.RecoverDetectors--args","text":"None Source code in kpf/spectrograph/ResetDetectors.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class RecoverDetectors ( KPFFunction ): '''Try to examine the state of all detectors an run the appropriate recovery ARGS: ===== None ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . warning ( 'Attempting a detector recovery' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) kpfmon = ktl . cache ( 'kpfmon' ) camera_status = kpfmon [ 'CAMSTATESTA' ] . read () if camera_status == 'OK' : log . warning ( 'No camera error state detected by kpfmon' ) explainnr = ktl . cache ( 'kpfexpose' , 'EXPLAINNR' ) explainnr_str = explainnr . read () if explainnr_str . find ( 'hk:' ) >= 0 : log . warning ( 'kpfexpose.EXPLAINNR contains hk' ) ResetCaHKDetector . execute ({}) elif camera_status == 'ERROR' : if kpfmon [ 'G_STATESTA' ] . read () == 'ERROR' : ResetGreenDetector . execute ({}) if kpfmon [ 'R_STATESTA' ] . read () == 'ERROR' : ResetRedDetector . execute ({}) if kpfmon [ 'H_STATESTA' ] . read () == 'ERROR' : ResetCaHKDetector . execute ({}) if kpfmon [ 'E_STATESTA' ] . read () == 'ERROR' : ResetExpMeterDetector . execute ({}) else : log . warning ( f 'kpfmon.CAMSTATESTA= { camera_status } . No action taken.' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ARGS:"},{"location":"scripts/RecoverFromLowPowerMode/","text":"RecoverFromLowPowerMode Bases: KPFFunction Recover from low power mode. Power on the Ca HK systems Restore cooling to Ca HK detector Re-enable Ca HK detector Power on CRED2 systems KTL Keywords Used: kpfconfig.CA_HK_ENABLED kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% kpfpower.OUTLET_K2% kpfpower.OUTLET_K3% kpfmon.HKTEMPDIS kpfmon.ST_EXPOSE2DIS kpfmon.OUTLET_J1_OODIS kpfmon.OUTLET_J2_OODIS kpfmon.OUTLET_J5_OODIS kpfmon.OUTLET_K2_OODIS kpfmon.OUTLET_K3_OODIS kpf_hk.COOLING kpf_hk.COOLTARG Source code in kpf/scripts/RecoverFromLowPowerMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class RecoverFromLowPowerMode ( KPFFunction ): '''Recover from low power mode. - Power on the Ca HK systems - Restore cooling to Ca HK detector - Re-enable Ca HK detector - Power on CRED2 systems KTL Keywords Used: - `kpfconfig.CA_HK_ENABLED` - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` - `kpfpower.OUTLET_K2%` - `kpfpower.OUTLET_K3%` - `kpfmon.HKTEMPDIS` - `kpfmon.ST_EXPOSE2DIS` - `kpfmon.OUTLET_J1_OODIS` - `kpfmon.OUTLET_J2_OODIS` - `kpfmon.OUTLET_J5_OODIS` - `kpfmon.OUTLET_K2_OODIS` - `kpfmon.OUTLET_K3_OODIS` - `kpf_hk.COOLING` - `kpf_hk.COOLTARG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) kpfpower = ktl . cache ( 'kpfpower' ) kpfmon = ktl . cache ( 'kpfmon' ) log . warning ( 'Recovering KPF from Low Power Mode' ) # Power up Ca HK detector systems kpf_hk = ktl . cache ( 'kpf_hk' ) log . info ( 'Powering on Ca HK detector systems' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J1_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J1' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J2' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J5_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J5' ] . write ( 'On' ) time . sleep ( 10 ) log . info ( 'Turning Ca HK detector cooling on' ) kpf_hk [ 'COOLING' ] . write ( 'On' ) kpf_hk [ 'COOLTARG' ] . write ( - 60 ) log . info ( 'Enabling Ca HK detector' ) kpfconfig [ 'CA_HK_ENABLED' ] . write ( 'Yes' ) log . warning ( 'Enabling HKTEMP alarm' ) kpfmon [ 'HKTEMPDIS' ] . write ( 0 ) log . warning ( 'Enabling ST_EXPOSE2 alarm' ) kpfmon [ 'ST_EXPOSE2DIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J1_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J1_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J2_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J2_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J5_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J5_OODIS' ] . write ( 0 ) # Power up CRED2 detector systems log . info ( 'Powering on CRED2 detector systems' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_K2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K2' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_K3_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K3' ] . write ( 'On' ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_K2_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_K2_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_K3_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_K3_OODIS' ] . write ( 0 ) @classmethod def post_condition ( cls , args ): pass","title":"RecoverFromLowPowerMode"},{"location":"scripts/RecoverFromLowPowerMode/#recoverfromlowpowermode","text":"Bases: KPFFunction Recover from low power mode. Power on the Ca HK systems Restore cooling to Ca HK detector Re-enable Ca HK detector Power on CRED2 systems KTL Keywords Used: kpfconfig.CA_HK_ENABLED kpfpower.OUTLET_J1% kpfpower.OUTLET_J2% kpfpower.OUTLET_J5% kpfpower.OUTLET_K2% kpfpower.OUTLET_K3% kpfmon.HKTEMPDIS kpfmon.ST_EXPOSE2DIS kpfmon.OUTLET_J1_OODIS kpfmon.OUTLET_J2_OODIS kpfmon.OUTLET_J5_OODIS kpfmon.OUTLET_K2_OODIS kpfmon.OUTLET_K3_OODIS kpf_hk.COOLING kpf_hk.COOLTARG Source code in kpf/scripts/RecoverFromLowPowerMode.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class RecoverFromLowPowerMode ( KPFFunction ): '''Recover from low power mode. - Power on the Ca HK systems - Restore cooling to Ca HK detector - Re-enable Ca HK detector - Power on CRED2 systems KTL Keywords Used: - `kpfconfig.CA_HK_ENABLED` - `kpfpower.OUTLET_J1%` - `kpfpower.OUTLET_J2%` - `kpfpower.OUTLET_J5%` - `kpfpower.OUTLET_K2%` - `kpfpower.OUTLET_K3%` - `kpfmon.HKTEMPDIS` - `kpfmon.ST_EXPOSE2DIS` - `kpfmon.OUTLET_J1_OODIS` - `kpfmon.OUTLET_J2_OODIS` - `kpfmon.OUTLET_J5_OODIS` - `kpfmon.OUTLET_K2_OODIS` - `kpfmon.OUTLET_K3_OODIS` - `kpf_hk.COOLING` - `kpf_hk.COOLTARG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) kpfpower = ktl . cache ( 'kpfpower' ) kpfmon = ktl . cache ( 'kpfmon' ) log . warning ( 'Recovering KPF from Low Power Mode' ) # Power up Ca HK detector systems kpf_hk = ktl . cache ( 'kpf_hk' ) log . info ( 'Powering on Ca HK detector systems' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J1_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J1' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J2' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_J5_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_J5' ] . write ( 'On' ) time . sleep ( 10 ) log . info ( 'Turning Ca HK detector cooling on' ) kpf_hk [ 'COOLING' ] . write ( 'On' ) kpf_hk [ 'COOLTARG' ] . write ( - 60 ) log . info ( 'Enabling Ca HK detector' ) kpfconfig [ 'CA_HK_ENABLED' ] . write ( 'Yes' ) log . warning ( 'Enabling HKTEMP alarm' ) kpfmon [ 'HKTEMPDIS' ] . write ( 0 ) log . warning ( 'Enabling ST_EXPOSE2 alarm' ) kpfmon [ 'ST_EXPOSE2DIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J1_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J1_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J2_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J2_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_J5_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_J5_OODIS' ] . write ( 0 ) # Power up CRED2 detector systems log . info ( 'Powering on CRED2 detector systems' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_K2_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K2' ] . write ( 'On' ) log . debug ( f \"Powering on { kpfpower [ 'OUTLET_K3_NAME' ] . read () } \" ) kpfpower [ 'OUTLET_K3' ] . write ( 'On' ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_K2_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_K2_OODIS' ] . write ( 0 ) log . warning ( f \"Enabling { kpfpower [ 'OUTLET_K3_NAME' ] . read () } alarm\" ) kpfmon [ 'OUTLET_K3_OODIS' ] . write ( 0 ) @classmethod def post_condition ( cls , args ): pass","title":"RecoverFromLowPowerMode"},{"location":"scripts/RemoveAllTargets/","text":"RemoveAllTargets Bases: KPFFunction MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Source code in kpf/magiq/RemoveTarget.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class RemoveAllTargets ( KPFFunction ): ''' MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) @classmethod def perform ( cls , args ): target_names , lines = GetTargetList . execute ({}) for target_name in target_names : params = { 'target' : target_name } result = magiq_server_command ( 'removeTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"RemoveAllTargets"},{"location":"scripts/RemoveAllTargets/#removealltargets","text":"Bases: KPFFunction MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Source code in kpf/magiq/RemoveTarget.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class RemoveAllTargets ( KPFFunction ): ''' MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) @classmethod def perform ( cls , args ): target_names , lines = GetTargetList . execute ({}) for target_name in target_names : params = { 'target' : target_name } result = magiq_server_command ( 'removeTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"RemoveAllTargets"},{"location":"scripts/RemoveTarget/","text":"RemoveTarget Bases: KPFFunction Remove the specified target from the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to remove. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/RemoveTarget.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class RemoveTarget ( KPFFunction ): '''Remove the specified target from the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to remove. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): target_name = args . get ( 'TargetName' , None ) params = { 'target' : target_name } log . info ( f 'Running Magiq removeTarget command { target_name } ' ) result = magiq_server_command ( 'removeTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"RemoveTarget"},{"location":"scripts/RemoveTarget/#removetarget","text":"Bases: KPFFunction Remove the specified target from the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to remove. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/RemoveTarget.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class RemoveTarget ( KPFFunction ): '''Remove the specified target from the OA star list. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to remove. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): target_name = args . get ( 'TargetName' , None ) params = { 'target' : target_name } log . info ( f 'Running Magiq removeTarget command { target_name } ' ) result = magiq_server_command ( 'removeTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"RemoveTarget"},{"location":"scripts/ResetCaHKDetector/","text":"ResetCaHKDetector Bases: KPFFunction Resets the Ca HK detector by aborting the exposure KTL Keywords Used: kpf_hk.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ResetCaHKDetector ( KPFFunction ): '''Resets the Ca HK detector by aborting the exposure KTL Keywords Used: - `kpf_hk.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expose = ktl . cache ( 'kpf_hk' , 'EXPOSE' ) log . warning ( f \"Resetting/Aborting: kpf_hk.EXPOSE = abort\" ) expose . write ( 'abort' ) log . debug ( 'Reset/abort command sent' ) @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_hk to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetCaHKDetector"},{"location":"scripts/ResetCaHKDetector/#resetcahkdetector","text":"Bases: KPFFunction Resets the Ca HK detector by aborting the exposure KTL Keywords Used: kpf_hk.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ResetCaHKDetector ( KPFFunction ): '''Resets the Ca HK detector by aborting the exposure KTL Keywords Used: - `kpf_hk.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expose = ktl . cache ( 'kpf_hk' , 'EXPOSE' ) log . warning ( f \"Resetting/Aborting: kpf_hk.EXPOSE = abort\" ) expose . write ( 'abort' ) log . debug ( 'Reset/abort command sent' ) @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_hk to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetCaHKDetector"},{"location":"scripts/ResetDetectors/","text":"ResetDetectors Bases: KPFFunction Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR Source code in kpf/spectrograph/ResetDetectors.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class ResetDetectors ( KPFFunction ): '''Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) log . warning ( f \"Resetting: kpfexpose.EXPOSE = Reset\" ) kpfexpose [ 'EXPOSE' ] . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetDetectors"},{"location":"scripts/ResetDetectors/#resetdetectors","text":"Bases: KPFFunction Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR Source code in kpf/spectrograph/ResetDetectors.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class ResetDetectors ( KPFFunction ): '''Resets the kpfexpose service by setting kpfexpose.EXPOSE = Reset Description from Will Deich: This sets EXPOSE=Reset for the appropriate service. For the ktlcamerad services, that just means, \u201ceven though you\u2019ve not received (from camerad) the normal sequence of messages for a completed exposure, pretend everything is fine for starting a new exposure.\u201d KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) log . warning ( f \"Resetting: kpfexpose.EXPOSE = Reset\" ) kpfexpose [ 'EXPOSE' ] . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . debug ( f 'Waiting { timeout : .1f } s for EXPOSE to be Readout or Ready' ) expr = f \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" log . warning ( f \"Waiting for kpfexpose to be Ready or Readout\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : kpfexposeexpose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedToReachDestination ( kpfexposeexpose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"Reset detectors done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetDetectors"},{"location":"scripts/ResetExpMeterDetector/","text":"ResetExpMeterDetector Bases: KPFFunction Resets the exposure meter detector KTL Keywords Used: kpf_expmeter.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ResetExpMeterDetector ( KPFFunction ): '''Resets the exposure meter detector KTL Keywords Used: - `kpf_expmeter.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expose = ktl . cache ( 'kpf_expmeter' , 'EXPOSE' ) log . warning ( f \"Resetting: kpf_expmeter.EXPOSE = abort\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_expmeter to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetExpMeterDetector"},{"location":"scripts/ResetExpMeterDetector/#resetexpmeterdetector","text":"Bases: KPFFunction Resets the exposure meter detector KTL Keywords Used: kpf_expmeter.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ResetExpMeterDetector ( KPFFunction ): '''Resets the exposure meter detector KTL Keywords Used: - `kpf_expmeter.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expose = ktl . cache ( 'kpf_expmeter' , 'EXPOSE' ) log . warning ( f \"Resetting: kpf_expmeter.EXPOSE = abort\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpf_expmeter to be Ready\" ) success = expstate . waitFor ( '==\"Ready\"' , timeout = timeout ) if success is not True : raise FailedToReachDestination ( expstate . read (), 'Ready' )","title":"ResetExpMeterDetector"},{"location":"scripts/ResetGreenDetector/","text":"ResetGreenDetector Bases: KPFFunction Resets the kpfgreen detector KTL Keywords Used: kpfgreen.EXPSTATE kpfgreen.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class ResetGreenDetector ( KPFFunction ): '''Resets the kpfgreen detector KTL Keywords Used: - `kpfgreen.EXPSTATE` - `kpfgreen.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfgreen.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfgreen to be Readout or Ready\" ) expr = f \"($kpfgreen.EXPOSE == 'Ready') or ($kpfgreen.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetGreenDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetGreenDetector"},{"location":"scripts/ResetGreenDetector/#resetgreendetector","text":"Bases: KPFFunction Resets the kpfgreen detector KTL Keywords Used: kpfgreen.EXPSTATE kpfgreen.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class ResetGreenDetector ( KPFFunction ): '''Resets the kpfgreen detector KTL Keywords Used: - `kpfgreen.EXPSTATE` - `kpfgreen.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfgreen.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfgreen to be Readout or Ready\" ) expr = f \"($kpfgreen.EXPOSE == 'Ready') or ($kpfgreen.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfgreen' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetGreenDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetGreenDetector"},{"location":"scripts/ResetRedDetector/","text":"ResetRedDetector Bases: KPFFunction Resets the kpfred detector KTL Keywords Used: kpfred.EXPSTATE kpfred.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ResetRedDetector ( KPFFunction ): '''Resets the kpfred detector KTL Keywords Used: - `kpfred.EXPSTATE` - `kpfred.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfred.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfred to be Readout or Ready\" ) expr = f \"($kpfred.EXPOSE == 'Ready') or ($kpfred.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetRedDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetRedDetector"},{"location":"scripts/ResetRedDetector/#resetreddetector","text":"Bases: KPFFunction Resets the kpfred detector KTL Keywords Used: kpfred.EXPSTATE kpfred.EXPOSE Source code in kpf/spectrograph/ResetDetectors.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class ResetRedDetector ( KPFFunction ): '''Resets the kpfred detector KTL Keywords Used: - `kpfred.EXPSTATE` - `kpfred.EXPOSE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Check if the auto reset is already doing this current_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) current_expstate . read () if current_expstate == 'Resetting' : return elif current_expstate == 'Exposing' : log . warning ( 'Can not send reset during exposure' ) return # Send the reset expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) log . warning ( f \"Resetting: kpfred.EXPOSE = Reset\" ) expose . write ( 'Reset' ) log . debug ( 'Reset command sent' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) log . warning ( f \"Waiting for kpfred to be Readout or Ready\" ) expr = f \"($kpfred.EXPOSE == 'Ready') or ($kpfred.EXPOSE == 'Readout')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : expose = ktl . cache ( 'kpfred' , 'EXPOSE' ) raise FailedToReachDestination ( expose . read (), 'Ready or Readout' ) else : kpfexpose = ktl . cache ( 'kpfexpose' ) log . info ( f \"ResetRedDetector done\" ) log . info ( f \"kpfexpose.EXPOSE = { kpfexpose [ 'EXPOSE' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINR = { kpfexpose [ 'EXPLAINR' ] . read () } \" ) log . info ( f \"kpfexpose.EXPLAINNR = { kpfexpose [ 'EXPLAINNR' ] . read () } \" )","title":"ResetRedDetector"},{"location":"scripts/Run2DGridSearch/","text":"Run2DGridSearch Bases: KPFTranslatorFunction Source code in kpf/engineering/Run2DGridSearch.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Run2DGridSearch ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): n = args . get ( 'n' ) d = args . get ( 'd' ) Gmag = args . get ( 'Gmag' ) time_on_position = args . get ( 'time_on_position' ) comment = args . get ( 'comment' , '' ) em_parameters = PredictExpMeterParameters . execute ({ 'Gmag' : Gmag }) # Check if FVCs are on, if so, use them FVCs_that_are_on = [] for camera in [ 'SCI' , 'CAHK' ]: camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () . lower () == 'on' : FVCs_that_are_on . append ( camera ) FVCstring = ',' . join ( FVCs_that_are_on ) if len ( FVCs_that_are_on ) > 0 : fvc_parameters = PredictFVCParameters . execute ({ 'Gmag' : Gmag }) print ( f \"Predicted FVC parameters:\" ) print ( fvc_parameters ) print ( 'Set the FVC parameters manually and press enter to continue' ) user_input = input () dcs = ktl . cache ( 'dcs1' ) targname = dcs [ 'TARGNAME' ] . read () args = { 'Template_Name' : 'kpf_eng_grid' , 'Template_Version' : 0.4 , 'Grid' : 'TipTilt' , 'dx' : d , 'dy' : d , 'TimeOnPosition' : time_on_position , 'TriggerCaHK' : False , 'TriggerGreen' : False , 'TriggerRed' : False , 'TriggerExpMeter' : True , 'UseCRED2' : True , 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_CalSciSky' : False , 'ExpMeter_exptime' : em_parameters [ 'ExpMeterExpTime' ], 'FVCs' : FVCstring , } x_args = { 'comment' : f '1D in X { targname } (G= { Gmag : .1f } ) { comment } ' , 'nx' : n , 'ny' : 1 , } args . update ( x_args ) GridSearch . execute ( args ) y_args = { 'comment' : f '1D in Y { targname } (G= { Gmag : .1f } ) { comment } ' , 'nx' : 1 , 'ny' : n , } args . update ( y_args ) GridSearch . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'd' , type = float , help = \"Separation between positions (in guder pix)\" ) parser . add_argument ( 'n' , type = int , help = \"Number of position samples in each axis\" ) parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--comment\" , dest = \"comment\" , type = str , default = '' , help = \"Additional comment text\" ) parser . add_argument ( \"--time\" , dest = \"time_on_position\" , type = float , default = 15 , help = \"Dwell time at each position (s)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Run2DGridSearch"},{"location":"scripts/Run2DGridSearch/#run2dgridsearch","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/Run2DGridSearch.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 class Run2DGridSearch ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): pass @classmethod def perform ( cls , args , logger , cfg ): n = args . get ( 'n' ) d = args . get ( 'd' ) Gmag = args . get ( 'Gmag' ) time_on_position = args . get ( 'time_on_position' ) comment = args . get ( 'comment' , '' ) em_parameters = PredictExpMeterParameters . execute ({ 'Gmag' : Gmag }) # Check if FVCs are on, if so, use them FVCs_that_are_on = [] for camera in [ 'SCI' , 'CAHK' ]: camnum = { 'SCI' : 1 , 'CAHK' : 2 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f 'KPFFVC { camnum } ' ) if powerkw . read () . lower () == 'on' : FVCs_that_are_on . append ( camera ) FVCstring = ',' . join ( FVCs_that_are_on ) if len ( FVCs_that_are_on ) > 0 : fvc_parameters = PredictFVCParameters . execute ({ 'Gmag' : Gmag }) print ( f \"Predicted FVC parameters:\" ) print ( fvc_parameters ) print ( 'Set the FVC parameters manually and press enter to continue' ) user_input = input () dcs = ktl . cache ( 'dcs1' ) targname = dcs [ 'TARGNAME' ] . read () args = { 'Template_Name' : 'kpf_eng_grid' , 'Template_Version' : 0.4 , 'Grid' : 'TipTilt' , 'dx' : d , 'dy' : d , 'TimeOnPosition' : time_on_position , 'TriggerCaHK' : False , 'TriggerGreen' : False , 'TriggerRed' : False , 'TriggerExpMeter' : True , 'UseCRED2' : True , 'SSS_Science' : True , 'SSS_Sky' : True , 'SSS_CalSciSky' : False , 'ExpMeter_exptime' : em_parameters [ 'ExpMeterExpTime' ], 'FVCs' : FVCstring , } x_args = { 'comment' : f '1D in X { targname } (G= { Gmag : .1f } ) { comment } ' , 'nx' : n , 'ny' : 1 , } args . update ( x_args ) GridSearch . execute ( args ) y_args = { 'comment' : f '1D in Y { targname } (G= { Gmag : .1f } ) { comment } ' , 'nx' : 1 , 'ny' : n , } args . update ( y_args ) GridSearch . execute ( args ) @classmethod def post_condition ( cls , args , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'd' , type = float , help = \"Separation between positions (in guder pix)\" ) parser . add_argument ( 'n' , type = int , help = \"Number of position samples in each axis\" ) parser . add_argument ( 'Gmag' , type = float , help = \"The G magnitude of the target\" ) parser . add_argument ( \"--comment\" , dest = \"comment\" , type = str , default = '' , help = \"Additional comment text\" ) parser . add_argument ( \"--time\" , dest = \"time_on_position\" , type = float , default = 15 , help = \"Dwell time at each position (s)\" ) return super () . add_cmdline_args ( parser , cfg )","title":"Run2DGridSearch"},{"location":"scripts/RunOB/","text":"RunOB Bases: KPFScript Script to run an OB. Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). leave_lamps_on ( bool ) \u2013 Leave the calibration lamps on after cleanup phase? waitforscript ( bool ) \u2013 Wait for a running script to end before starting? scheduled ( bool ) \u2013 Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfconfig.SLEWCALREQ kpfconfig.SLEWCALFILE kpfconfig.SCRIPTMSG dcs1.TARGNAME Functions Called: kpf.fiu.VerifyCurrentBase kpf.scripts.SetTargetInfo kpf.scripts.ConfigureForCalibrations kpf.scripts.ExecuteCal kpf.scripts.CleanupAfterCalibrations kpf.scripts.ConfigureForAcquisition kpf.scripts.WaitForConfigureAcquisition kpf.scripts.ConfigureForScience kpf.scripts.WaitForConfigureScience kpf.scripts.ExecuteSci kpf.scripts.CleanupAfterScience kpf.spectrograph.SetProgram kpf.observatoryAPIs.addObservingBlockHistory Source code in kpf/scripts/RunOB.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 class RunOB ( KPFScript ): '''Script to run an OB. Args: OB (ObservingBlock): A valid observing block (OB). leave_lamps_on (bool): Leave the calibration lamps on after cleanup phase? waitforscript (bool): Wait for a running script to end before starting? scheduled (bool): Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfconfig.SLEWCALREQ` - `kpfconfig.SLEWCALFILE` - `kpfconfig.SCRIPTMSG` - `dcs1.TARGNAME` Functions Called: - `kpf.fiu.VerifyCurrentBase` - `kpf.scripts.SetTargetInfo` - `kpf.scripts.ConfigureForCalibrations` - `kpf.scripts.ExecuteCal` - `kpf.scripts.CleanupAfterCalibrations` - `kpf.scripts.ConfigureForAcquisition` - `kpf.scripts.WaitForConfigureAcquisition` - `kpf.scripts.ConfigureForScience` - `kpf.scripts.WaitForConfigureScience` - `kpf.scripts.ExecuteSci` - `kpf.scripts.CleanupAfterScience` - `kpf.spectrograph.SetProgram` - `kpf.observatoryAPIs.addObservingBlockHistory` ''' @classmethod def pre_condition ( cls , args , OB = None ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) # Validate the OB OB . validate () # Check for script running unless waitforscript is set if args . get ( 'waitforscript' , False ) is False : check_script_running () @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , OB = None ): SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) # ------------------------------------------------------------- # If requested wait for an existing script to complete # ------------------------------------------------------------- if args . get ( 'waitforscript' , False ) == True : newscript = f ' { Path ( __file__ ) . name . replace ( \".py\" , \"\" ) } (PID { os . getpid () } )' wait_for_script ( newscript = newscript ) set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # ------------------------------------------------------------- # Log beginning of script # ------------------------------------------------------------- log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) if OB . OBID not in [ None , '' ]: log . info ( f \"OB ID = { OB . OBID } \" ) msg = f \"Executing OB: { OB . summary () } \" log . info ( msg ) SCRIPTMSG . write ( msg ) # ------------------------------------------------------------- # Set Target info for OA's Tip Tilt GUI # ------------------------------------------------------------- if OB . Target is not None : SetTargetInfo . execute ({}, OB = OB ) # ------------------------------------------------------------- # Add slew cal to OB if keywords indicate one is requested # ------------------------------------------------------------- SLEWCALREQ = ktl . cache ( 'kpfconfig' , 'SLEWCALREQ' ) SLEWCALFILE = ktl . cache ( 'kpfconfig' , 'SLEWCALFILE' ) if len ( OB . Observations ) > 0 and SLEWCALREQ . read ( binary = True ) is True : slewcal_OBfile = Path ( SLEWCALFILE . read ()) log . info ( 'Slewcal has been requested' ) log . debug ( f \"Reading: { slewcal_OBfile } \" ) with open ( slewcal_OBfile , 'r' ) as file : slewcal_OBdict = yaml . safe_load ( file ) slewcal_OB = ObservingBlock ( slewcal_OBdict ) OB . Calibrations . extend ( slewcal_OB . Calibrations ) # Now that slewcal has been added, reset the SLEWCALREQ value SLEWCALREQ . write ( False ) # ------------------------------------------------------------- # Perform Calibrations # ------------------------------------------------------------- if len ( OB . Calibrations ) > 0 : # Configure for Calibrations try : SCRIPTMSG . write ( 'Configuring for Calibrations' ) ConfigureForCalibrations . execute ( args , OB = OB ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ExecuteSci' ) log . error ( e ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return # Loop over calibrations and execute for i , calibration in enumerate ( OB . Calibrations ): msg = f 'Executing { calibration . summary () } (Calibration { i + 1 } / { len ( OB . Calibrations ) } )' log . info ( msg ) SCRIPTMSG . write ( msg ) try : ExecuteCal . execute ( calibration . to_dict ()) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ExecuteCal' ) log . error ( e ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return # Clean up after calibrations if len ( OB . Observations ) > 0 : # Don't stop FIU if we have observations to perform args [ 'FIUdest' ] = 'Observing' SCRIPTMSG . write ( 'Calibrations complete. Setting FIU to observing.' ) CleanupAfterCalibrations . execute ( args , OB = OB ) # ------------------------------------------------------------- # Configure for Acquisition # ------------------------------------------------------------- if OB . Target is not None : log . info ( f 'Configuring for Acquisition' ) try : ConfigureForAcquisition . execute ( args , OB = OB ) WaitForConfigureAcquisition . execute ( args , OB = OB ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterScience . execute ( args , OB = OB ) return except Exception as e : log . error ( 'Exception encountered during ConfigureForAcquisition' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) return # Proceed once target is on fiber and tip tilt is active msg = 'Waiting for user confirmation to begin exposures' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"###############################################################\" ) print ( \" Before continuing, please ensure that the OA has placed\" ) print ( \" the star on the KPF PO and they have initiated tip tilt\" ) print ( \" corrections (if desired).\" ) print () print ( \" Press 'Enter' to begin exposure(s) or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: log . error ( \"User chose to halt execution\" ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Verify dcs TARGNAME against OB.Target.TargetName dcsint = cfg . getint ( 'telescope' , 'telnr' , fallback = 1 ) TARGNAME = ktl . cache ( f 'dcs { dcsint : 1d } ' , 'TARGNAME' ) . read () if str ( TARGNAME ) . strip () . lower () != str ( OB . Target . TargetName ) . lower (): log . warning ( 'Target name mismatch detected' ) log . warning ( f \"dcs.TARGNAME ' { TARGNAME } ' != OB TargetName ' { OB . Target . TargetName } '\" ) msg = 'Waiting for user confirmation on target name mismatch' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"###############################################################\" ) print ( \" WARNING: The telescope control system target name: {TARGNAME} \" ) print ( \" WARNING: does not match the OB target name: {OB.Target.TargetName} \" ) print () print ( \" Press 'Enter' to begin exposure(s) anyway or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: log . error ( \"User chose to halt execution\" ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Verify Current Base try : VerifyCurrentBase . execute ({ 'query_user' : True }) except Exception as e : log . error ( 'Exception encountered during VerifyCurrentBase' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # ------------------------------------------------------------- # Perform Observations # ------------------------------------------------------------- if len ( OB . Observations ) > 0 : for i , observation in enumerate ( OB . Observations ): # Configure for Science try : observation_dict = observation . to_dict () observation_dict [ 'Gmag' ] = OB . Target . get ( 'Gmag' ) ConfigureForScience . execute ( observation_dict ) if OB . ProgramID != '' : SetProgram . execute ({ 'progname' : OB . ProgramID }) WaitForConfigureScience . execute ( observation_dict ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ConfigureForScience' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Execute Observation msg = f 'Executing { observation . summary () } (Observation { i + 1 } / { len ( OB . Observations ) } )' log . info ( msg ) SCRIPTMSG . write ( msg ) try : history , scriptstop = ExecuteSci . execute ( observation_dict ) log . info ( f 'History of execution:' ) log . info ( f \" Start Times: { history [ 'exposure_start_times' ] } \" ) log . info ( f \" Exposure Times: { history [ 'exposure_times' ] } \" ) log . debug ( history ) if OB . OBID != '' : history [ 'id' ] = OB . OBID log . info ( 'Submitting execution history to KPFCC API' ) log . debug ( f \" { history [ 'id' ] } \" ) result = addObservingBlockHistory ( history ) log . debug ( f \"KPFCC API Response: { result } \" ) if scriptstop : raise ScriptStopTriggered ( \"SCRIPTSTOP triggered\" ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) break except Exception as e : log . error ( 'Exception encountered during ExecuteSci' ) log . error ( e ) break # Cleanup After Science log . info ( f 'Cleaning up after Observations' ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the calibration lamps on after cleanup phase?' ) parser . add_argument ( '--waitforscript' , dest = \"waitforscript\" , default = False , action = \"store_true\" , help = 'Wait for running script to end before starting?' ) parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"RunOB"},{"location":"scripts/RunOB/#runob","text":"Bases: KPFScript Script to run an OB. Parameters: OB ( ObservingBlock ) \u2013 A valid observing block (OB). leave_lamps_on ( bool ) \u2013 Leave the calibration lamps on after cleanup phase? waitforscript ( bool ) \u2013 Wait for a running script to end before starting? scheduled ( bool ) \u2013 Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfconfig.SLEWCALREQ kpfconfig.SLEWCALFILE kpfconfig.SCRIPTMSG dcs1.TARGNAME Functions Called: kpf.fiu.VerifyCurrentBase kpf.scripts.SetTargetInfo kpf.scripts.ConfigureForCalibrations kpf.scripts.ExecuteCal kpf.scripts.CleanupAfterCalibrations kpf.scripts.ConfigureForAcquisition kpf.scripts.WaitForConfigureAcquisition kpf.scripts.ConfigureForScience kpf.scripts.WaitForConfigureScience kpf.scripts.ExecuteSci kpf.scripts.CleanupAfterScience kpf.spectrograph.SetProgram kpf.observatoryAPIs.addObservingBlockHistory Source code in kpf/scripts/RunOB.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 class RunOB ( KPFScript ): '''Script to run an OB. Args: OB (ObservingBlock): A valid observing block (OB). leave_lamps_on (bool): Leave the calibration lamps on after cleanup phase? waitforscript (bool): Wait for a running script to end before starting? scheduled (bool): Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfconfig.SLEWCALREQ` - `kpfconfig.SLEWCALFILE` - `kpfconfig.SCRIPTMSG` - `dcs1.TARGNAME` Functions Called: - `kpf.fiu.VerifyCurrentBase` - `kpf.scripts.SetTargetInfo` - `kpf.scripts.ConfigureForCalibrations` - `kpf.scripts.ExecuteCal` - `kpf.scripts.CleanupAfterCalibrations` - `kpf.scripts.ConfigureForAcquisition` - `kpf.scripts.WaitForConfigureAcquisition` - `kpf.scripts.ConfigureForScience` - `kpf.scripts.WaitForConfigureScience` - `kpf.scripts.ExecuteSci` - `kpf.scripts.CleanupAfterScience` - `kpf.spectrograph.SetProgram` - `kpf.observatoryAPIs.addObservingBlockHistory` ''' @classmethod def pre_condition ( cls , args , OB = None ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) # Validate the OB OB . validate () # Check for script running unless waitforscript is set if args . get ( 'waitforscript' , False ) is False : check_script_running () @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , OB = None ): SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) # ------------------------------------------------------------- # If requested wait for an existing script to complete # ------------------------------------------------------------- if args . get ( 'waitforscript' , False ) == True : newscript = f ' { Path ( __file__ ) . name . replace ( \".py\" , \"\" ) } (PID { os . getpid () } )' wait_for_script ( newscript = newscript ) set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) # ------------------------------------------------------------- # Log beginning of script # ------------------------------------------------------------- log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) if isinstance ( OB , dict ): OB = ObservingBlock ( OB ) if OB . OBID not in [ None , '' ]: log . info ( f \"OB ID = { OB . OBID } \" ) msg = f \"Executing OB: { OB . summary () } \" log . info ( msg ) SCRIPTMSG . write ( msg ) # ------------------------------------------------------------- # Set Target info for OA's Tip Tilt GUI # ------------------------------------------------------------- if OB . Target is not None : SetTargetInfo . execute ({}, OB = OB ) # ------------------------------------------------------------- # Add slew cal to OB if keywords indicate one is requested # ------------------------------------------------------------- SLEWCALREQ = ktl . cache ( 'kpfconfig' , 'SLEWCALREQ' ) SLEWCALFILE = ktl . cache ( 'kpfconfig' , 'SLEWCALFILE' ) if len ( OB . Observations ) > 0 and SLEWCALREQ . read ( binary = True ) is True : slewcal_OBfile = Path ( SLEWCALFILE . read ()) log . info ( 'Slewcal has been requested' ) log . debug ( f \"Reading: { slewcal_OBfile } \" ) with open ( slewcal_OBfile , 'r' ) as file : slewcal_OBdict = yaml . safe_load ( file ) slewcal_OB = ObservingBlock ( slewcal_OBdict ) OB . Calibrations . extend ( slewcal_OB . Calibrations ) # Now that slewcal has been added, reset the SLEWCALREQ value SLEWCALREQ . write ( False ) # ------------------------------------------------------------- # Perform Calibrations # ------------------------------------------------------------- if len ( OB . Calibrations ) > 0 : # Configure for Calibrations try : SCRIPTMSG . write ( 'Configuring for Calibrations' ) ConfigureForCalibrations . execute ( args , OB = OB ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ExecuteSci' ) log . error ( e ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return # Loop over calibrations and execute for i , calibration in enumerate ( OB . Calibrations ): msg = f 'Executing { calibration . summary () } (Calibration { i + 1 } / { len ( OB . Calibrations ) } )' log . info ( msg ) SCRIPTMSG . write ( msg ) try : ExecuteCal . execute ( calibration . to_dict ()) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ExecuteCal' ) log . error ( e ) CleanupAfterCalibrations . execute ( args , OB = OB ) clear_script_keywords () return # Clean up after calibrations if len ( OB . Observations ) > 0 : # Don't stop FIU if we have observations to perform args [ 'FIUdest' ] = 'Observing' SCRIPTMSG . write ( 'Calibrations complete. Setting FIU to observing.' ) CleanupAfterCalibrations . execute ( args , OB = OB ) # ------------------------------------------------------------- # Configure for Acquisition # ------------------------------------------------------------- if OB . Target is not None : log . info ( f 'Configuring for Acquisition' ) try : ConfigureForAcquisition . execute ( args , OB = OB ) WaitForConfigureAcquisition . execute ( args , OB = OB ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterScience . execute ( args , OB = OB ) return except Exception as e : log . error ( 'Exception encountered during ConfigureForAcquisition' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) return # Proceed once target is on fiber and tip tilt is active msg = 'Waiting for user confirmation to begin exposures' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"###############################################################\" ) print ( \" Before continuing, please ensure that the OA has placed\" ) print ( \" the star on the KPF PO and they have initiated tip tilt\" ) print ( \" corrections (if desired).\" ) print () print ( \" Press 'Enter' to begin exposure(s) or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: log . error ( \"User chose to halt execution\" ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Verify dcs TARGNAME against OB.Target.TargetName dcsint = cfg . getint ( 'telescope' , 'telnr' , fallback = 1 ) TARGNAME = ktl . cache ( f 'dcs { dcsint : 1d } ' , 'TARGNAME' ) . read () if str ( TARGNAME ) . strip () . lower () != str ( OB . Target . TargetName ) . lower (): log . warning ( 'Target name mismatch detected' ) log . warning ( f \"dcs.TARGNAME ' { TARGNAME } ' != OB TargetName ' { OB . Target . TargetName } '\" ) msg = 'Waiting for user confirmation on target name mismatch' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"###############################################################\" ) print ( \" WARNING: The telescope control system target name: {TARGNAME} \" ) print ( \" WARNING: does not match the OB target name: {OB.Target.TargetName} \" ) print () print ( \" Press 'Enter' to begin exposure(s) anyway or 'a' to abort script\" ) print ( \"###############################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () in [ 'a' , 'abort' , 'q' , 'quit' ]: log . error ( \"User chose to halt execution\" ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Verify Current Base try : VerifyCurrentBase . execute ({ 'query_user' : True }) except Exception as e : log . error ( 'Exception encountered during VerifyCurrentBase' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # ------------------------------------------------------------- # Perform Observations # ------------------------------------------------------------- if len ( OB . Observations ) > 0 : for i , observation in enumerate ( OB . Observations ): # Configure for Science try : observation_dict = observation . to_dict () observation_dict [ 'Gmag' ] = OB . Target . get ( 'Gmag' ) ConfigureForScience . execute ( observation_dict ) if OB . ProgramID != '' : SetProgram . execute ({ 'progname' : OB . ProgramID }) WaitForConfigureScience . execute ( observation_dict ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return except Exception as e : log . error ( 'Exception encountered during ConfigureForScience' ) log . error ( e ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () return # Execute Observation msg = f 'Executing { observation . summary () } (Observation { i + 1 } / { len ( OB . Observations ) } )' log . info ( msg ) SCRIPTMSG . write ( msg ) try : history , scriptstop = ExecuteSci . execute ( observation_dict ) log . info ( f 'History of execution:' ) log . info ( f \" Start Times: { history [ 'exposure_start_times' ] } \" ) log . info ( f \" Exposure Times: { history [ 'exposure_times' ] } \" ) log . debug ( history ) if OB . OBID != '' : history [ 'id' ] = OB . OBID log . info ( 'Submitting execution history to KPFCC API' ) log . debug ( f \" { history [ 'id' ] } \" ) result = addObservingBlockHistory ( history ) log . debug ( f \"KPFCC API Response: { result } \" ) if scriptstop : raise ScriptStopTriggered ( \"SCRIPTSTOP triggered\" ) except ScriptStopTriggered as scriptstop : log . error ( 'Script Stop Triggered' ) break except Exception as e : log . error ( 'Exception encountered during ExecuteSci' ) log . error ( e ) break # Cleanup After Science log . info ( f 'Cleaning up after Observations' ) CleanupAfterScience . execute ( args , OB = OB ) clear_script_keywords () @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--leave_lamps_on' , dest = \"leave_lamps_on\" , default = False , action = \"store_true\" , help = 'Leave the calibration lamps on after cleanup phase?' ) parser . add_argument ( '--waitforscript' , dest = \"waitforscript\" , default = False , action = \"store_true\" , help = 'Wait for running script to end before starting?' ) parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"RunOB"},{"location":"scripts/RunSoCal/","text":"RunSoCal Bases: KPFScript This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the kpfconfig.SCRIPT% keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the WaitForSoCalOnTarget script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the KPFTranslator configuration file ( kpf_inst_config.ini ). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the WaitForSoCalOnTarget script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using ParkSoCal if the park flag is set. Parameters: StartTimeHST ( float ) \u2013 The time (in decimal hours HST) to begin observing. EndTimeHST ( float ) \u2013 The time (in decimal hours HST) to end observing. park ( bool ) \u2013 If True, the script will park SoCal when complete. waitforscript ( bool ) \u2013 Wait for a running script to end before starting? scheduled ( bool ) \u2013 Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfconfig.SLEWCALFILE Functions Called: kpf.fiu.ConfigureFIU kpf.scripts.ExecuteCal kpf.scripts.CleanupAfterCalibrations kpf.scripts.EstimateOBDuration kpf.socal.ParkSoCal kpf.socal.SoCalStartAutonomous kpf.socal.WaitForSoCalOnTarget Source code in kpf/scripts/RunSoCal.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class RunSoCal ( KPFScript ): '''This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the `kpfconfig.SCRIPT%` keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the `WaitForSoCalOnTarget` script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the `KPFTranslator` configuration file (`kpf_inst_config.ini`). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the `WaitForSoCalOnTarget` script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using `ParkSoCal` if the park flag is set. Args: StartTimeHST (float): The time (in decimal hours HST) to begin observing. EndTimeHST (float): The time (in decimal hours HST) to end observing. park (bool): If True, the script will park SoCal when complete. waitforscript (bool): Wait for a running script to end before starting? scheduled (bool): Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfconfig.SLEWCALFILE` Functions Called: - `kpf.fiu.ConfigureFIU` - `kpf.scripts.ExecuteCal` - `kpf.scripts.CleanupAfterCalibrations` - `kpf.scripts.EstimateOBDuration` - `kpf.socal.ParkSoCal` - `kpf.socal.SoCalStartAutonomous` - `kpf.socal.WaitForSoCalOnTarget` ''' @classmethod def pre_condition ( cls , args , OB = None ): SoCalOBfile = Path ( cfg . get ( 'SoCal' , 'SoCalOB' , fallback = '/tmp/SoCalOB.yaml' )) if SoCalOBfile . exists () == False : raise FailedPreCondition ( f 'SoCal OB File does not exist: { SoCalOBfile } ' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , OB = None ): # Check the ALLOWSCHEDULEDCALS value if args . get ( 'scheduled' , True ) is True : ALLOWSCHEDULED = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULED . read () == 'No' : log . warning ( f 'Not running { cls . __name__ } because ALLOWSCHEDULEDCALS is No' ) return else : log . debug ( f ' { cls . __name__ } : Checked kpfconfig.ALLOWSCHEDULEDCALS' ) # Start SoCal in autonomous mode SoCalStartAutonomous . execute ({}) # If requested wait for an existing script to complete if args . get ( 'waitforscript' , False ) is True : newscript = f ' { Path ( __file__ ) . name . replace ( \".py\" , \"\" ) } (PID { os . getpid () } )' wait_for_script ( newscript = newscript ) check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) SoCalOBfile = Path ( cfg . get ( 'SoCal' , 'SoCalOB' , fallback = '/tmp/SoCalOB.yaml' )) log . info ( f \"Loading SoCal OB from { SoCalOBfile } \" ) SoCal_OB = ObservingBlock ( SoCalOBfile ) # Estimate time to Run SoCal OB SoCal_duration = EstimateOBDuration . execute ({}, OB = SoCal_OB ) # Estimate time to run Etalon OB SLEWCALFILE = ktl . cache ( 'kpfconfig' , 'SLEWCALFILE' ) slewcal_OBfile = Path ( SLEWCALFILE . read ()) log . debug ( f \"Reading: { slewcal_OBfile } \" ) with open ( slewcal_OBfile , 'r' ) as file : slewcal_OBdict = yaml . safe_load ( file ) SlewCal_OB = ObservingBlock ( slewcal_OBdict ) Etalon_duration = EstimateOBDuration . execute ({}, OB = SlewCal_OB ) log . debug ( f \"Estimated Etalon observation time = { Etalon_duration } \" ) # Start Loop start_time = args . get ( 'StartTimeHST' , 9 ) # End time subtracts off max duration of observation and 3 minutes of buffer end_time = args . get ( 'EndTimeHST' , 12 ) - max ([ SoCal_duration , Etalon_duration ]) / 60 - 0.05 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) if now_decimal < start_time : wait = ( start_time - now_decimal ) * 3600 log . info ( f 'Waiting { wait : .0f } s for SoCal window start time' ) time . sleep ( wait ) elif now_decimal > end_time : log . info ( \"End time for today's SoCal window has passed\" ) return ConfigureFIU . execute ({ 'mode' : 'Calibration' }) log . info ( f 'Starting SoCal observation loop' ) log . info ( f 'Start time: { start_time : .2f } HST' ) log . info ( f 'End Time: { end_time : .2f } HST' ) check_scriptstop () nSoCalObs = 0 nEtalonObs = 0 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) while now_decimal >= start_time and now_decimal < end_time : log . debug ( 'Checking if SoCal is on the Sun' ) on_target = WaitForSoCalOnTarget . execute ({ 'timeout' : 30 }) OB = { True : SoCal_OB , False : SlewCal_OB }[ on_target ] log . info ( f 'SoCal on target: { on_target } ' ) try : check_scriptstop () for i , calibration in enumerate ( OB . Calibrations ): ExecuteCal . execute ( calibration . to_dict ()) if on_target == True : nSoCalObs += 1 else : nEtalonObs += 1 except ScriptStopTriggered as e : raise e except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) check_scriptstop () # Update loop inputs now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) log . info ( 'SoCal observation loop completed' ) log . info ( f 'Executed { nSoCalObs } SoCal sequences' ) log . info ( f 'Executed { nEtalonObs } Etalon sequences' ) # Cleanup try : CleanupAfterCalibrations . execute ({}, OB = SlewCal_OB ) clear_script_keywords () except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Park SoCal? if args . get ( 'park' , False ) == True : ParkSoCal . execute ({}) @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'StartTimeHST' , type = float , help = 'Start of daily observing window in decimal hours HST.' ) parser . add_argument ( 'EndTimeHST' , type = float , help = 'End of daily observing window in decimal hours HST.' ) parser . add_argument ( \"--park\" , dest = \"park\" , default = False , action = \"store_true\" , help = \"Close and park SoCal when done?\" ) parser . add_argument ( '--waitforscript' , dest = \"waitforscript\" , default = False , action = \"store_true\" , help = 'Wait for running script to end before starting?' ) parser . add_argument ( \"--notscheduled\" , dest = \"scheduled\" , default = True , action = \"store_false\" , help = \"Do not respect the kpfconfig.ALLOWSCHEDULEDCALS flag.\" ) return super () . add_cmdline_args ( parser )","title":"RunSoCal"},{"location":"scripts/RunSoCal/#runsocal","text":"Bases: KPFScript This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the kpfconfig.SCRIPT% keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the WaitForSoCalOnTarget script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the KPFTranslator configuration file ( kpf_inst_config.ini ). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the WaitForSoCalOnTarget script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using ParkSoCal if the park flag is set. Parameters: StartTimeHST ( float ) \u2013 The time (in decimal hours HST) to begin observing. EndTimeHST ( float ) \u2013 The time (in decimal hours HST) to end observing. park ( bool ) \u2013 If True, the script will park SoCal when complete. waitforscript ( bool ) \u2013 Wait for a running script to end before starting? scheduled ( bool ) \u2013 Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: kpfconfig.ALLOWSCHEDULEDCALS kpfconfig.SLEWCALFILE Functions Called: kpf.fiu.ConfigureFIU kpf.scripts.ExecuteCal kpf.scripts.CleanupAfterCalibrations kpf.scripts.EstimateOBDuration kpf.socal.ParkSoCal kpf.socal.SoCalStartAutonomous kpf.socal.WaitForSoCalOnTarget Source code in kpf/scripts/RunSoCal.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class RunSoCal ( KPFScript ): '''This script runs a control loop to execute SoCal observations. When the script is invoked, it puts SoCal in AUTONOMOUS mode. This means that the SoCal dispatcher number 4 will handle opening the enclosure, acquiring and tracking the Sun, and will perform a weather safety shutdown if needed. The AUTONOMOUS mode will respect the CAN_OPEN keyword as well, so that keyword will lock out SoCal motions if that is desired. The script takes two required inputs: a start and end time in decimal hours (in HST). The start time can be after the invocation of this script. This is in fact the recommended operational strategy as the SoCal AUTONOMOUS mode will then have time to open and acquire the Sun before observations start. If needed, the script will wait until the start time before taking further actions (beyond setting AUTONOMOUS). Once the start time has passed, the script will check the `kpfconfig.SCRIPT%` keywords to see if something is currently running. If so, it will wait for the script keywords to clear before starting operations. Next the script will try to determine if SoCal is successfully observing the Sun by invoking the `WaitForSoCalOnTarget` script. If SoCal is on target, then a short observation of the Sun is performed. Some of the parameters can be modified in the `KPFTranslator` configuration file (`kpf_inst_config.ini`). This observation, as currently configured, takes about 15 minutes to complete. If SoCal is not on target (according to the `WaitForSoCalOnTarget` script), then an Etalon calibration set is taken. This is a way to make use of time that would otherwise be unproductive. This etalon script also takes around 15 minutes or a bit less to complete. Once either of the two observations above has completed, the script repeats the loop as long as there is enough time before the end time to complete a SoCal observation. Once the end time has passed, the system will perform basic cleanup of KPF, then it will park SoCal using `ParkSoCal` if the park flag is set. Args: StartTimeHST (float): The time (in decimal hours HST) to begin observing. EndTimeHST (float): The time (in decimal hours HST) to end observing. park (bool): If True, the script will park SoCal when complete. waitforscript (bool): Wait for a running script to end before starting? scheduled (bool): Script should obey ALLOWSCHEDULEDCALS keyword. KTL Keywords Used: - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpfconfig.SLEWCALFILE` Functions Called: - `kpf.fiu.ConfigureFIU` - `kpf.scripts.ExecuteCal` - `kpf.scripts.CleanupAfterCalibrations` - `kpf.scripts.EstimateOBDuration` - `kpf.socal.ParkSoCal` - `kpf.socal.SoCalStartAutonomous` - `kpf.socal.WaitForSoCalOnTarget` ''' @classmethod def pre_condition ( cls , args , OB = None ): SoCalOBfile = Path ( cfg . get ( 'SoCal' , 'SoCalOB' , fallback = '/tmp/SoCalOB.yaml' )) if SoCalOBfile . exists () == False : raise FailedPreCondition ( f 'SoCal OB File does not exist: { SoCalOBfile } ' ) @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , OB = None ): # Check the ALLOWSCHEDULEDCALS value if args . get ( 'scheduled' , True ) is True : ALLOWSCHEDULED = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULED . read () == 'No' : log . warning ( f 'Not running { cls . __name__ } because ALLOWSCHEDULEDCALS is No' ) return else : log . debug ( f ' { cls . __name__ } : Checked kpfconfig.ALLOWSCHEDULEDCALS' ) # Start SoCal in autonomous mode SoCalStartAutonomous . execute ({}) # If requested wait for an existing script to complete if args . get ( 'waitforscript' , False ) is True : newscript = f ' { Path ( __file__ ) . name . replace ( \".py\" , \"\" ) } (PID { os . getpid () } )' wait_for_script ( newscript = newscript ) check_script_running () set_script_keywords ( Path ( __file__ ) . name , os . getpid ()) log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) log . info ( '-------------------------' ) SoCalOBfile = Path ( cfg . get ( 'SoCal' , 'SoCalOB' , fallback = '/tmp/SoCalOB.yaml' )) log . info ( f \"Loading SoCal OB from { SoCalOBfile } \" ) SoCal_OB = ObservingBlock ( SoCalOBfile ) # Estimate time to Run SoCal OB SoCal_duration = EstimateOBDuration . execute ({}, OB = SoCal_OB ) # Estimate time to run Etalon OB SLEWCALFILE = ktl . cache ( 'kpfconfig' , 'SLEWCALFILE' ) slewcal_OBfile = Path ( SLEWCALFILE . read ()) log . debug ( f \"Reading: { slewcal_OBfile } \" ) with open ( slewcal_OBfile , 'r' ) as file : slewcal_OBdict = yaml . safe_load ( file ) SlewCal_OB = ObservingBlock ( slewcal_OBdict ) Etalon_duration = EstimateOBDuration . execute ({}, OB = SlewCal_OB ) log . debug ( f \"Estimated Etalon observation time = { Etalon_duration } \" ) # Start Loop start_time = args . get ( 'StartTimeHST' , 9 ) # End time subtracts off max duration of observation and 3 minutes of buffer end_time = args . get ( 'EndTimeHST' , 12 ) - max ([ SoCal_duration , Etalon_duration ]) / 60 - 0.05 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) if now_decimal < start_time : wait = ( start_time - now_decimal ) * 3600 log . info ( f 'Waiting { wait : .0f } s for SoCal window start time' ) time . sleep ( wait ) elif now_decimal > end_time : log . info ( \"End time for today's SoCal window has passed\" ) return ConfigureFIU . execute ({ 'mode' : 'Calibration' }) log . info ( f 'Starting SoCal observation loop' ) log . info ( f 'Start time: { start_time : .2f } HST' ) log . info ( f 'End Time: { end_time : .2f } HST' ) check_scriptstop () nSoCalObs = 0 nEtalonObs = 0 now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) while now_decimal >= start_time and now_decimal < end_time : log . debug ( 'Checking if SoCal is on the Sun' ) on_target = WaitForSoCalOnTarget . execute ({ 'timeout' : 30 }) OB = { True : SoCal_OB , False : SlewCal_OB }[ on_target ] log . info ( f 'SoCal on target: { on_target } ' ) try : check_scriptstop () for i , calibration in enumerate ( OB . Calibrations ): ExecuteCal . execute ( calibration . to_dict ()) if on_target == True : nSoCalObs += 1 else : nEtalonObs += 1 except ScriptStopTriggered as e : raise e except Exception as e : log . error ( \"ExecuteCal failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) # Email error to kpf_info if not isinstance ( e , ScriptStopTriggered ): try : msg = [ f ' { type ( e ) } ' , f ' { traceback . format_exc () } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'ExecuteCals Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) check_scriptstop () # Update loop inputs now = datetime . datetime . now () now_decimal = ( now . hour + now . minute / 60 + now . second / 3600 ) log . info ( 'SoCal observation loop completed' ) log . info ( f 'Executed { nSoCalObs } SoCal sequences' ) log . info ( f 'Executed { nEtalonObs } Etalon sequences' ) # Cleanup try : CleanupAfterCalibrations . execute ({}, OB = SlewCal_OB ) clear_script_keywords () except Exception as e : log . error ( \"CleanupAfterCalibrations failed:\" ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) clear_script_keywords () # Email error to kpf_info try : msg = [ f ' { type ( e ) } ' , f ' { traceback_text } ' , '' , f ' { OB } ' ] SendEmail . execute ({ 'Subject' : 'CleanupAfterCalibrations Failed' , 'Message' : ' \\n ' . join ( msg )}) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) # Park SoCal? if args . get ( 'park' , False ) == True : ParkSoCal . execute ({}) @classmethod def post_condition ( cls , args , OB = None ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'StartTimeHST' , type = float , help = 'Start of daily observing window in decimal hours HST.' ) parser . add_argument ( 'EndTimeHST' , type = float , help = 'End of daily observing window in decimal hours HST.' ) parser . add_argument ( \"--park\" , dest = \"park\" , default = False , action = \"store_true\" , help = \"Close and park SoCal when done?\" ) parser . add_argument ( '--waitforscript' , dest = \"waitforscript\" , default = False , action = \"store_true\" , help = 'Wait for running script to end before starting?' ) parser . add_argument ( \"--notscheduled\" , dest = \"scheduled\" , default = True , action = \"store_false\" , help = \"Do not respect the kpfconfig.ALLOWSCHEDULEDCALS flag.\" ) return super () . add_cmdline_args ( parser )","title":"RunSoCal"},{"location":"scripts/SelectTarget/","text":"SelectTarget Bases: KPFFunction Highlight the specified target in Magiq UI for the OA. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to highlight. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/SelectTarget.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SelectTarget ( KPFFunction ): '''Highlight the specified target in Magiq UI for the OA. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to highlight. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): target_name = args . get ( 'TargetName' , None ) params = { 'target' : target_name } log . info ( f 'Running Magiq selectTarget command { target_name } ' ) result = magiq_server_command ( 'selectTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"SelectTarget"},{"location":"scripts/SelectTarget/#selecttarget","text":"Bases: KPFFunction Highlight the specified target in Magiq UI for the OA. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: TargetName ( str ) \u2013 The name of the target to highlight. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/SelectTarget.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SelectTarget ( KPFFunction ): '''Highlight the specified target in Magiq UI for the OA. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: TargetName (str): The name of the target to highlight. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): target_name = args . get ( 'TargetName' , None ) params = { 'target' : target_name } log . info ( f 'Running Magiq selectTarget command { target_name } ' ) result = magiq_server_command ( 'selectTarget' , params = params ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'TargetName' , type = str , help = \"Name of target to select\" ) return super () . add_cmdline_args ( parser )","title":"SelectTarget"},{"location":"scripts/SendPCUtoHome/","text":"SendPCUtoHome Bases: KPFFunction Send the PCU stage to the \"home\" named position. KTL Keywords Used: ao.PCSFNAME ao.PCSFSTST Source code in kpf/ao/SendPCUtoHome.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SendPCUtoHome ( KPFFunction ): '''Send the PCU stage to the \"home\" named position. KTL Keywords Used: - `ao.PCSFNAME` - `ao.PCSFSTST` ''' @classmethod def pre_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) success = PCSFSTST . waitFor ( '!= \"FAULT\"' ) if success is not True : raise FailedPreCondition ( 'PCSFSTST is faulted' ) @classmethod def perform ( cls , args ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to Home\" ) PCSstagekw . write ( 'home' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'home' )","title":"SendPCUtoHome"},{"location":"scripts/SendPCUtoHome/#sendpcutohome","text":"Bases: KPFFunction Send the PCU stage to the \"home\" named position. KTL Keywords Used: ao.PCSFNAME ao.PCSFSTST Source code in kpf/ao/SendPCUtoHome.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SendPCUtoHome ( KPFFunction ): '''Send the PCU stage to the \"home\" named position. KTL Keywords Used: - `ao.PCSFNAME` - `ao.PCSFSTST` ''' @classmethod def pre_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) success = PCSFSTST . waitFor ( '!= \"FAULT\"' ) if success is not True : raise FailedPreCondition ( 'PCSFSTST is faulted' ) @classmethod def perform ( cls , args ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to Home\" ) PCSstagekw . write ( 'home' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args ): PCSstagekw = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSstagekw . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSstagekw . read (), 'home' )","title":"SendPCUtoHome"},{"location":"scripts/SendPCUtoKPF/","text":"SendPCUtoKPF Bases: KPFFunction Send the PCU stage to the \"kpf\" named position. KTL Keywords Used: ao.PCSFNAME ao.PCSFSTST Source code in kpf/ao/SendPCUtoKPF.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SendPCUtoKPF ( KPFFunction ): '''Send the PCU stage to the \"kpf\" named position. KTL Keywords Used: - `ao.PCSFNAME` - `ao.PCSFSTST` ''' @classmethod def pre_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) PCSFNAME = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSFSTST . waitFor ( '!= \"FAULT\"' , timeout = 1 ) != True : raise FailedPreCondition ( 'PCSFSTST is faulted' ) if PCSFSTST . waitfor ( \"== 'INPOS'\" , timeout = 120 ) == False : raise FailedPreCondition ( 'PCU is in motion' ) if PCSFNAME . waitfor ( \"== 'home'\" , timeout = 120 ) == False : raise FailedPreCondition ( 'PCU must be at home before moving to KPF' ) @classmethod def perform ( cls , args ): PCSFNAME = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to KPF\" ) PCSFNAME . write ( 'kpf' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSFSTST . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSFSTST . read (), 'kpf' )","title":"SendPCUtoKPF"},{"location":"scripts/SendPCUtoKPF/#sendpcutokpf","text":"Bases: KPFFunction Send the PCU stage to the \"kpf\" named position. KTL Keywords Used: ao.PCSFNAME ao.PCSFSTST Source code in kpf/ao/SendPCUtoKPF.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SendPCUtoKPF ( KPFFunction ): '''Send the PCU stage to the \"kpf\" named position. KTL Keywords Used: - `ao.PCSFNAME` - `ao.PCSFSTST` ''' @classmethod def pre_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) PCSFNAME = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSFSTST . waitFor ( '!= \"FAULT\"' , timeout = 1 ) != True : raise FailedPreCondition ( 'PCSFSTST is faulted' ) if PCSFSTST . waitfor ( \"== 'INPOS'\" , timeout = 120 ) == False : raise FailedPreCondition ( 'PCU is in motion' ) if PCSFNAME . waitfor ( \"== 'home'\" , timeout = 120 ) == False : raise FailedPreCondition ( 'PCU must be at home before moving to KPF' ) @classmethod def perform ( cls , args ): PCSFNAME = ktl . cache ( 'ao' , 'PCSFNAME' ) log . info ( f \"Sending PCU to KPF\" ) PCSFNAME . write ( 'kpf' ) shim_time = cfg . getfloat ( 'times' , 'ao_pcu_shim_time' , fallback = 5 ) time . sleep ( shim_time ) @classmethod def post_condition ( cls , args ): PCSFSTST = ktl . cache ( 'ao' , 'PCSFSTST' ) timeout = cfg . getfloat ( 'times' , 'ao_pcu_move_time' , fallback = 150 ) success = PCSFSTST . waitfor ( \"== INPOS\" , timeout = timeout ) if success is False : raise FailedToReachDestination ( PCSFSTST . read (), 'kpf' )","title":"SendPCUtoKPF"},{"location":"scripts/SetADCAngles/","text":"SetADCAngles Bases: KPFFunction Quick and dirty code to manually set ADC angles for a notional NULL position. KTL Keywords Used: kpffiu.ADC1VAL kpffiu.ADC2VAL Source code in kpf/fiu/SetADCAngles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class SetADCAngles ( KPFFunction ): '''Quick and dirty code to manually set ADC angles for a notional NULL position. KTL Keywords Used: - `kpffiu.ADC1VAL` - `kpffiu.ADC2VAL` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) el = args . get ( 'EL' ) za = 90 - el ADC_delta = calculate_ADC_delta ( za ) log . info ( f \"ADC Hack: za= { za : .1f } , ADC_delta= { ADC_delta : .1f } \" ) # Constants common_angle = 60 ADC1_offset = - 5 ADC2_offset = 5 log . debug ( f \"ADC Hack: common_angle= { common_angle : .1f } \" ) log . debug ( f \"ADC Hack: ADC1_offset= { ADC1_offset : .1f } \" ) log . debug ( f \"ADC Hack: ADC2_offset= { ADC2_offset : .1f } \" ) # Calculations ADC1 = common_angle + ADC1_offset + za - ADC_delta ADC2 = common_angle + ADC2_offset - za - ADC_delta log . info ( f \"ADC Hack: Writing ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'EL' , type = float , help = \"The telescope elevation to use in the calculation\" ) return super () . add_cmdline_args ( parser )","title":"SetADCAngles"},{"location":"scripts/SetADCAngles/#setadcangles","text":"Bases: KPFFunction Quick and dirty code to manually set ADC angles for a notional NULL position. KTL Keywords Used: kpffiu.ADC1VAL kpffiu.ADC2VAL Source code in kpf/fiu/SetADCAngles.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class SetADCAngles ( KPFFunction ): '''Quick and dirty code to manually set ADC angles for a notional NULL position. KTL Keywords Used: - `kpffiu.ADC1VAL` - `kpffiu.ADC2VAL` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) el = args . get ( 'EL' ) za = 90 - el ADC_delta = calculate_ADC_delta ( za ) log . info ( f \"ADC Hack: za= { za : .1f } , ADC_delta= { ADC_delta : .1f } \" ) # Constants common_angle = 60 ADC1_offset = - 5 ADC2_offset = 5 log . debug ( f \"ADC Hack: common_angle= { common_angle : .1f } \" ) log . debug ( f \"ADC Hack: ADC1_offset= { ADC1_offset : .1f } \" ) log . debug ( f \"ADC Hack: ADC2_offset= { ADC2_offset : .1f } \" ) # Calculations ADC1 = common_angle + ADC1_offset + za - ADC_delta ADC2 = common_angle + ADC2_offset - za - ADC_delta log . info ( f \"ADC Hack: Writing ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'EL' , type = float , help = \"The telescope elevation to use in the calculation\" ) return super () . add_cmdline_args ( parser )","title":"SetADCAngles"},{"location":"scripts/SetADCOffsets/","text":"SetADCOffsets Bases: KPFFunction Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. Parameters: ADC1OFF ( float ) \u2013 Offset for ADC1 (in degrees). ADC2OFF ( float ) \u2013 Offset for ADC2 (in degrees). KTL Keywords Used: kpffiu.ADC1VAL kpffiu.ADC2VAL kpffiu.ADCTRACK kpffiu.ADCPRISMS Source code in kpf/fiu/SetADCOffsets.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class SetADCOffsets ( KPFFunction ): '''Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. Args: ADC1OFF (float): Offset for ADC1 (in degrees). ADC2OFF (float): Offset for ADC2 (in degrees). KTL Keywords Used: - `kpffiu.ADC1VAL` - `kpffiu.ADC2VAL` - `kpffiu.ADCTRACK` - `kpffiu.ADCPRISMS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) if kpffiu [ 'ADCTRACK' ] . read () == 'On' : log . info ( f 'Setting ADCTRACK to Off' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) time . sleep ( 1 ) ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) ADC1 = ADC1_nominal + args . get ( 'ADC1OFF' ) ADC2 = ADC2_nominal + args . get ( 'ADC2OFF' ) log . info ( f \"Setting ADC to offset angles: ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) tol = 0.1 ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) adc1targ = ADC1_nominal + args . get ( 'ADC1OFF' ) adc2targ = ADC2_nominal + args . get ( 'ADC2OFF' ) expr = ( f \"($kpffiu.ADC1VAL > { adc1targ - tol } ) \" f \"and ($kpffiu.ADC1VAL < { adc1targ + tol } ) \" f \"and ($kpffiu.ADC2VAL > { adc2targ - tol } ) \" f \"and ($kpffiu.ADC2VAL < { adc2targ + tol } )\" ) success = ktl . waitFor ( expr , timeout = 20 ) if success is False : raise FailedPostCondition ( 'ADC Prisms did not reach destination angles' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ADC1OFF' , type = float , help = \"Offset for ADC1 (in degrees)\" ) parser . add_argument ( 'ADC2OFF' , type = float , help = \"Offset for ADC2 (in degrees)\" ) return super () . add_cmdline_args ( parser )","title":"SetADCOffsets"},{"location":"scripts/SetADCOffsets/#setadcoffsets","text":"Bases: KPFFunction Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. Parameters: ADC1OFF ( float ) \u2013 Offset for ADC1 (in degrees). ADC2OFF ( float ) \u2013 Offset for ADC2 (in degrees). KTL Keywords Used: kpffiu.ADC1VAL kpffiu.ADC2VAL kpffiu.ADCTRACK kpffiu.ADCPRISMS Source code in kpf/fiu/SetADCOffsets.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class SetADCOffsets ( KPFFunction ): '''Quick and dirty code to manually set ADC angles to prescribed offsets from nominal based on the telescope position. Args: ADC1OFF (float): Offset for ADC1 (in degrees). ADC2OFF (float): Offset for ADC2 (in degrees). KTL Keywords Used: - `kpffiu.ADC1VAL` - `kpffiu.ADC2VAL` - `kpffiu.ADCTRACK` - `kpffiu.ADCPRISMS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) if kpffiu [ 'ADCTRACK' ] . read () == 'On' : log . info ( f 'Setting ADCTRACK to Off' ) kpffiu [ 'ADCTRACK' ] . write ( 'Off' ) time . sleep ( 1 ) ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) ADC1 = ADC1_nominal + args . get ( 'ADC1OFF' ) ADC2 = ADC2_nominal + args . get ( 'ADC2OFF' ) log . info ( f \"Setting ADC to offset angles: ADC1VAL= { ADC1 : .1f } , ADC2VAL= { ADC2 : .1f } \" ) kpffiu [ 'ADC1VAL' ] . write ( ADC1 ) kpffiu [ 'ADC2VAL' ] . write ( ADC2 ) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) tol = 0.1 ADC1_nominal , ADC2_nominal = kpffiu [ 'ADCPRISMS' ] . read ( binary = True ) adc1targ = ADC1_nominal + args . get ( 'ADC1OFF' ) adc2targ = ADC2_nominal + args . get ( 'ADC2OFF' ) expr = ( f \"($kpffiu.ADC1VAL > { adc1targ - tol } ) \" f \"and ($kpffiu.ADC1VAL < { adc1targ + tol } ) \" f \"and ($kpffiu.ADC2VAL > { adc2targ - tol } ) \" f \"and ($kpffiu.ADC2VAL < { adc2targ + tol } )\" ) success = ktl . waitFor ( expr , timeout = 20 ) if success is False : raise FailedPostCondition ( 'ADC Prisms did not reach destination angles' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ADC1OFF' , type = float , help = \"Offset for ADC1 (in degrees)\" ) parser . add_argument ( 'ADC2OFF' , type = float , help = \"Offset for ADC2 (in degrees)\" ) return super () . add_cmdline_args ( parser )","title":"SetADCOffsets"},{"location":"scripts/SetAFMtoMirror/","text":"SetAFMtoMirror Bases: KPFFunction Set AFM to Mirror so ACAM sees light KTL Keywords Used: ao.OBAMNAME ao.OBAMSLEW ao.OBAMSTST Source code in kpf/ao/SetAFMtoMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetAFMtoMirror ( KPFFunction ): '''Set AFM to Mirror so ACAM sees light KTL Keywords Used: - `ao.OBAMNAME` - `ao.OBAMSLEW` - `ao.OBAMSTST` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBAMNAME = ktl . cache ( 'ao' , 'OBAMNAME' ) OBAMSLEW = ktl . cache ( 'ao' , 'OBAMSLEW' ) log . debug ( f \"Setting AFM to Mirror\" ) OBAMNAME . write ( 'Mirror' ) OBAMSLEW . write ( '1' ) @classmethod def post_condition ( cls , args ): expr = '($ao.OBAMSTST == INPOS) and ($ao.OBAMNAME == Mirror)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : OBAMNAME = ktl . cache ( 'ao' , 'OBAMNAME' ) FailedToReachDestination ( OBAMNAME . read (), 'Mirror' )","title":"SetAFMtoMirror"},{"location":"scripts/SetAFMtoMirror/#setafmtomirror","text":"Bases: KPFFunction Set AFM to Mirror so ACAM sees light KTL Keywords Used: ao.OBAMNAME ao.OBAMSLEW ao.OBAMSTST Source code in kpf/ao/SetAFMtoMirror.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetAFMtoMirror ( KPFFunction ): '''Set AFM to Mirror so ACAM sees light KTL Keywords Used: - `ao.OBAMNAME` - `ao.OBAMSLEW` - `ao.OBAMSTST` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBAMNAME = ktl . cache ( 'ao' , 'OBAMNAME' ) OBAMSLEW = ktl . cache ( 'ao' , 'OBAMSLEW' ) log . debug ( f \"Setting AFM to Mirror\" ) OBAMNAME . write ( 'Mirror' ) OBAMSLEW . write ( '1' ) @classmethod def post_condition ( cls , args ): expr = '($ao.OBAMSTST == INPOS) and ($ao.OBAMNAME == Mirror)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : OBAMNAME = ktl . cache ( 'ao' , 'OBAMNAME' ) FailedToReachDestination ( OBAMNAME . read (), 'Mirror' )","title":"SetAFMtoMirror"},{"location":"scripts/SetAFStoNGS/","text":"SetAFStoNGS Bases: KPFFunction ACAM should be set to NGS focus. LGS focus will not work for KPF. KTL Keywords Used: ao.OBASNAME ao.OBASSLEW ao.OBASSTST Source code in kpf/ao/SetAFStoNGS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetAFStoNGS ( KPFFunction ): '''ACAM should be set to NGS focus. LGS focus will not work for KPF. KTL Keywords Used: - `ao.OBASNAME` - `ao.OBASSLEW` - `ao.OBASSTST` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBASNAME = ktl . cache ( 'ao' , 'OBASNAME' ) OBASSLEW = ktl . cache ( 'ao' , 'OBASSLEW' ) log . debug ( f \"Setting AFS to NGS\" ) OBASNAME . write ( 'ngs' ) OBASSLEW . write ( '1' ) @classmethod def post_condition ( cls , args ): expr = f '($ao.OBASSTST == INPOS) and ($ao.OBASNAME == ngs)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : OBASNAME = ktl . cache ( 'ao' , 'OBASNAME' ) raise FailedToReachDestination ( OBASNAME . read (), 'ngs' )","title":"SetAFStoNGS"},{"location":"scripts/SetAFStoNGS/#setafstongs","text":"Bases: KPFFunction ACAM should be set to NGS focus. LGS focus will not work for KPF. KTL Keywords Used: ao.OBASNAME ao.OBASSLEW ao.OBASSTST Source code in kpf/ao/SetAFStoNGS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class SetAFStoNGS ( KPFFunction ): '''ACAM should be set to NGS focus. LGS focus will not work for KPF. KTL Keywords Used: - `ao.OBASNAME` - `ao.OBASSLEW` - `ao.OBASSTST` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBASNAME = ktl . cache ( 'ao' , 'OBASNAME' ) OBASSLEW = ktl . cache ( 'ao' , 'OBASSLEW' ) log . debug ( f \"Setting AFS to NGS\" ) OBASNAME . write ( 'ngs' ) OBASSLEW . write ( '1' ) @classmethod def post_condition ( cls , args ): expr = f '($ao.OBASSTST == INPOS) and ($ao.OBASNAME == ngs)' aoamstst_success = ktl . waitfor ( expr , timeout = 60 ) if not aoamstst_success : OBASNAME = ktl . cache ( 'ao' , 'OBASNAME' ) raise FailedToReachDestination ( OBASNAME . read (), 'ngs' )","title":"SetAFStoNGS"},{"location":"scripts/SetAODCStoSIM/","text":"SetAODCStoSIM Bases: KPFFunction Set AO in AO DCS sim mode, so AO doesn't communicate with telescope KTL Keywords Used: ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Source code in kpf/ao/SetAODCStoSIM.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetAODCStoSIM ( KPFFunction ): '''Set AO in AO DCS sim mode, so AO doesn't communicate with telescope KTL Keywords Used: - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AODCSSIM = ktl . cache ( 'ao' , 'AODCSSIM' ) AOCOMSIM = ktl . cache ( 'ao' , 'AOCOMSIM' ) AODCSSFP = ktl . cache ( 'ao' , 'AODCSSFP' ) log . debug ( \"Setting AO DCS to Sim\" ) AODCSSIM . write ( '1' ) AOCOMSIM . write ( '1' ) AODCSSFP . write ( '0' ) @classmethod def post_condition ( cls , args ): AODCSSIM = ktl . cache ( 'ao' , 'AODCSSIM' ) if not AODCSSIM . waitfor ( '== \"enabled\"' , timeout = 3 ): raise FailedToReachDestination ( AODCSSIM . read (), 'enabled' ) AOCOMSIM = ktl . cache ( 'ao' , 'AOCOMSIM' ) if not AOCOMSIM . waitfor ( '== \"enabled\"' , timeout = 3 ): raise FailedToReachDestination ( AOCOMSIM . read (), 'enabled' ) AODCSSFP = ktl . cache ( 'ao' , 'AODCSSFP' ) if not AODCSSFP . waitfor ( '== \"disabled\"' , timeout = 3 ): raise FailedToReachDestination ( AODCSSFP . read (), 'disabled' )","title":"SetAODCStoSIM"},{"location":"scripts/SetAODCStoSIM/#setaodcstosim","text":"Bases: KPFFunction Set AO in AO DCS sim mode, so AO doesn't communicate with telescope KTL Keywords Used: ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Source code in kpf/ao/SetAODCStoSIM.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SetAODCStoSIM ( KPFFunction ): '''Set AO in AO DCS sim mode, so AO doesn't communicate with telescope KTL Keywords Used: - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AODCSSIM = ktl . cache ( 'ao' , 'AODCSSIM' ) AOCOMSIM = ktl . cache ( 'ao' , 'AOCOMSIM' ) AODCSSFP = ktl . cache ( 'ao' , 'AODCSSFP' ) log . debug ( \"Setting AO DCS to Sim\" ) AODCSSIM . write ( '1' ) AOCOMSIM . write ( '1' ) AODCSSFP . write ( '0' ) @classmethod def post_condition ( cls , args ): AODCSSIM = ktl . cache ( 'ao' , 'AODCSSIM' ) if not AODCSSIM . waitfor ( '== \"enabled\"' , timeout = 3 ): raise FailedToReachDestination ( AODCSSIM . read (), 'enabled' ) AOCOMSIM = ktl . cache ( 'ao' , 'AOCOMSIM' ) if not AOCOMSIM . waitfor ( '== \"enabled\"' , timeout = 3 ): raise FailedToReachDestination ( AOCOMSIM . read (), 'enabled' ) AODCSSFP = ktl . cache ( 'ao' , 'AODCSSFP' ) if not AODCSSFP . waitfor ( '== \"disabled\"' , timeout = 3 ): raise FailedToReachDestination ( AODCSSFP . read (), 'disabled' )","title":"SetAODCStoSIM"},{"location":"scripts/SetAORotator/","text":"SetAORotator Bases: KPFFunction Set the AO rotator destination KTL Keywords Used: ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Parameters: dest ( float ) \u2013 Angle in degrees for the physical drive angle of the rotator. Source code in kpf/ao/SetAORotator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetAORotator ( KPFFunction ): '''Set the AO rotator destination KTL Keywords Used: - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` Args: dest (float): Angle in degrees for the physical drive angle of the rotator. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'dest' ) @classmethod def perform ( cls , args ): OBRT = ktl . cache ( 'ao' , 'OBRT' ) OBRTMOVE = ktl . cache ( 'ao' , 'OBRTMOVE' ) dest = args . get ( 'dest' , 0 ) log . debug ( f \"Setting AO Rotator to { dest : .1f } \" ) OBRT . write ( dest ) OBRTMOVE . write ( '1' ) @classmethod def post_condition ( cls , args ): OBRTSTST = ktl . cache ( 'ao' , 'OBRTSTST' ) if OBRTSTST . waitfor ( '== \"INPOS\"' , timeout = 180 ) is not True : raise FailedToReachDestination ( OBRTSTST . read (), 'INPOS' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'dest' , type = float , help = \"Desired rotator position\" ) return super () . add_cmdline_args ( parser )","title":"SetAORotator"},{"location":"scripts/SetAORotator/#setaorotator","text":"Bases: KPFFunction Set the AO rotator destination KTL Keywords Used: ao.AODCSSIM ao.AOCOMSIM ao.AODCSSFP Parameters: dest ( float ) \u2013 Angle in degrees for the physical drive angle of the rotator. Source code in kpf/ao/SetAORotator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetAORotator ( KPFFunction ): '''Set the AO rotator destination KTL Keywords Used: - `ao.AODCSSIM` - `ao.AOCOMSIM` - `ao.AODCSSFP` Args: dest (float): Angle in degrees for the physical drive angle of the rotator. ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'dest' ) @classmethod def perform ( cls , args ): OBRT = ktl . cache ( 'ao' , 'OBRT' ) OBRTMOVE = ktl . cache ( 'ao' , 'OBRTMOVE' ) dest = args . get ( 'dest' , 0 ) log . debug ( f \"Setting AO Rotator to { dest : .1f } \" ) OBRT . write ( dest ) OBRTMOVE . write ( '1' ) @classmethod def post_condition ( cls , args ): OBRTSTST = ktl . cache ( 'ao' , 'OBRTSTST' ) if OBRTSTST . waitfor ( '== \"INPOS\"' , timeout = 180 ) is not True : raise FailedToReachDestination ( OBRTSTST . read (), 'INPOS' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'dest' , type = float , help = \"Desired rotator position\" ) return super () . add_cmdline_args ( parser )","title":"SetAORotator"},{"location":"scripts/SetAORotatorManual/","text":"SetAORotatorManual Bases: KPFFunction AO rotator needs to be in the Manual mode before observing. KTL Keywords Used: ao.OBRTDSRC ao.OBRTMOVE Source code in kpf/ao/SetAORotatorManual.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class SetAORotatorManual ( KPFFunction ): '''AO rotator needs to be in the Manual mode before observing. KTL Keywords Used: - `ao.OBRTDSRC` - `ao.OBRTMOVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBRTDSRC = ktl . cache ( 'ao' , 'OBRTDSRC' ) OBRTMOVE = ktl . cache ( 'ao' , 'OBRTMOVE' ) log . debug ( \"Setting AO rotator to manual mode\" ) OBRTDSRC . write ( '0' ) OBRTMOVE . write ( '1' ) @classmethod def post_condition ( cls , args ): OBRTDSRC = ktl . cache ( 'ao' , 'OBRTDSRC' ) if OBRTDSRC . waitfor ( '== \"manual\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBRTDSRC . read (), 'manual' )","title":"SetAORotatorManual"},{"location":"scripts/SetAORotatorManual/#setaorotatormanual","text":"Bases: KPFFunction AO rotator needs to be in the Manual mode before observing. KTL Keywords Used: ao.OBRTDSRC ao.OBRTMOVE Source code in kpf/ao/SetAORotatorManual.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class SetAORotatorManual ( KPFFunction ): '''AO rotator needs to be in the Manual mode before observing. KTL Keywords Used: - `ao.OBRTDSRC` - `ao.OBRTMOVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBRTDSRC = ktl . cache ( 'ao' , 'OBRTDSRC' ) OBRTMOVE = ktl . cache ( 'ao' , 'OBRTMOVE' ) log . debug ( \"Setting AO rotator to manual mode\" ) OBRTDSRC . write ( '0' ) OBRTMOVE . write ( '1' ) @classmethod def post_condition ( cls , args ): OBRTDSRC = ktl . cache ( 'ao' , 'OBRTDSRC' ) if OBRTDSRC . waitfor ( '== \"manual\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBRTDSRC . read (), 'manual' )","title":"SetAORotatorManual"},{"location":"scripts/SetCalSource/","text":"SetCalSource Bases: KPFFunction Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword. Parameters: CalSource ( str ) \u2013 Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: kpfcal.OCTAGON Source code in kpf/calbench/SetCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetCalSource ( KPFFunction ): '''Selects which source is fed from the octagon in to the cal bench via the `kpfcal.OCTAGON` keyword. Args: CalSource (str): Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: - `kpfcal.OCTAGON` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalSource' ) OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) log . debug ( f \"Setting Cal Source (Octagon) to { target } \" ) OCTAGON . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 90 ) OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) if OCTAGON . waitFor ( f '== \" { target } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( OCTAGON . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetCalSource"},{"location":"scripts/SetCalSource/#setcalsource","text":"Bases: KPFFunction Selects which source is fed from the octagon in to the cal bench via the kpfcal.OCTAGON keyword. Parameters: CalSource ( str ) \u2013 Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: kpfcal.OCTAGON Source code in kpf/calbench/SetCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetCalSource ( KPFFunction ): '''Selects which source is fed from the octagon in to the cal bench via the `kpfcal.OCTAGON` keyword. Args: CalSource (str): Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: - `kpfcal.OCTAGON` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalSource' ) OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) log . debug ( f \"Setting Cal Source (Octagon) to { target } \" ) OCTAGON . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 90 ) OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) if OCTAGON . waitFor ( f '== \" { target } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( OCTAGON . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetCalSource"},{"location":"scripts/SetExpMeterExpTime/","text":"SetExpMeterExpTime Bases: KPFFunction Sets the exposure time for the exposure meter Parameters: ExpMeterExpTime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpf_expmeter.EXPOSURE Source code in kpf/expmeter/SetExpMeterExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetExpMeterExpTime ( KPFFunction ): '''Sets the exposure time for the exposure meter Args: ExpMeterExpTime (float): The exposure time in seconds. KTL Keywords Used: - `kpf_expmeter.EXPOSURE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpMeterExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): EXPOSURE = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) exptime = args . get ( 'ExpMeterExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) EXPOSURE . write ( exptime ) @classmethod def post_condition ( cls , args ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpMeterExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpf_expmeter.EXPOSURE >= { exptime - tol } ) and \" f \"($kpf_expmeter.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : EXPOSURE = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) raise FailedToReachDestination ( EXPOSURE . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpMeterExpTime' , type = float , help = \"The exposure time in seconds\" ) return super () . add_cmdline_args ( parser )","title":"SetExpMeterExpTime"},{"location":"scripts/SetExpMeterExpTime/#setexpmeterexptime","text":"Bases: KPFFunction Sets the exposure time for the exposure meter Parameters: ExpMeterExpTime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpf_expmeter.EXPOSURE Source code in kpf/expmeter/SetExpMeterExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class SetExpMeterExpTime ( KPFFunction ): '''Sets the exposure time for the exposure meter Args: ExpMeterExpTime (float): The exposure time in seconds. KTL Keywords Used: - `kpf_expmeter.EXPOSURE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpMeterExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): EXPOSURE = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) exptime = args . get ( 'ExpMeterExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) EXPOSURE . write ( exptime ) @classmethod def post_condition ( cls , args ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpMeterExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpf_expmeter.EXPOSURE >= { exptime - tol } ) and \" f \"($kpf_expmeter.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : EXPOSURE = ktl . cache ( 'kpf_expmeter' , 'EXPOSURE' ) raise FailedToReachDestination ( EXPOSURE . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpMeterExpTime' , type = float , help = \"The exposure time in seconds\" ) return super () . add_cmdline_args ( parser )","title":"SetExpMeterExpTime"},{"location":"scripts/SetExpMeterTerminationParameters/","text":"SetExpMeterTerminationParameters Bases: KPFFunction Sets the exposure meter exposure termination control parameters Parameters: Band ( int ) \u2013 Which of the 4 exposure meter bands to use? 0=All, 1=498nm, 2=604nm, 3=711nm, 4=817nm (from kpf_expmeter.THRESHOLDBIN). Flux ( float ) \u2013 The target flux (e/nm) in the science spectrum. KTL Keywords Used: kpf_expmeter.THRESHOLDBIN kpf_expmeter.THRESHOLD kpf_expmeter.USETHRESHOLD Source code in kpf/expmeter/SetExpMeterTerminationParameters.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class SetExpMeterTerminationParameters ( KPFFunction ): '''Sets the exposure meter exposure termination control parameters Args: Band (int): Which of the 4 exposure meter bands to use? 0=All, 1=498nm, 2=604nm, 3=711nm, 4=817nm (from kpf_expmeter.THRESHOLDBIN). Flux (float): The target flux (e/nm) in the science spectrum. KTL Keywords Used: - `kpf_expmeter.THRESHOLDBIN` - `kpf_expmeter.THRESHOLD` - `kpf_expmeter.USETHRESHOLD` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpMeterThreshold' , allowed_types = [ int , float ], value_min = 0 ) # check_input(args, 'ExpMeterBin', allowed_types=[int, float, str]) # band = float(args.get('ExpMeterBin')) # tbin = ktl.cache('kpf_expmeter', 'THRESHOLDBIN') # allowed_values = list(tbin._getEnumerators()) # allowed_values.pop(allowed_values.index('All')) # allowed_floats = np.array([float(x) for x in allowed_values]) # if int(band) not in [1, 2, 3, 4]: # band = (np.abs(allowed_floats-band)).argmin()+1 # if band not in [1, 2, 3, 4]: # raise FailedPreCondition(f'Unable to parse ExpMeterBin: {args.get(\"ExpMeterBin\")}') @classmethod def perform ( cls , args ): tbin = ktl . cache ( 'kpf_expmeter' , 'THRESHOLDBIN' ) allowed_values = list ( tbin . _getEnumerators ()) allowed_values . pop ( allowed_values . index ( 'All' )) allowed_floats = np . array ([ float ( x ) for x in allowed_values ]) floatband = float ( args . get ( 'ExpMeterBin' )) if int ( floatband ) in [ 1 , 2 , 3 , 4 ]: intband = int ( floatband ) else : intband = ( np . abs ( allowed_floats - floatband )) . argmin () + 1 stringband = { 1 : '498.125' , 2 : '604.375' , 3 : '710.625' , 4 : '816.875' }[ intband ] spectrograph_flux = args . get ( 'ExpMeterThreshold' ) expmeter_flux , snr_estimate = expeter_flux_target ( spectrograph_flux , stringband ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'THRESHOLDBIN' ] . write ( stringband ) kpf_expmeter [ 'THRESHOLD' ] . write ( expmeter_flux ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpMeterBin' , type = str , choices = [ '1' , '2' , '3' , '4' , '498.125' , '604.375' , '710.625' , '816.875' ], help = \"Which exposure meter band to use\" ) parser . add_argument ( 'ExpMeterThreshold' , type = float , help = \"Threshold flux in Mphotons/A in the main spectrograph\" ) return super () . add_cmdline_args ( parser )","title":"SetExpMeterTerminationParameters"},{"location":"scripts/SetExpMeterTerminationParameters/#setexpmeterterminationparameters","text":"Bases: KPFFunction Sets the exposure meter exposure termination control parameters Parameters: Band ( int ) \u2013 Which of the 4 exposure meter bands to use? 0=All, 1=498nm, 2=604nm, 3=711nm, 4=817nm (from kpf_expmeter.THRESHOLDBIN). Flux ( float ) \u2013 The target flux (e/nm) in the science spectrum. KTL Keywords Used: kpf_expmeter.THRESHOLDBIN kpf_expmeter.THRESHOLD kpf_expmeter.USETHRESHOLD Source code in kpf/expmeter/SetExpMeterTerminationParameters.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class SetExpMeterTerminationParameters ( KPFFunction ): '''Sets the exposure meter exposure termination control parameters Args: Band (int): Which of the 4 exposure meter bands to use? 0=All, 1=498nm, 2=604nm, 3=711nm, 4=817nm (from kpf_expmeter.THRESHOLDBIN). Flux (float): The target flux (e/nm) in the science spectrum. KTL Keywords Used: - `kpf_expmeter.THRESHOLDBIN` - `kpf_expmeter.THRESHOLD` - `kpf_expmeter.USETHRESHOLD` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpMeterThreshold' , allowed_types = [ int , float ], value_min = 0 ) # check_input(args, 'ExpMeterBin', allowed_types=[int, float, str]) # band = float(args.get('ExpMeterBin')) # tbin = ktl.cache('kpf_expmeter', 'THRESHOLDBIN') # allowed_values = list(tbin._getEnumerators()) # allowed_values.pop(allowed_values.index('All')) # allowed_floats = np.array([float(x) for x in allowed_values]) # if int(band) not in [1, 2, 3, 4]: # band = (np.abs(allowed_floats-band)).argmin()+1 # if band not in [1, 2, 3, 4]: # raise FailedPreCondition(f'Unable to parse ExpMeterBin: {args.get(\"ExpMeterBin\")}') @classmethod def perform ( cls , args ): tbin = ktl . cache ( 'kpf_expmeter' , 'THRESHOLDBIN' ) allowed_values = list ( tbin . _getEnumerators ()) allowed_values . pop ( allowed_values . index ( 'All' )) allowed_floats = np . array ([ float ( x ) for x in allowed_values ]) floatband = float ( args . get ( 'ExpMeterBin' )) if int ( floatband ) in [ 1 , 2 , 3 , 4 ]: intband = int ( floatband ) else : intband = ( np . abs ( allowed_floats - floatband )) . argmin () + 1 stringband = { 1 : '498.125' , 2 : '604.375' , 3 : '710.625' , 4 : '816.875' }[ intband ] spectrograph_flux = args . get ( 'ExpMeterThreshold' ) expmeter_flux , snr_estimate = expeter_flux_target ( spectrograph_flux , stringband ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) kpf_expmeter [ 'THRESHOLDBIN' ] . write ( stringband ) kpf_expmeter [ 'THRESHOLD' ] . write ( expmeter_flux ) kpf_expmeter [ 'USETHRESHOLD' ] . write ( 'Yes' ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpMeterBin' , type = str , choices = [ '1' , '2' , '3' , '4' , '498.125' , '604.375' , '710.625' , '816.875' ], help = \"Which exposure meter band to use\" ) parser . add_argument ( 'ExpMeterThreshold' , type = float , help = \"Threshold flux in Mphotons/A in the main spectrograph\" ) return super () . add_cmdline_args ( parser )","title":"SetExpMeterTerminationParameters"},{"location":"scripts/SetExpTime/","text":"SetExpTime Bases: KPFFunction Sets the exposure time for the science detectors in the kpfexpose keyword service. Parameters: ExpTime ( float ) \u2013 The exposure time in seconds KTL Keywords Used: kpfexpose.EXPOSURE Source code in kpf/spectrograph/SetExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SetExpTime ( KPFFunction ): '''Sets the exposure time for the science detectors in the kpfexpose keyword service. Args: ExpTime (float): The exposure time in seconds KTL Keywords Used: - `kpfexpose.EXPOSURE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): EXPOSURE = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) exptime = args . get ( 'ExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) EXPOSURE . write ( exptime ) @classmethod def post_condition ( cls , args ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpfexpose.EXPOSURE >= { exptime - tol } ) and \" f \"($kpfexpose.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : EXPOSURE = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) raise FailedToReachDestination ( EXPOSURE . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpTime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetExpTime"},{"location":"scripts/SetExpTime/#setexptime","text":"Bases: KPFFunction Sets the exposure time for the science detectors in the kpfexpose keyword service. Parameters: ExpTime ( float ) \u2013 The exposure time in seconds KTL Keywords Used: kpfexpose.EXPOSURE Source code in kpf/spectrograph/SetExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SetExpTime ( KPFFunction ): '''Sets the exposure time for the science detectors in the kpfexpose keyword service. Args: ExpTime (float): The exposure time in seconds KTL Keywords Used: - `kpfexpose.EXPOSURE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'ExpTime' , allowed_types = [ int , float ]) @classmethod def perform ( cls , args ): EXPOSURE = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) exptime = args . get ( 'ExpTime' ) log . debug ( f \"Setting exposure time to { exptime : .3f } \" ) EXPOSURE . write ( exptime ) @classmethod def post_condition ( cls , args ): log . debug ( \"Checking for success\" ) exptime = args . get ( 'ExpTime' ) tol = cfg . getfloat ( 'tolerances' , 'kpfexpose_exptime_tolerance' , fallback = 0.01 ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) expr = ( f \"($kpfexpose.EXPOSURE >= { exptime - tol } ) and \" f \"($kpfexpose.EXPOSURE <= { exptime + tol } )\" ) log . debug ( expr ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : EXPOSURE = ktl . cache ( 'kpfexpose' , 'EXPOSURE' ) raise FailedToReachDestination ( EXPOSURE . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'ExpTime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetExpTime"},{"location":"scripts/SetFVCExpTime/","text":"SetFVCExpTime Bases: KPFFunction Set the exposure time of the specified fiber viewing camera Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/SetFVCExpTime.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class SetFVCExpTime ( KPFFunction ): '''Set the exposure time of the specified fiber viewing camera Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) check_input ( args , 'exptime' , value_min = 0.005 , value_max = 60 ) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = args . get ( 'exptime' ) log . debug ( f \"Setting { camera } FVC exposure time to { exptime : .3f } s\" ) kpffvc [ f ' { camera } EXPTIME' ] . write ( exptime ) @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) tol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) expr = ( f '($kpffvc. { camera } EXPTIME > { exptime } - { tol } ) ' \\ f 'and ($kpffvc. { camera } EXPTIME < { exptime } + { tol } )' ) success = ktl . waitfor ( expr , timeout = timeout ) if success is not True : exptimekw = ktl . cache ( 'kpffvc' , f \" { camera } EXPTIME\" ) raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetFVCExpTime"},{"location":"scripts/SetFVCExpTime/#setfvcexptime","text":"Bases: KPFFunction Set the exposure time of the specified fiber viewing camera Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/SetFVCExpTime.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class SetFVCExpTime ( KPFFunction ): '''Set the exposure time of the specified fiber viewing camera Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) check_input ( args , 'exptime' , value_min = 0.005 , value_max = 60 ) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = args . get ( 'exptime' ) log . debug ( f \"Setting { camera } FVC exposure time to { exptime : .3f } s\" ) kpffvc [ f ' { camera } EXPTIME' ] . write ( exptime ) @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) tol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) expr = ( f '($kpffvc. { camera } EXPTIME > { exptime } - { tol } ) ' \\ f 'and ($kpffvc. { camera } EXPTIME < { exptime } + { tol } )' ) success = ktl . waitfor ( expr , timeout = timeout ) if success is not True : exptimekw = ktl . cache ( 'kpffvc' , f \" { camera } EXPTIME\" ) raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetFVCExpTime"},{"location":"scripts/SetFlatFieldFiberPos/","text":"SetFlatFieldFiberPos Bases: KPFFunction Description Set the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. Parameters: FF_FiberPos ( str ) \u2013 The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used kpfcal.FF_FIBERPOS Source code in kpf/calbench/SetFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetFlatFieldFiberPos ( KPFFunction ): '''# Description Set the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. Args: FF_FiberPos (str): The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used - `kpfcal.FF_FIBERPOS` ''' @classmethod def pre_condition ( cls , args ): FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) allowed_values = list ( FF_FIBERPOS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'FF_FiberPos' ) log . debug ( f \"Setting FF_FiberPos to { target } \" ) FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) FF_FIBERPOS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) if FF_FIBERPOS . waitFor ( f \"== ' { target } '\" , timeout = timeout ) is not True : raise FailedToReachDestination ( FF_FIBERPOS . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetFlatFieldFiberPos"},{"location":"scripts/SetFlatFieldFiberPos/#setflatfieldfiberpos","text":"Bases: KPFFunction","title":"SetFlatFieldFiberPos"},{"location":"scripts/SetFlatFieldFiberPos/#kpf.calbench.SetFlatFieldFiberPos.SetFlatFieldFiberPos--description","text":"Set the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. Parameters: FF_FiberPos ( str ) \u2013 The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used kpfcal.FF_FIBERPOS Source code in kpf/calbench/SetFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SetFlatFieldFiberPos ( KPFFunction ): '''# Description Set the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. Args: FF_FiberPos (str): The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used - `kpfcal.FF_FIBERPOS` ''' @classmethod def pre_condition ( cls , args ): FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) allowed_values = list ( FF_FIBERPOS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'FF_FiberPos' ) log . debug ( f \"Setting FF_FiberPos to { target } \" ) FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) FF_FIBERPOS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) FF_FIBERPOS = ktl . cache ( 'kpfcal' , 'FF_FIBERPOS' ) if FF_FIBERPOS . waitFor ( f \"== ' { target } '\" , timeout = timeout ) is not True : raise FailedToReachDestination ( FF_FIBERPOS . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"Description"},{"location":"scripts/SetGuiderExpTime/","text":"SetGuiderExpTime Bases: KPFFunction Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. Parameters: exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpfguide.EXPTIME Source code in kpf/guider/SetGuiderExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class SetGuiderExpTime ( KPFFunction ): '''Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. Args: exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpfguide.EXPTIME` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'exptime' , value_min = 0 ) @classmethod def perform ( cls , args ): exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptime = args . get ( 'exptime' ) exptimekw . write ( exptime ) @classmethod def post_condition ( cls , args ): exptol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptimeread = exptimekw . read ( binary = True ) exptime = args . get ( 'exptime' ) expr = ( f '($kpfguide.EXPTIME >= { exptime - exptol } ) and ' \\ f '($kpfguide.EXPTIME <= { exptime + exptol } )' ) success = ktl . waitFor ( expr , timeout = exptimeread + 1 ) if not success : raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderExpTime"},{"location":"scripts/SetGuiderExpTime/#setguiderexptime","text":"Bases: KPFFunction Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. Parameters: exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpfguide.EXPTIME Source code in kpf/guider/SetGuiderExpTime.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class SetGuiderExpTime ( KPFFunction ): '''Set the guider exposure time (in seconds) via the kpfguide.EXPTIME keyword. The guider exposure time is governed by several factors. The exposure time controlled here is generated by stacking (averaging) multiple frames as needed to obtain the specified exposure time. Those individual frames are controlled by the FPS, AVERAGE, STACK, and EXPTIME keywords. From Kyle: If you want to tweak an exposure setting, I recommend MAGIQ use the EXPTIME keyword as its preferred knob. This will translate to changing the number of frames averaged together. You can also choose to stack frames, but I doubt that will be necessary. Notice how EXPTIME remains unchanged when I change the STACK keyword: [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 100 frames STACK = 1 averaged frames EXPTIME = 1.000000 seconds [klanclos@kpffiuserver ~]$ modify -s kpfguide stack=2 setting stack = 2 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 50 frames STACK = 2 averaged frames EXPTIME = 1.000000 seconds ...but if I change AVERAGE, EXPTIME reflects the change: [klanclos@kpffiuserver ~]$ modify -s kpfguide average=20 setting average = 20 (wait) [klanclos@kpffiuserver ~]$ gshow -s kpfguide fps average stack exptime FPS = 100.0000 frames/second AVERAGE = 20 frames STACK = 1 averaged frames EXPTIME = 0.200000 seconds Stick to changing EXPTIME and you won't have to worry about it. Changing the frames per second is not recommended, because the tip/tilt system will be consuming this image stream, and it needs to retain full control of what an individual frame looks like. Args: exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpfguide.EXPTIME` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'exptime' , value_min = 0 ) @classmethod def perform ( cls , args ): exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptime = args . get ( 'exptime' ) exptimekw . write ( exptime ) @classmethod def post_condition ( cls , args ): exptol = cfg . getfloat ( 'tolerances' , 'guider_exptime_tolerance' , fallback = 0.01 ) exptimekw = ktl . cache ( 'kpfguide' , 'EXPTIME' ) exptimeread = exptimekw . read ( binary = True ) exptime = args . get ( 'exptime' ) expr = ( f '($kpfguide.EXPTIME >= { exptime - exptol } ) and ' \\ f '($kpfguide.EXPTIME <= { exptime + exptol } )' ) success = ktl . waitFor ( expr , timeout = exptimeread + 1 ) if not success : raise FailedToReachDestination ( exptimekw . read (), exptime ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderExpTime"},{"location":"scripts/SetGuiderFPS/","text":"SetGuiderFPS Bases: KPFFunction Set the guider FPS (frames per second) via the kpfguide.FPS keyword. Parameters: GuideFPS ( float ) \u2013 Number of frames per second. KTL Keywords Used: kpfguide.FPS Source code in kpf/guider/SetGuiderFPS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetGuiderFPS ( KPFFunction ): '''Set the guider FPS (frames per second) via the kpfguide.FPS keyword. Args: GuideFPS (float): Number of frames per second. KTL Keywords Used: - `kpfguide.FPS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideFPS' , value_min = 0.0001 , value_max = 400 ) return True @classmethod def perform ( cls , args ): fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) log . debug ( f 'Setting guider FPS to { fps } ' ) fpskw . write ( fps ) @classmethod def post_condition ( cls , args ): fpstol = cfg . getfloat ( 'tolerances' , 'guider_fps_tolerance' , fallback = 0.01 ) fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) expr = ( f '($kpfguide.FPS >= { fps - fpstol } ) and ' \\ f '($kpfguide.FPS <= { fps + fpstol } )' ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( fpskw . read (), fps ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideFPS' , type = float , help = 'The frames per second (FPS)' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderFPS"},{"location":"scripts/SetGuiderFPS/#setguiderfps","text":"Bases: KPFFunction Set the guider FPS (frames per second) via the kpfguide.FPS keyword. Parameters: GuideFPS ( float ) \u2013 Number of frames per second. KTL Keywords Used: kpfguide.FPS Source code in kpf/guider/SetGuiderFPS.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetGuiderFPS ( KPFFunction ): '''Set the guider FPS (frames per second) via the kpfguide.FPS keyword. Args: GuideFPS (float): Number of frames per second. KTL Keywords Used: - `kpfguide.FPS` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideFPS' , value_min = 0.0001 , value_max = 400 ) return True @classmethod def perform ( cls , args ): fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) log . debug ( f 'Setting guider FPS to { fps } ' ) fpskw . write ( fps ) @classmethod def post_condition ( cls , args ): fpstol = cfg . getfloat ( 'tolerances' , 'guider_fps_tolerance' , fallback = 0.01 ) fpskw = ktl . cache ( 'kpfguide' , 'FPS' ) fps = args . get ( 'GuideFPS' ) expr = ( f '($kpfguide.FPS >= { fps - fpstol } ) and ' \\ f '($kpfguide.FPS <= { fps + fpstol } )' ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( fpskw . read (), fps ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideFPS' , type = float , help = 'The frames per second (FPS)' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderFPS"},{"location":"scripts/SetGuiderGain/","text":"SetGuiderGain Bases: KPFFunction Set the guider gain via the kpfguide.GAIN keyword. Parameters: GuideCamGain ( str ) \u2013 The desired gain. Allowed values: high, medium, or low. KTL Keywords Used: kpfguide.GAIN Source code in kpf/guider/SetGuiderGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetGuiderGain ( KPFFunction ): '''Set the guider gain via the kpfguide.GAIN keyword. Args: GuideCamGain (str): The desired gain. Allowed values: high, medium, or low. KTL Keywords Used: - `kpfguide.GAIN` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideCamGain' , allowed_values = [ 'high' , 'medium' , 'low' ]) @classmethod def perform ( cls , args ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) log . debug ( f 'Setting guider gain to { gain } ' ) gainkw . write ( gain ) @classmethod def post_condition ( cls , args ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) expr = ( f \"($kpfguide.GAIN == ' { gain } ')\" ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( gainkw . read (), gain ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideCamGain' , type = str , choices = [ 'high' , 'medium' , 'low' ], help = 'The gain' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderGain"},{"location":"scripts/SetGuiderGain/#setguidergain","text":"Bases: KPFFunction Set the guider gain via the kpfguide.GAIN keyword. Parameters: GuideCamGain ( str ) \u2013 The desired gain. Allowed values: high, medium, or low. KTL Keywords Used: kpfguide.GAIN Source code in kpf/guider/SetGuiderGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetGuiderGain ( KPFFunction ): '''Set the guider gain via the kpfguide.GAIN keyword. Args: GuideCamGain (str): The desired gain. Allowed values: high, medium, or low. KTL Keywords Used: - `kpfguide.GAIN` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideCamGain' , allowed_values = [ 'high' , 'medium' , 'low' ]) @classmethod def perform ( cls , args ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) log . debug ( f 'Setting guider gain to { gain } ' ) gainkw . write ( gain ) @classmethod def post_condition ( cls , args ): gainkw = ktl . cache ( 'kpfguide' , 'GAIN' ) gain = args . get ( 'GuideCamGain' ) expr = ( f \"($kpfguide.GAIN == ' { gain } ')\" ) success = ktl . waitFor ( expr , timeout = 1 ) if not success : raise FailedToReachDestination ( gainkw . read (), gain ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideCamGain' , type = str , choices = [ 'high' , 'medium' , 'low' ], help = 'The gain' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderGain"},{"location":"scripts/SetGuiderOutdir/","text":"SetGuiderOutdir Bases: KPFFunction Set the value of the kpfguide.OUTDIR keyword Parameters: outdir ( str ) \u2013 The desired output path. KTL Keywords Used: kpfguide.OUTDIR Source code in kpf/guider/SetGuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SetGuiderOutdir ( KPFFunction ): '''Set the value of the kpfguide.OUTDIR keyword Args: outdir (str): The desired output path. KTL Keywords Used: - `kpfguide.OUTDIR` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'outdir' ) @classmethod def perform ( cls , args ): newoutdir = Path ( args . get ( 'outdir' )) . expanduser () . absolute () OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) OUTDIR . write ( f \" { newoutdir } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'outdir' , type = str , help = 'The desired output path' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderOutdir"},{"location":"scripts/SetGuiderOutdir/#setguideroutdir","text":"Bases: KPFFunction Set the value of the kpfguide.OUTDIR keyword Parameters: outdir ( str ) \u2013 The desired output path. KTL Keywords Used: kpfguide.OUTDIR Source code in kpf/guider/SetGuiderOutdir.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class SetGuiderOutdir ( KPFFunction ): '''Set the value of the kpfguide.OUTDIR keyword Args: outdir (str): The desired output path. KTL Keywords Used: - `kpfguide.OUTDIR` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'outdir' ) @classmethod def perform ( cls , args ): newoutdir = Path ( args . get ( 'outdir' )) . expanduser () . absolute () OUTDIR = ktl . cache ( 'kpfguide' , 'OUTDIR' ) OUTDIR . write ( f \" { newoutdir } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'outdir' , type = str , help = 'The desired output path' ) return super () . add_cmdline_args ( parser )","title":"SetGuiderOutdir"},{"location":"scripts/SetJunkStatus/","text":"SetJunkStatus Bases: KPFFunction Set the junk status of the specified exposure for the specified OB in the KPF-CC database. Parameters: id ( str ) \u2013 The unique identifier for the OB. start_time ( str ) \u2013 The start time of the exposure (in YYYY-mm-ddTHH:MM:SS.ss format) to mark. junk ( bool ) \u2013 Mark exposure as junk (True) or not junk (False). Source code in kpf/observatoryAPIs/SetJunkStatus.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetJunkStatus ( KPFFunction ): '''Set the junk status of the specified exposure for the specified OB in the KPF-CC database. Args: id (str): The unique identifier for the OB. start_time (str): The start time of the exposure (in YYYY-mm-ddTHH:MM:SS.ss format) to mark. junk (bool): Mark exposure as junk (True) or not junk (False). ''' @classmethod def pre_condition ( cls , args ): if args . get ( 'id' , None ) is None : raise FailedPreCondition ( 'id must be provided' ) if args . get ( 'start_time' , None ) is None : raise FailedPreCondition ( 'start_time must be provided' ) @classmethod def perform ( cls , args ): log . info ( f \"Running { cls . __name__ } \" ) log . debug ( args ) result = setKPFJunkValue ( args . get ( 'id' ), args . get ( 'start_time' ), junk = args . get ( 'junk' , False )) log . info ( f \"Response: { result } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'id' , type = str , help = 'The unique identifier for the OB.' ) parser . add_argument ( 'start_time' , type = str , help = 'The start_time of the exposure.' ) parser . add_argument ( '--junk' , dest = \"junk\" , default = False , action = \"store_true\" , help = 'Is this exposure junk?' ) return super () . add_cmdline_args ( parser )","title":"SetJunkStatus"},{"location":"scripts/SetJunkStatus/#setjunkstatus","text":"Bases: KPFFunction Set the junk status of the specified exposure for the specified OB in the KPF-CC database. Parameters: id ( str ) \u2013 The unique identifier for the OB. start_time ( str ) \u2013 The start time of the exposure (in YYYY-mm-ddTHH:MM:SS.ss format) to mark. junk ( bool ) \u2013 Mark exposure as junk (True) or not junk (False). Source code in kpf/observatoryAPIs/SetJunkStatus.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class SetJunkStatus ( KPFFunction ): '''Set the junk status of the specified exposure for the specified OB in the KPF-CC database. Args: id (str): The unique identifier for the OB. start_time (str): The start time of the exposure (in YYYY-mm-ddTHH:MM:SS.ss format) to mark. junk (bool): Mark exposure as junk (True) or not junk (False). ''' @classmethod def pre_condition ( cls , args ): if args . get ( 'id' , None ) is None : raise FailedPreCondition ( 'id must be provided' ) if args . get ( 'start_time' , None ) is None : raise FailedPreCondition ( 'start_time must be provided' ) @classmethod def perform ( cls , args ): log . info ( f \"Running { cls . __name__ } \" ) log . debug ( args ) result = setKPFJunkValue ( args . get ( 'id' ), args . get ( 'start_time' ), junk = args . get ( 'junk' , False )) log . info ( f \"Response: { result } \" ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'id' , type = str , help = 'The unique identifier for the OB.' ) parser . add_argument ( 'start_time' , type = str , help = 'The start_time of the exposure.' ) parser . add_argument ( '--junk' , dest = \"junk\" , default = False , action = \"store_true\" , help = 'Is this exposure junk?' ) return super () . add_cmdline_args ( parser )","title":"SetJunkStatus"},{"location":"scripts/SetLFCtoAstroComb/","text":"SetLFCtoAstroComb Bases: KPFFunction Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. KTL Keywords Used: kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA Functions Called: kpf.calbench.WaitForLFCReady Source code in kpf/calbench/SetLFCtoAstroComb.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetLFCtoAstroComb ( KPFFunction ): '''Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. KTL Keywords Used: - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` Functions Called: - `kpf.calbench.WaitForLFCReady` ''' @classmethod def pre_condition ( cls , args ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) hb_success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if hb_success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) . read () if lfc_mode not in [ 'AstroComb' , 'StandbyHigh' ]: raise FailedPreCondition ( f \"LFC must be in AstroComb or StandbyHigh: { lfc_mode } \" ) @classmethod def perform ( cls , args ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to AstroComb' ) lfc_mode . write ( 'AstroComb' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): success = WaitForLFCReady . execute ({}) if success is not True : raise FailedPostCondition ( 'LFC did not reach expected state' )","title":"SetLFCtoAstroComb"},{"location":"scripts/SetLFCtoAstroComb/#setlfctoastrocomb","text":"Bases: KPFFunction Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. KTL Keywords Used: kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA Functions Called: kpf.calbench.WaitForLFCReady Source code in kpf/calbench/SetLFCtoAstroComb.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetLFCtoAstroComb ( KPFFunction ): '''Set the Laser Frequency Comb (LFC) to \"AstroComb\" mode. This should be used during operation of the LFC. KTL Keywords Used: - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` Functions Called: - `kpf.calbench.WaitForLFCReady` ''' @classmethod def pre_condition ( cls , args ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) hb_success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if hb_success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) . read () if lfc_mode not in [ 'AstroComb' , 'StandbyHigh' ]: raise FailedPreCondition ( f \"LFC must be in AstroComb or StandbyHigh: { lfc_mode } \" ) @classmethod def perform ( cls , args ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to AstroComb' ) lfc_mode . write ( 'AstroComb' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): success = WaitForLFCReady . execute ({}) if success is not True : raise FailedPostCondition ( 'LFC did not reach expected state' )","title":"SetLFCtoAstroComb"},{"location":"scripts/SetLFCtoStandbyHigh/","text":"SetLFCtoStandbyHigh Bases: KPFFunction Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. KTL Keywords Used: kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA Source code in kpf/calbench/SetLFCtoStandbyHigh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetLFCtoStandbyHigh ( KPFFunction ): '''Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. KTL Keywords Used: - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` ''' @classmethod def pre_condition ( cls , args ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) . read () if lfc_mode not in [ 'AstroComb' , 'StandbyHigh' ]: raise FailedPreCondition ( f \"LFC must be in AstroComb: { lfc_mode } \" ) @classmethod def perform ( cls , args ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to StandbyHigh' ) lfc_mode . write ( 'StandbyHigh' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): pass","title":"SetLFCtoStandbyHigh"},{"location":"scripts/SetLFCtoStandbyHigh/#setlfctostandbyhigh","text":"Bases: KPFFunction Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. KTL Keywords Used: kpfcal.OPERATIONMODE kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA Source code in kpf/calbench/SetLFCtoStandbyHigh.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetLFCtoStandbyHigh ( KPFFunction ): '''Set the Laser Frequency Comb (LFC) to \"StandbyHigh\" mode. This is the mode which should be set after operation of the LFC for science is complete. KTL Keywords Used: - `kpfcal.OPERATIONMODE` - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` ''' @classmethod def pre_condition ( cls , args ): heartbeat = ktl . cache ( 'kpfmon' , 'HB_MENLOSTA' ) success = heartbeat . waitFor ( '== \"OK\"' , timeout = 3 ) if success is False : raise FailedPreCondition ( f \"Menlo heartbeat is not OK: { heartbeat . read () } \" ) lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) . read () if lfc_mode not in [ 'AstroComb' , 'StandbyHigh' ]: raise FailedPreCondition ( f \"LFC must be in AstroComb: { lfc_mode } \" ) @classmethod def perform ( cls , args ): lfc_mode = ktl . cache ( 'kpfcal' , 'OPERATIONMODE' ) log . info ( 'Setting LFC to StandbyHigh' ) lfc_mode . write ( 'StandbyHigh' ) time_shim = cfg . getfloat ( 'times' , 'LFC_shim_time' , fallback = 10 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): pass","title":"SetLFCtoStandbyHigh"},{"location":"scripts/SetMasterBiasToDefault/","text":"SetMasterBiasToDefault Bases: KPFFunction Sets the master bias file for the exposure meter to the default value KTL Keywords Used: kpf_expmeter.BIAS_FILE Source code in kpf/expmeter/SetMasterBiasToDefault.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class SetMasterBiasToDefault ( KPFFunction ): '''Sets the master bias file for the exposure meter to the default value KTL Keywords Used: - `kpf_expmeter.BIAS_FILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): BIAS_FILE = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) default_file = '/kroot/rel/default/data/kpf_expmeter/full_bias.fits' log . debug ( f \"Setting master bias file to { default_file } \" ) BIAS_FILE . write ( default_file ) @classmethod def post_condition ( cls , args ): pass","title":"SetMasterBiasToDefault"},{"location":"scripts/SetMasterBiasToDefault/#setmasterbiastodefault","text":"Bases: KPFFunction Sets the master bias file for the exposure meter to the default value KTL Keywords Used: kpf_expmeter.BIAS_FILE Source code in kpf/expmeter/SetMasterBiasToDefault.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class SetMasterBiasToDefault ( KPFFunction ): '''Sets the master bias file for the exposure meter to the default value KTL Keywords Used: - `kpf_expmeter.BIAS_FILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): BIAS_FILE = ktl . cache ( 'kpf_expmeter' , 'BIAS_FILE' ) default_file = '/kroot/rel/default/data/kpf_expmeter/full_bias.fits' log . debug ( f \"Setting master bias file to { default_file } \" ) BIAS_FILE . write ( default_file ) @classmethod def post_condition ( cls , args ): pass","title":"SetMasterBiasToDefault"},{"location":"scripts/SetND/","text":"SetND Bases: KPFFunction Set the filter in the ND1 & ND2 filter wheels via the kpfcal.ND1POS and kpfcal.ND2POS keywords. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True Functions Called: kpf.calbench.SetND1 kpf.calbench.SetND2 Source code in kpf/calbench/SetND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class SetND ( KPFFunction ): '''Set the filter in the ND1 & ND2 filter wheels via the `kpfcal.ND1POS` and `kpfcal.ND2POS` keywords. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` wait (bool): Wait for move to complete before returning? default: True Functions Called: - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): SetND1 . execute ( args ) SetND2 . execute ( args ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND"},{"location":"scripts/SetND/#setnd","text":"Bases: KPFFunction Set the filter in the ND1 & ND2 filter wheels via the kpfcal.ND1POS and kpfcal.ND2POS keywords. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True Functions Called: kpf.calbench.SetND1 kpf.calbench.SetND2 Source code in kpf/calbench/SetND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class SetND ( KPFFunction ): '''Set the filter in the ND1 & ND2 filter wheels via the `kpfcal.ND1POS` and `kpfcal.ND2POS` keywords. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` wait (bool): Wait for move to complete before returning? default: True Functions Called: - `kpf.calbench.SetND1` - `kpf.calbench.SetND2` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): SetND1 . execute ( args ) SetND2 . execute ( args ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND"},{"location":"scripts/SetND1/","text":"SetND1 Bases: KPFFunction Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used: kpfcal.ND1POS Source code in kpf/calbench/SetND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetND1 ( KPFFunction ): '''Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used: - `kpfcal.ND1POS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND1' ) log . debug ( f \"Setting ND1POS to { target } \" ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) ND1POS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND1"},{"location":"scripts/SetND1/#setnd1","text":"Bases: KPFFunction Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used: kpfcal.ND1POS Source code in kpf/calbench/SetND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class SetND1 ( KPFFunction ): '''Set the filter in the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used: - `kpfcal.ND1POS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND1' ) log . debug ( f \"Setting ND1POS to { target } \" ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) ND1POS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND1"},{"location":"scripts/SetND2/","text":"SetND2 Bases: KPFFunction Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. Parameters: CalND2 ( str ) \u2013 The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 1.0 , OD 1.3 , OD 2.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used: kpfcal.ND2POS Source code in kpf/calbench/SetND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class SetND2 ( KPFFunction ): '''Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. Args: CalND2 (str): The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 1.0`, `OD 1.3`, `OD 2.0` wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used: - `kpfcal.ND2POS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND2' ) log . debug ( f \"Setting ND2POS to { target } \" ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) ND2POS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND2"},{"location":"scripts/SetND2/#setnd2","text":"Bases: KPFFunction Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. Parameters: CalND2 ( str ) \u2013 The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 1.0 , OD 1.3 , OD 2.0 wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used: kpfcal.ND2POS Source code in kpf/calbench/SetND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class SetND2 ( KPFFunction ): '''Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. Args: CalND2 (str): The neutral density filter to put in the second filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 1.0`, `OD 1.3`, `OD 2.0` wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used: - `kpfcal.ND2POS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND2' ) log . debug ( f \"Setting ND2POS to { target } \" ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) ND2POS . write ( target , wait = args . get ( 'wait' , True )) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send move and return immediately?\" ) return super () . add_cmdline_args ( parser )","title":"SetND2"},{"location":"scripts/SetObject/","text":"SetObject Bases: KPFFunction Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. Parameters: Object ( str ) \u2013 The desired object keyword value. KTL Keywords Used: kpfexpose.OBJECT Source code in kpf/spectrograph/SetObject.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class SetObject ( KPFFunction ): '''Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. Args: Object (str): The desired object keyword value. KTL Keywords Used: - `kpfexpose.OBJECT` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBJECT = ktl . cache ( 'kpfexpose' , 'OBJECT' ) obj = args . get ( 'Object' , '' ) if obj is None : obj = '' log . debug ( f \"Setting OBJECT to ' { obj } '\" ) OBJECT . write ( obj ) @classmethod def post_condition ( cls , args ): obj = args . get ( 'Object' , '' ) if obj is None : obj = '' timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) OBJECT = ktl . cache ( 'kpfexpose' , 'OBJECT' ) if OBJECT . waitFor ( f \"== ' { obj } '\" , timeout = timeout ) is not True : raise FailedToReachDestination ( OBJECT . read (), obj ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Object' , type = str , help = 'The OBJECT keyword' ) return super () . add_cmdline_args ( parser )","title":"SetObject"},{"location":"scripts/SetObject/#setobject","text":"Bases: KPFFunction Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. Parameters: Object ( str ) \u2013 The desired object keyword value. KTL Keywords Used: kpfexpose.OBJECT Source code in kpf/spectrograph/SetObject.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class SetObject ( KPFFunction ): '''Sets the OBJECT keyword for the science detectors in the kpfexpose keyword service. Args: Object (str): The desired object keyword value. KTL Keywords Used: - `kpfexpose.OBJECT` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBJECT = ktl . cache ( 'kpfexpose' , 'OBJECT' ) obj = args . get ( 'Object' , '' ) if obj is None : obj = '' log . debug ( f \"Setting OBJECT to ' { obj } '\" ) OBJECT . write ( obj ) @classmethod def post_condition ( cls , args ): obj = args . get ( 'Object' , '' ) if obj is None : obj = '' timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) OBJECT = ktl . cache ( 'kpfexpose' , 'OBJECT' ) if OBJECT . waitFor ( f \"== ' { obj } '\" , timeout = timeout ) is not True : raise FailedToReachDestination ( OBJECT . read (), obj ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'Object' , type = str , help = 'The OBJECT keyword' ) return super () . add_cmdline_args ( parser )","title":"SetObject"},{"location":"scripts/SetObserver/","text":"SetObserver Bases: KPFFunction Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. Parameters: observer ( str ) \u2013 The desired value of the OBSERVER keyword. KTL Keywords Used: kpfexpose.OBSERVER Source code in kpf/spectrograph/SetObserver.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetObserver ( KPFFunction ): '''Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. Args: observer (str): The desired value of the OBSERVER keyword. KTL Keywords Used: - `kpfexpose.OBSERVER` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'observer' ) @classmethod def perform ( cls , args ): OBSERVER = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) log . info ( f \"Setting OBSERVER to { args . get ( 'observer' ) } \" ) OBSERVER . write ( args . get ( 'observer' )) @classmethod def post_condition ( cls , args ): observerval = args . get ( 'observer' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) OBSERVER = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) if OBSERVER . waitFor ( f '== \" { observerval } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( OBSERVER . read (), observerval ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'observer' , type = str , help = 'The OBSERVER keyword' ) return super () . add_cmdline_args ( parser )","title":"SetObserver"},{"location":"scripts/SetObserver/#setobserver","text":"Bases: KPFFunction Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. Parameters: observer ( str ) \u2013 The desired value of the OBSERVER keyword. KTL Keywords Used: kpfexpose.OBSERVER Source code in kpf/spectrograph/SetObserver.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetObserver ( KPFFunction ): '''Sets the OBSERVER keyword for the science detectors in the kpfexpose keyword service. Args: observer (str): The desired value of the OBSERVER keyword. KTL Keywords Used: - `kpfexpose.OBSERVER` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'observer' ) @classmethod def perform ( cls , args ): OBSERVER = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) log . info ( f \"Setting OBSERVER to { args . get ( 'observer' ) } \" ) OBSERVER . write ( args . get ( 'observer' )) @classmethod def post_condition ( cls , args ): observerval = args . get ( 'observer' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) OBSERVER = ktl . cache ( 'kpfexpose' , 'OBSERVER' ) if OBSERVER . waitFor ( f '== \" { observerval } \"' , timeout = timeout ) is not True : raise FailedToReachDestination ( OBSERVER . read (), observerval ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'observer' , type = str , help = 'The OBSERVER keyword' ) return super () . add_cmdline_args ( parser )","title":"SetObserver"},{"location":"scripts/SetObserverFromSchedule/","text":"SetObserverFromSchedule Bases: KPFFunction Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. Parameters: progname ( str ) \u2013 The program name to set if a choice is needed. Functions Called: kpf.spectrograph.SetObserver kpf.spectrograph.SetProgram kpf.observatoryAPIs.GetScheduledPrograms Source code in kpf/utils/SetObserverFromSchedule.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class SetObserverFromSchedule ( KPFFunction ): '''Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. Args: progname (str): The program name to set if a choice is needed. Functions Called: - `kpf.spectrograph.SetObserver` - `kpf.spectrograph.SetProgram` - `kpf.observatoryAPIs.GetScheduledPrograms` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): classical , cadence = GetScheduledPrograms . execute ({ 'semester' : 'tonight' }) KPF_programs = classical + cadence nKPFprograms = len ( KPF_programs ) project_codes = [ p [ 'ProjCode' ] for p in KPF_programs ] print () print ( f \"########################################\" ) print ( f \" Found { nKPFprograms } KPF programs scheduled for tonight:\" ) for project_code in project_codes : print ( f \" { project_code } \" ) print ( f \" Please enter the program ID for your observations:\" ) print ( f \"########################################\" ) print () progname = input () if progname . strip () not in project_codes : log . warning ( f \"Project code { progname } not on schedule\" ) # Set the program if progname is None : time . sleep ( 0.5 ) # try time shim for log line print () print ( f \" Please enter the program ID for your observations:\" ) print () progname = input () if progname == '' : log . info ( 'No progname specified' ) else : SetProgram . execute ({ 'progname' : progname }) # Set Observers this_program = [ p for p in KPF_programs if p [ 'ProjCode' ] == progname ] if len ( this_program ) > 0 : observers = this_program [ 0 ][ 'Observers' ] else : print () print ( f \" Please enter the observer names:\" ) print () observers = input () log . info ( f \"Setting observer list: { observers } \" ) SetObserver . execute ({ 'observer' : observers }) @classmethod def post_condition ( cls , args ): pass","title":"SetObserverFromSchedule"},{"location":"scripts/SetObserverFromSchedule/#setobserverfromschedule","text":"Bases: KPFFunction Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. Parameters: progname ( str ) \u2013 The program name to set if a choice is needed. Functions Called: kpf.spectrograph.SetObserver kpf.spectrograph.SetProgram kpf.observatoryAPIs.GetScheduledPrograms Source code in kpf/utils/SetObserverFromSchedule.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class SetObserverFromSchedule ( KPFFunction ): '''Look up the telescope schedule and try to determine the observer names based on the current date and the scheduled programs. If only one KPF program is on the schedule, the script will use that to set the observer names. If multiple programs are on the schedule, it will use the progname input (see below) or query the user if no progname is given. Args: progname (str): The program name to set if a choice is needed. Functions Called: - `kpf.spectrograph.SetObserver` - `kpf.spectrograph.SetProgram` - `kpf.observatoryAPIs.GetScheduledPrograms` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): classical , cadence = GetScheduledPrograms . execute ({ 'semester' : 'tonight' }) KPF_programs = classical + cadence nKPFprograms = len ( KPF_programs ) project_codes = [ p [ 'ProjCode' ] for p in KPF_programs ] print () print ( f \"########################################\" ) print ( f \" Found { nKPFprograms } KPF programs scheduled for tonight:\" ) for project_code in project_codes : print ( f \" { project_code } \" ) print ( f \" Please enter the program ID for your observations:\" ) print ( f \"########################################\" ) print () progname = input () if progname . strip () not in project_codes : log . warning ( f \"Project code { progname } not on schedule\" ) # Set the program if progname is None : time . sleep ( 0.5 ) # try time shim for log line print () print ( f \" Please enter the program ID for your observations:\" ) print () progname = input () if progname == '' : log . info ( 'No progname specified' ) else : SetProgram . execute ({ 'progname' : progname }) # Set Observers this_program = [ p for p in KPF_programs if p [ 'ProjCode' ] == progname ] if len ( this_program ) > 0 : observers = this_program [ 0 ][ 'Observers' ] else : print () print ( f \" Please enter the observer names:\" ) print () observers = input () log . info ( f \"Setting observer list: { observers } \" ) SetObserver . execute ({ 'observer' : observers }) @classmethod def post_condition ( cls , args ): pass","title":"SetObserverFromSchedule"},{"location":"scripts/SetOutdirs/","text":"SetOutdirs Bases: KPFFunction Set output directories for all detectors based on the current date. Source code in kpf/utils/SetOutdirs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class SetOutdirs ( KPFFunction ): '''Set output directories for all detectors based on the current date. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( f \"SetOutdirs invoked\" ) utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) magiq_outdir = Path ( f \"/s/sdata1701/kpfguide/ { date_str } \" ) log . debug ( f \"base outdir: { outdir } \" ) log . debug ( f \"magiq outdir: { magiq_outdir } \" ) if args . get ( 'CRED2' , True ) is True : log . info ( f \" Guider OUTDIR = { magiq_outdir } \" ) guide_outdir = ktl . cache ( 'kpfguide' , 'OUTDIR' ) try : guide_outdir . write ( f \" { magiq_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting guider outdir\" ) log . error ( e ) log . info ( f \" Guider TRIGOUTDIR = { outdir / 'CRED2' } \" ) trig_outdir = ktl . cache ( 'kpfguide' , 'TRIGOUTDIR' ) try : trig_outdir . write ( f \" { outdir / 'CRED2' } \" ) except Exception as e : log . error ( f \"ERROR setting guider TRIGOUTDIR\" ) log . error ( e ) kpffvc = ktl . cache ( 'kpffvc' ) if args . get ( 'FVC1' , False ) is True : log . info ( f \" FVC1 OUTDIR = { outdir / 'FVC1' } \" ) try : kpffvc [ 'SCIOUTDIR' ] . write ( f \" { outdir / 'FVC1' } \" ) except Exception as e : log . error ( f \"ERROR setting SCI FVC outdir\" ) log . error ( e ) if args . get ( 'FVC2' , False ) is True : log . info ( f \" FVC2 OUTDIR = { outdir / 'FVC2' } \" ) try : kpffvc [ 'CAHKOUTDIR' ] . write ( f \" { outdir / 'FVC2' } \" ) except Exception as e : log . error ( f \"ERROR setting CAHK FVC outdir\" ) log . error ( e ) if args . get ( 'FVC3' , False ) is True : log . info ( f \" FVC3 OUTDIR = { outdir / 'FVC3' } \" ) try : kpffvc [ 'CALOUTDIR' ] . write ( f \" { outdir / 'FVC3' } \" ) except Exception as e : log . error ( f \"ERROR setting CAL FVC outdir\" ) log . error ( e ) if args . get ( 'FVC4' , False ) is True : log . info ( f \" FVC4 OUTDIR = { outdir / 'FVC4' } \" ) try : kpffvc [ 'EXTOUTDIR' ] . write ( f \" { outdir / 'FVC4' } \" ) except Exception as e : log . error ( f \"ERROR setting EXT FVC outdir\" ) log . error ( e ) if args . get ( 'ExpMeter' , True ) is True : expmeter_outdir = outdir / 'ExpMeter' log . info ( f \" ExpMeter DATADIR = { expmeter_outdir } \" ) kpf_expmeter_outdir = ktl . cache ( 'kpf_expmeter' , 'DATADIR' ) try : kpf_expmeter_outdir . write ( f \" { expmeter_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting ExpMeter outdir\" ) log . error ( e ) if args . get ( 'CaHK' , True ) is True : cahk_outdir = outdir / 'CaHK' log . info ( f \" CaHK RECORDDIR = { cahk_outdir } \" ) kpf_hk_outdir = ktl . cache ( 'kpf_hk' , 'RECORDDIR' ) try : kpf_hk_outdir . write ( f \" { cahk_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting CaHK outdir\" ) log . error ( e ) if args . get ( 'Green' , True ) is True : green_outdir = outdir / 'Green' log . info ( f \" Green FITSDIR = { green_outdir } \" ) kpfgreen_outdir = ktl . cache ( 'kpfgreen' , 'FITSDIR' ) try : kpfgreen_outdir . write ( f \" { green_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Green outdir\" ) log . error ( e ) if args . get ( 'Red' , True ) is True : red_outdir = outdir / 'Red' log . info ( f \" Red FITSDIR = { red_outdir } \" ) kpfred_outdir = ktl . cache ( 'kpfred' , 'FITSDIR' ) try : kpfred_outdir . write ( f \" { red_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Red outdir\" ) log . error ( e ) if args . get ( 'L0' , True ) is True : L0_outdir = outdir / 'L0' log . info ( f \" kpfasemble OUTDIR = { L0_outdir } \" ) kpfassemble_outdir = ktl . cache ( 'kpfassemble' , 'OUTDIR' ) try : kpfassemble_outdir . write ( f \" { L0_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting kpfasemble outdir\" ) log . error ( e ) @classmethod def post_condition ( cls , args ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) tests = [] if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.OUTDIR == '/s/sdata1701/kpfguide'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.TRIGOUTDIR == ' { outdir } /CRED2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC1' , False ) is True : expr = f \"$kpffvc.SCIOUTDIR == ' { outdir } /FVC1'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC2' , False ) is True : expr = f \"$kpffvc.CAHKOUTDIR == ' { outdir } /FVC2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC3' , False ) is True : expr = f \"$kpffvc.CALOUTDIR == ' { outdir } /FVC3'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC4' , False ) is True : expr = f \"$kpffvc.EXTOUTDIR == ' { outdir } /FVC4'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'ExpMeter' , True ) is True : expr = f \"$kpf_expmeter.DATADIR == ' { outdir } /ExpMeter'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CaHK' , True ) is True : expr = f \"$kpf_hk.RECORDDIR == ' { outdir } /CaHK'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Green' , True ) is True : expr = f \"$kpfgreen.FITSDIR == ' { outdir } /Green'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Red' , True ) is True : expr = f \"$kpfred.FITSDIR == ' { outdir } /Red'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'L0' , True ) is True : expr = f \"$kpfassemble.OUTDIR == ' { outdir } /L0'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) return np . all ( np . array ( tests ))","title":"SetOutdirs"},{"location":"scripts/SetOutdirs/#setoutdirs","text":"Bases: KPFFunction Set output directories for all detectors based on the current date. Source code in kpf/utils/SetOutdirs.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 class SetOutdirs ( KPFFunction ): '''Set output directories for all detectors based on the current date. ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( f \"SetOutdirs invoked\" ) utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) magiq_outdir = Path ( f \"/s/sdata1701/kpfguide/ { date_str } \" ) log . debug ( f \"base outdir: { outdir } \" ) log . debug ( f \"magiq outdir: { magiq_outdir } \" ) if args . get ( 'CRED2' , True ) is True : log . info ( f \" Guider OUTDIR = { magiq_outdir } \" ) guide_outdir = ktl . cache ( 'kpfguide' , 'OUTDIR' ) try : guide_outdir . write ( f \" { magiq_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting guider outdir\" ) log . error ( e ) log . info ( f \" Guider TRIGOUTDIR = { outdir / 'CRED2' } \" ) trig_outdir = ktl . cache ( 'kpfguide' , 'TRIGOUTDIR' ) try : trig_outdir . write ( f \" { outdir / 'CRED2' } \" ) except Exception as e : log . error ( f \"ERROR setting guider TRIGOUTDIR\" ) log . error ( e ) kpffvc = ktl . cache ( 'kpffvc' ) if args . get ( 'FVC1' , False ) is True : log . info ( f \" FVC1 OUTDIR = { outdir / 'FVC1' } \" ) try : kpffvc [ 'SCIOUTDIR' ] . write ( f \" { outdir / 'FVC1' } \" ) except Exception as e : log . error ( f \"ERROR setting SCI FVC outdir\" ) log . error ( e ) if args . get ( 'FVC2' , False ) is True : log . info ( f \" FVC2 OUTDIR = { outdir / 'FVC2' } \" ) try : kpffvc [ 'CAHKOUTDIR' ] . write ( f \" { outdir / 'FVC2' } \" ) except Exception as e : log . error ( f \"ERROR setting CAHK FVC outdir\" ) log . error ( e ) if args . get ( 'FVC3' , False ) is True : log . info ( f \" FVC3 OUTDIR = { outdir / 'FVC3' } \" ) try : kpffvc [ 'CALOUTDIR' ] . write ( f \" { outdir / 'FVC3' } \" ) except Exception as e : log . error ( f \"ERROR setting CAL FVC outdir\" ) log . error ( e ) if args . get ( 'FVC4' , False ) is True : log . info ( f \" FVC4 OUTDIR = { outdir / 'FVC4' } \" ) try : kpffvc [ 'EXTOUTDIR' ] . write ( f \" { outdir / 'FVC4' } \" ) except Exception as e : log . error ( f \"ERROR setting EXT FVC outdir\" ) log . error ( e ) if args . get ( 'ExpMeter' , True ) is True : expmeter_outdir = outdir / 'ExpMeter' log . info ( f \" ExpMeter DATADIR = { expmeter_outdir } \" ) kpf_expmeter_outdir = ktl . cache ( 'kpf_expmeter' , 'DATADIR' ) try : kpf_expmeter_outdir . write ( f \" { expmeter_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting ExpMeter outdir\" ) log . error ( e ) if args . get ( 'CaHK' , True ) is True : cahk_outdir = outdir / 'CaHK' log . info ( f \" CaHK RECORDDIR = { cahk_outdir } \" ) kpf_hk_outdir = ktl . cache ( 'kpf_hk' , 'RECORDDIR' ) try : kpf_hk_outdir . write ( f \" { cahk_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting CaHK outdir\" ) log . error ( e ) if args . get ( 'Green' , True ) is True : green_outdir = outdir / 'Green' log . info ( f \" Green FITSDIR = { green_outdir } \" ) kpfgreen_outdir = ktl . cache ( 'kpfgreen' , 'FITSDIR' ) try : kpfgreen_outdir . write ( f \" { green_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Green outdir\" ) log . error ( e ) if args . get ( 'Red' , True ) is True : red_outdir = outdir / 'Red' log . info ( f \" Red FITSDIR = { red_outdir } \" ) kpfred_outdir = ktl . cache ( 'kpfred' , 'FITSDIR' ) try : kpfred_outdir . write ( f \" { red_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting Red outdir\" ) log . error ( e ) if args . get ( 'L0' , True ) is True : L0_outdir = outdir / 'L0' log . info ( f \" kpfasemble OUTDIR = { L0_outdir } \" ) kpfassemble_outdir = ktl . cache ( 'kpfassemble' , 'OUTDIR' ) try : kpfassemble_outdir . write ( f \" { L0_outdir } \" ) except Exception as e : log . error ( f \"ERROR setting kpfasemble outdir\" ) log . error ( e ) @classmethod def post_condition ( cls , args ): utnow = datetime . utcnow () date = utnow - timedelta ( days = 1 ) date_str = date . strftime ( '%Y%b %d ' ) . lower () outdir = Path ( f \"/s/sdata1701/ { os . getlogin () } / { date_str } \" ) tests = [] if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.OUTDIR == '/s/sdata1701/kpfguide'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CRED2' , True ) is True : expr = f \"$kpfguide.TRIGOUTDIR == ' { outdir } /CRED2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC1' , False ) is True : expr = f \"$kpffvc.SCIOUTDIR == ' { outdir } /FVC1'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC2' , False ) is True : expr = f \"$kpffvc.CAHKOUTDIR == ' { outdir } /FVC2'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC3' , False ) is True : expr = f \"$kpffvc.CALOUTDIR == ' { outdir } /FVC3'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'FVC4' , False ) is True : expr = f \"$kpffvc.EXTOUTDIR == ' { outdir } /FVC4'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'ExpMeter' , True ) is True : expr = f \"$kpf_expmeter.DATADIR == ' { outdir } /ExpMeter'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'CaHK' , True ) is True : expr = f \"$kpf_hk.RECORDDIR == ' { outdir } /CaHK'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Green' , True ) is True : expr = f \"$kpfgreen.FITSDIR == ' { outdir } /Green'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'Red' , True ) is True : expr = f \"$kpfred.FITSDIR == ' { outdir } /Red'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) if args . get ( 'L0' , True ) is True : expr = f \"$kpfassemble.OUTDIR == ' { outdir } /L0'\" success = ktl . waitFor ( expr , timeout = 5 ) tests . append ( success ) return np . all ( np . array ( tests ))","title":"SetOutdirs"},{"location":"scripts/SetProgram/","text":"SetProgram Bases: KPFFunction Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. Parameters: progname ( str ) \u2013 The program ID to set. KTL Keywords Used: kpfexpose.PROGNAME Source code in kpf/spectrograph/SetProgram.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetProgram ( KPFFunction ): '''Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. Args: progname (str): The program ID to set. KTL Keywords Used: - `kpfexpose.PROGNAME` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'progname' ) @classmethod def perform ( cls , args ): PROGNAME = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) prognameval = args . get ( 'progname' ) log . debug ( 'Waiting for kpfexpose to be ready' ) WaitForReady . execute ({}) log . info ( f \"Setting PROGNAME to ' { prognameval } '\" ) PROGNAME . write ( prognameval ) @classmethod def post_condition ( cls , args ): PROGNAME = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) prognameval = args . get ( 'progname' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) if PROGNAME . waitFor ( f \"== ' { prognameval } '\" , timeout = timeout ) != True : raise FailedToReachDestination ( PROGNAME . read (), prognameval ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'progname' , type = str , help = 'The PROGNAME keyword' ) return super () . add_cmdline_args ( parser )","title":"SetProgram"},{"location":"scripts/SetProgram/#setprogram","text":"Bases: KPFFunction Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. Parameters: progname ( str ) \u2013 The program ID to set. KTL Keywords Used: kpfexpose.PROGNAME Source code in kpf/spectrograph/SetProgram.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class SetProgram ( KPFFunction ): '''Sets the PROGNAME keyword for the science detectors in the kpfexpose keyword service. Args: progname (str): The program ID to set. KTL Keywords Used: - `kpfexpose.PROGNAME` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'progname' ) @classmethod def perform ( cls , args ): PROGNAME = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) prognameval = args . get ( 'progname' ) log . debug ( 'Waiting for kpfexpose to be ready' ) WaitForReady . execute ({}) log . info ( f \"Setting PROGNAME to ' { prognameval } '\" ) PROGNAME . write ( prognameval ) @classmethod def post_condition ( cls , args ): PROGNAME = ktl . cache ( 'kpfexpose' , 'PROGNAME' ) prognameval = args . get ( 'progname' ) timeout = cfg . getfloat ( 'times' , 'kpfexpose_response_time' , fallback = 1 ) if PROGNAME . waitFor ( f \"== ' { prognameval } '\" , timeout = timeout ) != True : raise FailedToReachDestination ( PROGNAME . read (), prognameval ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'progname' , type = str , help = 'The PROGNAME keyword' ) return super () . add_cmdline_args ( parser )","title":"SetProgram"},{"location":"scripts/SetReadModeFast/","text":"SetReadModeFast Bases: KPFFunction Configure both detectors to fast read mode by changing the ACF files they are using. KTL Keywords Used: kpfgreen.ACFFILE kpfgreen.ACF kpfred.ACFFILE kpfred.ACF Functions Called: kpf.spectrograph.QueryReadMode kpf.utils.SendEmail Source code in kpf/spectrograph/SetReadModeFast.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class SetReadModeFast ( KPFFunction ): '''Configure both detectors to fast read mode by changing the ACF files they are using. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfgreen.ACF` - `kpfred.ACFFILE` - `kpfred.ACF` Functions Called: - `kpf.spectrograph.QueryReadMode` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != 'fast' : msg = f 'Setting Green CCD read mode fast' log . info ( msg ) # Email to kpf_info # try: # SendEmail.execute({'Subject': msg, 'Message': msg}) # except Exception as email_err: # log.error(f'Sending email failed') # log.error(email_err) # kpfgreen = ktl.cache('kpfgreen') # green_fast_file = cfg.get('acf_files', 'green_fast') # green_ACFFILE = Path(kpfgreen['ACFFILE'].read()).stem # if green_ACFFILE != green_fast_file: # kpfgreen['ACF'].write(green_fast_file) if red_mode != 'fast' : msg = f 'Setting Red CCD read mode fast' log . info ( msg ) # Email to kpf_info # try: # SendEmail.execute({'Subject': msg, 'Message': msg}) # except Exception as email_err: # log.error(f'Sending email failed') # log.error(email_err) # kpfred = ktl.cache('kpfred') # red_fast_file = cfg.get('acf_files', 'red_fast') # red_ACFFILE = Path(kpfred['ACFFILE'].read()).stem # if red_ACFFILE != red_fast_file: # kpfred['ACF'].write(red_fast_file) @classmethod def post_condition ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != \"fast\" : raise FailedToReachDestination ( green_mode , \"fast\" ) if red_mode != \"fast\" : raise FailedToReachDestination ( red_mode , \"fast\" )","title":"SetReadModeFast"},{"location":"scripts/SetReadModeFast/#setreadmodefast","text":"Bases: KPFFunction Configure both detectors to fast read mode by changing the ACF files they are using. KTL Keywords Used: kpfgreen.ACFFILE kpfgreen.ACF kpfred.ACFFILE kpfred.ACF Functions Called: kpf.spectrograph.QueryReadMode kpf.utils.SendEmail Source code in kpf/spectrograph/SetReadModeFast.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class SetReadModeFast ( KPFFunction ): '''Configure both detectors to fast read mode by changing the ACF files they are using. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfgreen.ACF` - `kpfred.ACFFILE` - `kpfred.ACF` Functions Called: - `kpf.spectrograph.QueryReadMode` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != 'fast' : msg = f 'Setting Green CCD read mode fast' log . info ( msg ) # Email to kpf_info # try: # SendEmail.execute({'Subject': msg, 'Message': msg}) # except Exception as email_err: # log.error(f'Sending email failed') # log.error(email_err) # kpfgreen = ktl.cache('kpfgreen') # green_fast_file = cfg.get('acf_files', 'green_fast') # green_ACFFILE = Path(kpfgreen['ACFFILE'].read()).stem # if green_ACFFILE != green_fast_file: # kpfgreen['ACF'].write(green_fast_file) if red_mode != 'fast' : msg = f 'Setting Red CCD read mode fast' log . info ( msg ) # Email to kpf_info # try: # SendEmail.execute({'Subject': msg, 'Message': msg}) # except Exception as email_err: # log.error(f'Sending email failed') # log.error(email_err) # kpfred = ktl.cache('kpfred') # red_fast_file = cfg.get('acf_files', 'red_fast') # red_ACFFILE = Path(kpfred['ACFFILE'].read()).stem # if red_ACFFILE != red_fast_file: # kpfred['ACF'].write(red_fast_file) @classmethod def post_condition ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != \"fast\" : raise FailedToReachDestination ( green_mode , \"fast\" ) if red_mode != \"fast\" : raise FailedToReachDestination ( red_mode , \"fast\" )","title":"SetReadModeFast"},{"location":"scripts/SetReadModeNormal/","text":"SetReadModeNormal Bases: KPFFunction Configure both detectors to normal read mode by changing the ACF files they are using. KTL Keywords Used: kpfgreen.ACFFILE kpfgreen.ACF kpfred.ACFFILE kpfred.ACF Functions Called: kpf.spectrograph.QueryReadMode kpf.utils.SendEmail Source code in kpf/spectrograph/SetReadModeNormal.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SetReadModeNormal ( KPFFunction ): '''Configure both detectors to normal read mode by changing the ACF files they are using. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfgreen.ACF` - `kpfred.ACFFILE` - `kpfred.ACF` Functions Called: - `kpf.spectrograph.QueryReadMode` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != 'normal' : msg = f 'Setting Green CCD read mode normal' log . info ( msg ) # Email to kpf_info try : SendEmail . execute ({ 'Subject' : msg , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) kpfgreen = ktl . cache ( 'kpfgreen' ) green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) green_ACFFILE = Path ( kpfgreen [ 'ACFFILE' ] . read ()) . stem if green_ACFFILE != green_normal_file : kpfgreen [ 'ACF' ] . write ( green_normal_file ) time . sleep ( 1 ) if red_mode != 'normal' : msg = f 'Setting Red CCD read mode normal' log . info ( msg ) # Email to kpf_info try : SendEmail . execute ({ 'Subject' : msg , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) kpfred = ktl . cache ( 'kpfred' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) red_ACFFILE = Path ( kpfred [ 'ACFFILE' ] . read ()) . stem if red_ACFFILE != red_normal_file : kpfred [ 'ACF' ] . write ( red_normal_file ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != \"normal\" : raise FailedToReachDestination ( green_mode , \"normal\" ) if red_mode != \"normal\" : raise FailedToReachDestination ( red_mode , \"normal\" )","title":"SetReadModeNormal"},{"location":"scripts/SetReadModeNormal/#setreadmodenormal","text":"Bases: KPFFunction Configure both detectors to normal read mode by changing the ACF files they are using. KTL Keywords Used: kpfgreen.ACFFILE kpfgreen.ACF kpfred.ACFFILE kpfred.ACF Functions Called: kpf.spectrograph.QueryReadMode kpf.utils.SendEmail Source code in kpf/spectrograph/SetReadModeNormal.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SetReadModeNormal ( KPFFunction ): '''Configure both detectors to normal read mode by changing the ACF files they are using. KTL Keywords Used: - `kpfgreen.ACFFILE` - `kpfgreen.ACF` - `kpfred.ACFFILE` - `kpfred.ACF` Functions Called: - `kpf.spectrograph.QueryReadMode` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != 'normal' : msg = f 'Setting Green CCD read mode normal' log . info ( msg ) # Email to kpf_info try : SendEmail . execute ({ 'Subject' : msg , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) kpfgreen = ktl . cache ( 'kpfgreen' ) green_normal_file = cfg . get ( 'acf_files' , 'green_normal' ) green_ACFFILE = Path ( kpfgreen [ 'ACFFILE' ] . read ()) . stem if green_ACFFILE != green_normal_file : kpfgreen [ 'ACF' ] . write ( green_normal_file ) time . sleep ( 1 ) if red_mode != 'normal' : msg = f 'Setting Red CCD read mode normal' log . info ( msg ) # Email to kpf_info try : SendEmail . execute ({ 'Subject' : msg , 'Message' : msg }) except Exception as email_err : log . error ( f 'Sending email failed' ) log . error ( email_err ) kpfred = ktl . cache ( 'kpfred' ) red_normal_file = cfg . get ( 'acf_files' , 'red_normal' ) red_ACFFILE = Path ( kpfred [ 'ACFFILE' ] . read ()) . stem if red_ACFFILE != red_normal_file : kpfred [ 'ACF' ] . write ( red_normal_file ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args ): green_mode , red_mode = QueryReadMode . execute ({}) if green_mode != \"normal\" : raise FailedToReachDestination ( green_mode , \"normal\" ) if red_mode != \"normal\" : raise FailedToReachDestination ( red_mode , \"normal\" )","title":"SetReadModeNormal"},{"location":"scripts/SetSimulCalSource/","text":"SetSimulCalSource Bases: KPFFunction Set the simultaneous calibration source based on the kpfconfig.SIMULCALSOURCE keyword. KTL Keywords Used: kpfconfig.SIMULCALSOURCE kpfcal.OCTAGON Functions Called: kpf.calbench.SetCalSource Source code in kpf/calbench/SetSimulCalSource.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetSimulCalSource ( KPFFunction ): '''Set the simultaneous calibration source based on the kpfconfig.SIMULCALSOURCE keyword. KTL Keywords Used: - `kpfconfig.SIMULCALSOURCE` - `kpfcal.OCTAGON` Functions Called: - `kpf.calbench.SetCalSource` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): calsource = ktl . cache ( 'kpfconfig' , 'SIMULCALSOURCE' ) . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) @classmethod def post_condition ( cls , args ): pass","title":"SetSimulCalSource"},{"location":"scripts/SetSimulCalSource/#setsimulcalsource","text":"Bases: KPFFunction Set the simultaneous calibration source based on the kpfconfig.SIMULCALSOURCE keyword. KTL Keywords Used: kpfconfig.SIMULCALSOURCE kpfcal.OCTAGON Functions Called: kpf.calbench.SetCalSource Source code in kpf/calbench/SetSimulCalSource.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SetSimulCalSource ( KPFFunction ): '''Set the simultaneous calibration source based on the kpfconfig.SIMULCALSOURCE keyword. KTL Keywords Used: - `kpfconfig.SIMULCALSOURCE` - `kpfcal.OCTAGON` Functions Called: - `kpf.calbench.SetCalSource` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): calsource = ktl . cache ( 'kpfconfig' , 'SIMULCALSOURCE' ) . read () octagon = ktl . cache ( 'kpfcal' , 'OCTAGON' ) . read () log . debug ( f \"Current OCTAGON = { octagon } , desired = { calsource } \" ) if octagon != calsource : log . info ( f \"Set CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : False }) @classmethod def post_condition ( cls , args ): pass","title":"SetSimulCalSource"},{"location":"scripts/SetSourceSelectShutters/","text":"SetSourceSelectShutters Bases: KPFFunction Opens and closes the source select shutters via the kpfexpose.SRC_SHUTTERS keyword. Parameters: OpenScienceShutter ( bool ) \u2013 Open the SciSelect shutter? (default=False) OpenSkyShutter ( bool ) \u2013 Open the SkySelect shutter? (default=False) OpenCalSciSkyShutter ( bool ) \u2013 Open the Cal_SciSky shutter? (default=False) OpenSoCalSciShutter ( bool ) \u2013 Open the SoCalSci shutter? (default=False) OpenSoCalCalShutter ( bool ) \u2013 Open the SoCalCal shutter? (default=False) KTL Keywords Used: kpfexpose.SRC_SHUTTERS Source code in kpf/spectrograph/SetSourceSelectShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class SetSourceSelectShutters ( KPFFunction ): '''Opens and closes the source select shutters via the `kpfexpose.SRC_SHUTTERS` keyword. Args: OpenScienceShutter (bool): Open the SciSelect shutter? (default=False) OpenSkyShutter (bool): Open the SkySelect shutter? (default=False) OpenCalSciSkyShutter (bool): Open the Cal_SciSky shutter? (default=False) OpenSoCalSciShutter (bool): Open the SoCalSci shutter? (default=False) OpenSoCalCalShutter (bool): Open the SoCalCal shutter? (default=False) KTL Keywords Used: - `kpfexpose.SRC_SHUTTERS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): shutter_list = [] if args . get ( 'OpenScienceShutter' , False ) is True : shutter_list . append ( 'SciSelect' ) if args . get ( 'OpenSkyShutter' , False ) is True : shutter_list . append ( 'SkySelect' ) if args . get ( 'OpenSoCalSciShutter' , False ) is True : shutter_list . append ( 'SoCalSci' ) if args . get ( 'OpenSoCalCalShutter' , False ) is True : shutter_list . append ( 'SoCalCal' ) if args . get ( 'OpenCalSciSkyShutter' , False ) is True : shutter_list . append ( 'Cal_SciSky' ) shutters_string = ',' . join ( shutter_list ) log . debug ( f \"Setting source select shutters to ' { shutters_string } '\" ) SRC_SHUTTERS = ktl . cache ( 'kpfexpose' , 'SRC_SHUTTERS' ) SRC_SHUTTERS . write ( shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args ): SRC_SHUTTERS = ktl . cache ( 'kpfexpose' , 'SRC_SHUTTERS' ) SRC_SHUTTERS . monitor () shutter_names = [( 'SciSelect' , 'OpenScienceShutter' ), ( 'SkySelect' , 'OpenSkyShutter' ), ( 'SoCalSci' , 'OpenSoCalSciShutter' ), ( 'SoCalCal' , 'OpenSoCalCalShutter' ), ( 'Cal_SciSky' , 'OpenCalSciSkyShutter' )] shutter_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( shutter_tests ) != True and total_time < 0.25 : shutter_tests = [] for shutter in shutter_names : if args . get ( shutter [ 1 ], False ) is True : shutter_tests . append ( shutter [ 0 ] in SRC_SHUTTERS . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( shutter_tests ) != True : raise FailedToReachDestination ( SRC_SHUTTERS . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , dest = \"OpenScienceShutter\" , default = False , action = \"store_true\" , help = \"Open the SciSelect shutter?\" ) parser . add_argument ( \"--Sky\" , \"--sky\" , dest = \"OpenSkyShutter\" , default = False , action = \"store_true\" , help = \"Open the SkySelect shutter?\" ) parser . add_argument ( \"--CalSciSky\" , dest = \"OpenCalSciSkyShutter\" , default = False , action = \"store_true\" , help = \"Open the Cal_SciSky shutter?\" ) parser . add_argument ( \"--SoCalSci\" , dest = \"OpenSoCalSciShutter\" , default = False , action = \"store_true\" , help = \"Open the SoCalSci shutter?\" ) parser . add_argument ( \"--SoCalCal\" , dest = \"OpenSoCalCalShutter\" , default = False , action = \"store_true\" , help = \"Open the SoCalCal shutter?\" ) return super () . add_cmdline_args ( parser )","title":"SetSourceSelectShutters"},{"location":"scripts/SetSourceSelectShutters/#setsourceselectshutters","text":"Bases: KPFFunction Opens and closes the source select shutters via the kpfexpose.SRC_SHUTTERS keyword. Parameters: OpenScienceShutter ( bool ) \u2013 Open the SciSelect shutter? (default=False) OpenSkyShutter ( bool ) \u2013 Open the SkySelect shutter? (default=False) OpenCalSciSkyShutter ( bool ) \u2013 Open the Cal_SciSky shutter? (default=False) OpenSoCalSciShutter ( bool ) \u2013 Open the SoCalSci shutter? (default=False) OpenSoCalCalShutter ( bool ) \u2013 Open the SoCalCal shutter? (default=False) KTL Keywords Used: kpfexpose.SRC_SHUTTERS Source code in kpf/spectrograph/SetSourceSelectShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class SetSourceSelectShutters ( KPFFunction ): '''Opens and closes the source select shutters via the `kpfexpose.SRC_SHUTTERS` keyword. Args: OpenScienceShutter (bool): Open the SciSelect shutter? (default=False) OpenSkyShutter (bool): Open the SkySelect shutter? (default=False) OpenCalSciSkyShutter (bool): Open the Cal_SciSky shutter? (default=False) OpenSoCalSciShutter (bool): Open the SoCalSci shutter? (default=False) OpenSoCalCalShutter (bool): Open the SoCalCal shutter? (default=False) KTL Keywords Used: - `kpfexpose.SRC_SHUTTERS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): shutter_list = [] if args . get ( 'OpenScienceShutter' , False ) is True : shutter_list . append ( 'SciSelect' ) if args . get ( 'OpenSkyShutter' , False ) is True : shutter_list . append ( 'SkySelect' ) if args . get ( 'OpenSoCalSciShutter' , False ) is True : shutter_list . append ( 'SoCalSci' ) if args . get ( 'OpenSoCalCalShutter' , False ) is True : shutter_list . append ( 'SoCalCal' ) if args . get ( 'OpenCalSciSkyShutter' , False ) is True : shutter_list . append ( 'Cal_SciSky' ) shutters_string = ',' . join ( shutter_list ) log . debug ( f \"Setting source select shutters to ' { shutters_string } '\" ) SRC_SHUTTERS = ktl . cache ( 'kpfexpose' , 'SRC_SHUTTERS' ) SRC_SHUTTERS . write ( shutters_string ) shim_time = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) sleep ( shim_time ) @classmethod def post_condition ( cls , args ): SRC_SHUTTERS = ktl . cache ( 'kpfexpose' , 'SRC_SHUTTERS' ) SRC_SHUTTERS . monitor () shutter_names = [( 'SciSelect' , 'OpenScienceShutter' ), ( 'SkySelect' , 'OpenSkyShutter' ), ( 'SoCalSci' , 'OpenSoCalSciShutter' ), ( 'SoCalCal' , 'OpenSoCalCalShutter' ), ( 'Cal_SciSky' , 'OpenCalSciSkyShutter' )] shutter_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( shutter_tests ) != True and total_time < 0.25 : shutter_tests = [] for shutter in shutter_names : if args . get ( shutter [ 1 ], False ) is True : shutter_tests . append ( shutter [ 0 ] in SRC_SHUTTERS . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( shutter_tests ) != True : raise FailedToReachDestination ( SRC_SHUTTERS . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Science\" , \"--Sci\" , \"--science\" , \"--sci\" , dest = \"OpenScienceShutter\" , default = False , action = \"store_true\" , help = \"Open the SciSelect shutter?\" ) parser . add_argument ( \"--Sky\" , \"--sky\" , dest = \"OpenSkyShutter\" , default = False , action = \"store_true\" , help = \"Open the SkySelect shutter?\" ) parser . add_argument ( \"--CalSciSky\" , dest = \"OpenCalSciSkyShutter\" , default = False , action = \"store_true\" , help = \"Open the Cal_SciSky shutter?\" ) parser . add_argument ( \"--SoCalSci\" , dest = \"OpenSoCalSciShutter\" , default = False , action = \"store_true\" , help = \"Open the SoCalSci shutter?\" ) parser . add_argument ( \"--SoCalCal\" , dest = \"OpenSoCalCalShutter\" , default = False , action = \"store_true\" , help = \"Open the SoCalCal shutter?\" ) return super () . add_cmdline_args ( parser )","title":"SetSourceSelectShutters"},{"location":"scripts/SetTargetList/","text":"SetTargetList Bases: KPFFunction Given a list of OBs, generate a Keck Star List and send to MAGIQ. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: StarList ( str ) \u2013 The full star list to submit. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/SetTargetList.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetTargetList ( KPFFunction ): '''Given a list of OBs, generate a Keck Star List and send to MAGIQ. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: StarList (str): The full star list to submit. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): star_list_string = args . get ( 'StarList' ) params = { 'targetlist' : star_list_string } nlines = len ( args . get ( 'StarList' ) . split ( ' \\n ' )) log . info ( f 'Running Magiq setTargetList command with { nlines } lines' ) log . debug ( star_list_string ) result = magiq_server_command ( 'setTargetlist' , params = params , post = True ) @classmethod def post_condition ( cls , args ): pass","title":"SetTargetList"},{"location":"scripts/SetTargetList/#settargetlist","text":"Bases: KPFFunction Given a list of OBs, generate a Keck Star List and send to MAGIQ. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Parameters: StarList ( str ) \u2013 The full star list to submit. Functions Called: kpf.observatoryAPIs.GetTelescopeRelease Source code in kpf/magiq/SetTargetList.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class SetTargetList ( KPFFunction ): '''Given a list of OBs, generate a Keck Star List and send to MAGIQ. MAGIQ API documentation: http://suwebserver01.keck.hawaii.edu/magiqStatus/magiqServer.php Args: StarList (str): The full star list to submit. Functions Called: - `kpf.observatoryAPIs.GetTelescopeRelease` ''' @classmethod def pre_condition ( cls , args ): if not KPF_is_selected_instrument (): raise KPFException ( 'KPF is not selected instrument' ) if not GetTelescopeRelease . execute ({}): raise KPFException ( 'Telescope is not released' ) @classmethod def perform ( cls , args ): star_list_string = args . get ( 'StarList' ) params = { 'targetlist' : star_list_string } nlines = len ( args . get ( 'StarList' ) . split ( ' \\n ' )) log . info ( f 'Running Magiq setTargetList command with { nlines } lines' ) log . debug ( star_list_string ) result = magiq_server_command ( 'setTargetlist' , params = params , post = True ) @classmethod def post_condition ( cls , args ): pass","title":"SetTargetList"},{"location":"scripts/SetTimedShutters/","text":"SetTimedShutters Bases: KPFFunction Selects which timed shutters will be triggered by setting the kpfexpose.TIMED_SHUTTERS keyword value. Parameters: TimedShutter_Scrambler ( bool ) \u2013 Open the TimedShutter_Scrambler shutter? (default=False) TimedShutter_SimulCal ( bool ) \u2013 Open the TimedShutter_SimulCal shutter? (default=False) TimedShutter_CaHK ( bool ) \u2013 Open the TimedShutter_CaHK shutter? (default=False) TimedShutter_FlatField ( bool ) \u2013 Open the TimedShutter_FlatField shutter? (default=False) KTL Keywords Used: kpfexpose.TIMED_TARG Source code in kpf/spectrograph/SetTimedShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class SetTimedShutters ( KPFFunction ): '''Selects which timed shutters will be triggered by setting the `kpfexpose.TIMED_SHUTTERS` keyword value. Args: TimedShutter_Scrambler (bool): Open the TimedShutter_Scrambler shutter? (default=False) TimedShutter_SimulCal (bool): Open the TimedShutter_SimulCal shutter? (default=False) TimedShutter_CaHK (bool): Open the TimedShutter_CaHK shutter? (default=False) TimedShutter_FlatField (bool): Open the TimedShutter_FlatField shutter? (default=False) KTL Keywords Used: - `kpfexpose.TIMED_TARG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Scrambler 2 SimulCal 3 FF_Fiber 4 Ca_HK timed_shutters_list = [] if args . get ( 'TimedShutter_Scrambler' , False ) is True : timed_shutters_list . append ( 'Scrambler' ) if args . get ( 'TimedShutter_SimulCal' , False ) is True : timed_shutters_list . append ( 'SimulCal' ) if args . get ( 'TimedShutter_FlatField' , False ) is True : timed_shutters_list . append ( 'FF_Fiber' ) if args . get ( 'TimedShutter_CaHK' , False ) is True : timed_shutters_list . append ( 'Ca_HK' ) timed_shutters_string = ',' . join ( timed_shutters_list ) log . debug ( f \"Setting timed shutters to ' { timed_shutters_string } '\" ) TIMED_TARG = ktl . cache ( 'kpfexpose' , 'TIMED_TARG' ) TIMED_TARG . write ( timed_shutters_string ) @classmethod def post_condition ( cls , args ): TIMED_TARG = ktl . cache ( 'kpfexpose' , 'TIMED_TARG' ) TIMED_TARG . monitor () shutter_names = [( 'Scrambler' , 'TimedShutter_Scrambler' ), ( 'SimulCal' , 'TimedShutter_SimulCal' ), ( 'FF_Fiber' , 'TimedShutter_FlatField' ), ( 'Ca_HK' , 'TimedShutter_CaHK' )] shutter_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( shutter_tests ) != True and total_time < 0.25 : shutter_tests = [] for shutter in shutter_names : if args . get ( shutter [ 1 ], False ) is True : shutter_tests . append ( shutter [ 0 ] in TIMED_TARG . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( shutter_tests ) != True : raise FailedToReachDestination ( TIMED_TARG . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Scrambler\" , \"--scrambler\" , dest = \"TimedShutter_Scrambler\" , default = False , action = \"store_true\" , help = \"Open the Scrambler Timed Shutter during exposure?\" ) parser . add_argument ( \"--SimulCal\" , \"--simulcal\" , dest = \"TimedShutter_SimulCal\" , default = False , action = \"store_true\" , help = \"Open the SimulCal Timed Shutter during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TimedShutter_CaHK\" , default = False , action = \"store_true\" , help = \"Open the CaHK Timed Shutter during exposure?\" ) parser . add_argument ( \"--FlatField\" , \"--flatfield\" , dest = \"TimedShutter_FlatField\" , default = False , action = \"store_true\" , help = \"Open the FlatField Timed Shutter during exposure?\" ) return super () . add_cmdline_args ( parser )","title":"SetTimedShutters"},{"location":"scripts/SetTimedShutters/#settimedshutters","text":"Bases: KPFFunction Selects which timed shutters will be triggered by setting the kpfexpose.TIMED_SHUTTERS keyword value. Parameters: TimedShutter_Scrambler ( bool ) \u2013 Open the TimedShutter_Scrambler shutter? (default=False) TimedShutter_SimulCal ( bool ) \u2013 Open the TimedShutter_SimulCal shutter? (default=False) TimedShutter_CaHK ( bool ) \u2013 Open the TimedShutter_CaHK shutter? (default=False) TimedShutter_FlatField ( bool ) \u2013 Open the TimedShutter_FlatField shutter? (default=False) KTL Keywords Used: kpfexpose.TIMED_TARG Source code in kpf/spectrograph/SetTimedShutters.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class SetTimedShutters ( KPFFunction ): '''Selects which timed shutters will be triggered by setting the `kpfexpose.TIMED_SHUTTERS` keyword value. Args: TimedShutter_Scrambler (bool): Open the TimedShutter_Scrambler shutter? (default=False) TimedShutter_SimulCal (bool): Open the TimedShutter_SimulCal shutter? (default=False) TimedShutter_CaHK (bool): Open the TimedShutter_CaHK shutter? (default=False) TimedShutter_FlatField (bool): Open the TimedShutter_FlatField shutter? (default=False) KTL Keywords Used: - `kpfexpose.TIMED_TARG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Scrambler 2 SimulCal 3 FF_Fiber 4 Ca_HK timed_shutters_list = [] if args . get ( 'TimedShutter_Scrambler' , False ) is True : timed_shutters_list . append ( 'Scrambler' ) if args . get ( 'TimedShutter_SimulCal' , False ) is True : timed_shutters_list . append ( 'SimulCal' ) if args . get ( 'TimedShutter_FlatField' , False ) is True : timed_shutters_list . append ( 'FF_Fiber' ) if args . get ( 'TimedShutter_CaHK' , False ) is True : timed_shutters_list . append ( 'Ca_HK' ) timed_shutters_string = ',' . join ( timed_shutters_list ) log . debug ( f \"Setting timed shutters to ' { timed_shutters_string } '\" ) TIMED_TARG = ktl . cache ( 'kpfexpose' , 'TIMED_TARG' ) TIMED_TARG . write ( timed_shutters_string ) @classmethod def post_condition ( cls , args ): TIMED_TARG = ktl . cache ( 'kpfexpose' , 'TIMED_TARG' ) TIMED_TARG . monitor () shutter_names = [( 'Scrambler' , 'TimedShutter_Scrambler' ), ( 'SimulCal' , 'TimedShutter_SimulCal' ), ( 'FF_Fiber' , 'TimedShutter_FlatField' ), ( 'Ca_HK' , 'TimedShutter_CaHK' )] shutter_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( shutter_tests ) != True and total_time < 0.25 : shutter_tests = [] for shutter in shutter_names : if args . get ( shutter [ 1 ], False ) is True : shutter_tests . append ( shutter [ 0 ] in TIMED_TARG . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( shutter_tests ) != True : raise FailedToReachDestination ( TIMED_TARG . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Scrambler\" , \"--scrambler\" , dest = \"TimedShutter_Scrambler\" , default = False , action = \"store_true\" , help = \"Open the Scrambler Timed Shutter during exposure?\" ) parser . add_argument ( \"--SimulCal\" , \"--simulcal\" , dest = \"TimedShutter_SimulCal\" , default = False , action = \"store_true\" , help = \"Open the SimulCal Timed Shutter during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TimedShutter_CaHK\" , default = False , action = \"store_true\" , help = \"Open the CaHK Timed Shutter during exposure?\" ) parser . add_argument ( \"--FlatField\" , \"--flatfield\" , dest = \"TimedShutter_FlatField\" , default = False , action = \"store_true\" , help = \"Open the FlatField Timed Shutter during exposure?\" ) return super () . add_cmdline_args ( parser )","title":"SetTimedShutters"},{"location":"scripts/SetTipTiltCalculations/","text":"SetTipTiltCalculations Bases: KPFFunction Turn the tip tilt calculation software on or off. Parameters: calculations ( str ) \u2013 The desired state of the calculations. Allowed values: Active or Inactive KTL Keywords Used: kpfguide.TIPTILT_CALC Source code in kpf/fiu/SetTipTiltCalculations.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetTipTiltCalculations ( KPFFunction ): '''Turn the tip tilt calculation software on or off. Args: calculations (str): The desired state of the calculations. Allowed values: Active or Inactive KTL Keywords Used: - `kpfguide.TIPTILT_CALC` ''' @classmethod def pre_condition ( cls , args ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'calculations' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): calculations = args . get ( 'calculations' ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) TIPTILT_CALC . write ( calculations ) @classmethod def post_condition ( cls , args ): calculations = args . get ( 'calculations' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CALC == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) raise FailedToReachDestination ( TIPTILT_CALC . read (), calculations ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'calculations' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Calulations \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltCalculations"},{"location":"scripts/SetTipTiltCalculations/#settiptiltcalculations","text":"Bases: KPFFunction Turn the tip tilt calculation software on or off. Parameters: calculations ( str ) \u2013 The desired state of the calculations. Allowed values: Active or Inactive KTL Keywords Used: kpfguide.TIPTILT_CALC Source code in kpf/fiu/SetTipTiltCalculations.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetTipTiltCalculations ( KPFFunction ): '''Turn the tip tilt calculation software on or off. Args: calculations (str): The desired state of the calculations. Allowed values: Active or Inactive KTL Keywords Used: - `kpfguide.TIPTILT_CALC` ''' @classmethod def pre_condition ( cls , args ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'calculations' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): calculations = args . get ( 'calculations' ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) TIPTILT_CALC . write ( calculations ) @classmethod def post_condition ( cls , args ): calculations = args . get ( 'calculations' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CALC == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) raise FailedToReachDestination ( TIPTILT_CALC . read (), calculations ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'calculations' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Calulations \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltCalculations"},{"location":"scripts/SetTipTiltControl/","text":"SetTipTiltControl Bases: KPFFunction Turn the tip tilt control software on or off. Parameters: control ( str ) \u2013 The desired state of the control. Allowed values: Active or Inactive KTL Keywords Used: kpfguide.TIPTILT_CONTROL Source code in kpf/fiu/SetTipTiltControl.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetTipTiltControl ( KPFFunction ): '''Turn the tip tilt control software on or off. Args: control (str): The desired state of the control. Allowed values: Active or Inactive KTL Keywords Used: - `kpfguide.TIPTILT_CONTROL` ''' @classmethod def pre_condition ( cls , args ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'control' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): control = args . get ( 'control' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) TIPTILT_CONTROL . write ( control ) @classmethod def post_condition ( cls , args ): control = args . get ( 'control' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CONTROL == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) raise FailedToReachDestination ( TIPTILT_CONTROL . read (), control ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'control' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Control \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltControl"},{"location":"scripts/SetTipTiltControl/#settiptiltcontrol","text":"Bases: KPFFunction Turn the tip tilt control software on or off. Parameters: control ( str ) \u2013 The desired state of the control. Allowed values: Active or Inactive KTL Keywords Used: kpfguide.TIPTILT_CONTROL Source code in kpf/fiu/SetTipTiltControl.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class SetTipTiltControl ( KPFFunction ): '''Turn the tip tilt control software on or off. Args: control (str): The desired state of the control. Allowed values: Active or Inactive KTL Keywords Used: - `kpfguide.TIPTILT_CONTROL` ''' @classmethod def pre_condition ( cls , args ): allowed_values = [ 'Active' , 'Inactive' , '1' , '0' , 1 , 0 ] check_input ( args , 'control' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): control = args . get ( 'control' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) TIPTILT_CONTROL . write ( control ) @classmethod def post_condition ( cls , args ): control = args . get ( 'control' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) expr = f \"($kpfguide.TIPTILT_CONTROL == { calculations } ) \" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) raise FailedToReachDestination ( TIPTILT_CONTROL . read (), control ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'control' , type = str , choices = [ 'Active' , 'Inactive' ], help = 'Control \"Active\" or \"Inactive\"' ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltControl"},{"location":"scripts/SetTipTiltGain/","text":"SetTipTiltGain Bases: KPFFunction Set the guide loop gain. Parameters: GuideLoopGain ( float ) \u2013 The desired gain value. KTL Keywords Used: kpfguide.TIPTILT_GAIN Source code in kpf/fiu/SetTipTiltGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetTipTiltGain ( KPFFunction ): '''Set the guide loop gain. Args: GuideLoopGain (float): The desired gain value. KTL Keywords Used: - `kpfguide.TIPTILT_GAIN` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideLoopGain' , value_min = 0 , value_max = 1 ) @classmethod def perform ( cls , args ): gain = float ( args . get ( 'GuideLoopGain' )) TIPTILT_GAIN = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) TIPTILT_GAIN . write ( gain ) @classmethod def post_condition ( cls , args ): gain = float ( args . get ( 'GuideLoopGain' )) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_gain_tolerance' , fallback = 0.001 ) expr = ( f \"($kpfguide.TIPTILT_GAIN >= { gain - tol } ) and \" f \"($kpfguide.TIPTILT_GAIN <= { gain + tol } )\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_GAIN = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) raise FailedToReachDestination ( TIPTILT_GAIN . read (), gain ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideLoopGain' , type = float , help = \"Tip tilt control loop gain\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltGain"},{"location":"scripts/SetTipTiltGain/#settiptiltgain","text":"Bases: KPFFunction Set the guide loop gain. Parameters: GuideLoopGain ( float ) \u2013 The desired gain value. KTL Keywords Used: kpfguide.TIPTILT_GAIN Source code in kpf/fiu/SetTipTiltGain.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class SetTipTiltGain ( KPFFunction ): '''Set the guide loop gain. Args: GuideLoopGain (float): The desired gain value. KTL Keywords Used: - `kpfguide.TIPTILT_GAIN` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'GuideLoopGain' , value_min = 0 , value_max = 1 ) @classmethod def perform ( cls , args ): gain = float ( args . get ( 'GuideLoopGain' )) TIPTILT_GAIN = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) TIPTILT_GAIN . write ( gain ) @classmethod def post_condition ( cls , args ): gain = float ( args . get ( 'GuideLoopGain' )) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_gain_tolerance' , fallback = 0.001 ) expr = ( f \"($kpfguide.TIPTILT_GAIN >= { gain - tol } ) and \" f \"($kpfguide.TIPTILT_GAIN <= { gain + tol } )\" ) success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : TIPTILT_GAIN = ktl . cache ( 'kpfguide' , 'TIPTILT_GAIN' ) raise FailedToReachDestination ( TIPTILT_GAIN . read (), gain ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'GuideLoopGain' , type = float , help = \"Tip tilt control loop gain\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltGain"},{"location":"scripts/SetTipTiltPosition/","text":"SetTipTiltPosition Bases: KPFFunction Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the kpf.fiu.SetTipTiltTargetPixel translator module function. Parameters: x ( float ) \u2013 The desired X position (TTXVAX). y ( float ) \u2013 The desired Y position (TTYVAX). KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX Source code in kpf/fiu/SetTipTiltPosition.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class SetTipTiltPosition ( KPFFunction ): '''Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the `kpf.fiu.SetTipTiltTargetPixel` translator module function. Args: x (float): The desired X position (TTXVAX). y (float): The desired Y position (TTYVAX). KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'x' ) check_input ( args , 'y' ) @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'TTXVAX' ] . write ( args . get ( 'x' )) kpffiu [ 'TTYVAX' ] . write ( args . get ( 'y' )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) xdest = args . get ( 'x' ) ydest = args . get ( 'y' ) expr = ( f '($kpffiu.TTXVAX > { xdest - tol } ) and ' \\ f '($kpffiu.TTXVAX < { xdest + tol } )' ) successx = ktl . waitFor ( expr , timeout = timeout ) if successx is not True : raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), xdest ) expr = ( f '($kpffiu.TTYVAX > { ydest - tol } ) and ' \\ f '($kpffiu.TTYVAX < { ydest + tol } )' ) successy = ktl . waitFor ( expr , timeout = timeout ) if successy is not True : raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), ydest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'x' , type = float , help = \"X position of the tip tilt mirror (TTXVAX)\" ) parser . add_argument ( 'y' , type = float , help = \"X position of the tip tilt mirror (TTYVAX)\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltPosition"},{"location":"scripts/SetTipTiltPosition/#settiptiltposition","text":"Bases: KPFFunction Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the kpf.fiu.SetTipTiltTargetPixel translator module function. Parameters: x ( float ) \u2013 The desired X position (TTXVAX). y ( float ) \u2013 The desired Y position (TTYVAX). KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX Source code in kpf/fiu/SetTipTiltPosition.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class SetTipTiltPosition ( KPFFunction ): '''Set the position of the tip tilt mirror. This should only be used in an engineering context. To control the position of a star, set the CURRENT_BASE or PIX_TARGET keywords as appropriate, e.g. via the `kpf.fiu.SetTipTiltTargetPixel` translator module function. Args: x (float): The desired X position (TTXVAX). y (float): The desired Y position (TTYVAX). KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'x' ) check_input ( args , 'y' ) @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'TTXVAX' ] . write ( args . get ( 'x' )) kpffiu [ 'TTYVAX' ] . write ( args . get ( 'y' )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) xdest = args . get ( 'x' ) ydest = args . get ( 'y' ) expr = ( f '($kpffiu.TTXVAX > { xdest - tol } ) and ' \\ f '($kpffiu.TTXVAX < { xdest + tol } )' ) successx = ktl . waitFor ( expr , timeout = timeout ) if successx is not True : raise FailedToReachDestination ( kpffiu [ 'TTXVAX' ] . read (), xdest ) expr = ( f '($kpffiu.TTYVAX > { ydest - tol } ) and ' \\ f '($kpffiu.TTYVAX < { ydest + tol } )' ) successy = ktl . waitFor ( expr , timeout = timeout ) if successy is not True : raise FailedToReachDestination ( kpffiu [ 'TTYVAX' ] . read (), ydest ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'x' , type = float , help = \"X position of the tip tilt mirror (TTXVAX)\" ) parser . add_argument ( 'y' , type = float , help = \"X position of the tip tilt mirror (TTYVAX)\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltPosition"},{"location":"scripts/SetTipTiltTargetPixel/","text":"SetTipTiltTargetPixel Bases: KPFFunction Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. Parameters: x ( float ) \u2013 The desired X target pixel. y ( float ) \u2013 The desired Y target pixel. KTL Keywords Used: kpfguide.CURRENT_BASE Source code in kpf/fiu/SetTipTiltTargetPixel.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SetTipTiltTargetPixel ( KPFFunction ): '''Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. Args: x (float): The desired X target pixel. y (float): The desired Y target pixel. KTL Keywords Used: - `kpfguide.CURRENT_BASE` ''' @classmethod def pre_condition ( cls , args ): min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) check_input ( args , 'x' , value_min = min_x_pixel , value_max = max_x_pixel ) check_input ( args , 'y' , value_min = min_y_pixel , value_max = max_y_pixel ) @classmethod def perform ( cls , args ): x = args . get ( 'x' ) y = args . get ( 'y' ) pixtarget = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) pixtarget . write (( x , y )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.01 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'x' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) parser . add_argument ( 'y' , type = float , help = \"Y pixel target (CURRENT_BASE)\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltTargetPixel"},{"location":"scripts/SetTipTiltTargetPixel/#settiptilttargetpixel","text":"Bases: KPFFunction Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. Parameters: x ( float ) \u2013 The desired X target pixel. y ( float ) \u2013 The desired Y target pixel. KTL Keywords Used: kpfguide.CURRENT_BASE Source code in kpf/fiu/SetTipTiltTargetPixel.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class SetTipTiltTargetPixel ( KPFFunction ): '''Set the target pixel of the tip tilt mirror. This sets the CURRENT_BASE keyword. Args: x (float): The desired X target pixel. y (float): The desired Y target pixel. KTL Keywords Used: - `kpfguide.CURRENT_BASE` ''' @classmethod def pre_condition ( cls , args ): min_x_pixel = cfg . getint ( 'guider' , 'min_x_pixel' , fallback = 0 ) max_x_pixel = cfg . getint ( 'guider' , 'max_x_pixel' , fallback = 640 ) min_y_pixel = cfg . getint ( 'guider' , 'min_y_pixel' , fallback = 0 ) max_y_pixel = cfg . getint ( 'guider' , 'max_y_pixel' , fallback = 512 ) check_input ( args , 'x' , value_min = min_x_pixel , value_max = max_x_pixel ) check_input ( args , 'y' , value_min = min_y_pixel , value_max = max_y_pixel ) @classmethod def perform ( cls , args ): x = args . get ( 'x' ) y = args . get ( 'y' ) pixtarget = ktl . cache ( 'kpfguide' , 'CURRENT_BASE' ) pixtarget . write (( x , y )) time_shim = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.01 ) time . sleep ( time_shim ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'x' , type = float , help = \"X pixel target (CURRENT_BASE)\" ) parser . add_argument ( 'y' , type = float , help = \"Y pixel target (CURRENT_BASE)\" ) return super () . add_cmdline_args ( parser )","title":"SetTipTiltTargetPixel"},{"location":"scripts/SetTriggeredDetectors/","text":"SetTriggeredDetectors Bases: KPFFunction Selects which cameras will be triggered by setting the kpfexpose.TRIG_TARG keyword value. Parameters: TriggerRed ( bool ) \u2013 Trigger the Red detector? (default=False) TriggerGreen ( bool ) \u2013 Trigger the Green detector? (default=False) TriggerCaHK ( bool ) \u2013 Trigger the CaH&K detector? (default=False) TriggerExpMeter ( bool ) \u2013 Trigger the ExpMeter detector? (default=False) KTL Keywords Used: kpfexpose.TRIG_TARG kpfconfig.RED_ENABLED kpfconfig.GREEN_ENABLED kpfconfig.CA_HK_ENABLED kpfconfig.EXPMETER_ENABLED Source code in kpf/spectrograph/SetTriggeredDetectors.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class SetTriggeredDetectors ( KPFFunction ): '''Selects which cameras will be triggered by setting the `kpfexpose.TRIG_TARG` keyword value. Args: TriggerRed (bool): Trigger the Red detector? (default=False) TriggerGreen (bool): Trigger the Green detector? (default=False) TriggerCaHK (bool): Trigger the CaH&K detector? (default=False) TriggerExpMeter (bool): Trigger the ExpMeter detector? (default=False) KTL Keywords Used: - `kpfexpose.TRIG_TARG` - `kpfconfig.RED_ENABLED` - `kpfconfig.GREEN_ENABLED` - `kpfconfig.CA_HK_ENABLED` - `kpfconfig.EXPMETER_ENABLED` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) detector_list = [] if args . get ( 'TriggerRed' , False ) is True : if kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Red detector is not enabled' ) else : detector_list . append ( 'Red' ) if args . get ( 'TriggerGreen' , False ) is True : if kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Green detector is not enabled' ) else : detector_list . append ( 'Green' ) if args . get ( 'TriggerCaHK' , False ) is True : if kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Ca HK detector is not enabled' ) else : detector_list . append ( 'Ca_HK' ) if args . get ( 'TriggerExpMeter' , False ) is True : if kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'ExpMeter detector is not enabled' ) else : detector_list . append ( 'ExpMeter' ) if args . get ( 'TriggerGuide' , False ) is True : detector_list . append ( 'Guide' ) detectors_string = ',' . join ( detector_list ) log . debug ( f \"Setting triggered detectors to ' { detectors_string } '\" ) TRIG_TARG = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) TRIG_TARG . write ( detectors_string ) @classmethod def post_condition ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) TRIG_TARG = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) TRIG_TARG . monitor () detector_names = [( 'Red' , 'TriggerRed' , kpfconfig [ f 'RED_ENABLED' ] . read ( binary = True )), ( 'Green' , 'TriggerGreen' , kpfconfig [ f 'GREEN_ENABLED' ] . read ( binary = True )), ( 'Ca_HK' , 'TriggerCaHK' , kpfconfig [ f 'CA_HK_ENABLED' ] . read ( binary = True )), ( 'ExpMeter' , 'TriggerExpMeter' , kpfconfig [ f 'EXPMETER_ENABLED' ] . read ( binary = True )), ] detector_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( detector_tests ) != True and total_time < 0.25 : detector_tests = [] for detector in detector_names : if args . get ( detector [ 1 ], False ) and detector [ 2 ]: detector_tests . append ( detector [ 0 ] in TRIG_TARG . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( detector_tests ) != True : raise FailedToReachDestination ( TRIG_TARG . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Red\" , \"--red\" , \"-r\" , dest = \"TriggerRed\" , default = False , action = \"store_true\" , help = \"Trigger the Red detector during exposure?\" ) parser . add_argument ( \"--Green\" , \"--green\" , \"-g\" , dest = \"TriggerGreen\" , default = False , action = \"store_true\" , help = \"Trigger the Green detector during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TriggerCaHK\" , default = False , action = \"store_true\" , help = \"Trigger the CaHK detector during exposure?\" ) parser . add_argument ( \"--ExpMeter\" , \"--expmeter\" , \"--EM\" , \"--em\" , dest = \"TriggerExpMeter\" , default = False , action = \"store_true\" , help = \"Trigger the ExpMeter detector during exposure?\" ) parser . add_argument ( \"--Guide\" , \"--Guider\" , \"--guide\" , \"--guider\" , \"--CRED2\" , dest = \"TriggerGuide\" , default = False , action = \"store_true\" , help = \"Trigger the Guider detector during exposure?\" ) return super () . add_cmdline_args ( parser )","title":"SetTriggeredDetectors"},{"location":"scripts/SetTriggeredDetectors/#settriggereddetectors","text":"Bases: KPFFunction Selects which cameras will be triggered by setting the kpfexpose.TRIG_TARG keyword value. Parameters: TriggerRed ( bool ) \u2013 Trigger the Red detector? (default=False) TriggerGreen ( bool ) \u2013 Trigger the Green detector? (default=False) TriggerCaHK ( bool ) \u2013 Trigger the CaH&K detector? (default=False) TriggerExpMeter ( bool ) \u2013 Trigger the ExpMeter detector? (default=False) KTL Keywords Used: kpfexpose.TRIG_TARG kpfconfig.RED_ENABLED kpfconfig.GREEN_ENABLED kpfconfig.CA_HK_ENABLED kpfconfig.EXPMETER_ENABLED Source code in kpf/spectrograph/SetTriggeredDetectors.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class SetTriggeredDetectors ( KPFFunction ): '''Selects which cameras will be triggered by setting the `kpfexpose.TRIG_TARG` keyword value. Args: TriggerRed (bool): Trigger the Red detector? (default=False) TriggerGreen (bool): Trigger the Green detector? (default=False) TriggerCaHK (bool): Trigger the CaH&K detector? (default=False) TriggerExpMeter (bool): Trigger the ExpMeter detector? (default=False) KTL Keywords Used: - `kpfexpose.TRIG_TARG` - `kpfconfig.RED_ENABLED` - `kpfconfig.GREEN_ENABLED` - `kpfconfig.CA_HK_ENABLED` - `kpfconfig.EXPMETER_ENABLED` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) detector_list = [] if args . get ( 'TriggerRed' , False ) is True : if kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Red detector is not enabled' ) else : detector_list . append ( 'Red' ) if args . get ( 'TriggerGreen' , False ) is True : if kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Green detector is not enabled' ) else : detector_list . append ( 'Green' ) if args . get ( 'TriggerCaHK' , False ) is True : if kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'Ca HK detector is not enabled' ) else : detector_list . append ( 'Ca_HK' ) if args . get ( 'TriggerExpMeter' , False ) is True : if kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) == False : log . warning ( f 'ExpMeter detector is not enabled' ) else : detector_list . append ( 'ExpMeter' ) if args . get ( 'TriggerGuide' , False ) is True : detector_list . append ( 'Guide' ) detectors_string = ',' . join ( detector_list ) log . debug ( f \"Setting triggered detectors to ' { detectors_string } '\" ) TRIG_TARG = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) TRIG_TARG . write ( detectors_string ) @classmethod def post_condition ( cls , args ): kpfconfig = ktl . cache ( 'kpfconfig' ) TRIG_TARG = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) TRIG_TARG . monitor () detector_names = [( 'Red' , 'TriggerRed' , kpfconfig [ f 'RED_ENABLED' ] . read ( binary = True )), ( 'Green' , 'TriggerGreen' , kpfconfig [ f 'GREEN_ENABLED' ] . read ( binary = True )), ( 'Ca_HK' , 'TriggerCaHK' , kpfconfig [ f 'CA_HK_ENABLED' ] . read ( binary = True )), ( 'ExpMeter' , 'TriggerExpMeter' , kpfconfig [ f 'EXPMETER_ENABLED' ] . read ( binary = True )), ] detector_tests = [ False ] timeshim = cfg . getfloat ( 'times' , 'kpfexpose_shim_time' , fallback = 0.01 ) total_time = 0 while np . all ( detector_tests ) != True and total_time < 0.25 : detector_tests = [] for detector in detector_names : if args . get ( detector [ 1 ], False ) and detector [ 2 ]: detector_tests . append ( detector [ 0 ] in TRIG_TARG . ascii . split ( ',' )) sleep ( timeshim ) total_time += timeshim if np . all ( detector_tests ) != True : raise FailedToReachDestination ( TRIG_TARG . ascii , 'TBD' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--Red\" , \"--red\" , \"-r\" , dest = \"TriggerRed\" , default = False , action = \"store_true\" , help = \"Trigger the Red detector during exposure?\" ) parser . add_argument ( \"--Green\" , \"--green\" , \"-g\" , dest = \"TriggerGreen\" , default = False , action = \"store_true\" , help = \"Trigger the Green detector during exposure?\" ) parser . add_argument ( \"--CaHK\" , \"--HK\" , \"--cahk\" , \"--hk\" , dest = \"TriggerCaHK\" , default = False , action = \"store_true\" , help = \"Trigger the CaHK detector during exposure?\" ) parser . add_argument ( \"--ExpMeter\" , \"--expmeter\" , \"--EM\" , \"--em\" , dest = \"TriggerExpMeter\" , default = False , action = \"store_true\" , help = \"Trigger the ExpMeter detector during exposure?\" ) parser . add_argument ( \"--Guide\" , \"--Guider\" , \"--guide\" , \"--guider\" , \"--CRED2\" , dest = \"TriggerGuide\" , default = False , action = \"store_true\" , help = \"Trigger the Guider detector during exposure?\" ) return super () . add_cmdline_args ( parser )","title":"SetTriggeredDetectors"},{"location":"scripts/SetupAOforACAM/","text":"SetupAOforACAM Bases: KPFFunction Set up AO in the safe mode for ACAM operation to assist KPF acquisition Functions Called: kpf.ao.SetAFMtoMirror kpf.ao.SetAFStoNGS Source code in kpf/ao/SetupAOforACAM.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class SetupAOforACAM ( KPFFunction ): '''Set up AO in the safe mode for ACAM operation to assist KPF acquisition Functions Called: - `kpf.ao.SetAFMtoMirror` - `kpf.ao.SetAFStoNGS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Set AFM to Mirror' ) SetAFMtoMirror . execute ({}) log . info ( 'Set AFS to NGS' ) SetAFStoNGS . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"SetupAOforACAM"},{"location":"scripts/SetupAOforACAM/#setupaoforacam","text":"Bases: KPFFunction Set up AO in the safe mode for ACAM operation to assist KPF acquisition Functions Called: kpf.ao.SetAFMtoMirror kpf.ao.SetAFStoNGS Source code in kpf/ao/SetupAOforACAM.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class SetupAOforACAM ( KPFFunction ): '''Set up AO in the safe mode for ACAM operation to assist KPF acquisition Functions Called: - `kpf.ao.SetAFMtoMirror` - `kpf.ao.SetAFStoNGS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Set AFM to Mirror' ) SetAFMtoMirror . execute ({}) log . info ( 'Set AFS to NGS' ) SetAFStoNGS . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"SetupAOforACAM"},{"location":"scripts/SetupAOforKPF/","text":"SetupAOforKPF Bases: KPFFunction Set up AO in the safe mode for KPF operation Set AO roator in Manual mode Set AO rotator to 0 deg Turn off HEPA Set AO in DCS sim mode Home PCU Move PCU to the KPF position Open AO hatch KTL Keywords Used: ao.PCSFNAME Functions Called: kpf.ao.SetAORotatorManual kpf.ao.SetAORotator kpf.ao.TurnHepaOff kpf.ao.SetAODCStoSIM kpf.ao.TurnLightSourceOff kpf.ao.SendPCUtoHome kpf.ao.SendPCUtoKPF Source code in kpf/ao/SetupAOforKPF.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class SetupAOforKPF ( KPFFunction ): '''Set up AO in the safe mode for KPF operation - Set AO roator in Manual mode - Set AO rotator to 0 deg - Turn off HEPA - Set AO in DCS sim mode - Home PCU - Move PCU to the KPF position - Open AO hatch KTL Keywords Used: - `ao.PCSFNAME` Functions Called: - `kpf.ao.SetAORotatorManual` - `kpf.ao.SetAORotator` - `kpf.ao.TurnHepaOff` - `kpf.ao.SetAODCStoSIM` - `kpf.ao.TurnLightSourceOff` - `kpf.ao.SendPCUtoHome` - `kpf.ao.SendPCUtoKPF` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Set AO rotator to Manual' ) SetAORotatorManual . execute ({}) log . info ( 'Set AO rotator to 0 deg' ) SetAORotator . execute ({ 'dest' : 0 }) log . info ( 'Turn off HEPA' ) TurnHepaOff . execute ({}) log . info ( 'Set AO in DCS sim mode' ) SetAODCStoSIM . execute ({}) log . info ( 'Turn K1 AO light source off' ) TurnLightSourceOff . execute ({}) PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSstagekw . read () != 'kpf' : log . info ( 'Move PCU to Home' ) SendPCUtoHome . execute ({}) log . info ( 'Move PCU to KPF' ) SendPCUtoKPF . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"SetupAOforKPF"},{"location":"scripts/SetupAOforKPF/#setupaoforkpf","text":"Bases: KPFFunction Set up AO in the safe mode for KPF operation Set AO roator in Manual mode Set AO rotator to 0 deg Turn off HEPA Set AO in DCS sim mode Home PCU Move PCU to the KPF position Open AO hatch KTL Keywords Used: ao.PCSFNAME Functions Called: kpf.ao.SetAORotatorManual kpf.ao.SetAORotator kpf.ao.TurnHepaOff kpf.ao.SetAODCStoSIM kpf.ao.TurnLightSourceOff kpf.ao.SendPCUtoHome kpf.ao.SendPCUtoKPF Source code in kpf/ao/SetupAOforKPF.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class SetupAOforKPF ( KPFFunction ): '''Set up AO in the safe mode for KPF operation - Set AO roator in Manual mode - Set AO rotator to 0 deg - Turn off HEPA - Set AO in DCS sim mode - Home PCU - Move PCU to the KPF position - Open AO hatch KTL Keywords Used: - `ao.PCSFNAME` Functions Called: - `kpf.ao.SetAORotatorManual` - `kpf.ao.SetAORotator` - `kpf.ao.TurnHepaOff` - `kpf.ao.SetAODCStoSIM` - `kpf.ao.TurnLightSourceOff` - `kpf.ao.SendPCUtoHome` - `kpf.ao.SendPCUtoKPF` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . info ( 'Set AO rotator to Manual' ) SetAORotatorManual . execute ({}) log . info ( 'Set AO rotator to 0 deg' ) SetAORotator . execute ({ 'dest' : 0 }) log . info ( 'Turn off HEPA' ) TurnHepaOff . execute ({}) log . info ( 'Set AO in DCS sim mode' ) SetAODCStoSIM . execute ({}) log . info ( 'Turn K1 AO light source off' ) TurnLightSourceOff . execute ({}) PCSstagekw = ktl . cache ( 'ao' , 'PCSFNAME' ) if PCSstagekw . read () != 'kpf' : log . info ( 'Move PCU to Home' ) SendPCUtoHome . execute ({}) log . info ( 'Move PCU to KPF' ) SendPCUtoKPF . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"SetupAOforKPF"},{"location":"scripts/SetupExpMeter/","text":"SetupExpMeter Bases: KPFFunction Configure the exposure meter using the given OB arguments. Parameters: ExpMeterMode ( str ) \u2013 See Science OB definition. TriggerExpMeter ( bool ) \u2013 See Science OB definition. KTL Keywords Used: kpf_expmeter.USETHRESHOLD kpfconfig.EXPMETER_ENABLED Functions Called: kpf.expmeter.SetExpMeterTerminationParameters Source code in kpf/expmeter/SetupExpMeter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class SetupExpMeter ( KPFFunction ): '''Configure the exposure meter using the given OB arguments. Args: ExpMeterMode (str): See Science OB definition. TriggerExpMeter (bool): See Science OB definition. KTL Keywords Used: - `kpf_expmeter.USETHRESHOLD` - `kpfconfig.EXPMETER_ENABLED` Functions Called: - `kpf.expmeter.SetExpMeterTerminationParameters` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) EXPMETER_ENABLED = ktl . cache ( 'kpfconfig' , 'EXPMETER_ENABLED' ) ## ---------------------------------------------------------------- ## Configure exposure meter ## ---------------------------------------------------------------- log . debug ( 'Setting up exposure meter using SetupExpMeter' ) EM_mode = args . get ( 'ExpMeterMode' , 'off' ) EM_enabled = EXPMETER_ENABLED . read () == 'Yes' if EM_mode == 'monitor' and EM_enabled : USETHRESHOLD . write ( 'No' ) args [ 'TriggerExpMeter' ] = True elif EM_mode == 'control' and EM_enabled : args [ 'TriggerExpMeter' ] = True try : SetExpMeterTerminationParameters . execute ( args ) except Exception as e : log . error ( 'SetExpMeterTerminationParameters failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) USETHRESHOLD . write ( 'No' ) elif EM_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both args [ 'TriggerExpMeter' ] = False elif EM_enabled == False : log . warning ( 'ExpMeter is disabled' ) args [ 'TriggerExpMeter' ] = False else : log . warning ( f \"ExpMeterMode { EM_mode } is not available\" ) USETHRESHOLD . write ( 'No' ) # Must return args as we have edited them return args @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser )","title":"SetupExpMeter"},{"location":"scripts/SetupExpMeter/#setupexpmeter","text":"Bases: KPFFunction Configure the exposure meter using the given OB arguments. Parameters: ExpMeterMode ( str ) \u2013 See Science OB definition. TriggerExpMeter ( bool ) \u2013 See Science OB definition. KTL Keywords Used: kpf_expmeter.USETHRESHOLD kpfconfig.EXPMETER_ENABLED Functions Called: kpf.expmeter.SetExpMeterTerminationParameters Source code in kpf/expmeter/SetupExpMeter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class SetupExpMeter ( KPFFunction ): '''Configure the exposure meter using the given OB arguments. Args: ExpMeterMode (str): See Science OB definition. TriggerExpMeter (bool): See Science OB definition. KTL Keywords Used: - `kpf_expmeter.USETHRESHOLD` - `kpfconfig.EXPMETER_ENABLED` Functions Called: - `kpf.expmeter.SetExpMeterTerminationParameters` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): USETHRESHOLD = ktl . cache ( 'kpf_expmeter' , 'USETHRESHOLD' ) EXPMETER_ENABLED = ktl . cache ( 'kpfconfig' , 'EXPMETER_ENABLED' ) ## ---------------------------------------------------------------- ## Configure exposure meter ## ---------------------------------------------------------------- log . debug ( 'Setting up exposure meter using SetupExpMeter' ) EM_mode = args . get ( 'ExpMeterMode' , 'off' ) EM_enabled = EXPMETER_ENABLED . read () == 'Yes' if EM_mode == 'monitor' and EM_enabled : USETHRESHOLD . write ( 'No' ) args [ 'TriggerExpMeter' ] = True elif EM_mode == 'control' and EM_enabled : args [ 'TriggerExpMeter' ] = True try : SetExpMeterTerminationParameters . execute ( args ) except Exception as e : log . error ( 'SetExpMeterTerminationParameters failed' ) log . error ( e ) traceback_text = traceback . format_exc () log . error ( traceback_text ) USETHRESHOLD . write ( 'No' ) elif EM_mode in [ 'off' , False ]: # pyyaml converts 'off' to False, so handle both args [ 'TriggerExpMeter' ] = False elif EM_enabled == False : log . warning ( 'ExpMeter is disabled' ) args [ 'TriggerExpMeter' ] = False else : log . warning ( f \"ExpMeterMode { EM_mode } is not available\" ) USETHRESHOLD . write ( 'No' ) # Must return args as we have edited them return args @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( '--nointensemon' , dest = \"nointensemon\" , default = False , action = \"store_true\" , help = 'Skip the intensity monitor measurement?' ) return super () . add_cmdline_args ( parser )","title":"SetupExpMeter"},{"location":"scripts/ShutdownTipTilt/","text":"ShutdownTipTilt Bases: KPFFunction Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. KTL Keywords Used: kpffiu.TTXSRV kpffiu.TTYSRV kpffiu.TTXVAX kpffiu.TTYVAX kpfguide.TIPTILT_CONTROL kpfguide.TIPTILT_CALC kpfguide.TIPTILT_HOME Source code in kpf/fiu/ShutdownTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class ShutdownTipTilt ( KPFFunction ): '''Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. KTL Keywords Used: - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpfguide.TIPTILT_CONTROL` - `kpfguide.TIPTILT_CALC` - `kpfguide.TIPTILT_HOME` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpffiu = ktl . cache ( 'kpffiu' ) xopen = kpffiu [ 'TTXSRV' ] . read () == 'Open' yopen = kpffiu [ 'TTYSRV' ] . read () == 'Open' if xopen and yopen : # No actions needed return elif xopen == False and yopen == False : # Both axis are in closed loop mode # Shut down tip tilt activity and park mirror before opening loops kpfguide [ 'TIPTILT_CONTROL' ] . write ( 'Inactive' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Inactive' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) else : # We're in a mixed state, just open the loops log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) success1 = ktl . waitFor ( '($kpffiu.TTXSRV == open)' , timeout = timeout ) success2 = ktl . waitFor ( '($kpffiu.TTYSRV == open)' , timeout = timeout ) if success1 == False or success2 == False : raise FailedPostCondition ( f 'TT[X and/or Y]SRV did not open' )","title":"ShutdownTipTilt"},{"location":"scripts/ShutdownTipTilt/#shutdowntiptilt","text":"Bases: KPFFunction Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. KTL Keywords Used: kpffiu.TTXSRV kpffiu.TTYSRV kpffiu.TTXVAX kpffiu.TTYVAX kpfguide.TIPTILT_CONTROL kpfguide.TIPTILT_CALC kpfguide.TIPTILT_HOME Source code in kpf/fiu/ShutdownTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class ShutdownTipTilt ( KPFFunction ): '''Shutdown the tip tilt system by setting the control mode to open loop and setting the target values in X and Y to 0. KTL Keywords Used: - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpfguide.TIPTILT_CONTROL` - `kpfguide.TIPTILT_CALC` - `kpfguide.TIPTILT_HOME` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpffiu = ktl . cache ( 'kpffiu' ) xopen = kpffiu [ 'TTXSRV' ] . read () == 'Open' yopen = kpffiu [ 'TTYSRV' ] . read () == 'Open' if xopen and yopen : # No actions needed return elif xopen == False and yopen == False : # Both axis are in closed loop mode # Shut down tip tilt activity and park mirror before opening loops kpfguide [ 'TIPTILT_CONTROL' ] . write ( 'Inactive' ) kpfguide [ 'TIPTILT_CALC' ] . write ( 'Inactive' ) tthome = ktl . cache ( 'kpfguide' , 'TIPTILT_HOME' ) home = tthome . read ( binary = True ) log . debug ( f 'Sending Tip tilt mirror to home: { home [ 0 ] } { home [ 1 ] } ' ) kpffiu [ 'TTXVAX' ] . write ( home [ 0 ]) kpffiu [ 'TTYVAX' ] . write ( home [ 1 ]) log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) else : # We're in a mixed state, just open the loops log . debug ( 'Opening tip tilt mirror servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'open' ) kpffiu [ 'TTYSRV' ] . write ( 'open' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) success1 = ktl . waitFor ( '($kpffiu.TTXSRV == open)' , timeout = timeout ) success2 = ktl . waitFor ( '($kpffiu.TTYSRV == open)' , timeout = timeout ) if success1 == False or success2 == False : raise FailedPostCondition ( f 'TT[X and/or Y]SRV did not open' )","title":"ShutdownTipTilt"},{"location":"scripts/SoCalStartAutonomous/","text":"SoCalStartAutonomous Bases: KPFFunction Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 KTL Keywords Used: kpfsocal.AUTONOMOUS Source code in kpf/socal/SoCalStartAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStartAutonomous ( KPFFunction ): '''Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 KTL Keywords Used: - `kpfsocal.AUTONOMOUS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 1' ) AUTONOMOUS . write ( 1 ) @classmethod def post_condition ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 1' )","title":"SoCalStartAutonomous"},{"location":"scripts/SoCalStartAutonomous/#socalstartautonomous","text":"Bases: KPFFunction Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 KTL Keywords Used: kpfsocal.AUTONOMOUS Source code in kpf/socal/SoCalStartAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStartAutonomous ( KPFFunction ): '''Start SoCal's AUTONOMOUS mode by setting AUTONOMOUS=1 KTL Keywords Used: - `kpfsocal.AUTONOMOUS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 1' ) AUTONOMOUS . write ( 1 ) @classmethod def post_condition ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==1\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 1' )","title":"SoCalStartAutonomous"},{"location":"scripts/SoCalStopAutonomous/","text":"SoCalStopAutonomous Bases: KPFFunction Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 KTL Keywords Used: kpfsocal.AUTONOMOUS Source code in kpf/socal/SoCalStopAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStopAutonomous ( KPFFunction ): '''Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 KTL Keywords Used: - `kpfsocal.AUTONOMOUS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 0' ) AUTONOMOUS . write ( 0 ) @classmethod def post_condition ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 0' )","title":"SoCalStopAutonomous"},{"location":"scripts/SoCalStopAutonomous/#socalstopautonomous","text":"Bases: KPFFunction Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 KTL Keywords Used: kpfsocal.AUTONOMOUS Source code in kpf/socal/SoCalStopAutonomous.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class SoCalStopAutonomous ( KPFFunction ): '''Stop SoCal's AUTONOMOUS mode by setting AUTONOMOUS=0 KTL Keywords Used: - `kpfsocal.AUTONOMOUS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) log . info ( 'Setting kpfsocal.AUTONOMOUS = 0' ) AUTONOMOUS . write ( 0 ) @classmethod def post_condition ( cls , args ): AUTONOMOUS = ktl . cache ( 'kpfsocal' , 'AUTONOMOUS' ) success = AUTONOMOUS . waitFor ( \"==0\" , timeout = 1 ) if success is False : raise FailedToReachDestination ( 'kpfsocal.AUTONOMOUS is not 0' )","title":"SoCalStopAutonomous"},{"location":"scripts/StartAgitator/","text":"StartAgitator Bases: KPFFunction Start the agitator motion and wait the appropriate startup time before returning. KTL Keywords Used: kpfmot.AGITATOR Source code in kpf/spectrograph/StartAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class StartAgitator ( KPFFunction ): '''Start the agitator motion and wait the appropriate startup time before returning. KTL Keywords Used: - `kpfmot.AGITATOR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . read () == 'Running' : log . debug ( 'Agitator is running' ) else : startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) log . debug ( 'Starting agitator motion' ) try : AGITATOR . write ( 'Run' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) AGITATOR . write ( 'Run' ) time . sleep ( startup ) @classmethod def post_condition ( cls , args ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . waitFor ( '== \"Running\"' , timeout = 5 * startup ) is not True : raise FailedToReachDestination ( AGITATOR . read (), 'Running' )","title":"StartAgitator"},{"location":"scripts/StartAgitator/#startagitator","text":"Bases: KPFFunction Start the agitator motion and wait the appropriate startup time before returning. KTL Keywords Used: kpfmot.AGITATOR Source code in kpf/spectrograph/StartAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class StartAgitator ( KPFFunction ): '''Start the agitator motion and wait the appropriate startup time before returning. KTL Keywords Used: - `kpfmot.AGITATOR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . read () == 'Running' : log . debug ( 'Agitator is running' ) else : startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) log . debug ( 'Starting agitator motion' ) try : AGITATOR . write ( 'Run' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) AGITATOR . write ( 'Run' ) time . sleep ( startup ) @classmethod def post_condition ( cls , args ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . waitFor ( '== \"Running\"' , timeout = 5 * startup ) is not True : raise FailedToReachDestination ( AGITATOR . read (), 'Running' )","title":"StartAgitator"},{"location":"scripts/StartExposure/","text":"StartExposure Bases: KPFFunction Begins an triggered exposure by setting the kpfexpose.EXPOSE keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfconfig.RED_ENABLED kpfconfig.GREEN_ENABLED kpfconfig.CA_HK_ENABLED kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE Source code in kpf/spectrograph/StartExposure.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class StartExposure ( KPFFunction ): '''Begins an triggered exposure by setting the `kpfexpose.EXPOSE` keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfconfig.RED_ENABLED` - `kpfconfig.GREEN_ENABLED` - `kpfconfig.CA_HK_ENABLED` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): EXPOSE = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) WaitForReady . execute ({}) log . debug ( f \"Beginning Exposure\" ) EXPOSE . write ( 'Start' ) @classmethod def post_condition ( cls , args ): expr = f \"(kpfexpose.EXPOSE != Start)\" kpfexpose = ktl . cache ( 'kpfexpose' ) is_GREEN_ENABLED = ktl . cache ( 'kpfconfig' , 'GREEN_ENABLED' ) . read () == 'Yes' is_RED_ENABLED = ktl . cache ( 'kpfconfig' , 'RED_ENABLED' ) . read () == 'Yes' is_CA_HK_ENABLED = ktl . cache ( 'kpfconfig' , 'CA_HK_ENABLED' ) . read () == 'Yes' trig_targ = kpfexpose [ 'TRIG_TARG' ] . read () . split ( ',' ) if 'Green' in trig_targ and is_GREEN_ENABLED : expr += ' and ($kpfgreen.EXPSTATE != Start)' if 'Red' in trig_targ and is_RED_ENABLED : expr += ' and ($kpfred.EXPSTATE != Start)' if 'Ca_HK' in trig_targ and is_CA_HK_ENABLED : expr += ' and ($kpf_hk.EXPSTATE != Start)' exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) timeout = 6 left_start_state = ktl . waitFor ( expr , timeout = timeout ) if left_start_state is False : log . warning ( f 'We are still in start state after { timeout } s' ) # Figure out which detector is stuck in the start state? if is_GREEN_ENABLED : green_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) . read () log . debug ( f 'kpfgreen.EXPSTATE = { green_expstate } ' ) if is_RED_ENABLED : red_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) . read () log . debug ( f 'kpfred.EXPSTATE = { red_expstate } ' ) if is_CA_HK_ENABLED : cahk_expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) . read () log . debug ( f 'kpf_hk.EXPSTATE = { cahk_expstate } ' ) # Abort the current exposure elapsed = kpfexpose [ 'ELAPSED' ] . read ( binary = True ) remaining = exptime - elapsed if remaining <= 10 : # Don't stop exposure, just wait it out log . debug ( f 'Waiting out remaining { remaining } s of exposure' ) time . sleep ( remaining + 2 ) else : log . warning ( 'Stopping current exposure (with read out)' ) kpfexpose [ 'EXPOSE' ] . write ( 'End' ) time . sleep ( 2 ) # Time shim, this time is a WAG # Now reset the offending detector if is_GREEN_ENABLED : if green_expstate == 'Start' : ResetGreenDetector . execute ({}) if is_RED_ENABLED : if red_expstate == 'Start' : ResetRedDetector . execute ({}) if is_CA_HK_ENABLED : if cahk_expstate == 'Start' : ResetCaHKDetector . execute ({}) # Now start a fresh exposure WaitForReady . execute ({}) time . sleep ( 1.0 ) # This time shim and the WaitForReady are hacks to catch if the WaitForReady . execute ({}) # reset detector went in to readout, but we didn't know. log . warning ( 'Restarting exposure' ) StartExposure . execute ( args )","title":"StartExposure"},{"location":"scripts/StartExposure/#startexposure","text":"Bases: KPFFunction Begins an triggered exposure by setting the kpfexpose.EXPOSE keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfconfig.RED_ENABLED kpfconfig.GREEN_ENABLED kpfconfig.CA_HK_ENABLED kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE Source code in kpf/spectrograph/StartExposure.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class StartExposure ( KPFFunction ): '''Begins an triggered exposure by setting the `kpfexpose.EXPOSE` keyword to Start. This will return immediately after. Use commands like WaitForReadout or WaitForReady to determine when an exposure is done. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfconfig.RED_ENABLED` - `kpfconfig.GREEN_ENABLED` - `kpfconfig.CA_HK_ENABLED` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): EXPOSE = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) WaitForReady . execute ({}) log . debug ( f \"Beginning Exposure\" ) EXPOSE . write ( 'Start' ) @classmethod def post_condition ( cls , args ): expr = f \"(kpfexpose.EXPOSE != Start)\" kpfexpose = ktl . cache ( 'kpfexpose' ) is_GREEN_ENABLED = ktl . cache ( 'kpfconfig' , 'GREEN_ENABLED' ) . read () == 'Yes' is_RED_ENABLED = ktl . cache ( 'kpfconfig' , 'RED_ENABLED' ) . read () == 'Yes' is_CA_HK_ENABLED = ktl . cache ( 'kpfconfig' , 'CA_HK_ENABLED' ) . read () == 'Yes' trig_targ = kpfexpose [ 'TRIG_TARG' ] . read () . split ( ',' ) if 'Green' in trig_targ and is_GREEN_ENABLED : expr += ' and ($kpfgreen.EXPSTATE != Start)' if 'Red' in trig_targ and is_RED_ENABLED : expr += ' and ($kpfred.EXPSTATE != Start)' if 'Ca_HK' in trig_targ and is_CA_HK_ENABLED : expr += ' and ($kpf_hk.EXPSTATE != Start)' exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) timeout = 6 left_start_state = ktl . waitFor ( expr , timeout = timeout ) if left_start_state is False : log . warning ( f 'We are still in start state after { timeout } s' ) # Figure out which detector is stuck in the start state? if is_GREEN_ENABLED : green_expstate = ktl . cache ( 'kpfgreen' , 'EXPSTATE' ) . read () log . debug ( f 'kpfgreen.EXPSTATE = { green_expstate } ' ) if is_RED_ENABLED : red_expstate = ktl . cache ( 'kpfred' , 'EXPSTATE' ) . read () log . debug ( f 'kpfred.EXPSTATE = { red_expstate } ' ) if is_CA_HK_ENABLED : cahk_expstate = ktl . cache ( 'kpf_hk' , 'EXPSTATE' ) . read () log . debug ( f 'kpf_hk.EXPSTATE = { cahk_expstate } ' ) # Abort the current exposure elapsed = kpfexpose [ 'ELAPSED' ] . read ( binary = True ) remaining = exptime - elapsed if remaining <= 10 : # Don't stop exposure, just wait it out log . debug ( f 'Waiting out remaining { remaining } s of exposure' ) time . sleep ( remaining + 2 ) else : log . warning ( 'Stopping current exposure (with read out)' ) kpfexpose [ 'EXPOSE' ] . write ( 'End' ) time . sleep ( 2 ) # Time shim, this time is a WAG # Now reset the offending detector if is_GREEN_ENABLED : if green_expstate == 'Start' : ResetGreenDetector . execute ({}) if is_RED_ENABLED : if red_expstate == 'Start' : ResetRedDetector . execute ({}) if is_CA_HK_ENABLED : if cahk_expstate == 'Start' : ResetCaHKDetector . execute ({}) # Now start a fresh exposure WaitForReady . execute ({}) time . sleep ( 1.0 ) # This time shim and the WaitForReady are hacks to catch if the WaitForReady . execute ({}) # reset detector went in to readout, but we didn't know. log . warning ( 'Restarting exposure' ) StartExposure . execute ( args )","title":"StartExposure"},{"location":"scripts/StartGUIs/","text":"StartGUIs Bases: KPFFunction Start KPF GUIs Source code in kpf/utils/StartGUIs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class StartGUIs ( KPFFunction ): '''Start KPF GUIs ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Get DISPLAY varibales env = os . environ uidisp = {} kvncstatus_proc = subprocess . run ([ 'kvncstatus' ], env = env , stdout = subprocess . PIPE ) kvncstatus = Table . read ( kvncstatus_proc . stdout . decode (), format = 'ascii' ) username = os . getlogin () display = { 'control0' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control0' ][ 'Display' ][ 0 ], 'control1' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control1' ][ 'Display' ][ 0 ], 'control2' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control2' ][ 'Display' ][ 0 ], 'telstatus' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -telstatus' ][ 'Display' ][ 0 ], } # Start GUIs if needed for GUI in GUI_list : # Find out of GUIs are Running log . debug ( f \"Setting DISPLAY to kpf { display [ GUI [ 'display' ]] } \" ) env [ 'DISPLAY' ] = f \"kpf { display [ GUI [ 'display' ]] } \" window_names = get_window_list ( env = env ) GUIname = GUI [ 'name' ] if GUIname not in window_names and args . get ( 'position_only' , False ) is False : instrume = ktl . cache ( 'dcs1' , 'INSTRUME' ) if GUIname == 'MAGIQ - Observer UI: KPF on Keck1' and instrume . read () != 'KPF' : log . info ( f 'Selected instrument is not KPF, not starting magiq' ) success = False else : log . info ( f \"Starting ' { GUIname } ' GUI\" ) gui_proc = subprocess . Popen ( GUI [ 'cmd' ], env = env , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) success = waitfor_window_to_appear ( GUIname , env = env ) if success is False : log . error ( f ' { GUIname } did not come up' ) stdout , stderr = gui_proc . communicate () log . error ( f \"STDERR: { stderr . decode () } \" ) log . error ( f \"STDOUT: { stdout . decode () } \" ) else : log . info ( f \"Existing ' { GUIname } ' window found\" ) success = True time . sleep ( 2 ) if GUI . get ( 'position' , None ) is not None and success is True : log . info ( f \"Positioning ' { GUIname } ' GUI\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , f '\" { GUIname } \"' , '-e' , GUI [ 'position' ]] log . debug ( f \" Running: { ' ' . join ( wmctrl_cmd ) } \" ) wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUI [ 'cmd' ][ 0 ] == 'xterm' : xterm_title = GUI [ 'cmd' ][ 2 ] success = waitfor_window_to_appear ( xterm_title , env = env ) log . info ( f \"Minimizing ' { xterm_title } '\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , xterm_title , '-b' , 'add,hidden' ] wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUIname == 'SAOImage kpfds9' : # Configure ds9 initial color maps and scaling cmaps = { '1' : 'cool' , '2' : 'green' , '3' : 'heat' } for frameno in cmaps . keys (): xpaset_cmds = [[ 'xpaset' , '-p' , 'kpfds9' , 'frame' , 'frameno' , f ' { frameno } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'cmap' , f ' { cmaps [ frameno ] } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'scale' , '99.5' ]] for xpaset_cmd in xpaset_cmds : xpa_proc = subprocess . Popen ( xpaset_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--position\" , \"-p\" , dest = \"position_only\" , default = False , action = \"store_true\" , help = \"Only position the GUIs, do not start\" ) return super () . add_cmdline_args ( parser )","title":"StartGUIs"},{"location":"scripts/StartGUIs/#startguis","text":"Bases: KPFFunction Start KPF GUIs Source code in kpf/utils/StartGUIs.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 class StartGUIs ( KPFFunction ): '''Start KPF GUIs ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Get DISPLAY varibales env = os . environ uidisp = {} kvncstatus_proc = subprocess . run ([ 'kvncstatus' ], env = env , stdout = subprocess . PIPE ) kvncstatus = Table . read ( kvncstatus_proc . stdout . decode (), format = 'ascii' ) username = os . getlogin () display = { 'control0' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control0' ][ 'Display' ][ 0 ], 'control1' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control1' ][ 'Display' ][ 0 ], 'control2' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -control2' ][ 'Display' ][ 0 ], 'telstatus' : kvncstatus [ kvncstatus [ 'Desktop' ] == f 'kpf- { username } -telstatus' ][ 'Display' ][ 0 ], } # Start GUIs if needed for GUI in GUI_list : # Find out of GUIs are Running log . debug ( f \"Setting DISPLAY to kpf { display [ GUI [ 'display' ]] } \" ) env [ 'DISPLAY' ] = f \"kpf { display [ GUI [ 'display' ]] } \" window_names = get_window_list ( env = env ) GUIname = GUI [ 'name' ] if GUIname not in window_names and args . get ( 'position_only' , False ) is False : instrume = ktl . cache ( 'dcs1' , 'INSTRUME' ) if GUIname == 'MAGIQ - Observer UI: KPF on Keck1' and instrume . read () != 'KPF' : log . info ( f 'Selected instrument is not KPF, not starting magiq' ) success = False else : log . info ( f \"Starting ' { GUIname } ' GUI\" ) gui_proc = subprocess . Popen ( GUI [ 'cmd' ], env = env , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) success = waitfor_window_to_appear ( GUIname , env = env ) if success is False : log . error ( f ' { GUIname } did not come up' ) stdout , stderr = gui_proc . communicate () log . error ( f \"STDERR: { stderr . decode () } \" ) log . error ( f \"STDOUT: { stdout . decode () } \" ) else : log . info ( f \"Existing ' { GUIname } ' window found\" ) success = True time . sleep ( 2 ) if GUI . get ( 'position' , None ) is not None and success is True : log . info ( f \"Positioning ' { GUIname } ' GUI\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , f '\" { GUIname } \"' , '-e' , GUI [ 'position' ]] log . debug ( f \" Running: { ' ' . join ( wmctrl_cmd ) } \" ) wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUI [ 'cmd' ][ 0 ] == 'xterm' : xterm_title = GUI [ 'cmd' ][ 2 ] success = waitfor_window_to_appear ( xterm_title , env = env ) log . info ( f \"Minimizing ' { xterm_title } '\" ) wmctrl_cmd = [ 'wmctrl' , '-r' , xterm_title , '-b' , 'add,hidden' ] wmctrl_proc = subprocess . run ( ' ' . join ( wmctrl_cmd ), env = env , shell = True ) if GUIname == 'SAOImage kpfds9' : # Configure ds9 initial color maps and scaling cmaps = { '1' : 'cool' , '2' : 'green' , '3' : 'heat' } for frameno in cmaps . keys (): xpaset_cmds = [[ 'xpaset' , '-p' , 'kpfds9' , 'frame' , 'frameno' , f ' { frameno } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'cmap' , f ' { cmaps [ frameno ] } ' ], [ 'xpaset' , '-p' , 'kpfds9' , 'scale' , '99.5' ]] for xpaset_cmd in xpaset_cmds : xpa_proc = subprocess . Popen ( xpaset_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) time . sleep ( 1 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--position\" , \"-p\" , dest = \"position_only\" , default = False , action = \"store_true\" , help = \"Only position the GUIs, do not start\" ) return super () . add_cmdline_args ( parser )","title":"StartGUIs"},{"location":"scripts/StartGuiderContinuous/","text":"StartGuiderContinuous Bases: KPFFunction Put the guider in to continuous exposure mode and set images to be saved. KTL Keywords Used: kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/guider/StartGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class StartGuiderContinuous ( KPFFunction ): '''Put the guider in to continuous exposure mode and set images to be saved. KTL Keywords Used: - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'active' ) kpfguide [ 'SAVE' ] . write ( 'active' ) @classmethod def post_condition ( cls , args ): if guider_is_active () == False : raise FailedPostCondition ( 'Guider is not active' ) if guider_is_saving () == False : raise FailedPostCondition ( 'Guider is not saving' )","title":"StartGuiderContinuous"},{"location":"scripts/StartGuiderContinuous/#startguidercontinuous","text":"Bases: KPFFunction Put the guider in to continuous exposure mode and set images to be saved. KTL Keywords Used: kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/guider/StartGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class StartGuiderContinuous ( KPFFunction ): '''Put the guider in to continuous exposure mode and set images to be saved. KTL Keywords Used: - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'active' ) kpfguide [ 'SAVE' ] . write ( 'active' ) @classmethod def post_condition ( cls , args ): if guider_is_active () == False : raise FailedPostCondition ( 'Guider is not active' ) if guider_is_saving () == False : raise FailedPostCondition ( 'Guider is not saving' )","title":"StartGuiderContinuous"},{"location":"scripts/StartOfNight/","text":"StartOfNight Bases: KPFFunction Send KPF in to a reasonable starting configuration set FIU mode to observing reset guider bias/sky subtraction file to default Setup AO for KPF Configure DCS (ROTDEST and ROTMODE) ARGS: AO - bool Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) Source code in kpf/utils/StartOfNight.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class StartOfNight ( KPFFunction ): '''Send KPF in to a reasonable starting configuration - set FIU mode to observing - reset guider bias/sky subtraction file to default - Setup AO for KPF - Configure DCS (ROTDEST and ROTMODE) ARGS: ===== * __AO__ - `bool` Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): log . info ( f \"Running KPF Start of Night script\" ) # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) script_running = scriptname not in [ '' , 'None' , None ] or pid >= 0 if script_running and args . get ( 'confirm' , False ) is True : log . error ( 'Non-interactive mode set and script is running' ) return if script_running : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Depending on when you are seeing this, it may be a scheduled\" , \"nighttime calibration which can and should be interrupted to\" , \"enable observing.\" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running StartOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Disallow cron job calibration scripts log . info ( 'Set ALLOWSCHEDULEDCALS to No' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'No' ) HKCOOLING = ktl . cache ( 'kpf_hk' , 'COOLING' ) if HKCOOLING . read () != 'On' : log . warning ( 'HK Detector Cooling is not On' ) # Set Observer SetObserverFromSchedule . execute ({}) # Configure FIU log . info ( 'Configure FIU for \"Observing\"' ) ConfigureFIU . execute ({ 'mode' : 'Observing' }) # Reset CRED2 subtraction file to default kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ f 'SUB_HIGH' ] . write ( f '/kroot/rel/default/data/kpfguide/kpfguide_gain_high.fits' ) # Set DCS rotator parameters dcs = ktl . cache ( 'dcs1' ) inst = dcs [ 'INSTRUME' ] . read () if inst == 'KPF' : log . info ( f \"Setting dcs.ROTDEST = 0\" ) dcs [ 'ROTDEST' ] . write ( 0 ) log . info ( f \"Setting dcs.ROTMODE = stationary\" ) dcs [ 'ROTMODE' ] . write ( 'stationary' ) else : log . warning ( f \"Instrument is { inst } , not configuring DCS\" ) # Report Agitator status runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : log . info ( f \"Agitator use is enabled\" ) else : log . warning ( f \"Agitator use is disabled for tonight\" ) # Pre-configure cal source calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () log . info ( f \"Setting simultaneous CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : True }) # Power on Simulcal lamp if needed if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'on' }) # Set tip tilt loop gain to default value tip_tilt_gain = cfg . getfloat ( 'tiptilt' , 'tiptilt_loop_gain' , fallback = 0.3 ) log . info ( f \"Setting default tip tilt loop gain of { tip_tilt_gain } \" ) SetTipTiltGain . execute ({ 'GuideLoopGain' : tip_tilt_gain }) # Set tip tilt loop detection threshold to default value detect_snr = cfg . getfloat ( 'tiptilt' , 'detect_snr' , fallback = 7 ) log . info ( f \"Setting default tip tilt detection SNR of { detect_snr } \" ) kpfguide [ 'OBJECT_INTENSITY' ] . write ( detect_snr ) # Set tip tilt loop detection area to default value detect_area = cfg . getfloat ( 'tiptilt' , 'detect_area' , fallback = 100 ) log . info ( f \"Setting default tip tilt detection area of { detect_area } \" ) kpfguide [ 'OBJECT_AREA' ] . write ( detect_area ) # Set tip tilt loop deblend parameter to default value deblend = cfg . getfloat ( 'tiptilt' , 'deblend' , fallback = 1 ) log . info ( f \"Setting default tip tilt deblending parameter of { deblend } \" ) kpfguide [ 'OBJECT_DBCONT' ] . write ( 1.0 ) # Set DAR parameter to default value log . info ( f \"Ensuring DAR correction is on\" ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) # Set Outdirs if expose . read () != 'Ready' : log . info ( 'Waiting for kpfexpose to be Ready' ) WaitForReady . execute ({}) SetOutdirs . execute ({}) # Set guider gain to high for initial acquisition and focus SetGuiderGain . execute ({ 'GuideCamGain' : 'high' }) # Summarize Detector Disabled States cahk_enabled = kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) if cahk_enabled is False : log . warning ( f \"The CA_HK detector is disabled tonight\" ) green_enabled = kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) if green_enabled is False : log . warning ( f \"The Green detector is disabled tonight\" ) red_enabled = kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) if red_enabled is False : log . warning ( f \"The Red detector is disabled tonight\" ) expmeter_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) if expmeter_enabled is False : log . warning ( f \"The ExpMeter detector is disabled tonight\" ) # Setup AO if args . get ( 'AO' , True ) is True and args . get ( 'confirm' , False ) is False : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"This script will configure the FIU and AO bench for observing.\" , \"The AO bench area should be clear of personnel before proceeding.\" , \"Do you wish to to continue?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : SetupAOforKPF . execute ({}) log . info ( 'Open AO hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'open' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) print () print ( '----------------------------------------------------------' ) print ( 'AO hatch reported problems moving. Make sure stars are' ) print ( 'visible on guide camera before proceeding.' ) print ( '----------------------------------------------------------' ) print () @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) parser . add_argument ( \"--confirm\" , dest = \"confirm\" , default = False , action = \"store_true\" , help = \"Skip confirmation questions (script will be non interactive)?\" ) return super () . add_cmdline_args ( parser )","title":"StartOfNight"},{"location":"scripts/StartOfNight/#startofnight","text":"Bases: KPFFunction Send KPF in to a reasonable starting configuration set FIU mode to observing reset guider bias/sky subtraction file to default Setup AO for KPF Configure DCS (ROTDEST and ROTMODE)","title":"StartOfNight"},{"location":"scripts/StartOfNight/#kpf.utils.StartOfNight.StartOfNight--args","text":"AO - bool Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) Source code in kpf/utils/StartOfNight.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 class StartOfNight ( KPFFunction ): '''Send KPF in to a reasonable starting configuration - set FIU mode to observing - reset guider bias/sky subtraction file to default - Setup AO for KPF - Configure DCS (ROTDEST and ROTMODE) ARGS: ===== * __AO__ - `bool` Open AO hatch, send PCU to KPF, and turn on HEPA? (default=True) ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): pass @classmethod @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): log . info ( f \"Running KPF Start of Night script\" ) # Check Scripts kpfconfig = ktl . cache ( 'kpfconfig' ) expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) scriptname = kpfconfig [ 'SCRIPTNAME' ] . read () pid = kpfconfig [ 'SCRIPTPID' ] . read ( binary = True ) script_running = scriptname not in [ '' , 'None' , None ] or pid >= 0 if script_running and args . get ( 'confirm' , False ) is True : log . error ( 'Non-interactive mode set and script is running' ) return if script_running : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , f \"A script ( { scriptname } , { pid } ) is currently running. \" , \"\" , \"Depending on when you are seeing this, it may be a scheduled\" , \"nighttime calibration which can and should be interrupted to\" , \"enable observing.\" , \"\" , \"Do you wish to end the current exposure and request a script\" , \"stop in order to proceed with running StartOfNight?\" , \"\" , \"End Exposure and Request Script Stop?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : log . info ( 'User opted to stop existing script' ) kpfconfig [ 'SCRIPTSTOP' ] . write ( 1 ) expose . write ( 'End' ) waittime = 120 log . info ( f 'Waiting up to { waittime : .0f } s for running script to end' ) kpfconfig [ 'SCRIPTPID' ] . waitFor ( \"==-1\" , timeout = waittime ) time . sleep ( 2 ) # time shim check_script_running () # --------------------------------- # Remaining non-AO Actions # --------------------------------- # Disallow cron job calibration scripts log . info ( 'Set ALLOWSCHEDULEDCALS to No' ) kpfconfig = ktl . cache ( 'kpfconfig' ) kpfconfig [ 'ALLOWSCHEDULEDCALS' ] . write ( 'No' ) HKCOOLING = ktl . cache ( 'kpf_hk' , 'COOLING' ) if HKCOOLING . read () != 'On' : log . warning ( 'HK Detector Cooling is not On' ) # Set Observer SetObserverFromSchedule . execute ({}) # Configure FIU log . info ( 'Configure FIU for \"Observing\"' ) ConfigureFIU . execute ({ 'mode' : 'Observing' }) # Reset CRED2 subtraction file to default kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ f 'SUB_HIGH' ] . write ( f '/kroot/rel/default/data/kpfguide/kpfguide_gain_high.fits' ) # Set DCS rotator parameters dcs = ktl . cache ( 'dcs1' ) inst = dcs [ 'INSTRUME' ] . read () if inst == 'KPF' : log . info ( f \"Setting dcs.ROTDEST = 0\" ) dcs [ 'ROTDEST' ] . write ( 0 ) log . info ( f \"Setting dcs.ROTMODE = stationary\" ) dcs [ 'ROTMODE' ] . write ( 'stationary' ) else : log . warning ( f \"Instrument is { inst } , not configuring DCS\" ) # Report Agitator status runagitator = kpfconfig [ 'USEAGITATOR' ] . read ( binary = True ) if runagitator is True : log . info ( f \"Agitator use is enabled\" ) else : log . warning ( f \"Agitator use is disabled for tonight\" ) # Pre-configure cal source calsource = kpfconfig [ 'SIMULCALSOURCE' ] . read () log . info ( f \"Setting simultaneous CalSource/Octagon: { calsource } \" ) SetCalSource . execute ({ 'CalSource' : calsource , 'wait' : True }) # Power on Simulcal lamp if needed if calsource in [ 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' ]: CalLampPower . execute ({ 'lamp' : calsource , 'power' : 'on' }) # Set tip tilt loop gain to default value tip_tilt_gain = cfg . getfloat ( 'tiptilt' , 'tiptilt_loop_gain' , fallback = 0.3 ) log . info ( f \"Setting default tip tilt loop gain of { tip_tilt_gain } \" ) SetTipTiltGain . execute ({ 'GuideLoopGain' : tip_tilt_gain }) # Set tip tilt loop detection threshold to default value detect_snr = cfg . getfloat ( 'tiptilt' , 'detect_snr' , fallback = 7 ) log . info ( f \"Setting default tip tilt detection SNR of { detect_snr } \" ) kpfguide [ 'OBJECT_INTENSITY' ] . write ( detect_snr ) # Set tip tilt loop detection area to default value detect_area = cfg . getfloat ( 'tiptilt' , 'detect_area' , fallback = 100 ) log . info ( f \"Setting default tip tilt detection area of { detect_area } \" ) kpfguide [ 'OBJECT_AREA' ] . write ( detect_area ) # Set tip tilt loop deblend parameter to default value deblend = cfg . getfloat ( 'tiptilt' , 'deblend' , fallback = 1 ) log . info ( f \"Setting default tip tilt deblending parameter of { deblend } \" ) kpfguide [ 'OBJECT_DBCONT' ] . write ( 1.0 ) # Set DAR parameter to default value log . info ( f \"Ensuring DAR correction is on\" ) kpfguide [ 'DAR_ENABLE' ] . write ( 'Yes' ) # Set Outdirs if expose . read () != 'Ready' : log . info ( 'Waiting for kpfexpose to be Ready' ) WaitForReady . execute ({}) SetOutdirs . execute ({}) # Set guider gain to high for initial acquisition and focus SetGuiderGain . execute ({ 'GuideCamGain' : 'high' }) # Summarize Detector Disabled States cahk_enabled = kpfconfig [ 'CA_HK_ENABLED' ] . read ( binary = True ) if cahk_enabled is False : log . warning ( f \"The CA_HK detector is disabled tonight\" ) green_enabled = kpfconfig [ 'GREEN_ENABLED' ] . read ( binary = True ) if green_enabled is False : log . warning ( f \"The Green detector is disabled tonight\" ) red_enabled = kpfconfig [ 'RED_ENABLED' ] . read ( binary = True ) if red_enabled is False : log . warning ( f \"The Red detector is disabled tonight\" ) expmeter_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read ( binary = True ) if expmeter_enabled is False : log . warning ( f \"The ExpMeter detector is disabled tonight\" ) # Setup AO if args . get ( 'AO' , True ) is True and args . get ( 'confirm' , False ) is False : # --------------------------------- # User Verification # --------------------------------- msg = [ \"\" , \"--------------------------------------------------------------\" , \"This script will configure the FIU and AO bench for observing.\" , \"The AO bench area should be clear of personnel before proceeding.\" , \"Do you wish to to continue?\" , \"(y/n) [y]:\" , \"--------------------------------------------------------------\" , \"\" , ] for line in msg : print ( line ) user_input = input () if user_input . lower () in [ 'n' , 'no' , 'q' , 'quit' , 'abort' ]: log . warning ( f 'User aborted Start Of Night' ) return else : SetupAOforKPF . execute ({}) log . info ( 'Open AO hatch' ) try : ControlAOHatch . execute ({ 'destination' : 'open' }) except FailedToReachDestination : log . error ( f \"AO hatch did not move successfully\" ) print () print ( '----------------------------------------------------------' ) print ( 'AO hatch reported problems moving. Make sure stars are' ) print ( 'visible on guide camera before proceeding.' ) print ( '----------------------------------------------------------' ) print () @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( \"--noAO\" , dest = \"AO\" , default = True , action = \"store_false\" , help = \"Skip configuring AO?\" ) parser . add_argument ( \"--confirm\" , dest = \"confirm\" , default = False , action = \"store_true\" , help = \"Skip confirmation questions (script will be non interactive)?\" ) return super () . add_cmdline_args ( parser )","title":"ARGS:"},{"location":"scripts/StartTipTilt/","text":"StartTipTilt Bases: KPFFunction Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: kpffiu.TTXSRV kpffiu.TTYSRV kpfguide.DAR_ENABLE kpfguide.ALL_LOOPS Source code in kpf/fiu/StartTipTilt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class StartTipTilt ( KPFFunction ): '''Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpfguide.DAR_ENABLE` - `kpfguide.ALL_LOOPS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expr = \"($kpffiu.TTXSRV == 'Closed') and ($kpffiu.TTYSRV == 'Closed')\" servo_loops_closed = ktl . waitFor ( expr , timeout = 0.5 ) if not servo_loops_closed : kpffiu = ktl . cache ( 'kpffiu' ) log . info ( 'Closing servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'Closed' ) kpffiu [ 'TTYSRV' ] . write ( 'Closed' ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( 10 * movetime ) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Turning kpfguide.ALL_LOOPS on' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args ): pass","title":"StartTipTilt"},{"location":"scripts/StartTipTilt/#starttiptilt","text":"Bases: KPFFunction Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: kpffiu.TTXSRV kpffiu.TTYSRV kpfguide.DAR_ENABLE kpfguide.ALL_LOOPS Source code in kpf/fiu/StartTipTilt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class StartTipTilt ( KPFFunction ): '''Start the tip tilt control loop. This uses the ALL_LOOPS keyword to start all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: - `kpffiu.TTXSRV` - `kpffiu.TTYSRV` - `kpfguide.DAR_ENABLE` - `kpfguide.ALL_LOOPS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expr = \"($kpffiu.TTXSRV == 'Closed') and ($kpffiu.TTYSRV == 'Closed')\" servo_loops_closed = ktl . waitFor ( expr , timeout = 0.5 ) if not servo_loops_closed : kpffiu = ktl . cache ( 'kpffiu' ) log . info ( 'Closing servo loops' ) kpffiu [ 'TTXSRV' ] . write ( 'Closed' ) kpffiu [ 'TTYSRV' ] . write ( 'Closed' ) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) time . sleep ( 10 * movetime ) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( 'Turning kpfguide.ALL_LOOPS on' ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args ): pass","title":"StartTipTilt"},{"location":"scripts/StartTriggerFile/","text":"StartTriggerFile Bases: KPFFunction Start a \"trigger file\" from the guide camera. KTL Keywords Used: kpfguide.TRIGCUBE kpfguide.TRIGGER Source code in kpf/guider/StartTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StartTriggerFile ( KPFFunction ): '''Start a \"trigger file\" from the guide camera. KTL Keywords Used: - `kpfguide.TRIGCUBE` - `kpfguide.TRIGGER` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) cube = kpfguide [ 'TRIGCUBE' ] . read () log . info ( f \"Start guider trigger file data collection: TRIGCUBE= { cube } \" ) kpfguide [ 'TRIGGER' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args ): pass","title":"StartTriggerFile"},{"location":"scripts/StartTriggerFile/#starttriggerfile","text":"Bases: KPFFunction Start a \"trigger file\" from the guide camera. KTL Keywords Used: kpfguide.TRIGCUBE kpfguide.TRIGGER Source code in kpf/guider/StartTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StartTriggerFile ( KPFFunction ): '''Start a \"trigger file\" from the guide camera. KTL Keywords Used: - `kpfguide.TRIGCUBE` - `kpfguide.TRIGGER` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) cube = kpfguide [ 'TRIGCUBE' ] . read () log . info ( f \"Start guider trigger file data collection: TRIGCUBE= { cube } \" ) kpfguide [ 'TRIGGER' ] . write ( 'Active' ) @classmethod def post_condition ( cls , args ): pass","title":"StartTriggerFile"},{"location":"scripts/StopAgitator/","text":"StopAgitator Bases: KPFFunction Stop the agitator motion. KTL Keywords Used: kpfmot.AGITATOR Source code in kpf/spectrograph/StopAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopAgitator ( KPFFunction ): '''Stop the agitator motion. KTL Keywords Used: - `kpfmot.AGITATOR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . read () == 'Stopped' : log . debug ( 'Agitator is stopped' ) else : log . debug ( 'Stopping agitator' ) try : AGITATOR . write ( 'Stop' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) AGITATOR . write ( 'Stop' ) @classmethod def post_condition ( cls , args ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . waitFor ( '== \"Stopped\"' , timeout = 5 * startup ) is not True : raise FailedToReachDestination ( AGITATOR . read (), 'Stopped' )","title":"StopAgitator"},{"location":"scripts/StopAgitator/#stopagitator","text":"Bases: KPFFunction Stop the agitator motion. KTL Keywords Used: kpfmot.AGITATOR Source code in kpf/spectrograph/StopAgitator.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopAgitator ( KPFFunction ): '''Stop the agitator motion. KTL Keywords Used: - `kpfmot.AGITATOR` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . read () == 'Stopped' : log . debug ( 'Agitator is stopped' ) else : log . debug ( 'Stopping agitator' ) try : AGITATOR . write ( 'Stop' ) except Exception as e : log . warning ( 'Write to kpfmot.AGITATOR failed' ) log . debug ( e ) log . warning ( 'Retrying' ) time . sleep ( 1 ) AGITATOR . write ( 'Stop' ) @classmethod def post_condition ( cls , args ): startup = cfg . getfloat ( 'times' , 'agitator_startup_time' , fallback = 0.325 ) AGITATOR = ktl . cache ( 'kpfmot' , 'AGITATOR' ) if AGITATOR . waitFor ( '== \"Stopped\"' , timeout = 5 * startup ) is not True : raise FailedToReachDestination ( AGITATOR . read (), 'Stopped' )","title":"StopAgitator"},{"location":"scripts/StopGUIs/","text":"StopGUIs Bases: KPFFunction Stop KPF GUIs ARGS None Source code in kpf/utils/StopGUIs.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class StopGUIs ( KPFFunction ): '''Stop KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): for GUI in GUI_list : GUIname = GUI [ 'name' ] if GUI [ 'cmd' ][ 0 ] == 'kpf' : GUIscriptname = GUI [ 'cmd' ][ 2 ] status_cmd = GUI [ 'cmd' ] status_cmd [ 1 ] = 'status' log . info ( f \"Getting status of ' { GUIname } ' GUI\" ) gui_proc = subprocess . run ( status_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) stdout = gui_proc . stdout . decode () . strip () is_running = re . search ( 'is running on' , stdout ) if is_running is not None : stop_cmd = GUI [ 'cmd' ] stop_cmd [ 1 ] = 'stop' log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stopout = subprocess . run ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" { stopout . returncode } \" ) log . debug ( f \" { stopout . stdout . decode () } \" ) log . debug ( f \" { stopout . stderr . decode () } \" ) else : log . info ( f \" { GUIname } is not running\" ) log . debug ( f \" { stdout } \" ) elif GUIname == 'MAGIQ - Observer UI' : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stop_cmd = GUI [ 'cmd' ] stop_cmd [ 4 ] = 'stop' gui_proc = subprocess . Popen ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) else : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) kill_process ( GUI [ 'cmd' ], server = 'kpf' ) @classmethod def post_condition ( cls , args ): pass","title":"StopGUIs"},{"location":"scripts/StopGUIs/#stopguis","text":"Bases: KPFFunction Stop KPF GUIs","title":"StopGUIs"},{"location":"scripts/StopGUIs/#kpf.utils.StopGUIs.StopGUIs--args","text":"None Source code in kpf/utils/StopGUIs.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class StopGUIs ( KPFFunction ): '''Stop KPF GUIs ### ARGS None ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): for GUI in GUI_list : GUIname = GUI [ 'name' ] if GUI [ 'cmd' ][ 0 ] == 'kpf' : GUIscriptname = GUI [ 'cmd' ][ 2 ] status_cmd = GUI [ 'cmd' ] status_cmd [ 1 ] = 'status' log . info ( f \"Getting status of ' { GUIname } ' GUI\" ) gui_proc = subprocess . run ( status_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) stdout = gui_proc . stdout . decode () . strip () is_running = re . search ( 'is running on' , stdout ) if is_running is not None : stop_cmd = GUI [ 'cmd' ] stop_cmd [ 1 ] = 'stop' log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stopout = subprocess . run ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) log . debug ( f \" { stopout . returncode } \" ) log . debug ( f \" { stopout . stdout . decode () } \" ) log . debug ( f \" { stopout . stderr . decode () } \" ) else : log . info ( f \" { GUIname } is not running\" ) log . debug ( f \" { stdout } \" ) elif GUIname == 'MAGIQ - Observer UI' : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) stop_cmd = GUI [ 'cmd' ] stop_cmd [ 4 ] = 'stop' gui_proc = subprocess . Popen ( stop_cmd , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) else : log . info ( f \"Stopping ' { GUIname } ' GUI\" ) kill_process ( GUI [ 'cmd' ], server = 'kpf' ) @classmethod def post_condition ( cls , args ): pass","title":"ARGS"},{"location":"scripts/StopGuiderContinuous/","text":"StopGuiderContinuous Bases: KPFFunction Stop the guider's continuous exposure mode and stop saving images. KTL Keywords Used: kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/guider/StopGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class StopGuiderContinuous ( KPFFunction ): '''Stop the guider's continuous exposure mode and stop saving images. KTL Keywords Used: - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'inactive' ) kpfguide [ 'SAVE' ] . write ( 'inactive' ) @classmethod def post_condition ( cls , args ): if guider_is_active () != False : raise FailedPostCondition ( 'Guider is not inactive' ) if guider_is_saving () != False : raise FailedPostCondition ( 'Guider is still saving' )","title":"StopGuiderContinuous"},{"location":"scripts/StopGuiderContinuous/#stopguidercontinuous","text":"Bases: KPFFunction Stop the guider's continuous exposure mode and stop saving images. KTL Keywords Used: kpfguide.CONTINUOUS kpfguide.SAVE Source code in kpf/guider/StopGuiderContinuous.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class StopGuiderContinuous ( KPFFunction ): '''Stop the guider's continuous exposure mode and stop saving images. KTL Keywords Used: - `kpfguide.CONTINUOUS` - `kpfguide.SAVE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) kpfguide [ 'CONTINUOUS' ] . write ( 'inactive' ) kpfguide [ 'SAVE' ] . write ( 'inactive' ) @classmethod def post_condition ( cls , args ): if guider_is_active () != False : raise FailedPostCondition ( 'Guider is not inactive' ) if guider_is_saving () != False : raise FailedPostCondition ( 'Guider is still saving' )","title":"StopGuiderContinuous"},{"location":"scripts/StopTipTilt/","text":"StopTipTilt Bases: KPFFunction Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: kpfguide.TIPTILT_CALC kpfguide.TIPTILT_CONTROL kpfguide.OFFLOAD kpfguide.ALL_LOOPS Source code in kpf/fiu/StopTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopTipTilt ( KPFFunction ): '''Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: - `kpfguide.TIPTILT_CALC` - `kpfguide.TIPTILT_CONTROL` - `kpfguide.OFFLOAD` - `kpfguide.ALL_LOOPS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ALL_LOOPS = ktl . cache ( 'kpfguide' , 'ALL_LOOPS' ) ALL_LOOPS . write ( 'Inactive' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) if TIPTILT_CALC . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( TIPTILT_CALC . read (), 'Inactive' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) if TIPTILT_CONTROL . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( TIPTILT_CONTROL . read (), 'Inactive' ) OFFLOAD = ktl . cache ( 'kpfguide' , 'OFFLOAD' ) if OFFLOAD . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( OFFLOAD . read (), 'Inactive' )","title":"StopTipTilt"},{"location":"scripts/StopTipTilt/#stoptiptilt","text":"Bases: KPFFunction Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: kpfguide.TIPTILT_CALC kpfguide.TIPTILT_CONTROL kpfguide.OFFLOAD kpfguide.ALL_LOOPS Source code in kpf/fiu/StopTipTilt.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class StopTipTilt ( KPFFunction ): '''Stop the tip tilt control loop. This uses the ALL_LOOPS keyword to stop all functions including DAR (via DAR_ENABLE), tip tilt calculations (via TIPTILT_CALC), tip tilt control (via TIPTILT_CONTROL), offloading to the telescope (via OFFLOAD_DCS and OFFLOAD). KTL Keywords Used: - `kpfguide.TIPTILT_CALC` - `kpfguide.TIPTILT_CONTROL` - `kpfguide.OFFLOAD` - `kpfguide.ALL_LOOPS` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ALL_LOOPS = ktl . cache ( 'kpfguide' , 'ALL_LOOPS' ) ALL_LOOPS . write ( 'Inactive' ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) TIPTILT_CALC = ktl . cache ( 'kpfguide' , 'TIPTILT_CALC' ) if TIPTILT_CALC . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( TIPTILT_CALC . read (), 'Inactive' ) TIPTILT_CONTROL = ktl . cache ( 'kpfguide' , 'TIPTILT_CONTROL' ) if TIPTILT_CONTROL . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( TIPTILT_CONTROL . read (), 'Inactive' ) OFFLOAD = ktl . cache ( 'kpfguide' , 'OFFLOAD' ) if OFFLOAD . waitFor ( \"== 'Inactive'\" ) is False : raise FailedToReachDestination ( OFFLOAD . read (), 'Inactive' )","title":"StopTipTilt"},{"location":"scripts/StopTriggerFile/","text":"StopTriggerFile Bases: KPFFunction Stop a \"trigger file\" from the guide camera. KTL Keywords Used: kpfguide.TRIGGER Source code in kpf/guider/StopTriggerFile.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class StopTriggerFile ( KPFFunction ): '''Stop a \"trigger file\" from the guide camera. KTL Keywords Used: - `kpfguide.TRIGGER` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): TRIGGER = ktl . cache ( 'kpfguide' , 'TRIGGER' ) log . info ( f \"Stopping guider trigger file data collection\" ) TRIGGER . write ( 'Inactive' ) @classmethod def post_condition ( cls , args ): pass","title":"StopTriggerFile"},{"location":"scripts/StopTriggerFile/#stoptriggerfile","text":"Bases: KPFFunction Stop a \"trigger file\" from the guide camera. KTL Keywords Used: kpfguide.TRIGGER Source code in kpf/guider/StopTriggerFile.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class StopTriggerFile ( KPFFunction ): '''Stop a \"trigger file\" from the guide camera. KTL Keywords Used: - `kpfguide.TRIGGER` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): TRIGGER = ktl . cache ( 'kpfguide' , 'TRIGGER' ) log . info ( f \"Stopping guider trigger file data collection\" ) TRIGGER . write ( 'Inactive' ) @classmethod def post_condition ( cls , args ): pass","title":"StopTriggerFile"},{"location":"scripts/SubmitObserverComment/","text":"SubmitObserverComment Bases: KPFFunction Adds a comment to the specified OB in the KPF-CC database. Also emails the PI of the associated program immediately with the comment. Parameters: OBid ( str ) \u2013 The unique identifier for the OB to comment on. observer ( str ) \u2013 The commenter/observer's name comment ( str ) \u2013 The comment to submit. Functions Called: kpf.observatoryAPIs.GetObservingBlocks kpf.utils.SendEmail Source code in kpf/observatoryAPIs/SubmitObserverComment.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class SubmitObserverComment ( KPFFunction ): '''Adds a comment to the specified OB in the KPF-CC database. Also emails the PI of the associated program immediately with the comment. Args: OBid (str): The unique identifier for the OB to comment on. observer (str): The commenter/observer's name comment (str): The comment to submit. Functions Called: - `kpf.observatoryAPIs.GetObservingBlocks` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): OBid = args . get ( 'OBid' , None ) if OBid is None : raise FailedPreCondition ( 'OBid must be provided' ) @classmethod def perform ( cls , args ): log . info ( f \"Running { cls . __name__ } \" ) if args . get ( 'OBid' , None ) == None : log . warning ( 'No OB ID found, unable to submit comment' ) return params = { 'id' : args . get ( 'OBid' , '' ), 'observer' : args . get ( 'observer' , '' ), 'comment' : args . get ( 'comment' , '' ), } # For testing # comments = ['an observer comment', 'another comment', 'this is a lot of comments for a single OB!', # 'This is a long soliloquy on the observing conditions during this observation which is here to make sure we do not have overly restrictive string length limits somewhere in the system.', # \"For completeness, a check on various inconvienient characters:\\nJohn O'Meara, Cecilia Payne-Gaposchkin, are question marks ok? (should I even ask?) [perhaps not] {right?}\"] # params[\"comment\"] = '\\n'.join(comments) log . info ( 'Submitting data to DB:' ) log . info ( params ) result = addObservingBlockHistory ( params ) log . info ( f \"Response: { result } \" ) # Email PI log . info ( f \"Collecting info to email the PI\" ) OB = GetObservingBlocks . execute ({ 'OBid' : args . get ( 'OBid' )})[ 0 ] if not isinstance ( OB , ObservingBlock ): log . error ( 'Unable to retrieve OB from API' ) log . error ( OB ) return result = getPI ( OB . semid ) if result . get ( 'success' , False ) == False : log . error ( 'Unable to retrieve PIinfo from API' ) else : PIinfo = result . get ( 'data' , {}) email = { 'To' : PIinfo . get ( 'Email' ), 'From' : 'cc@keck.hawaii.edu' , 'Subject' : f 'KPF Observer Comment on { OB . summary () } ' , 'Message' : args . get ( 'comment' , '' ), } SendEmail . execute ( email ) # import json # import logging # from pathlib import Path # # Set up temporary file for test emails to sit # for handler in log.handlers: # if isinstance(handler, logging.handlers.RotatingFileHandler): # kpflog_filehandler = handler # utnow = datetime.datetime.utcnow() # date = utnow-datetime.timedelta(days=1) # date_str = date.strftime('%Y%b%d').lower() # date_log_path = Path(kpflog_filehandler.baseFilename).parent / date_str # if date_log_path.exists() is False: # date_log_path.mkdir(mode=0o777, parents=True) # # Try to set permissions on the date directory # # necessary because the mode input to mkdir is modified by umask # try: # os.chmod(date_log_path, 0o777) # except OSError as e: # pass # email_buffer_file = date_log_path / 'emails.json' # if email_buffer_file.exists(): # with open(email_buffer_file, 'r') as f: # emails = json.loads(f.read()) # else: # emails = [] # emails.append(email) # print(emails) # with open(email_buffer_file, 'w') as f: # json.dump(emails, f) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'OBid' , type = str , help = 'The unique identifier for the OB.' ) parser . add_argument ( 'observer' , type = str , help = 'The observer submitting the comment.' ) parser . add_argument ( 'comment' , type = str , help = 'The comment.' ) return super () . add_cmdline_args ( parser )","title":"SubmitObserverComment"},{"location":"scripts/SubmitObserverComment/#submitobservercomment","text":"Bases: KPFFunction Adds a comment to the specified OB in the KPF-CC database. Also emails the PI of the associated program immediately with the comment. Parameters: OBid ( str ) \u2013 The unique identifier for the OB to comment on. observer ( str ) \u2013 The commenter/observer's name comment ( str ) \u2013 The comment to submit. Functions Called: kpf.observatoryAPIs.GetObservingBlocks kpf.utils.SendEmail Source code in kpf/observatoryAPIs/SubmitObserverComment.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class SubmitObserverComment ( KPFFunction ): '''Adds a comment to the specified OB in the KPF-CC database. Also emails the PI of the associated program immediately with the comment. Args: OBid (str): The unique identifier for the OB to comment on. observer (str): The commenter/observer's name comment (str): The comment to submit. Functions Called: - `kpf.observatoryAPIs.GetObservingBlocks` - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): OBid = args . get ( 'OBid' , None ) if OBid is None : raise FailedPreCondition ( 'OBid must be provided' ) @classmethod def perform ( cls , args ): log . info ( f \"Running { cls . __name__ } \" ) if args . get ( 'OBid' , None ) == None : log . warning ( 'No OB ID found, unable to submit comment' ) return params = { 'id' : args . get ( 'OBid' , '' ), 'observer' : args . get ( 'observer' , '' ), 'comment' : args . get ( 'comment' , '' ), } # For testing # comments = ['an observer comment', 'another comment', 'this is a lot of comments for a single OB!', # 'This is a long soliloquy on the observing conditions during this observation which is here to make sure we do not have overly restrictive string length limits somewhere in the system.', # \"For completeness, a check on various inconvienient characters:\\nJohn O'Meara, Cecilia Payne-Gaposchkin, are question marks ok? (should I even ask?) [perhaps not] {right?}\"] # params[\"comment\"] = '\\n'.join(comments) log . info ( 'Submitting data to DB:' ) log . info ( params ) result = addObservingBlockHistory ( params ) log . info ( f \"Response: { result } \" ) # Email PI log . info ( f \"Collecting info to email the PI\" ) OB = GetObservingBlocks . execute ({ 'OBid' : args . get ( 'OBid' )})[ 0 ] if not isinstance ( OB , ObservingBlock ): log . error ( 'Unable to retrieve OB from API' ) log . error ( OB ) return result = getPI ( OB . semid ) if result . get ( 'success' , False ) == False : log . error ( 'Unable to retrieve PIinfo from API' ) else : PIinfo = result . get ( 'data' , {}) email = { 'To' : PIinfo . get ( 'Email' ), 'From' : 'cc@keck.hawaii.edu' , 'Subject' : f 'KPF Observer Comment on { OB . summary () } ' , 'Message' : args . get ( 'comment' , '' ), } SendEmail . execute ( email ) # import json # import logging # from pathlib import Path # # Set up temporary file for test emails to sit # for handler in log.handlers: # if isinstance(handler, logging.handlers.RotatingFileHandler): # kpflog_filehandler = handler # utnow = datetime.datetime.utcnow() # date = utnow-datetime.timedelta(days=1) # date_str = date.strftime('%Y%b%d').lower() # date_log_path = Path(kpflog_filehandler.baseFilename).parent / date_str # if date_log_path.exists() is False: # date_log_path.mkdir(mode=0o777, parents=True) # # Try to set permissions on the date directory # # necessary because the mode input to mkdir is modified by umask # try: # os.chmod(date_log_path, 0o777) # except OSError as e: # pass # email_buffer_file = date_log_path / 'emails.json' # if email_buffer_file.exists(): # with open(email_buffer_file, 'r') as f: # emails = json.loads(f.read()) # else: # emails = [] # emails.append(email) # print(emails) # with open(email_buffer_file, 'w') as f: # json.dump(emails, f) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'OBid' , type = str , help = 'The unique identifier for the OB.' ) parser . add_argument ( 'observer' , type = str , help = 'The observer submitting the comment.' ) parser . add_argument ( 'comment' , type = str , help = 'The comment.' ) return super () . add_cmdline_args ( parser )","title":"SubmitObserverComment"},{"location":"scripts/TakeADCGridData/","text":"TakeADCGridData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeADCGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1min = args . get ( 'ADC1MIN' , 60 ) adc1max = args . get ( 'ADC1MAX' , 70 ) adc2min = args . get ( 'ADC2MIN' , 60 ) adc2max = args . get ( 'ADC2MAX' , 70 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1vals = np . arange ( adc1min , adc1max + adcstep , adcstep ) adc2vals = np . arange ( adc2min , adc2max + adcstep , adcstep ) adcsleeptime = 1 fvcsleeptime = 0.25 ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' )) for i , adc1 in enumerate ( adc1vals ): for j , adc2 in enumerate ( adc2vals ): log . info ( f 'Moving ADC1 to { adc1 : .1f } , ADC2 to { adc2 : .1f } ' ) ADC1VAL . write ( f \" { adc1 : .1f } \" ) ADC2VAL . write ( f \" { adc2 : .1f } \" ) time . sleep ( adcsleeptime ) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1MIN' , type = float , help = \"Starting ADC1 angle\" ) parser . add_argument ( 'ADC1MAX' , type = float , help = \"Ending ADC1 angle\" ) parser . add_argument ( 'ADC2MIN' , type = float , help = \"Starting ADC2 angle\" ) parser . add_argument ( 'ADC2MAX' , type = float , help = \"Ending ADC2 angle\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCGridData"},{"location":"scripts/TakeADCGridData/#takeadcgriddata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeADCGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1min = args . get ( 'ADC1MIN' , 60 ) adc1max = args . get ( 'ADC1MAX' , 70 ) adc2min = args . get ( 'ADC2MIN' , 60 ) adc2max = args . get ( 'ADC2MAX' , 70 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1vals = np . arange ( adc1min , adc1max + adcstep , adcstep ) adc2vals = np . arange ( adc2min , adc2max + adcstep , adcstep ) adcsleeptime = 1 fvcsleeptime = 0.25 ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' )) for i , adc1 in enumerate ( adc1vals ): for j , adc2 in enumerate ( adc2vals ): log . info ( f 'Moving ADC1 to { adc1 : .1f } , ADC2 to { adc2 : .1f } ' ) ADC1VAL . write ( f \" { adc1 : .1f } \" ) ADC2VAL . write ( f \" { adc2 : .1f } \" ) time . sleep ( adcsleeptime ) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1MIN' , type = float , help = \"Starting ADC1 angle\" ) parser . add_argument ( 'ADC1MAX' , type = float , help = \"Ending ADC1 angle\" ) parser . add_argument ( 'ADC2MIN' , type = float , help = \"Starting ADC2 angle\" ) parser . add_argument ( 'ADC2MAX' , type = float , help = \"Ending ADC2 angle\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCGridData"},{"location":"scripts/TakeADCOffsetGridData/","text":"TakeADCOffsetGridData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCOffsetGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TakeADCOffsetGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1delta = args . get ( 'ADC1DELTA' , 5 ) adc2delta = args . get ( 'ADC2DELTA' , 5 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1deltas = np . arange ( - adc1delta , adc1delta , adcstep ) adc2deltas = np . arange ( - adc2delta , adc2delta , adcstep ) fvcsleeptime = 0.25 ADCPRISMS = ktl . cache ( 'kpffiu' , 'ADCPRISMS' ) ADCPRISMS . monitor () ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'DELTA1' , 'DELTA2' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' , 'f4' , 'f4' )) for i , delta1 in enumerate ( adc1deltas ): for j , delta2 in enumerate ( adc2deltas ): log . info ( f 'Moving ADCs to offset positions: { delta1 : .1f } , { delta2 : .1f } ' ) SetADCOffsets . execute ({ 'ADC1OFF' : delta1 , 'ADC2OFF' : delta2 }) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'DELTA1' : delta1 , 'DELTA2' : delta2 , 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1DELTA' , type = float , help = \"Maximum ADC1 offset from nominal\" ) parser . add_argument ( 'ADC2DELTA' , type = float , help = \"Maximum ADC2 offset from nominal\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCOffsetGridData"},{"location":"scripts/TakeADCOffsetGridData/#takeadcoffsetgriddata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeADCOffsetGridData.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class TakeADCOffsetGridData ( KPFTranslatorFunction ): ''' ''' @classmethod def pre_condition ( cls , OB , logger , cfg ): pass @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in args : log . debug ( f \" { key } : { args [ key ] } \" ) log . info ( '-------------------------' ) adc1delta = args . get ( 'ADC1DELTA' , 5 ) adc2delta = args . get ( 'ADC2DELTA' , 5 ) adcstep = args . get ( 'ADCSTEP' , 1 ) adc1deltas = np . arange ( - adc1delta , adc1delta , adcstep ) adc2deltas = np . arange ( - adc2delta , adc2delta , adcstep ) fvcsleeptime = 0.25 ADCPRISMS = ktl . cache ( 'kpffiu' , 'ADCPRISMS' ) ADCPRISMS . monitor () ADC1VAL = ktl . cache ( 'kpffiu' , 'ADC1VAL' ) ADC1VAL . monitor () ADC2VAL = ktl . cache ( 'kpffiu' , 'ADC2VAL' ) ADC2VAL . monitor () LASTFILE = ktl . cache ( 'kpffvc' , 'EXTLASTFILE' ) LASTFILE . monitor () this_file_name = Path ( __file__ ) . name . replace ( '.py' , '' ) utnow = datetime . utcnow () now_str = utnow . strftime ( '%Y%m %d at%H%M%S' ) date_str = ( utnow - timedelta ( days = 1 )) . strftime ( '%Y%b %d ' ) . lower () log_path = Path ( f '/s/sdata1701/KPFTranslator_logs/ { date_str } ' ) images_file = log_path / Path ( f ' { this_file_name } _ { now_str } .txt' ) images = Table ( names = ( 'file' , 'DELTA1' , 'DELTA2' , 'ADC1VAL' , 'ADC2VAL' ), dtype = ( 'a90' , 'f4' , 'f4' , 'f4' , 'f4' )) for i , delta1 in enumerate ( adc1deltas ): for j , delta2 in enumerate ( adc2deltas ): log . info ( f 'Moving ADCs to offset positions: { delta1 : .1f } , { delta2 : .1f } ' ) SetADCOffsets . execute ({ 'ADC1OFF' : delta1 , 'ADC2OFF' : delta2 }) log . info ( 'Taking EXT FVC exposure' ) TakeFVCExposure . execute ({ 'camera' : 'EXT' }) time . sleep ( fvcsleeptime ) row = { 'file' : str ( LASTFILE ), 'DELTA1' : delta1 , 'DELTA2' : delta2 , 'ADC1VAL' : str ( ADC1VAL ), 'ADC2VAL' : str ( ADC2VAL )} log . info ( f ' { row [ \"file\" ] } ' ) images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) log . info ( 'Done' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'ADC1DELTA' , type = float , help = \"Maximum ADC1 offset from nominal\" ) parser . add_argument ( 'ADC2DELTA' , type = float , help = \"Maximum ADC2 offset from nominal\" ) parser . add_argument ( 'ADCSTEP' , type = float , help = \"Anglular step size\" ) return super () . add_cmdline_args ( parser , cfg )","title":"TakeADCOffsetGridData"},{"location":"scripts/TakeExpMeterBiases/","text":"TakeExpMeterBiases Bases: KPFFunction Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) Parameters: nExp ( int ) \u2013 The number of frames to take. combine ( bool ) \u2013 Combine the files in to a master bias? output ( str ) \u2013 The output combined bias file. update ( bool ) \u2013 Update the bias file in use with the newly generated file? (only used if combine is True). KTL Keywords Used: kpfconfig.EXPMETER_ENABLED kpfconfig.ALLOWSCHEDULEDCALS kpf_expmeter.COOLING kpf_expmeter.COOLTARG kpf_expmeter.COOLTEMP kpf_expmeter.BINX kpf_expmeter.BINY kpf_expmeter.TOP kpf_expmeter.LEFT kpf_expmeter.WIDTH kpf_expmeter.HEIGHT kpf_expmeter.EXPOSURE kpf_expmeter.OBJECT kpf_expmeter.OBSERVER kpf_expmeter.EXPMODE kpf_expmeter.EXPSTATE kpf_expmeter.EXPOSE kpf_expmeter.SEQNUM kpf_expmeter.FITSFILE kpfexpose.TRIG_TARG Functions Called: kpf.calbench.SetCalSource kpf.calbench.WaitForCalSource kpf.spectrograph.WaitForReady kpf.spectrograph.SetSourceSelectShutters kpf.expmeter.BuildMasterBias kpf.spectrograph.ResetDetectors.ResetExpMeterDetector Source code in kpf/expmeter/TakeExpMeterBiases.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class TakeExpMeterBiases ( KPFFunction ): '''Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) Args: nExp (int): The number of frames to take. combine (bool): Combine the files in to a master bias? output (str): The output combined bias file. update (bool): Update the bias file in use with the newly generated file? (only used if combine is True). KTL Keywords Used: - `kpfconfig.EXPMETER_ENABLED` - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpf_expmeter.COOLING` - `kpf_expmeter.COOLTARG` - `kpf_expmeter.COOLTEMP` - `kpf_expmeter.BINX` - `kpf_expmeter.BINY` - `kpf_expmeter.TOP` - `kpf_expmeter.LEFT` - `kpf_expmeter.WIDTH` - `kpf_expmeter.HEIGHT` - `kpf_expmeter.EXPOSURE` - `kpf_expmeter.OBJECT` - `kpf_expmeter.OBSERVER` - `kpf_expmeter.EXPMODE` - `kpf_expmeter.EXPSTATE` - `kpf_expmeter.EXPOSE` - `kpf_expmeter.SEQNUM` - `kpf_expmeter.FITSFILE` - `kpfexpose.TRIG_TARG` Functions Called: - `kpf.calbench.SetCalSource` - `kpf.calbench.WaitForCalSource` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.expmeter.BuildMasterBias` - `kpf.spectrograph.ResetDetectors.ResetExpMeterDetector` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) check_input ( args , 'nExp' , allowed_types = [ int ]) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Check exposure meter enabled kpfconfig = ktl . cache ( 'kpfconfig' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_enabled == False : raise FailedPreCondition ( 'Exposure meter is not enabled' ) # Check on exposure meter detector status if kpf_expmeter [ 'COOLING' ] . read ( binary = True ) != True : raise FailedPreCondition ( 'Exposure meter cooling is not On' ) cooltarg = kpf_expmeter [ 'COOLTARG' ] . read ( binary = True ) currtemp = kpf_expmeter [ 'CURRTEMP' ] . read ( binary = True ) deltaT = abs ( currtemp - cooltarg ) deltaT_threshold = cfg . getfloat ( 'tolerances' , 'expmeter_detector_temperature_tolerance' , fallback = 0.5 ) if deltaT > deltaT_threshold : raise FailedPreCondition ( 'Exposure meter not near target temperature' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): # Check if we're ok to take data allowscheduledcals = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if allowscheduledcals . read ( binary = True ) == False : log . warning ( f 'kpfconfig.ALLOWSCHEDULEDCALS=No. Not taking biases.' ) return [] # Proceed with taking biases nExp = int ( args . get ( 'nExp' )) log . info ( f \"Taking { nExp } exposure meter bias frames\" ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set exposure meter to full frame to take biases log . info ( f \"Setting exposure meter to full frame for biases\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 0 ) kpf_expmeter [ 'WIDTH' ] . write ( 1072 ) kpf_expmeter [ 'HEIGHT' ] . write ( 1024 ) kpf_expmeter [ 'EXPOSURE' ] . write ( 0.12 ) kpf_expmeter [ 'OBJECT' ] . write ( 'bias' ) kpf_expmeter [ 'OBSERVER' ] . write ( 'TakeExpMeterBiases' ) kpf_expmeter [ 'EXPMODE' ] . write ( 'Continuous' ) log . debug ( 'Set Octagon to Home and close all source select shutters' ) SetCalSource . execute ({ 'CalSource' : 'Home' }) WaitForReady . execute ({}) SetSourceSelectShutters . execute ({}) WaitForCalSource . execute ({ 'CalSource' : 'Home' }) # Set TRIG_TARG to None, so that kpfassemble doesn't try # to pick up this data set trig_targ = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) trig_targ . write ( 'None' ) ready = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) if ready is not True : raise KPFException ( f \"Exposure Meter did not reach ready state\" ) # Start continuous exposures log . info ( f \"Starting continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'Start' ) started = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"!= 'Ready'\" , timeout = 5 ) if started is not True : raise KPFException ( f \"Exposure Meter did not start exposures\" ) got_frames = kpf_expmeter [ 'SEQNUM' ] . waitFor ( f \"== { nExp } \" , timeout = 2 * nExp ) if got_frames is not True : raise KPFException ( f \"Exposure Meter did not get all exposures\" ) log . info ( f \"Stopping continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'End' ) # Arbitrary wait to let file writing and DRP finish time . sleep ( 2 ) # Get FITSFILE lastfile = Path ( kpf_expmeter [ 'FITSFILE' ] . read ()) if lastfile . exists () is False : raise KPFException ( f \"Could not find file: { lastfile } \" ) filename_parts = lastfile . name . split ( '.' ) filename_parts [ 1 ] = '*' biases = [ f for f in lastfile . parent . glob ( '.' . join ( filename_parts ))] # Set exposure meter back to operations settings log . info ( f \"Setting exposure meter to operational windowing\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 1 ) kpf_expmeter [ 'WIDTH' ] . write ( 651 ) kpf_expmeter [ 'HEIGHT' ] . write ( 300 ) kpf_expmeter [ 'OBJECT' ] . write ( '' ) if args . get ( 'combine' , False ) is True : BuildMasterBias . execute ({ 'files' : biases , 'output' : args . get ( 'output' ), 'update' : args . get ( 'update' )}) return biases @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) expstate . monitor () timeout = 60 ready = expstate . waitFor ( \"== 'Ready'\" , timeout = timeout ) if ready is not True : log . error ( f 'ExpMeter is not Ready after { timeout } s' ) log . warning ( f 'ExpMeter is { expstate . ascii } . Resetting.' ) ResetExpMeterDetector . execute ({}) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'nExp' , type = int , help = \"The number of frames to take\" ) parser . add_argument ( \"-c\" , \"--combine\" , dest = \"combine\" , default = False , action = \"store_true\" , help = \"Combine the files in to a master bias?\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file? (only used if --combine is used)\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"TakeExpMeterBiases"},{"location":"scripts/TakeExpMeterBiases/#takeexpmeterbiases","text":"Bases: KPFFunction Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) Parameters: nExp ( int ) \u2013 The number of frames to take. combine ( bool ) \u2013 Combine the files in to a master bias? output ( str ) \u2013 The output combined bias file. update ( bool ) \u2013 Update the bias file in use with the newly generated file? (only used if combine is True). KTL Keywords Used: kpfconfig.EXPMETER_ENABLED kpfconfig.ALLOWSCHEDULEDCALS kpf_expmeter.COOLING kpf_expmeter.COOLTARG kpf_expmeter.COOLTEMP kpf_expmeter.BINX kpf_expmeter.BINY kpf_expmeter.TOP kpf_expmeter.LEFT kpf_expmeter.WIDTH kpf_expmeter.HEIGHT kpf_expmeter.EXPOSURE kpf_expmeter.OBJECT kpf_expmeter.OBSERVER kpf_expmeter.EXPMODE kpf_expmeter.EXPSTATE kpf_expmeter.EXPOSE kpf_expmeter.SEQNUM kpf_expmeter.FITSFILE kpfexpose.TRIG_TARG Functions Called: kpf.calbench.SetCalSource kpf.calbench.WaitForCalSource kpf.spectrograph.WaitForReady kpf.spectrograph.SetSourceSelectShutters kpf.expmeter.BuildMasterBias kpf.spectrograph.ResetDetectors.ResetExpMeterDetector Source code in kpf/expmeter/TakeExpMeterBiases.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class TakeExpMeterBiases ( KPFFunction ): '''Take a set of bias frames for the exposure meter. Obeys kpfconfig.ALLOWSCHEDULEDCALS (will not run if that is set to No) Args: nExp (int): The number of frames to take. combine (bool): Combine the files in to a master bias? output (str): The output combined bias file. update (bool): Update the bias file in use with the newly generated file? (only used if combine is True). KTL Keywords Used: - `kpfconfig.EXPMETER_ENABLED` - `kpfconfig.ALLOWSCHEDULEDCALS` - `kpf_expmeter.COOLING` - `kpf_expmeter.COOLTARG` - `kpf_expmeter.COOLTEMP` - `kpf_expmeter.BINX` - `kpf_expmeter.BINY` - `kpf_expmeter.TOP` - `kpf_expmeter.LEFT` - `kpf_expmeter.WIDTH` - `kpf_expmeter.HEIGHT` - `kpf_expmeter.EXPOSURE` - `kpf_expmeter.OBJECT` - `kpf_expmeter.OBSERVER` - `kpf_expmeter.EXPMODE` - `kpf_expmeter.EXPSTATE` - `kpf_expmeter.EXPOSE` - `kpf_expmeter.SEQNUM` - `kpf_expmeter.FITSFILE` - `kpfexpose.TRIG_TARG` Functions Called: - `kpf.calbench.SetCalSource` - `kpf.calbench.WaitForCalSource` - `kpf.spectrograph.WaitForReady` - `kpf.spectrograph.SetSourceSelectShutters` - `kpf.expmeter.BuildMasterBias` - `kpf.spectrograph.ResetDetectors.ResetExpMeterDetector` ''' @classmethod @obey_scriptrun def pre_condition ( cls , args ): # If specified obey the ALLOWSCHEDULEDCALS keyword if args . get ( 'scheduled' , False ) == True : ALLOWSCHEDULEDCALS = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if ALLOWSCHEDULEDCALS . read ( binary = True ) == False : raise FailedPreCondition ( 'ALLOWSCHEDULEDCALS is No' ) check_input ( args , 'nExp' , allowed_types = [ int ]) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Check exposure meter enabled kpfconfig = ktl . cache ( 'kpfconfig' ) EM_enabled = kpfconfig [ 'EXPMETER_ENABLED' ] . read () == 'Yes' if EM_enabled == False : raise FailedPreCondition ( 'Exposure meter is not enabled' ) # Check on exposure meter detector status if kpf_expmeter [ 'COOLING' ] . read ( binary = True ) != True : raise FailedPreCondition ( 'Exposure meter cooling is not On' ) cooltarg = kpf_expmeter [ 'COOLTARG' ] . read ( binary = True ) currtemp = kpf_expmeter [ 'CURRTEMP' ] . read ( binary = True ) deltaT = abs ( currtemp - cooltarg ) deltaT_threshold = cfg . getfloat ( 'tolerances' , 'expmeter_detector_temperature_tolerance' , fallback = 0.5 ) if deltaT > deltaT_threshold : raise FailedPreCondition ( 'Exposure meter not near target temperature' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , args ): # Check if we're ok to take data allowscheduledcals = ktl . cache ( 'kpfconfig' , 'ALLOWSCHEDULEDCALS' ) if allowscheduledcals . read ( binary = True ) == False : log . warning ( f 'kpfconfig.ALLOWSCHEDULEDCALS=No. Not taking biases.' ) return [] # Proceed with taking biases nExp = int ( args . get ( 'nExp' )) log . info ( f \"Taking { nExp } exposure meter bias frames\" ) kpf_expmeter = ktl . cache ( 'kpf_expmeter' ) # Set exposure meter to full frame to take biases log . info ( f \"Setting exposure meter to full frame for biases\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 0 ) kpf_expmeter [ 'WIDTH' ] . write ( 1072 ) kpf_expmeter [ 'HEIGHT' ] . write ( 1024 ) kpf_expmeter [ 'EXPOSURE' ] . write ( 0.12 ) kpf_expmeter [ 'OBJECT' ] . write ( 'bias' ) kpf_expmeter [ 'OBSERVER' ] . write ( 'TakeExpMeterBiases' ) kpf_expmeter [ 'EXPMODE' ] . write ( 'Continuous' ) log . debug ( 'Set Octagon to Home and close all source select shutters' ) SetCalSource . execute ({ 'CalSource' : 'Home' }) WaitForReady . execute ({}) SetSourceSelectShutters . execute ({}) WaitForCalSource . execute ({ 'CalSource' : 'Home' }) # Set TRIG_TARG to None, so that kpfassemble doesn't try # to pick up this data set trig_targ = ktl . cache ( 'kpfexpose' , 'TRIG_TARG' ) trig_targ . write ( 'None' ) ready = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"== 'Ready'\" , timeout = 60 ) if ready is not True : raise KPFException ( f \"Exposure Meter did not reach ready state\" ) # Start continuous exposures log . info ( f \"Starting continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'Start' ) started = kpf_expmeter [ 'EXPSTATE' ] . waitFor ( \"!= 'Ready'\" , timeout = 5 ) if started is not True : raise KPFException ( f \"Exposure Meter did not start exposures\" ) got_frames = kpf_expmeter [ 'SEQNUM' ] . waitFor ( f \"== { nExp } \" , timeout = 2 * nExp ) if got_frames is not True : raise KPFException ( f \"Exposure Meter did not get all exposures\" ) log . info ( f \"Stopping continuous exposures\" ) kpf_expmeter [ 'EXPOSE' ] . write ( 'End' ) # Arbitrary wait to let file writing and DRP finish time . sleep ( 2 ) # Get FITSFILE lastfile = Path ( kpf_expmeter [ 'FITSFILE' ] . read ()) if lastfile . exists () is False : raise KPFException ( f \"Could not find file: { lastfile } \" ) filename_parts = lastfile . name . split ( '.' ) filename_parts [ 1 ] = '*' biases = [ f for f in lastfile . parent . glob ( '.' . join ( filename_parts ))] # Set exposure meter back to operations settings log . info ( f \"Setting exposure meter to operational windowing\" ) kpf_expmeter [ 'BINX' ] . write ( 1 ) kpf_expmeter [ 'BINY' ] . write ( 1 ) kpf_expmeter [ 'TOP' ] . write ( 0 ) kpf_expmeter [ 'LEFT' ] . write ( 1 ) kpf_expmeter [ 'WIDTH' ] . write ( 651 ) kpf_expmeter [ 'HEIGHT' ] . write ( 300 ) kpf_expmeter [ 'OBJECT' ] . write ( '' ) if args . get ( 'combine' , False ) is True : BuildMasterBias . execute ({ 'files' : biases , 'output' : args . get ( 'output' ), 'update' : args . get ( 'update' )}) return biases @classmethod def post_condition ( cls , args ): expstate = ktl . cache ( 'kpf_expmeter' , 'EXPSTATE' ) expstate . monitor () timeout = 60 ready = expstate . waitFor ( \"== 'Ready'\" , timeout = timeout ) if ready is not True : log . error ( f 'ExpMeter is not Ready after { timeout } s' ) log . warning ( f 'ExpMeter is { expstate . ascii } . Resetting.' ) ResetExpMeterDetector . execute ({}) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'nExp' , type = int , help = \"The number of frames to take\" ) parser . add_argument ( \"-c\" , \"--combine\" , dest = \"combine\" , default = False , action = \"store_true\" , help = \"Combine the files in to a master bias?\" ) parser . add_argument ( \"--update\" , dest = \"update\" , default = False , action = \"store_true\" , help = \"Update the bias file in use with the newly generated file? (only used if --combine is used)\" ) parser . add_argument ( \"--output\" , dest = \"output\" , type = str , default = '' , help = \"The output combined bias file.\" ) parser . add_argument ( '--scheduled' , dest = \"scheduled\" , default = False , action = \"store_true\" , help = 'Script is scheduled and should obey ALLOWSCHEDULEDCALS keyword' ) return super () . add_cmdline_args ( parser )","title":"TakeExpMeterBiases"},{"location":"scripts/TakeFVCContinuous/","text":"TakeFVCContinuous Bases: KPFFunction Take exposures with the specified FVC continuously and display to ds9. Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/TakeFVCContinuous.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class TakeFVCContinuous ( KPFFunction ): '''Take exposures with the specified FVC continuously and display to ds9. Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) SetFVCExpTime . execute ( args ) while True : TakeFVCExposure . execute ({ 'camera' : camera , 'display' : True }) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"TakeFVCContinuous"},{"location":"scripts/TakeFVCContinuous/#takefvccontinuous","text":"Bases: KPFFunction Take exposures with the specified FVC continuously and display to ds9. Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime ( float ) \u2013 The exposure time in seconds. KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/TakeFVCContinuous.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class TakeFVCContinuous ( KPFFunction ): '''Take exposures with the specified FVC continuously and display to ds9. Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL exptime (float): The exposure time in seconds. KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 }[ camera ] powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) exptime = args . get ( 'exptime' ) SetFVCExpTime . execute ( args ) while True : TakeFVCExposure . execute ({ 'camera' : camera , 'display' : True }) time . sleep ( 0.5 ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( 'exptime' , type = float , help = 'The exposure time in seconds' ) return super () . add_cmdline_args ( parser )","title":"TakeFVCContinuous"},{"location":"scripts/TakeFVCExposure/","text":"TakeFVCExposure Bases: KPFFunction Take an exposure with the specified fiber viewing camera Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL wait ( bool ) \u2013 Wait for image to complete before returning? (default: True) display ( bool ) \u2013 Display the resulting image to the engineering ds9 instance for FVCs using XPA? KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpffvc.SCILASTFILE kpffvc.CALLASTFILE kpffvc.EXTLASTFILE kpffvc.CAHKLASTFILE kpffvc.SCIEXPOSE kpffvc.CALEXPOSE kpffvc.EXTEXPOSE kpffvc.CAHKEXPOSE kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/TakeFVCExposure.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeFVCExposure ( KPFFunction ): '''Take an exposure with the specified fiber viewing camera Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL wait (bool): Wait for image to complete before returning? (default: True) display (bool): Display the resulting image to the engineering ds9 instance for FVCs using XPA? KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpffvc.SCILASTFILE` - `kpffvc.CALLASTFILE` - `kpffvc.EXTLASTFILE` - `kpffvc.CAHKLASTFILE` - `kpffvc.SCIEXPOSE` - `kpffvc.CALEXPOSE` - `kpffvc.EXTEXPOSE` - `kpffvc.CAHKEXPOSE` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = kpffvc [ f ' { camera } EXPTIME' ] . read ( binary = True ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] initial_lastfile = lastfile . read () wait = args . get ( 'wait' , True ) kpffvc [ f ' { camera } EXPOSE' ] . write ( 'yes' , wait = wait ) if wait is True : timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) expr = f \"($kpffvc. { camera } LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) if wait is True and args . get ( 'display' , False ) is True : display_name = cfg . get ( 'display' , 'fvc_xpa_target' , fallback = 'FVC' ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { lastfile . read () } \" , '<' , f \" { lastfile . read () } \" ] log . debug ( f \"Running: { ' ' . join ( ds9cmd ) } \" ) subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_ { camera . lower () } fvc.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] log . debug ( f \"Running: { ' ' . join ( overlaycmd ) } \" ) subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) return kpffvc [ f \" { camera } LASTFILE\" ] . read () @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' , 'SCI' ) kpffvc = ktl . cache ( 'kpffvc' ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] lastfile . monitor () new_file = Path ( f \" { lastfile } \" ) log . debug ( f \" { camera } FVC LASTFILE: { new_file } \" ) if new_file . exists () == False : raise FailedPostCondition ( f 'Output file not found: { new_file } ' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) parser . add_argument ( \"--display\" , dest = \"display\" , default = False , action = \"store_true\" , help = \"Display image via engineering ds9?\" ) return super () . add_cmdline_args ( parser )","title":"TakeFVCExposure"},{"location":"scripts/TakeFVCExposure/#takefvcexposure","text":"Bases: KPFFunction Take an exposure with the specified fiber viewing camera Parameters: camera ( str ) \u2013 Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL wait ( bool ) \u2013 Wait for image to complete before returning? (default: True) display ( bool ) \u2013 Display the resulting image to the engineering ds9 instance for FVCs using XPA? KTL Keywords Used: kpffvc.SCIEXPTIME kpffvc.CAHKEXPTIME kpffvc.EXTEXPTIME kpffvc.CALEXPTIME kpffvc.SCILASTFILE kpffvc.CALLASTFILE kpffvc.EXTLASTFILE kpffvc.CAHKLASTFILE kpffvc.SCIEXPOSE kpffvc.CALEXPOSE kpffvc.EXTEXPOSE kpffvc.CAHKEXPOSE kpfpower.KPFFVC1 kpfpower.KPFFVC2 kpfpower.KPFFVC3 Source code in kpf/fvc/TakeFVCExposure.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class TakeFVCExposure ( KPFFunction ): '''Take an exposure with the specified fiber viewing camera Args: camera (str): Which FVC camera? Allowed values: SCI, CAHK, EXT, CAL wait (bool): Wait for image to complete before returning? (default: True) display (bool): Display the resulting image to the engineering ds9 instance for FVCs using XPA? KTL Keywords Used: - `kpffvc.SCIEXPTIME` - `kpffvc.CAHKEXPTIME` - `kpffvc.EXTEXPTIME` - `kpffvc.CALEXPTIME` - `kpffvc.SCILASTFILE` - `kpffvc.CALLASTFILE` - `kpffvc.EXTLASTFILE` - `kpffvc.CAHKLASTFILE` - `kpffvc.SCIEXPOSE` - `kpffvc.CALEXPOSE` - `kpffvc.EXTEXPOSE` - `kpffvc.CAHKEXPOSE` - `kpfpower.KPFFVC1` - `kpfpower.KPFFVC2` - `kpfpower.KPFFVC3` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'camera' , allowed_values = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ]) # Check if power is on camera = args . get ( 'camera' ) camnum = { 'SCI' : 1 , 'CAHK' : 2 , 'CAL' : 3 , 'EXT' : None }[ camera ] if camnum is not None : powerkw = ktl . cache ( 'kpfpower' , f \"KPFFVC { camnum } \" ) if powerkw . read () != 'On' : raise FailedPreCondition ( f \" { camera } FVC power is not On\" ) @classmethod def perform ( cls , args ): camera = args . get ( 'camera' ) kpffvc = ktl . cache ( 'kpffvc' ) exptime = kpffvc [ f ' { camera } EXPTIME' ] . read ( binary = True ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] initial_lastfile = lastfile . read () wait = args . get ( 'wait' , True ) kpffvc [ f ' { camera } EXPOSE' ] . write ( 'yes' , wait = wait ) if wait is True : timeout = cfg . getfloat ( 'times' , 'fvc_command_timeout' , fallback = 5 ) expr = f \"($kpffvc. { camera } LASTFILE != ' { initial_lastfile } ')\" ktl . waitFor ( expr , timeout = exptime + timeout ) if wait is True and args . get ( 'display' , False ) is True : display_name = cfg . get ( 'display' , 'fvc_xpa_target' , fallback = 'FVC' ) ds9cmd = [ 'xpaset' , display_name , 'fits' , f \" { lastfile . read () } \" , '<' , f \" { lastfile . read () } \" ] log . debug ( f \"Running: { ' ' . join ( ds9cmd ) } \" ) subprocess . call ( ' ' . join ( ds9cmd ), shell = True ) regfile = Path ( f '/home/kpfeng/fibers_on_ { camera . lower () } fvc.reg' ) if regfile . exists () is True : overlaycmd = [ 'xpaset' , '-p' , display_name , 'regions' , 'file' , f \" { regfile } \" ] log . debug ( f \"Running: { ' ' . join ( overlaycmd ) } \" ) subprocess . call ( ' ' . join ( overlaycmd ), shell = True ) return kpffvc [ f \" { camera } LASTFILE\" ] . read () @classmethod def post_condition ( cls , args ): camera = args . get ( 'camera' , 'SCI' ) kpffvc = ktl . cache ( 'kpffvc' ) lastfile = kpffvc [ f ' { camera } LASTFILE' ] lastfile . monitor () new_file = Path ( f \" { lastfile } \" ) log . debug ( f \" { camera } FVC LASTFILE: { new_file } \" ) if new_file . exists () == False : raise FailedPostCondition ( f 'Output file not found: { new_file } ' ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'camera' , type = str , choices = [ 'SCI' , 'CAHK' , 'CAL' , 'EXT' ], help = 'The FVC camera' ) parser . add_argument ( \"--nowait\" , dest = \"wait\" , default = True , action = \"store_false\" , help = \"Send exposure command and return immediately?\" ) parser . add_argument ( \"--display\" , dest = \"display\" , default = False , action = \"store_true\" , help = \"Display image via engineering ds9?\" ) return super () . add_cmdline_args ( parser )","title":"TakeFVCExposure"},{"location":"scripts/TakeGuiderCube/","text":"TakeGuiderCube Bases: KPFFunction Take a \"trigger file\" from the guide camera of a given duration. Parameters: duration ( float ) \u2013 The duration in seconds of the image set. ImageCube ( bool ) \u2013 Collect the full cube of images? (default True) This will slow down file write considerably. KTL Keywords Used: kpfguide.TRIGCUBE kpfguide.LASTTRIGFILE kpfguide.ALL_LOOPS Functions Called: kpf.guider.StartTriggerFile kpf.guider.StopTriggerFile kpf.guider.WaitForTriggerFile Source code in kpf/guider/TakeGuiderCube.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TakeGuiderCube ( KPFFunction ): '''Take a \"trigger file\" from the guide camera of a given duration. Args: duration (float): The duration in seconds of the image set. ImageCube (bool): Collect the full cube of images? (default True) This will slow down file write considerably. KTL Keywords Used: - `kpfguide.TRIGCUBE` - `kpfguide.LASTTRIGFILE` - `kpfguide.ALL_LOOPS` Functions Called: - `kpf.guider.StartTriggerFile` - `kpf.guider.StopTriggerFile` - `kpf.guider.WaitForTriggerFile` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'duration' , value_min = 0 ) @classmethod def perform ( cls , args ): duration = float ( args . get ( 'duration' )) kpfguide = ktl . cache ( 'kpfguide' ) # Read initial conditions, so we can set them back at the end initial_trigcube = kpfguide [ 'TRIGCUBE' ] . read () initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () initial_all_loops = kpfguide [ 'ALL_LOOPS' ] . read () # Do we want to take the image cube? collect_image_cube = args . get ( 'ImageCube' , True ) set_trigcube = { True : 'Active' , False : 'Inactive' }[ collect_image_cube ] kpfguide [ 'TRIGCUBE' ] . write ( set_trigcube ) # Trigger data collection log . info ( f \"Starting guider cube data collection, duration = { duration : .1f } s\" ) StartTriggerFile . execute ({}) time . sleep ( duration ) StopTriggerFile . execute ({}) # Stop all loops if we're writing out a full image cube # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write('Inactive', wait=False) cube_file = WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_lastfile }) # Reset TRIGCUBE kpfguide [ 'TRIGCUBE' ] . write ( initial_trigcube ) # Reset ALL_LOOPS to initial values # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write(initial_all_loops) print ( cube_file ) return cube_file @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'duration' , type = float , help = 'The duration in seconds' ) parser . add_argument ( \"--noTRIGCUBE\" , dest = \"ImageCube\" , default = True , action = \"store_false\" , help = \"Collect the full image cube?\" ) return super () . add_cmdline_args ( parser )","title":"TakeGuiderCube"},{"location":"scripts/TakeGuiderCube/#takeguidercube","text":"Bases: KPFFunction Take a \"trigger file\" from the guide camera of a given duration. Parameters: duration ( float ) \u2013 The duration in seconds of the image set. ImageCube ( bool ) \u2013 Collect the full cube of images? (default True) This will slow down file write considerably. KTL Keywords Used: kpfguide.TRIGCUBE kpfguide.LASTTRIGFILE kpfguide.ALL_LOOPS Functions Called: kpf.guider.StartTriggerFile kpf.guider.StopTriggerFile kpf.guider.WaitForTriggerFile Source code in kpf/guider/TakeGuiderCube.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TakeGuiderCube ( KPFFunction ): '''Take a \"trigger file\" from the guide camera of a given duration. Args: duration (float): The duration in seconds of the image set. ImageCube (bool): Collect the full cube of images? (default True) This will slow down file write considerably. KTL Keywords Used: - `kpfguide.TRIGCUBE` - `kpfguide.LASTTRIGFILE` - `kpfguide.ALL_LOOPS` Functions Called: - `kpf.guider.StartTriggerFile` - `kpf.guider.StopTriggerFile` - `kpf.guider.WaitForTriggerFile` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'duration' , value_min = 0 ) @classmethod def perform ( cls , args ): duration = float ( args . get ( 'duration' )) kpfguide = ktl . cache ( 'kpfguide' ) # Read initial conditions, so we can set them back at the end initial_trigcube = kpfguide [ 'TRIGCUBE' ] . read () initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () initial_all_loops = kpfguide [ 'ALL_LOOPS' ] . read () # Do we want to take the image cube? collect_image_cube = args . get ( 'ImageCube' , True ) set_trigcube = { True : 'Active' , False : 'Inactive' }[ collect_image_cube ] kpfguide [ 'TRIGCUBE' ] . write ( set_trigcube ) # Trigger data collection log . info ( f \"Starting guider cube data collection, duration = { duration : .1f } s\" ) StartTriggerFile . execute ({}) time . sleep ( duration ) StopTriggerFile . execute ({}) # Stop all loops if we're writing out a full image cube # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write('Inactive', wait=False) cube_file = WaitForTriggerFile . execute ({ 'initial_lastfile' : initial_lastfile }) # Reset TRIGCUBE kpfguide [ 'TRIGCUBE' ] . write ( initial_trigcube ) # Reset ALL_LOOPS to initial values # if initial_all_loops == 'Active' and collect_image_cube == True: # kpfguide['ALL_LOOPS'].write(initial_all_loops) print ( cube_file ) return cube_file @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'duration' , type = float , help = 'The duration in seconds' ) parser . add_argument ( \"--noTRIGCUBE\" , dest = \"ImageCube\" , default = True , action = \"store_false\" , help = \"Collect the full image cube?\" ) return super () . add_cmdline_args ( parser )","title":"TakeGuiderCube"},{"location":"scripts/TakeGuiderExposure/","text":"TakeGuiderExposure Bases: KPFFunction Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. KTL Keywords Used: kpfguide.EXPTIME kpfguide.LASTFILE Functions Called: kpf.guider.TriggerSingleGuiderExposure kpf.guider.GrabGuiderExposure Source code in kpf/guider/TakeGuiderExposure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class TakeGuiderExposure ( KPFFunction ): '''Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. KTL Keywords Used: - `kpfguide.EXPTIME` - `kpfguide.LASTFILE` Functions Called: - `kpf.guider.TriggerSingleGuiderExposure` - `kpf.guider.GrabGuiderExposure` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) lastfile = kpfguide [ 'LASTFILE' ] if guider_is_active (): if guider_is_saving (): GrabGuiderExposure . execute ({}) else : # not sure what right action is here log . warning ( 'Guider is active, but not saving. No image saved.' ) else : TriggerSingleGuiderExposure . execute ({}) lastfile . monitor () lastfile . wait ( timeout = exptime * 2 + 1 ) # Wait for update which signals a new file @classmethod def post_condition ( cls , args ): pass","title":"TakeGuiderExposure"},{"location":"scripts/TakeGuiderExposure/#takeguiderexposure","text":"Bases: KPFFunction Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. KTL Keywords Used: kpfguide.EXPTIME kpfguide.LASTFILE Functions Called: kpf.guider.TriggerSingleGuiderExposure kpf.guider.GrabGuiderExposure Source code in kpf/guider/TakeGuiderExposure.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class TakeGuiderExposure ( KPFFunction ): '''Depending on whether the guide camera is running in continuous mode or not, this will either grab the next exposure (if in continuous mode) or trigger a new exposure. KTL Keywords Used: - `kpfguide.EXPTIME` - `kpfguide.LASTFILE` Functions Called: - `kpf.guider.TriggerSingleGuiderExposure` - `kpf.guider.GrabGuiderExposure` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfguide = ktl . cache ( 'kpfguide' ) exptime = kpfguide [ 'EXPTIME' ] . read ( binary = True ) lastfile = kpfguide [ 'LASTFILE' ] if guider_is_active (): if guider_is_saving (): GrabGuiderExposure . execute ({}) else : # not sure what right action is here log . warning ( 'Guider is active, but not saving. No image saved.' ) else : TriggerSingleGuiderExposure . execute ({}) lastfile . monitor () lastfile . wait ( timeout = exptime * 2 + 1 ) # Wait for update which signals a new file @classmethod def post_condition ( cls , args ): pass","title":"TakeGuiderExposure"},{"location":"scripts/TakeGuiderSensitivityData/","text":"TakeGuiderSensitivityData Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeGuiderSensitivityData.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TakeGuiderSensitivityData ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_tgsd' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.3' ) check_input ( OB , 'FPSvalues' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) images_file = log_dir / Path ( f ' { this_file_name } _images_ { now_str } .txt' ) images = Table ( names = ( 'cube file' , 'fps' ), dtype = ( 'a90' , 'f4' )) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Guider gain is { kpfguide [ 'GAIN' ] . read () } \" ) log . info ( f \"Ensuring TRIGCUBE is Active\" ) kpfguide [ 'TRIGCUBE' ] . write ( 'Active' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read ( binary = True ) cube_duration = OB . get ( 'cube_duration' ) for FPS in OB . get ( 'FPSvalues' ): log . info ( f \"Setting FPS to { FPS } \" ) SetGuiderFPS . execute ({ 'GuideFPS' : FPS }) # Start cube collection log . info ( f 'Starting data collection for { cube_duration } s' ) initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () kpfguide [ 'TRIGGER' ] . write ( 'Active' ) log . debug ( f \"Sleeping { cube_duration } s\" ) time . sleep ( cube_duration ) # End cube collection kpfguide [ 'TRIGGER' ] . write ( 'Inactive' , wait = False ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) # Wait for cube file to be updated ktl . waitFor ( f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \" cube file: { cube_file } \" ) if all_loops == 1 : kpfguide [ 'ALL_LOOPS' ] . write ( 1 ) row = { 'cube file' : cube_file , 'fps' : FPS } images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"TakeGuiderSensitivityData"},{"location":"scripts/TakeGuiderSensitivityData/#takeguidersensitivitydata","text":"Bases: KPFTranslatorFunction Source code in kpf/engineering/TakeGuiderSensitivityData.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class TakeGuiderSensitivityData ( KPFTranslatorFunction ): ''' ''' @classmethod @obey_scriptrun def pre_condition ( cls , OB , logger , cfg ): check_input ( OB , 'Template_Name' , allowed_values = [ 'kpf_eng_tgsd' ]) check_input ( OB , 'Template_Version' , version_check = True , value_min = '0.3' ) check_input ( OB , 'FPSvalues' ) @classmethod @register_script ( Path ( __file__ ) . name , os . getpid ()) @add_script_log ( Path ( __file__ ) . name . replace ( \".py\" , \"\" )) def perform ( cls , OB , logger , cfg ): log . info ( '-------------------------' ) log . info ( f \"Running { cls . __name__ } \" ) for key in OB : log . debug ( f \" { key } : { OB [ key ] } \" ) log . info ( '-------------------------' ) images_file = log_dir / Path ( f ' { this_file_name } _images_ { now_str } .txt' ) images = Table ( names = ( 'cube file' , 'fps' ), dtype = ( 'a90' , 'f4' )) kpfguide = ktl . cache ( 'kpfguide' ) log . info ( f \"Guider gain is { kpfguide [ 'GAIN' ] . read () } \" ) log . info ( f \"Ensuring TRIGCUBE is Active\" ) kpfguide [ 'TRIGCUBE' ] . write ( 'Active' ) all_loops = kpfguide [ 'ALL_LOOPS' ] . read ( binary = True ) cube_duration = OB . get ( 'cube_duration' ) for FPS in OB . get ( 'FPSvalues' ): log . info ( f \"Setting FPS to { FPS } \" ) SetGuiderFPS . execute ({ 'GuideFPS' : FPS }) # Start cube collection log . info ( f 'Starting data collection for { cube_duration } s' ) initial_lastfile = kpfguide [ 'LASTTRIGFILE' ] . read () kpfguide [ 'TRIGGER' ] . write ( 'Active' ) log . debug ( f \"Sleeping { cube_duration } s\" ) time . sleep ( cube_duration ) # End cube collection kpfguide [ 'TRIGGER' ] . write ( 'Inactive' , wait = False ) kpfguide [ 'ALL_LOOPS' ] . write ( 'Inactive' ) # Wait for cube file to be updated ktl . waitFor ( f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" ) cube_file = kpfguide [ 'LASTTRIGFILE' ] . read () log . info ( f \" cube file: { cube_file } \" ) if all_loops == 1 : kpfguide [ 'ALL_LOOPS' ] . write ( 1 ) row = { 'cube file' : cube_file , 'fps' : FPS } images . add_row ( row ) if images_file . exists (): images_file . unlink () images . write ( images_file , format = 'ascii.csv' ) @classmethod def post_condition ( cls , OB , logger , cfg ): pass","title":"TakeGuiderSensitivityData"},{"location":"scripts/TakeIntensityReading/","text":"TakeIntensityReading Bases: KPFFunction Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. KTL Keywords Used: kpflamps.INTENSEMON kpfcal.SERIALCONN kpfcal.INTENMON kpfcal.NAVG kpfcal.AVG kpfcal.MEASURING Functions Called: kpf.utils.SendEmail Source code in kpf/calbench/TakeIntensityReading.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class TakeIntensityReading ( KPFFunction ): '''Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. KTL Keywords Used: - `kpflamps.INTENSEMON` - `kpfcal.SERIALCONN` - `kpfcal.INTENMON` - `kpfcal.NAVG` - `kpfcal.AVG` - `kpfcal.MEASURING` Functions Called: - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfcal = ktl . cache ( 'kpfcal' ) intensemon = ktl . cache ( 'kpflamps' , 'INTENSEMON' ) # Turn on intensity monitor if intensemon . read () == 'Off' : log . debug ( 'Turning kpflamps.INTENSEMON on' ) intensemon . write ( 'On' ) boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) time . sleep ( boottime ) # Verify serial connection is active if kpfcal [ 'SERIALCONN' ] . read () == 'Off' : log . debug ( 'Initiating serial connection' ) kpfcal [ 'SERIALCONN' ] . write ( 'On' ) expr = f \"($kpfcal.SERIALCONN == 'On')\" boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) success = ktl . waitFor ( expr , timeout = boottime ) if success is False : msg = f 'Intensity monitor serial connection is Off' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor in to beam log . info ( 'Moving Intensity Monitor in to beam' ) kpfcal [ 'INTENMON' ] . write ( 'Boresight' ) # Set averaging navg = cfg . getfloat ( 'times' , 'intenmon_avg_time' , fallback = 60 ) log . info ( f 'Starting measurement: NAVG= { navg } ' ) kpfcal [ 'NAVG' ] . write ( navg ) kpfcal [ 'AVG' ] . write ( 'On' ) # Check whether measuring is taking place expr = f \"($kpfcal.MEASURING == 'Yes')\" success = ktl . waitFor ( expr , timeout = 5 ) if success is False : msg = f 'Intensity monitor is not measuring' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Wait for readings to be complete expr = f \"($kpfcal.AVG == 'Off')\" success = ktl . waitFor ( expr , timeout = navg + 10 ) if success is False : msg = f 'Intensity monitor measurement timed out' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor out of beam log . info ( 'Moving Intensity Monitor out of beam' ) kpfcal [ 'INTENMON' ] . write ( 'Out' ) # Turn off intensity monitor log . debug ( 'Turning kpflamps.INTENSEMON off' ) intensemon . write ( 'Off' ) log . debug ( 'Turning kpfcal.SERIALCONN off' ) kpfcal [ 'SERIALCONN' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args ): pass","title":"TakeIntensityReading"},{"location":"scripts/TakeIntensityReading/#takeintensityreading","text":"Bases: KPFFunction Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. KTL Keywords Used: kpflamps.INTENSEMON kpfcal.SERIALCONN kpfcal.INTENMON kpfcal.NAVG kpfcal.AVG kpfcal.MEASURING Functions Called: kpf.utils.SendEmail Source code in kpf/calbench/TakeIntensityReading.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class TakeIntensityReading ( KPFFunction ): '''Insert the intensity monitor (aka \"cal diode\") in to the beam and record a measurement of the cal lamp intensity. KTL Keywords Used: - `kpflamps.INTENSEMON` - `kpfcal.SERIALCONN` - `kpfcal.INTENMON` - `kpfcal.NAVG` - `kpfcal.AVG` - `kpfcal.MEASURING` Functions Called: - `kpf.utils.SendEmail` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfcal = ktl . cache ( 'kpfcal' ) intensemon = ktl . cache ( 'kpflamps' , 'INTENSEMON' ) # Turn on intensity monitor if intensemon . read () == 'Off' : log . debug ( 'Turning kpflamps.INTENSEMON on' ) intensemon . write ( 'On' ) boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) time . sleep ( boottime ) # Verify serial connection is active if kpfcal [ 'SERIALCONN' ] . read () == 'Off' : log . debug ( 'Initiating serial connection' ) kpfcal [ 'SERIALCONN' ] . write ( 'On' ) expr = f \"($kpfcal.SERIALCONN == 'On')\" boottime = cfg . getfloat ( 'times' , 'intenmon_boot_time' , fallback = 5 ) success = ktl . waitFor ( expr , timeout = boottime ) if success is False : msg = f 'Intensity monitor serial connection is Off' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor in to beam log . info ( 'Moving Intensity Monitor in to beam' ) kpfcal [ 'INTENMON' ] . write ( 'Boresight' ) # Set averaging navg = cfg . getfloat ( 'times' , 'intenmon_avg_time' , fallback = 60 ) log . info ( f 'Starting measurement: NAVG= { navg } ' ) kpfcal [ 'NAVG' ] . write ( navg ) kpfcal [ 'AVG' ] . write ( 'On' ) # Check whether measuring is taking place expr = f \"($kpfcal.MEASURING == 'Yes')\" success = ktl . waitFor ( expr , timeout = 5 ) if success is False : msg = f 'Intensity monitor is not measuring' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Wait for readings to be complete expr = f \"($kpfcal.AVG == 'Off')\" success = ktl . waitFor ( expr , timeout = navg + 10 ) if success is False : msg = f 'Intensity monitor measurement timed out' log . error ( msg ) SendEmail . execute ({ 'Subject' : 'TakeIntensityReading Failed' , 'Message' : f ' { msg } ' }) # Move sensor out of beam log . info ( 'Moving Intensity Monitor out of beam' ) kpfcal [ 'INTENMON' ] . write ( 'Out' ) # Turn off intensity monitor log . debug ( 'Turning kpflamps.INTENSEMON off' ) intensemon . write ( 'Off' ) log . debug ( 'Turning kpfcal.SERIALCONN off' ) kpfcal [ 'SERIALCONN' ] . write ( 'Off' ) @classmethod def post_condition ( cls , args ): pass","title":"TakeIntensityReading"},{"location":"scripts/TestTipTiltMirrorRange/","text":"TestTipTiltMirrorRange Bases: KPFFunction Verify if the tip tilt system is reaching the nominal range. Output is only via log messages. KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX kpfguide.TIPTILT_HOME kpfguide.TIPTILT_XRANGE kpfguide.TIPTILT_YRANGE Scripts Called: kpf.fiu.InitializeTipTilt kpf.fiu.ShutdownTipTilt Source code in kpf/fiu/TestTipTiltMirrorRange.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TestTipTiltMirrorRange ( KPFFunction ): '''Verify if the tip tilt system is reaching the nominal range. Output is only via log messages. KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpfguide.TIPTILT_HOME` - `kpfguide.TIPTILT_XRANGE` - `kpfguide.TIPTILT_YRANGE` Scripts Called: - `kpf.fiu.InitializeTipTilt` - `kpf.fiu.ShutdownTipTilt` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Measure tip tilt ranges log . info ( 'Beginning TestTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) axis = [ 'X' , 'Y' ] for i , ax in enumerate ( axis ): nominal_range = kpfguide [ f 'TIPTILT_ { ax } RANGE' ] . read ( binary = True ) home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True )[ i ] commanded_position = home - nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) commanded_position = home + nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) time . sleep ( movetime * 100 ) InitializeTipTilt . execute ({}) time . sleep ( movetime * 100 ) ShutdownTipTilt . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"TestTipTiltMirrorRange"},{"location":"scripts/TestTipTiltMirrorRange/#testtiptiltmirrorrange","text":"Bases: KPFFunction Verify if the tip tilt system is reaching the nominal range. Output is only via log messages. KTL Keywords Used: kpffiu.TTXVAX kpffiu.TTYVAX kpfguide.TIPTILT_HOME kpfguide.TIPTILT_XRANGE kpfguide.TIPTILT_YRANGE Scripts Called: kpf.fiu.InitializeTipTilt kpf.fiu.ShutdownTipTilt Source code in kpf/fiu/TestTipTiltMirrorRange.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class TestTipTiltMirrorRange ( KPFFunction ): '''Verify if the tip tilt system is reaching the nominal range. Output is only via log messages. KTL Keywords Used: - `kpffiu.TTXVAX` - `kpffiu.TTYVAX` - `kpfguide.TIPTILT_HOME` - `kpfguide.TIPTILT_XRANGE` - `kpfguide.TIPTILT_YRANGE` Scripts Called: - `kpf.fiu.InitializeTipTilt` - `kpf.fiu.ShutdownTipTilt` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): # Measure tip tilt ranges log . info ( 'Beginning TestTipTiltMirrorRange' ) InitializeTipTilt . execute ({}) movetime = cfg . getfloat ( 'times' , 'tip_tilt_move_time' , fallback = 0.1 ) tol = cfg . getfloat ( 'tolerances' , 'tip_tilt_move_tolerance' , fallback = 0.1 ) kpffiu = ktl . cache ( 'kpffiu' ) kpfguide = ktl . cache ( 'kpfguide' ) axis = [ 'X' , 'Y' ] for i , ax in enumerate ( axis ): nominal_range = kpfguide [ f 'TIPTILT_ { ax } RANGE' ] . read ( binary = True ) home = kpfguide [ 'TIPTILT_HOME' ] . read ( binary = True )[ i ] commanded_position = home - nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) commanded_position = home + nominal_range log . info ( f \"Sending TT { ax } VAX to { commanded_position } \" ) kpffiu [ f 'TT { ax } VAX' ] . write ( commanded_position ) time . sleep ( movetime * 100 ) current_position = kpffiu [ f 'TT { ax } VAX' ] . read ( binary = True ) if abs ( current_position - commanded_position ) < tol : log . info ( f \" { ax } reached nominal range: { commanded_position } \" ) else : log . error ( f \" { ax } failed to reach { commanded_position } : { current_position } \" ) time . sleep ( movetime * 100 ) InitializeTipTilt . execute ({}) time . sleep ( movetime * 100 ) ShutdownTipTilt . execute ({}) @classmethod def post_condition ( cls , args ): pass","title":"TestTipTiltMirrorRange"},{"location":"scripts/TriggerGreenMiniFill/","text":"TriggerGreenMiniFill Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerGreenMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerGreenMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Green fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting green mini fill' ) kpffill [ 'GREENSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'GREENFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping green mini fill' ) kpffill [ 'GREENSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected green mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : msg = 'Green still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerGreenMiniFill"},{"location":"scripts/TriggerGreenMiniFill/#triggergreenminifill","text":"Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerGreenMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerGreenMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Green fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting green mini fill' ) kpffill [ 'GREENSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'GREENFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping green mini fill' ) kpffill [ 'GREENSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected green mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'GREENFILLIP' ] . read () == 'True' : msg = 'Green still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerGreenMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerGreenMiniFill"},{"location":"scripts/TriggerRedMiniFill/","text":"TriggerRedMiniFill Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerRedMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerRedMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'REDFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Red fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting Red mini fill' ) kpffill [ 'REDSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'REDFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping Red mini fill' ) kpffill [ 'REDSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected Red mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'RedFILLIP' ] . read () == 'True' : msg = 'Red still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerRedMiniFill"},{"location":"scripts/TriggerRedMiniFill/#triggerredminifill","text":"Bases: KPFTranslatorFunction I really hope this is not necessary in the long term. Source code in kpf/engineering/TriggerRedMiniFill.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class TriggerRedMiniFill ( KPFTranslatorFunction ): '''I really hope this is not necessary in the long term. ''' @classmethod def pre_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'REDFILLIP' ] . read () == 'True' : raise FailedPreCondition ( 'Red fill already in progress' ) @classmethod def perform ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) # Start fill log . warning ( f 'Starting Red mini fill' ) kpffill [ 'REDSTART' ] . write ( 1 ) # Wait sleep_time = args . get ( 'duration' , 240 ) log . debug ( f 'Sleeping { sleep_time : .0f } s' ) time . sleep ( sleep_time ) # Stop fill if kpffill [ 'REDFILLIP' ] . read () == 'True' : log . warning ( f 'Stopping Red mini fill' ) kpffill [ 'REDSTOP' ] . write ( 1 ) time . sleep ( 5 ) else : msg = 'Expected Red mini fill to be in progress.' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise KPFException ( msg ) @classmethod def post_condition ( cls , args , logger , cfg ): kpffill = ktl . cache ( 'kpffill' ) if kpffill [ 'RedFILLIP' ] . read () == 'True' : msg = 'Red still in progress, should be stopped!' SendEmail . execute ({ 'Subject' : 'TriggerRedMiniFill Failed' , 'Message' : f ' { msg } ' }) raise FailedPostCondition ( msg ) @classmethod def add_cmdline_args ( cls , parser , cfg = None ): parser . add_argument ( 'duration' , type = float , help = 'The duration of the fill in seconds (240 recommended)' ) return super () . add_cmdline_args ( parser , cfg )","title":"TriggerRedMiniFill"},{"location":"scripts/TurnHepaOff/","text":"TurnHepaOff Bases: KPFFunction Turn HEPA Filter system off KTL Keywords Used: ao.OBHPAON ao.OBHPASTA Source code in kpf/ao/TurnHepaOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnHepaOff ( KPFFunction ): '''Turn HEPA Filter system off KTL Keywords Used: - `ao.OBHPAON` - `ao.OBHPASTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBHPAON = ktl . cache ( 'ao' , 'OBHPAON' ) log . debug ( 'Setting AO HEPA filter to off' ) OBHPAON . write ( 0 ) @classmethod def post_condition ( cls , args ): OBHPASTA = ktl . cache ( 'ao' , 'OBHPASTA' ) if OBHPASTA . waitfor ( '== \"off\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBHPASTA . read (), 'off' )","title":"TurnHepaOff"},{"location":"scripts/TurnHepaOff/#turnhepaoff","text":"Bases: KPFFunction Turn HEPA Filter system off KTL Keywords Used: ao.OBHPAON ao.OBHPASTA Source code in kpf/ao/TurnHepaOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnHepaOff ( KPFFunction ): '''Turn HEPA Filter system off KTL Keywords Used: - `ao.OBHPAON` - `ao.OBHPASTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBHPAON = ktl . cache ( 'ao' , 'OBHPAON' ) log . debug ( 'Setting AO HEPA filter to off' ) OBHPAON . write ( 0 ) @classmethod def post_condition ( cls , args ): OBHPASTA = ktl . cache ( 'ao' , 'OBHPASTA' ) if OBHPASTA . waitfor ( '== \"off\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBHPASTA . read (), 'off' )","title":"TurnHepaOff"},{"location":"scripts/TurnHepaOn/","text":"TurnHepaOn Bases: KPFFunction Turn HEPA Filter system on KTL Keywords Used: ao.OBHPAON ao.OBHPASTA Source code in kpf/ao/TurnHepaOn.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnHepaOn ( KPFFunction ): '''Turn HEPA Filter system on KTL Keywords Used: - `ao.OBHPAON` - `ao.OBHPASTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBHPAON = ktl . cache ( 'ao' , 'OBHPAON' ) log . debug ( 'Setting AO HEPA filter to off' ) OBHPAON . write ( 1 ) @classmethod def post_condition ( cls , args ): OBHPASTA = ktl . cache ( 'ao' , 'OBHPASTA' ) if OBHPASTA . waitfor ( '== \"on\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBHPASTA . read (), 'on' )","title":"TurnHepaOn"},{"location":"scripts/TurnHepaOn/#turnhepaon","text":"Bases: KPFFunction Turn HEPA Filter system on KTL Keywords Used: ao.OBHPAON ao.OBHPASTA Source code in kpf/ao/TurnHepaOn.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnHepaOn ( KPFFunction ): '''Turn HEPA Filter system on KTL Keywords Used: - `ao.OBHPAON` - `ao.OBHPASTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBHPAON = ktl . cache ( 'ao' , 'OBHPAON' ) log . debug ( 'Setting AO HEPA filter to off' ) OBHPAON . write ( 1 ) @classmethod def post_condition ( cls , args ): OBHPASTA = ktl . cache ( 'ao' , 'OBHPASTA' ) if OBHPASTA . waitfor ( '== \"on\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBHPASTA . read (), 'on' )","title":"TurnHepaOn"},{"location":"scripts/TurnLightSourceOff/","text":"TurnLightSourceOff Bases: KPFFunction Turn K1 AO light source off KTL Keywords Used: ao.OBSWON ao.OBSWSTA Source code in kpf/ao/TurnLightSourceOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnLightSourceOff ( KPFFunction ): '''Turn K1 AO light source off KTL Keywords Used: - `ao.OBSWON` - `ao.OBSWSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBSWON = ktl . cache ( 'ao' , 'OBSWON' ) log . debug ( 'Turning AO light source off' ) OBSWON . write ( 0 ) @classmethod def post_condition ( cls , args ): OBSWSTA = ktl . cache ( 'ao' , 'OBSWSTA' ) if OBSWSTA . waitfor ( '== \"off\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBSWSTA . read (), 'off' )","title":"TurnLightSourceOff"},{"location":"scripts/TurnLightSourceOff/#turnlightsourceoff","text":"Bases: KPFFunction Turn K1 AO light source off KTL Keywords Used: ao.OBSWON ao.OBSWSTA Source code in kpf/ao/TurnLightSourceOff.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class TurnLightSourceOff ( KPFFunction ): '''Turn K1 AO light source off KTL Keywords Used: - `ao.OBSWON` - `ao.OBSWSTA` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): OBSWON = ktl . cache ( 'ao' , 'OBSWON' ) log . debug ( 'Turning AO light source off' ) OBSWON . write ( 0 ) @classmethod def post_condition ( cls , args ): OBSWSTA = ktl . cache ( 'ao' , 'OBSWSTA' ) if OBSWSTA . waitfor ( '== \"off\"' , timeout = 3 ) is not True : raise FailedToReachDestination ( OBSWSTA . read (), 'off' )","title":"TurnLightSourceOff"},{"location":"scripts/UnlockFIU/","text":"UnlockFIU Bases: KPFFunction Unlock the FIU mechanisms KTL Keywords Used: kpffiu.ADC1LCK kpffiu.ADC2LCK kpffiu.FOLDLCK kpffiu.HKXLCK kpffiu.HKYLCK kpffiu.TTXLCK kpffiu.TTYLCK Source code in kpf/fiu/UnlockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class UnlockFIU ( KPFFunction ): '''Unlock the FIU mechanisms KTL Keywords Used: - `kpffiu.ADC1LCK` - `kpffiu.ADC2LCK` - `kpffiu.FOLDLCK` - `kpffiu.HKXLCK` - `kpffiu.HKYLCK` - `kpffiu.TTXLCK` - `kpffiu.TTYLCK` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( '' ) kpffiu [ 'adc2lck' ] . write ( '' ) kpffiu [ 'foldlck' ] . write ( '' ) kpffiu [ 'hkxlck' ] . write ( '' ) kpffiu [ 'hkylck' ] . write ( '' ) kpffiu [ 'ttxlck' ] . write ( '' ) kpffiu [ 'ttylck' ] . write ( '' ) @classmethod def post_condition ( cls , args ): pass","title":"UnlockFIU"},{"location":"scripts/UnlockFIU/#unlockfiu","text":"Bases: KPFFunction Unlock the FIU mechanisms KTL Keywords Used: kpffiu.ADC1LCK kpffiu.ADC2LCK kpffiu.FOLDLCK kpffiu.HKXLCK kpffiu.HKYLCK kpffiu.TTXLCK kpffiu.TTYLCK Source code in kpf/fiu/UnlockFIU.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class UnlockFIU ( KPFFunction ): '''Unlock the FIU mechanisms KTL Keywords Used: - `kpffiu.ADC1LCK` - `kpffiu.ADC2LCK` - `kpffiu.FOLDLCK` - `kpffiu.HKXLCK` - `kpffiu.HKYLCK` - `kpffiu.TTXLCK` - `kpffiu.TTYLCK` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpffiu = ktl . cache ( 'kpffiu' ) kpffiu [ 'adc1lck' ] . write ( '' ) kpffiu [ 'adc2lck' ] . write ( '' ) kpffiu [ 'foldlck' ] . write ( '' ) kpffiu [ 'hkxlck' ] . write ( '' ) kpffiu [ 'hkylck' ] . write ( '' ) kpffiu [ 'ttxlck' ] . write ( '' ) kpffiu [ 'ttylck' ] . write ( '' ) @classmethod def post_condition ( cls , args ): pass","title":"UnlockFIU"},{"location":"scripts/VerifyCurrentBase/","text":"VerifyCurrentBase Bases: KPFFunction Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) KTL Keywords Used: dcs1.PONAME kpfguide.CURRENT_BASE kpfguide.SCIENCE_BASE kpfguide.SKY_BASE kpfconfig.SCRIPTMSG Source code in kpf/fiu/VerifyCurrentBase.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class VerifyCurrentBase ( KPFFunction ): '''Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) KTL Keywords Used: - `dcs1.PONAME` - `kpfguide.CURRENT_BASE` - `kpfguide.SCIENCE_BASE` - `kpfguide.SKY_BASE` - `kpfconfig.SCRIPTMSG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ponamekw = ktl . cache ( 'dcs1' , 'PONAME' ) poname = ponamekw . read () . upper () kpfguide = ktl . cache ( 'kpfguide' ) current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) science_base = kpfguide [ 'SCIENCE_BASE' ] . read ( binary = True ) sky_base = kpfguide [ 'SKY_BASE' ] . read ( binary = True ) science_match = np . all ( np . isclose ( current_base , science_base , atol = 0.01 )) sky_match = np . all ( np . isclose ( current_base , sky_base , atol = 0.01 )) msg = f \"CURRENT_BASE=\" if science_match : log . debug ( f \"CURRENT_BASE is science fiber, PO = { poname } \" ) msg += 'SCIENCE_BASE' elif sky_match : log . debug ( f \"CURRENT_BASE is sky fiber, PO = { poname } \" ) msg += 'SKY_BASE' else : log . debug ( f \"CURRENT_BASE is { current_base } , PO = { poname } \" ) msg += 'custom' poname_match = ( science_match and poname == 'KPF' ) \\ or ( sky_match and poname == 'SKY' ) if poname_match : msg += f \" which is consistent with PONAME= { poname } \" log . debug ( msg ) else : msg += f \" which is NOT consistent with PONAME= { poname } \" log . error ( msg ) print ( msg ) if args . get ( 'query_user' , False ) == True and poname_match == False : # Check with user SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) msg = 'Waiting for user confirmation on PO mismatch' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"#####################################################\" ) print ( \"The dcs.PONAME value is incosistent with CURRENT_BASE\" ) print ( \"Please double check that the target object is where you\" ) print ( \"want it to be before proceeding.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) return poname_match @classmethod def post_condition ( cls , args ): pass","title":"VerifyCurrentBase"},{"location":"scripts/VerifyCurrentBase/#verifycurrentbase","text":"Bases: KPFFunction Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) KTL Keywords Used: dcs1.PONAME kpfguide.CURRENT_BASE kpfguide.SCIENCE_BASE kpfguide.SKY_BASE kpfconfig.SCRIPTMSG Source code in kpf/fiu/VerifyCurrentBase.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class VerifyCurrentBase ( KPFFunction ): '''Check whether the tip tilt system's target pixel (kpffiu.CURRENT_BASE) is consistent with the selected pointing origin (dcs.PONAME) KTL Keywords Used: - `dcs1.PONAME` - `kpfguide.CURRENT_BASE` - `kpfguide.SCIENCE_BASE` - `kpfguide.SKY_BASE` - `kpfconfig.SCRIPTMSG` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): ponamekw = ktl . cache ( 'dcs1' , 'PONAME' ) poname = ponamekw . read () . upper () kpfguide = ktl . cache ( 'kpfguide' ) current_base = kpfguide [ 'CURRENT_BASE' ] . read ( binary = True ) science_base = kpfguide [ 'SCIENCE_BASE' ] . read ( binary = True ) sky_base = kpfguide [ 'SKY_BASE' ] . read ( binary = True ) science_match = np . all ( np . isclose ( current_base , science_base , atol = 0.01 )) sky_match = np . all ( np . isclose ( current_base , sky_base , atol = 0.01 )) msg = f \"CURRENT_BASE=\" if science_match : log . debug ( f \"CURRENT_BASE is science fiber, PO = { poname } \" ) msg += 'SCIENCE_BASE' elif sky_match : log . debug ( f \"CURRENT_BASE is sky fiber, PO = { poname } \" ) msg += 'SKY_BASE' else : log . debug ( f \"CURRENT_BASE is { current_base } , PO = { poname } \" ) msg += 'custom' poname_match = ( science_match and poname == 'KPF' ) \\ or ( sky_match and poname == 'SKY' ) if poname_match : msg += f \" which is consistent with PONAME= { poname } \" log . debug ( msg ) else : msg += f \" which is NOT consistent with PONAME= { poname } \" log . error ( msg ) print ( msg ) if args . get ( 'query_user' , False ) == True and poname_match == False : # Check with user SCRIPTMSG = ktl . cache ( 'kpfconfig' , 'SCRIPTMSG' ) msg = 'Waiting for user confirmation on PO mismatch' log . info ( msg ) SCRIPTMSG . write ( msg ) print () print ( \"#####################################################\" ) print ( \"The dcs.PONAME value is incosistent with CURRENT_BASE\" ) print ( \"Please double check that the target object is where you\" ) print ( \"want it to be before proceeding.\" ) print () print ( \"Do you wish to continue executing this OB?\" ) print ( \"(y/n) [y]:\" ) print ( \"#####################################################\" ) print () user_input = input () log . debug ( f 'response: \" { user_input } \"' ) SCRIPTMSG . write ( '' ) if user_input . lower () . strip () in [ 'n' , 'no' , 'a' , 'abort' , 'q' , 'quit' ]: raise KPFException ( \"User chose to halt execution\" ) return poname_match @classmethod def post_condition ( cls , args ): pass","title":"VerifyCurrentBase"},{"location":"scripts/WaitForCalSource/","text":"WaitForCalSource Bases: KPFFunction Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). Parameters: CalSource ( str ) \u2013 Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: kpfcal.OCTAGON Source code in kpf/calbench/WaitForCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WaitForCalSource ( KPFFunction ): '''Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). Args: CalSource (str): Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: - `kpfcal.OCTAGON` ''' @classmethod def pre_condition ( cls , args ): OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( OCTAGON . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for octagon\" ) @classmethod def post_condition ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) raise FailedToReachDestination ( OCTAGON . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) return super () . add_cmdline_args ( parser )","title":"WaitForCalSource"},{"location":"scripts/WaitForCalSource/#waitforcalsource","text":"Bases: KPFFunction Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). Parameters: CalSource ( str ) \u2013 Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: kpfcal.OCTAGON Source code in kpf/calbench/WaitForCalSource.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WaitForCalSource ( KPFFunction ): '''Wait for the move to a cal source is complete (kpfcal.OCTAGON keyword). Args: CalSource (str): Which lamp to select? Allowed Values: EtalonFiber, BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, SoCal-CalFib, LFCFiber KTL Keywords Used: - `kpfcal.OCTAGON` ''' @classmethod def pre_condition ( cls , args ): OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) allowed_values = list ( OCTAGON . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalSource' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for octagon\" ) @classmethod def post_condition ( cls , args ): target = args . get ( 'CalSource' ) timeout = cfg . getfloat ( 'times' , 'octagon_move_time' , fallback = 60 ) expr = f \"($kpfcal.OCTAGON == { target } )\" success = ktl . waitFor ( expr , timeout = timeout ) if success is not True : OCTAGON = ktl . cache ( 'kpfcal' , 'OCTAGON' ) raise FailedToReachDestination ( OCTAGON . read (), target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalSource' , type = str , choices = [ 'Home' , 'EtalonFiber' , 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'SoCal-CalFib' , 'LFCFiber' ], help = 'Octagon position to choose?' ) return super () . add_cmdline_args ( parser )","title":"WaitForCalSource"},{"location":"scripts/WaitForConfigureFIU/","text":"WaitForConfigureFIU Bases: KPFFunction Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. Parameters: mode ( str ) \u2013 The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration KTL Keywords Used: kpffiu.MODE Scripts Called: kpf.calbench.ConfigureFIUOnce Source code in kpf/fiu/WaitForConfigureFIU.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class WaitForConfigureFIU ( KPFFunction ): '''Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. Args: mode (str): The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration KTL Keywords Used: - `kpffiu.MODE` Scripts Called: - `kpf.calbench.ConfigureFIUOnce` ''' @classmethod def pre_condition ( cls , args ): MODE = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( MODE . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args ): dest = args . get ( 'mode' ) ntries = cfg . getint ( 'retries' , 'fiu_mode_tries' , fallback = 2 ) shim_time = cfg . getfloat ( 'times' , 'fiu_mode_shim_time' , fallback = 2 ) for i in range ( ntries ): ok = WaitForConfigureFIUOnce . execute ({ 'mode' : dest }) if ok is False : log . warning ( f 'FIU move failed on attempt { i + 1 } of { ntries } ' ) time . sleep ( shim_time ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : True }) else : break @classmethod def post_condition ( cls , args ): dest = args . get ( 'mode' ) MODE = ktl . cache ( 'kpffiu' , 'MODE' ) modes = MODE . read () if dest . lower () not in modes . lower () . split ( ',' ): raise FailedToReachDestination ( modes , dest ) else : log . info ( f \"FIU mode is now { dest } \" ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) return super () . add_cmdline_args ( parser )","title":"WaitForConfigureFIU"},{"location":"scripts/WaitForConfigureFIU/#waitforconfigurefiu","text":"Bases: KPFFunction Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. Parameters: mode ( str ) \u2013 The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration KTL Keywords Used: kpffiu.MODE Scripts Called: kpf.calbench.ConfigureFIUOnce Source code in kpf/fiu/WaitForConfigureFIU.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class WaitForConfigureFIU ( KPFFunction ): '''Wait for the FIU to reach specified mode (kpffiu.MODE). This will retry the configure command if the system fails to reach its destination. Args: mode (str): The desired FIU mode. Allowed values: Stowed, Alignment, Acquisition, Observing, Calibration KTL Keywords Used: - `kpffiu.MODE` Scripts Called: - `kpf.calbench.ConfigureFIUOnce` ''' @classmethod def pre_condition ( cls , args ): MODE = ktl . cache ( 'kpffiu' , 'MODE' ) allowed_values = list ( MODE . _getEnumerators ()) if 'None' in allowed_values : allowed_values . pop ( allowed_values . index ( 'None' )) check_input ( args , 'mode' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args ): dest = args . get ( 'mode' ) ntries = cfg . getint ( 'retries' , 'fiu_mode_tries' , fallback = 2 ) shim_time = cfg . getfloat ( 'times' , 'fiu_mode_shim_time' , fallback = 2 ) for i in range ( ntries ): ok = WaitForConfigureFIUOnce . execute ({ 'mode' : dest }) if ok is False : log . warning ( f 'FIU move failed on attempt { i + 1 } of { ntries } ' ) time . sleep ( shim_time ) ConfigureFIUOnce . execute ({ 'mode' : dest , 'wait' : True }) else : break @classmethod def post_condition ( cls , args ): dest = args . get ( 'mode' ) MODE = ktl . cache ( 'kpffiu' , 'MODE' ) modes = MODE . read () if dest . lower () not in modes . lower () . split ( ',' ): raise FailedToReachDestination ( modes , dest ) else : log . info ( f \"FIU mode is now { dest } \" ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'mode' , type = str , choices = [ 'Stowed' , 'Alignment' , 'Acquisition' , 'Observing' , 'Calibration' ], help = 'Desired mode (see kpffiu.MODE)' ) return super () . add_cmdline_args ( parser )","title":"WaitForConfigureFIU"},{"location":"scripts/WaitForFlatFieldFiberPos/","text":"WaitForFlatFieldFiberPos Bases: KPFFunction Wait for the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. Parameters: FF_FiberPos ( str ) \u2013 The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used kpfcal.FF_FIBERPOS Source code in kpf/calbench/WaitForFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class WaitForFlatFieldFiberPos ( KPFFunction ): '''Wait for the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. Args: FF_FiberPos (str): The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used - `kpfcal.FF_FIBERPOS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for FF_FiberPos filter wheel\" ) @classmethod def post_condition ( cls , args ): target = args . get ( 'FF_FiberPos' ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = 0.1 ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForFlatFieldFiberPos"},{"location":"scripts/WaitForFlatFieldFiberPos/#waitforflatfieldfiberpos","text":"Bases: KPFFunction Wait for the flat field fiber aperture via the kpfcal.FF_FIBERPOS keyword. Parameters: FF_FiberPos ( str ) \u2013 The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait ( bool ) \u2013 Wait for move to complete before returning? default: True KTL Keywords Used kpfcal.FF_FIBERPOS Source code in kpf/calbench/WaitForFlatFieldFiberPos.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class WaitForFlatFieldFiberPos ( KPFFunction ): '''Wait for the flat field fiber aperture via the `kpfcal.FF_FIBERPOS` keyword. Args: FF_FiberPos (str): The name of the flat field fiber position desired. Allowed Values: \"Blank\", \"6 mm f/5\", \"7.5 mm f/4\", \"10 mm f/3\", \"13.2 mm f/2.3\", \"Open\". wait (bool): Wait for move to complete before returning? default: True KTL Keywords Used - `kpfcal.FF_FIBERPOS` ''' @classmethod def pre_condition ( cls , args ): keyword = ktl . cache ( 'kpfcal' , 'FF_FiberPos' ) allowed_values = list ( keyword . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'FF_FiberPos' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'FF_FiberPos' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for FF_FiberPos filter wheel\" ) @classmethod def post_condition ( cls , args ): target = args . get ( 'FF_FiberPos' ) expr = f \"($kpfcal.FF_FiberPos == ' { target } ')\" success = ktl . waitFor ( expr , timeout = 0.1 ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'FF_FiberPos' , type = str , choices = [ \"Blank\" , \"6 mm f/5\" , \"7.5 mm f/4\" , \"10 mm f/3\" , \"13.2 mm f/2.3\" , \"Open\" ], help = 'Wide flat aperture to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForFlatFieldFiberPos"},{"location":"scripts/WaitForL0File/","text":"WaitForL0File Bases: KPFFunction Wait a short time to see if kpfassemble writes a new L0 file. If it does, print a log line with that file name. KTL Keywords Used: kpfassemble.LOUTFILE Source code in kpf/spectrograph/WaitForL0File.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class WaitForL0File ( KPFFunction ): '''Wait a short time to see if `kpfassemble` writes a new L0 file. If it does, print a log line with that file name. KTL Keywords Used: - `kpfassemble.LOUTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( 'Waiting for new L0 file' ) LOUTFILE = ktl . cache ( 'kpfassemble' , 'LOUTFILE' ) initial_LOUTFILE = LOUTFILE . read () timeout = 10 timeout = cfg . getfloat ( 'times' , 'L0_file_creation' , fallback = 10 ) found_new_file = LOUTFILE . waitFor ( f '!=\" { initial_LOUTFILE } \"' , timeout = timeout ) if found_new_file is True : new_file = LOUTFILE . read () try : hdr = fits . getheader ( new_file , ext = 0 ) green_file = hdr . get ( 'GRFILENA' ) red_file = hdr . get ( 'RDFILENA' ) new_file_name = Path ( new_file ) . name log . info ( f \"L0 file { new_file_name } assembled from { green_file } , { red_file } \" ) except : log . info ( f 'L0 file { new_file } assembled' ) else : log . debug ( 'WaitForL0File did not find new file' ) @classmethod def post_condition ( cls , args ): pass","title":"WaitForL0File"},{"location":"scripts/WaitForL0File/#waitforl0file","text":"Bases: KPFFunction Wait a short time to see if kpfassemble writes a new L0 file. If it does, print a log line with that file name. KTL Keywords Used: kpfassemble.LOUTFILE Source code in kpf/spectrograph/WaitForL0File.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class WaitForL0File ( KPFFunction ): '''Wait a short time to see if `kpfassemble` writes a new L0 file. If it does, print a log line with that file name. KTL Keywords Used: - `kpfassemble.LOUTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( 'Waiting for new L0 file' ) LOUTFILE = ktl . cache ( 'kpfassemble' , 'LOUTFILE' ) initial_LOUTFILE = LOUTFILE . read () timeout = 10 timeout = cfg . getfloat ( 'times' , 'L0_file_creation' , fallback = 10 ) found_new_file = LOUTFILE . waitFor ( f '!=\" { initial_LOUTFILE } \"' , timeout = timeout ) if found_new_file is True : new_file = LOUTFILE . read () try : hdr = fits . getheader ( new_file , ext = 0 ) green_file = hdr . get ( 'GRFILENA' ) red_file = hdr . get ( 'RDFILENA' ) new_file_name = Path ( new_file ) . name log . info ( f \"L0 file { new_file_name } assembled from { green_file } , { red_file } \" ) except : log . info ( f 'L0 file { new_file } assembled' ) else : log . debug ( 'WaitForL0File did not find new file' ) @classmethod def post_condition ( cls , args ): pass","title":"WaitForL0File"},{"location":"scripts/WaitForLFCReady/","text":"WaitForLFCReady Bases: KPFFunction Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode KTL Keywords Used: kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA kpfcal.WOBBLE kpfcal.OPERATIONMODE kpfcal.SPECFLAT Source code in kpf/calbench/WaitForLFCReady.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class WaitForLFCReady ( KPFFunction ): '''Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode KTL Keywords Used: - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` - `kpfcal.WOBBLE` - `kpfcal.OPERATIONMODE` - `kpfcal.SPECFLAT` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expr = f \"($kpfmon.HB_MENLOSTA == 'OK')\" expr += f \"and ($kpfmon.LFCREADYSTA == 'OK')\" expr += f \"and ($kpfcal.WOBBLE == 'False')\" expr += f \"and ($kpfcal.OPERATIONMODE == 'AstroComb')\" expr += f \"and ($kpfcal.SPECFLATIR == 'True')\" expr += f \"and ($kpfcal.SPECFLATVIS == 'True')\" timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 300 ) success = ktl . waitFor ( expr , timeout = timeout ) return success @classmethod def post_condition ( cls , args ): pass","title":"WaitForLFCReady"},{"location":"scripts/WaitForLFCReady/#waitforlfcready","text":"Bases: KPFFunction Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode KTL Keywords Used: kpfmon.HB_MENLOSTA kpfmon.LFCREADYSTA kpfcal.WOBBLE kpfcal.OPERATIONMODE kpfcal.SPECFLAT Source code in kpf/calbench/WaitForLFCReady.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class WaitForLFCReady ( KPFFunction ): '''Wait for the Laser Frequency Comb (LFC) to be ready and in \"AstroComb\" mode KTL Keywords Used: - `kpfmon.HB_MENLOSTA` - `kpfmon.LFCREADYSTA` - `kpfcal.WOBBLE` - `kpfcal.OPERATIONMODE` - `kpfcal.SPECFLAT` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): expr = f \"($kpfmon.HB_MENLOSTA == 'OK')\" expr += f \"and ($kpfmon.LFCREADYSTA == 'OK')\" expr += f \"and ($kpfcal.WOBBLE == 'False')\" expr += f \"and ($kpfcal.OPERATIONMODE == 'AstroComb')\" expr += f \"and ($kpfcal.SPECFLATIR == 'True')\" expr += f \"and ($kpfcal.SPECFLATVIS == 'True')\" timeout = cfg . getfloat ( 'times' , 'LFC_startup_time' , fallback = 300 ) success = ktl . waitFor ( expr , timeout = timeout ) return success @classmethod def post_condition ( cls , args ): pass","title":"WaitForLFCReady"},{"location":"scripts/WaitForLampWarm/","text":"WaitForLampWarm Bases: KPFFunction Wait for the specified lamp to be warm. Parameters: CalSource ( str ) \u2013 Which lamp to wait for. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat KTL Keywords Used: kpflamps.FF_FIBER_STATUS kpflamps.FF_FIBER_TIMEON kpflamps.FF_FIBER_THRESHOLD kpflamps.BRDBANDFIBER_STATUS kpflamps.BRDBANDFIBER_TIMEON kpflamps.BRDBANDFIBER_THRESHOLD kpflamps.TH_DAILY_STATUS kpflamps.TH_DAILY_TIMEON kpflamps.TH_DAILY_THRESHOLD kpflamps.TH_GOLD_STATUS kpflamps.TH_GOLD_TIMEON kpflamps.TH_GOLD_THRESHOLD kpflamps.U_DAILY_STATUS kpflamps.U_DAILY_TIMEON kpflamps.U_DAILY_THRESHOLD kpflamps.U_GOLD_STATUS kpflamps.U_GOLD_TIMEON kpflamps.U_GOLD_THRESHOLD Scripts Called: kpf.calbench.CalLampPower Source code in kpf/calbench/WaitForLampWarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class WaitForLampWarm ( KPFFunction ): '''Wait for the specified lamp to be warm. Args: CalSource (str): Which lamp to wait for. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat KTL Keywords Used: - `kpflamps.FF_FIBER_STATUS` - `kpflamps.FF_FIBER_TIMEON` - `kpflamps.FF_FIBER_THRESHOLD` - `kpflamps.BRDBANDFIBER_STATUS` - `kpflamps.BRDBANDFIBER_TIMEON` - `kpflamps.BRDBANDFIBER_THRESHOLD` - `kpflamps.TH_DAILY_STATUS` - `kpflamps.TH_DAILY_TIMEON` - `kpflamps.TH_DAILY_THRESHOLD` - `kpflamps.TH_GOLD_STATUS` - `kpflamps.TH_GOLD_TIMEON` - `kpflamps.TH_GOLD_THRESHOLD` - `kpflamps.U_DAILY_STATUS` - `kpflamps.U_DAILY_TIMEON` - `kpflamps.U_DAILY_THRESHOLD` - `kpflamps.U_GOLD_STATUS` - `kpflamps.U_GOLD_TIMEON` - `kpflamps.U_GOLD_THRESHOLD` Scripts Called: - `kpf.calbench.CalLampPower` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'CalSource' ) @classmethod def perform ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : kpflamps = ktl . cache ( 'kpflamps' ) log . debug ( f 'Lamp { lamp } does need to be warmed up before use' ) # Check that lamp is actually on lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : log . warning ( f \"Lamp { lamp } is not on: { lamp_status } \" ) CalLampPower . execute ({ 'lamp' : args . get ( 'CalSource' ), 'power' : 'on' }) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : raise KPFException ( f \"Lamp { lamp } should be on: { lamp_status } \" ) elif lamp_status == 'Warm' : log . debug ( f \"Lamp { lamp } is warm\" ) elif lamp_status == 'Warming' : lamp_timeon = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) lamp_threshold = kpflamps [ f ' { lamp } _THRESHOLD' ] . read ( binary = True ) time_to_wait = lamp_threshold - lamp_timeon log . info ( f \"Lamp { lamp } is warming\" ) log . info ( f \"Estimated time remaining = { time_to_wait : .0f } s\" ) while lamp_statuskw . read () != 'Warm' : # Check if scriptstop has been activated check_scriptstop () log . debug ( f 'Waiting for { lamp } _STATUS == Warm' ) expr = f \"($kpflamps. { lamp } _STATUS == 'Warm')\" warm = ktl . waitFor ( expr , timeout = 30 ) if warm is False : new_lamp_timeton = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) if new_lamp_timeton <= lamp_timeon : break lamp_timeon = new_lamp_timeton @classmethod def post_condition ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status != 'Warm' : raise FailedPostCondition ( f \"Lamp { lamp } should be warm: { lamp_status } \" ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' ], help = 'Which lamp are we waiting on?' ) return super () . add_cmdline_args ( parser )","title":"WaitForLampWarm"},{"location":"scripts/WaitForLampWarm/#waitforlampwarm","text":"Bases: KPFFunction Wait for the specified lamp to be warm. Parameters: CalSource ( str ) \u2013 Which lamp to wait for. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat KTL Keywords Used: kpflamps.FF_FIBER_STATUS kpflamps.FF_FIBER_TIMEON kpflamps.FF_FIBER_THRESHOLD kpflamps.BRDBANDFIBER_STATUS kpflamps.BRDBANDFIBER_TIMEON kpflamps.BRDBANDFIBER_THRESHOLD kpflamps.TH_DAILY_STATUS kpflamps.TH_DAILY_TIMEON kpflamps.TH_DAILY_THRESHOLD kpflamps.TH_GOLD_STATUS kpflamps.TH_GOLD_TIMEON kpflamps.TH_GOLD_THRESHOLD kpflamps.U_DAILY_STATUS kpflamps.U_DAILY_TIMEON kpflamps.U_DAILY_THRESHOLD kpflamps.U_GOLD_STATUS kpflamps.U_GOLD_TIMEON kpflamps.U_GOLD_THRESHOLD Scripts Called: kpf.calbench.CalLampPower Source code in kpf/calbench/WaitForLampWarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class WaitForLampWarm ( KPFFunction ): '''Wait for the specified lamp to be warm. Args: CalSource (str): Which lamp to wait for. Allowed Values: BrdbandFiber, U_gold, U_daily, Th_daily, Th_gold, WideFlat KTL Keywords Used: - `kpflamps.FF_FIBER_STATUS` - `kpflamps.FF_FIBER_TIMEON` - `kpflamps.FF_FIBER_THRESHOLD` - `kpflamps.BRDBANDFIBER_STATUS` - `kpflamps.BRDBANDFIBER_TIMEON` - `kpflamps.BRDBANDFIBER_THRESHOLD` - `kpflamps.TH_DAILY_STATUS` - `kpflamps.TH_DAILY_TIMEON` - `kpflamps.TH_DAILY_THRESHOLD` - `kpflamps.TH_GOLD_STATUS` - `kpflamps.TH_GOLD_TIMEON` - `kpflamps.TH_GOLD_THRESHOLD` - `kpflamps.U_DAILY_STATUS` - `kpflamps.U_DAILY_TIMEON` - `kpflamps.U_DAILY_THRESHOLD` - `kpflamps.U_GOLD_STATUS` - `kpflamps.U_GOLD_TIMEON` - `kpflamps.U_GOLD_THRESHOLD` Scripts Called: - `kpf.calbench.CalLampPower` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'CalSource' ) @classmethod def perform ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : kpflamps = ktl . cache ( 'kpflamps' ) log . debug ( f 'Lamp { lamp } does need to be warmed up before use' ) # Check that lamp is actually on lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : log . warning ( f \"Lamp { lamp } is not on: { lamp_status } \" ) CalLampPower . execute ({ 'lamp' : args . get ( 'CalSource' ), 'power' : 'on' }) lamp_status = lamp_statuskw . read () if lamp_status == 'Off' : raise KPFException ( f \"Lamp { lamp } should be on: { lamp_status } \" ) elif lamp_status == 'Warm' : log . debug ( f \"Lamp { lamp } is warm\" ) elif lamp_status == 'Warming' : lamp_timeon = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) lamp_threshold = kpflamps [ f ' { lamp } _THRESHOLD' ] . read ( binary = True ) time_to_wait = lamp_threshold - lamp_timeon log . info ( f \"Lamp { lamp } is warming\" ) log . info ( f \"Estimated time remaining = { time_to_wait : .0f } s\" ) while lamp_statuskw . read () != 'Warm' : # Check if scriptstop has been activated check_scriptstop () log . debug ( f 'Waiting for { lamp } _STATUS == Warm' ) expr = f \"($kpflamps. { lamp } _STATUS == 'Warm')\" warm = ktl . waitFor ( expr , timeout = 30 ) if warm is False : new_lamp_timeton = kpflamps [ f ' { lamp } _TIMEON' ] . read ( binary = True ) if new_lamp_timeton <= lamp_timeon : break lamp_timeon = new_lamp_timeton @classmethod def post_condition ( cls , args ): lamp = standardize_lamp_name ( args . get ( 'CalSource' )) lamps_that_need_warmup = [ 'FF_FIBER' , 'BRDBANDFIBER' , 'TH_DAILY' , 'TH_GOLD' , 'U_DAILY' , 'U_GOLD' ] if lamp in lamps_that_need_warmup : lamp_statuskw = ktl . cache ( 'kpflamps' , f ' { lamp } _STATUS' ) lamp_status = lamp_statuskw . read () if lamp_status != 'Warm' : raise FailedPostCondition ( f \"Lamp { lamp } should be warm: { lamp_status } \" ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'lamp' , type = str , choices = [ 'BrdbandFiber' , 'U_gold' , 'U_daily' , 'Th_daily' , 'Th_gold' , 'WideFlat' ], help = 'Which lamp are we waiting on?' ) return super () . add_cmdline_args ( parser )","title":"WaitForLampWarm"},{"location":"scripts/WaitForND/","text":"WaitForND Bases: KPFFunction Wait for both ND filter wheels. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Functions Called: kpf.calbench.WaitForND1 kpf.calbench.WaitForND2 Source code in kpf/calbench/WaitForND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class WaitForND ( KPFFunction ): '''Wait for both ND filter wheels. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` Functions Called: - `kpf.calbench.WaitForND1` - `kpf.calbench.WaitForND2` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForND"},{"location":"scripts/WaitForND/#waitfornd","text":"Bases: KPFFunction Wait for both ND filter wheels. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 0.8 , OD 1.0 , OD 4.0 Functions Called: kpf.calbench.WaitForND1 kpf.calbench.WaitForND2 Source code in kpf/calbench/WaitForND.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class WaitForND ( KPFFunction ): '''Wait for both ND filter wheels. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 0.8`, `OD 1.0`, `OD 4.0` Functions Called: - `kpf.calbench.WaitForND1` - `kpf.calbench.WaitForND2` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): WaitForND1 . execute ( args ) WaitForND2 . execute ( args ) @classmethod def post_condition ( cls , args ): pass @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForND"},{"location":"scripts/WaitForND1/","text":"WaitForND1 Bases: KPFFunction Wait for the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 KTL Keywords Used: kpfcal.ND1POS Source code in kpf/calbench/WaitForND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class WaitForND1 ( KPFFunction ): '''Wait for the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` KTL Keywords Used: - `kpfcal.ND1POS` ''' @classmethod def pre_condition ( cls , args ): ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( ND1POS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND1' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND1POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND1 filter wheel\" ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForND1"},{"location":"scripts/WaitForND1/#waitfornd1","text":"Bases: KPFFunction Wait for the ND1 filter wheel (the one at the output of the octagon) via the kpfcal.ND1POS keyword. Parameters: CalND1 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: OD 0.1 , OD 1.0 , OD 1.3 , OD 2.0 , OD 3.0 , OD 4.0 KTL Keywords Used: kpfcal.ND1POS Source code in kpf/calbench/WaitForND1.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class WaitForND1 ( KPFFunction ): '''Wait for the ND1 filter wheel (the one at the output of the octagon) via the `kpfcal.ND1POS` keyword. Args: CalND1 (str): The neutral density filter to put in the first filter wheel. This affects both the simultaneous calibration light and light which can be routed through the FIU to the science and sky fibers. Allowed Values: `OD 0.1`, `OD 1.0`, `OD 1.3`, `OD 2.0`, `OD 3.0`, `OD 4.0` KTL Keywords Used: - `kpfcal.ND1POS` ''' @classmethod def pre_condition ( cls , args ): ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) allowed_values = list ( ND1POS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND1' , allowed_values = allowed_values ) @classmethod def perform ( cls , args ): target = args . get ( 'CalND1' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND1POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND1 filter wheel\" ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND1target = args . get ( 'CalND1' ) ND1POS = ktl . cache ( 'kpfcal' , 'ND1POS' ) if ND1POS . waitFor ( f \"== ' { ND1target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND1POS . read (), ND1target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND1' , type = str , choices = [ \"OD 0.1\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" , \"OD 3.0\" , \"OD 4.0\" ], help = 'ND1 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForND1"},{"location":"scripts/WaitForND2/","text":"WaitForND2 Bases: KPFFunction Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. Parameters: CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 1.0 , OD 1.3 , OD 2.0 KTL Keywords Used: kpfcal.ND2POS Source code in kpf/calbench/WaitForND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class WaitForND2 ( KPFFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. Args: CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 1.0`, `OD 1.3`, `OD 2.0` KTL Keywords Used: - `kpfcal.ND2POS` ''' @classmethod def pre_condition ( cls , args ): ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( ND2POS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args ): target = args . get ( 'CalND2' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND2POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND2 filter wheel\" ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"WaitForND2"},{"location":"scripts/WaitForND2/#waitfornd2","text":"Bases: KPFFunction","title":"WaitForND2"},{"location":"scripts/WaitForND2/#kpf.calbench.WaitForND2.WaitForND2--description","text":"Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the kpfcal.ND2POS keyword. Parameters: CalND2 ( str ) \u2013 The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: OD 0.1 , OD 0.3 , OD 0.5 , OD 1.0 , OD 1.3 , OD 2.0 KTL Keywords Used: kpfcal.ND2POS Source code in kpf/calbench/WaitForND2.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class WaitForND2 ( KPFFunction ): '''# Description Set the filter in the ND2 filter wheel (the one at the output of the octagon) via the `kpfcal.ND2POS` keyword. Args: CalND2 (str): The neutral density filter to put in the first filter wheel. This affects only the light injected in to the simultaneous calibration fiber. Allowed Values: `OD 0.1`, `OD 0.3`, `OD 0.5`, `OD 1.0`, `OD 1.3`, `OD 2.0` KTL Keywords Used: - `kpfcal.ND2POS` ''' @classmethod def pre_condition ( cls , args ): ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) allowed_values = list ( ND2POS . _getEnumerators ()) if 'Unknown' in allowed_values : allowed_values . pop ( allowed_values . index ( 'Unknown' )) check_input ( args , 'CalND2' , allowed_values = allowed_values ) return True @classmethod def perform ( cls , args ): target = args . get ( 'CalND2' ) timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) expr = f \"($kpfcal.ND2POS == ' { target } ')\" success = ktl . waitFor ( expr , timeout = timeout ) if success is False : log . error ( f \"Timed out waiting for ND2 filter wheel\" ) @classmethod def post_condition ( cls , args ): timeout = cfg . getfloat ( 'times' , 'nd_move_time' , fallback = 20 ) ND2target = args . get ( 'CalND2' ) ND2POS = ktl . cache ( 'kpfcal' , 'ND2POS' ) if ND2POS . waitFor ( f \"== ' { ND2target } '\" , timeout = timeout ) == False : raise FailedToReachDestination ( ND2POS . read (), ND2target ) @classmethod def add_cmdline_args ( cls , parser ): parser . add_argument ( 'CalND2' , type = str , choices = [ \"OD 0.1\" , \"OD 0.3\" , \"OD 0.5\" , \"OD 1.0\" , \"OD 1.3\" , \"OD 2.0\" ], help = 'ND2 Filter to use.' ) return super () . add_cmdline_args ( parser )","title":"Description"},{"location":"scripts/WaitForReadout/","text":"WaitForReadout Bases: KPFFunction Waits for the kpfexpose.EXPOSE keyword to be \"Readout\". This will block until the camera enters the readout state. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE kpfgreen.NEXTFILE kpfred.NEXTFILE Source code in kpf/spectrograph/WaitForReadout.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class WaitForReadout ( KPFFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Readout\". This will block until the camera enters the readout state. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` - `kpfgreen.NEXTFILE` - `kpfred.NEXTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) wait_time = exptime + buffer_time if starting_status < 3 else buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 4)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 4)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 4)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 4)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for readout to begin\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) if 'Green' in detector_list : nextfile = ktl . cache ( 'kpfgreen' , 'NEXTFILE' ) log . debug ( f \"Green nextfile: { nextfile . read () } \" ) if 'Red' in detector_list : nextfile = ktl . cache ( 'kpfred' , 'NEXTFILE' ) log . debug ( f \"Red nextfile: { nextfile . read () } \" ) else : log . warning ( 'WaitForReadout failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args ): expr = \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready or Readout\" )","title":"WaitForReadout"},{"location":"scripts/WaitForReadout/#waitforreadout","text":"Bases: KPFFunction Waits for the kpfexpose.EXPOSE keyword to be \"Readout\". This will block until the camera enters the readout state. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE kpfgreen.NEXTFILE kpfred.NEXTFILE Source code in kpf/spectrograph/WaitForReadout.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class WaitForReadout ( KPFFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Readout\". This will block until the camera enters the readout state. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` - `kpfgreen.NEXTFILE` - `kpfred.NEXTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) wait_time = exptime + buffer_time if starting_status < 3 else buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 4)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 4)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 4)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 4)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for readout to begin\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) if 'Green' in detector_list : nextfile = ktl . cache ( 'kpfgreen' , 'NEXTFILE' ) log . debug ( f \"Green nextfile: { nextfile . read () } \" ) if 'Red' in detector_list : nextfile = ktl . cache ( 'kpfred' , 'NEXTFILE' ) log . debug ( f \"Red nextfile: { nextfile . read () } \" ) else : log . warning ( 'WaitForReadout failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args ): expr = \"($kpfexpose.EXPOSE == 'Ready') or ($kpfexpose.EXPOSE == 'Readout')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready or Readout\" )","title":"WaitForReadout"},{"location":"scripts/WaitForReady/","text":"WaitForReady Bases: KPFFunction Waits for the kpfexpose.EXPOSE keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE kpfgreen.NEXTFILE kpfred.NEXTFILE Source code in kpf/spectrograph/WaitForReady.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class WaitForReady ( KPFFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` - `kpfgreen.NEXTFILE` - `kpfred.NEXTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) read_times = [ cfg . getfloat ( 'time_estimates' , 'readout_red' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_green' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ), cfg . getfloat ( 'time_estimates' , 'readout_expmeter' , fallback = 1 ), ] slowest_read = max ( read_times ) wait_time = exptime + slowest_read + buffer_time if starting_status < 3 else slowest_read + buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 0)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 0)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 0)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 0)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for detectors to be ready\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) else : log . warning ( 'WaitForReady failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) if kpfexpose [ 'EXPOSE' ] . read () == 'Readout' : # Readout errors are handled in kpfred and kpfgreen services. # Just wait some extra time for that to recover the system. success = ktl . waitFor ( wait_logic , timeout = wait_time ) else : RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args ): expr = \"($kpfexpose.EXPOSE == 'Ready')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready\" )","title":"WaitForReady"},{"location":"scripts/WaitForReady/#waitforready","text":"Bases: KPFFunction Waits for the kpfexpose.EXPOSE keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. KTL Keywords Used: kpfexpose.EXPOSE kpfexpose.EXPLAINR kpfexpose.EXPLAINNR kpfexpose.EXPOSURE kpfexpose.TRIG_TARG kpfgreen.EXPSTATE kpfred.EXPSTATE kpf_hk.EXPSTATE kpfgreen.NEXTFILE kpfred.NEXTFILE Source code in kpf/spectrograph/WaitForReady.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class WaitForReady ( KPFFunction ): '''Waits for the `kpfexpose.EXPOSE` keyword to be \"Ready\". This will block until the camera is ready for another exposure. Times out after waiting for exposure time plus a set buffer time. KTL Keywords Used: - `kpfexpose.EXPOSE` - `kpfexpose.EXPLAINR` - `kpfexpose.EXPLAINNR` - `kpfexpose.EXPOSURE` - `kpfexpose.TRIG_TARG` - `kpfgreen.EXPSTATE` - `kpfred.EXPSTATE` - `kpf_hk.EXPSTATE` - `kpfgreen.NEXTFILE` - `kpfred.NEXTFILE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): kpfexpose = ktl . cache ( 'kpfexpose' ) exptime = kpfexpose [ 'EXPOSURE' ] . read ( binary = True ) starting_status = kpfexpose [ 'EXPOSE' ] . read ( binary = True ) detectors = kpfexpose [ 'TRIG_TARG' ] . read () detector_list = detectors . split ( ',' ) buffer_time = cfg . getfloat ( 'times' , 'readout_buffer_time' , fallback = 10 ) read_times = [ cfg . getfloat ( 'time_estimates' , 'readout_red' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_green' , fallback = 60 ), cfg . getfloat ( 'time_estimates' , 'readout_cahk' , fallback = 1 ), cfg . getfloat ( 'time_estimates' , 'readout_expmeter' , fallback = 1 ), ] slowest_read = max ( read_times ) wait_time = exptime + slowest_read + buffer_time if starting_status < 3 else slowest_read + buffer_time wait_logic_steps = [ '($kpfexpose.EXPOSE == 0)' ] if 'Green' in detector_list : wait_logic_steps . append ( \"($kpfgreen.EXPSTATE == 0)\" ) if 'Red' in detector_list : wait_logic_steps . append ( \"($kpfred.EXPSTATE == 0)\" ) if 'Ca_HK' in detector_list : wait_logic_steps . append ( \"($kpf_hk.EXPSTATE == 0)\" ) wait_logic = ' and ' . join ( wait_logic_steps ) log . debug ( f \"Waiting ( { wait_time : .0f } s max) for detectors to be ready\" ) success = ktl . waitFor ( wait_logic , timeout = wait_time ) if success is True : log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) else : log . warning ( 'WaitForReady failed to reach expected state' ) log . debug ( f 'kpfexpose is { kpfexpose [ \"EXPOSE\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINR = { kpfexpose [ \"EXPLAINR\" ] . read () } ' ) log . debug ( f 'kpfexpose EXPLAINNR = { kpfexpose [ \"EXPLAINNR\" ] . read () } ' ) if kpfexpose [ 'EXPOSE' ] . read () == 'Readout' : # Readout errors are handled in kpfred and kpfgreen services. # Just wait some extra time for that to recover the system. success = ktl . waitFor ( wait_logic , timeout = wait_time ) else : RecoverDetectors . execute ({}) @classmethod def post_condition ( cls , args ): expr = \"($kpfexpose.EXPOSE == 'Ready')\" timeout = cfg . getfloat ( 'times' , 'kpfexpose_reset_time' , fallback = 10 ) ok = ktl . waitFor ( expr , timeout = timeout ) if ok is not True : expose = ktl . cache ( 'kpfexpose' , 'EXPOSE' ) raise FailedPostCondition ( f \"kpfexpose.EXPOSE= { expose . read () } is not Ready\" )","title":"WaitForReady"},{"location":"scripts/WaitForSoCalOnTarget/","text":"WaitForSoCalOnTarget Bases: KPFFunction Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. KTL Keywords Used: kpfsocal.ENCSTA kpfsocal.EKOONLINE kpfsocal.EKOMODE kpfsocal.PYRIRRAD kpfsocal.AUTONOMOUS kpfsocal.CAN_OPEN kpfsocal.IS_OPEN kpfsocal.IS_TRACKING kpfsocal.ONLINE kpfsocal.STATE Source code in kpf/socal/WaitForSoCalOnTarget.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class WaitForSoCalOnTarget ( KPFFunction ): '''Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. KTL Keywords Used: - `kpfsocal.ENCSTA` - `kpfsocal.EKOONLINE` - `kpfsocal.EKOMODE` - `kpfsocal.PYRIRRAD` - `kpfsocal.AUTONOMOUS` - `kpfsocal.CAN_OPEN` - `kpfsocal.IS_OPEN` - `kpfsocal.IS_TRACKING` - `kpfsocal.ONLINE` - `kpfsocal.STATE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) pyrirrad_threshold = cfg . getfloat ( 'SoCal' , 'pyrirrad_threshold' , fallback = 1000 ) expr = '($kpfsocal.ENCSTA == 0) ' expr += 'and ($kpfsocal.EKOONLINE == Online)' expr += 'and ($kpfsocal.EKOMODE == 3)' expr += f 'and ($kpfsocal.PYRIRRAD > { pyrirrad_threshold } )' expr += 'and ($kpfsocal.AUTONOMOUS == 1)' expr += 'and ($kpfsocal.CAN_OPEN == True)' expr += 'and ($kpfsocal.IS_OPEN == True)' expr += 'and ($kpfsocal.IS_TRACKING == True)' expr += 'and ($kpfsocal.ONLINE == True)' expr += 'and ($kpfsocal.STATE == Tracking)' on_target = ktl . waitFor ( expr , timeout = timeout ) msg = { True : 'On Target' , False : 'NOT On Target' }[ on_target ] print ( msg ) if on_target == False : kpfsocal = ktl . cache ( 'kpfsocal' ) if kpfsocal [ 'ENCSTA' ] . read ( binary = True ) != 0 : log . info ( f 'ENCSTA != 0' ) if kpfsocal [ 'EKOONLINE' ] . read () != 'Online' : log . info ( f 'EKOONLINE != Online' ) if kpfsocal [ 'EKOMODE' ] . read ( binary = True ) != 3 : log . info ( f 'EKOMODE != 3' ) if kpfsocal [ 'PYRIRRAD' ] . read ( binary = True ) < pyrirrad_threshold : log . info ( f 'PYRIRRAD < { pyrirrad_threshold } ' ) if kpfsocal [ 'AUTONOMOUS' ] . read ( binary = True ) != 1 : log . info ( f 'AUTONOMOUS != 1' ) if kpfsocal [ 'IS_OPEN' ] . read ( binary = True ) != True : log . info ( f 'IS_OPEN != True' ) if kpfsocal [ 'IS_TRACKING' ] . read ( binary = True ) != True : log . info ( f 'IS_TRACKING != True' ) if kpfsocal [ 'ONLINE' ] . read ( binary = True ) != True : log . info ( f 'ONLINE != True' ) if kpfsocal [ 'STATE' ] . read () != 'Tracking' : log . info ( f 'STATE != Tracking' ) return on_target @classmethod def post_condition ( cls , args ): pass","title":"WaitForSoCalOnTarget"},{"location":"scripts/WaitForSoCalOnTarget/#waitforsocalontarget","text":"Bases: KPFFunction Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. KTL Keywords Used: kpfsocal.ENCSTA kpfsocal.EKOONLINE kpfsocal.EKOMODE kpfsocal.PYRIRRAD kpfsocal.AUTONOMOUS kpfsocal.CAN_OPEN kpfsocal.IS_OPEN kpfsocal.IS_TRACKING kpfsocal.ONLINE kpfsocal.STATE Source code in kpf/socal/WaitForSoCalOnTarget.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class WaitForSoCalOnTarget ( KPFFunction ): '''Returns True if, within a set timeout, a set of conditions which suggest that SoCal is on the Sun accurately evaluate to True. KTL Keywords Used: - `kpfsocal.ENCSTA` - `kpfsocal.EKOONLINE` - `kpfsocal.EKOMODE` - `kpfsocal.PYRIRRAD` - `kpfsocal.AUTONOMOUS` - `kpfsocal.CAN_OPEN` - `kpfsocal.IS_OPEN` - `kpfsocal.IS_TRACKING` - `kpfsocal.ONLINE` - `kpfsocal.STATE` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): timeout = cfg . getfloat ( 'SoCal' , 'enclosure_status_time' , fallback = 10 ) pyrirrad_threshold = cfg . getfloat ( 'SoCal' , 'pyrirrad_threshold' , fallback = 1000 ) expr = '($kpfsocal.ENCSTA == 0) ' expr += 'and ($kpfsocal.EKOONLINE == Online)' expr += 'and ($kpfsocal.EKOMODE == 3)' expr += f 'and ($kpfsocal.PYRIRRAD > { pyrirrad_threshold } )' expr += 'and ($kpfsocal.AUTONOMOUS == 1)' expr += 'and ($kpfsocal.CAN_OPEN == True)' expr += 'and ($kpfsocal.IS_OPEN == True)' expr += 'and ($kpfsocal.IS_TRACKING == True)' expr += 'and ($kpfsocal.ONLINE == True)' expr += 'and ($kpfsocal.STATE == Tracking)' on_target = ktl . waitFor ( expr , timeout = timeout ) msg = { True : 'On Target' , False : 'NOT On Target' }[ on_target ] print ( msg ) if on_target == False : kpfsocal = ktl . cache ( 'kpfsocal' ) if kpfsocal [ 'ENCSTA' ] . read ( binary = True ) != 0 : log . info ( f 'ENCSTA != 0' ) if kpfsocal [ 'EKOONLINE' ] . read () != 'Online' : log . info ( f 'EKOONLINE != Online' ) if kpfsocal [ 'EKOMODE' ] . read ( binary = True ) != 3 : log . info ( f 'EKOMODE != 3' ) if kpfsocal [ 'PYRIRRAD' ] . read ( binary = True ) < pyrirrad_threshold : log . info ( f 'PYRIRRAD < { pyrirrad_threshold } ' ) if kpfsocal [ 'AUTONOMOUS' ] . read ( binary = True ) != 1 : log . info ( f 'AUTONOMOUS != 1' ) if kpfsocal [ 'IS_OPEN' ] . read ( binary = True ) != True : log . info ( f 'IS_OPEN != True' ) if kpfsocal [ 'IS_TRACKING' ] . read ( binary = True ) != True : log . info ( f 'IS_TRACKING != True' ) if kpfsocal [ 'ONLINE' ] . read ( binary = True ) != True : log . info ( f 'ONLINE != True' ) if kpfsocal [ 'STATE' ] . read () != 'Tracking' : log . info ( f 'STATE != Tracking' ) return on_target @classmethod def post_condition ( cls , args ): pass","title":"WaitForSoCalOnTarget"},{"location":"scripts/WaitForTriggerFile/","text":"WaitForTriggerFile Bases: KPFFunction Wait for a trigger file in progress to finish being collected. KTL Keywords Used: kpfguide.LASTTRIGFILE Source code in kpf/guider/WaitForTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class WaitForTriggerFile ( KPFFunction ): '''Wait for a trigger file in progress to finish being collected. KTL Keywords Used: - `kpfguide.LASTTRIGFILE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'initial_lastfile' ) @classmethod def perform ( cls , args ): initial_lastfile = args . get ( 'initial_lastfile' , False ) LASTTRIGFILE = ktl . cache ( 'kpfguide' , 'LASTTRIGFILE' ) log . debug ( f \"Waiting for guider trigger file to be written out\" ) # Wait for cube file to be updated expr = f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" success = ktl . waitFor ( expr , timeout = 20 ) if success : cube_file = LASTTRIGFILE . read () log . info ( f \"New cube file: { cube_file } \" ) else : cube_file = None log . error ( f \"kpfguide.LASTTRIGFILE did not update\" ) return cube_file @classmethod def post_condition ( cls , args ): pass","title":"WaitForTriggerFile"},{"location":"scripts/WaitForTriggerFile/#waitfortriggerfile","text":"Bases: KPFFunction Wait for a trigger file in progress to finish being collected. KTL Keywords Used: kpfguide.LASTTRIGFILE Source code in kpf/guider/WaitForTriggerFile.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class WaitForTriggerFile ( KPFFunction ): '''Wait for a trigger file in progress to finish being collected. KTL Keywords Used: - `kpfguide.LASTTRIGFILE` ''' @classmethod def pre_condition ( cls , args ): check_input ( args , 'initial_lastfile' ) @classmethod def perform ( cls , args ): initial_lastfile = args . get ( 'initial_lastfile' , False ) LASTTRIGFILE = ktl . cache ( 'kpfguide' , 'LASTTRIGFILE' ) log . debug ( f \"Waiting for guider trigger file to be written out\" ) # Wait for cube file to be updated expr = f \"$kpfguide.LASTTRIGFILE != ' { initial_lastfile } '\" success = ktl . waitFor ( expr , timeout = 20 ) if success : cube_file = LASTTRIGFILE . read () log . info ( f \"New cube file: { cube_file } \" ) else : cube_file = None log . error ( f \"kpfguide.LASTTRIGFILE did not update\" ) return cube_file @classmethod def post_condition ( cls , args ): pass","title":"WaitForTriggerFile"},{"location":"scripts/ZeroOutSlewCalTime/","text":"ZeroOutSlewCalTime Bases: KPFFunction Zero out the slew cal timer by setting it to the current timestamp. KTL Keywords Used: kpfconfig.LASTSLEWCAL Source code in kpf/utils/ZeroOutSlewCalTime.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ZeroOutSlewCalTime ( KPFFunction ): '''Zero out the slew cal timer by setting it to the current timestamp. KTL Keywords Used: - `kpfconfig.LASTSLEWCAL` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( 'Updating LASTSLEWCAL time stamp to reset slew cal timer' ) ktl . write ( 'kpfconfig' , 'LASTSLEWCAL' , time . time (), binary = True ) @classmethod def post_condition ( cls , args ): pass","title":"ZeroOutSlewCalTime"},{"location":"scripts/ZeroOutSlewCalTime/#zerooutslewcaltime","text":"Bases: KPFFunction Zero out the slew cal timer by setting it to the current timestamp. KTL Keywords Used: kpfconfig.LASTSLEWCAL Source code in kpf/utils/ZeroOutSlewCalTime.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class ZeroOutSlewCalTime ( KPFFunction ): '''Zero out the slew cal timer by setting it to the current timestamp. KTL Keywords Used: - `kpfconfig.LASTSLEWCAL` ''' @classmethod def pre_condition ( cls , args ): pass @classmethod def perform ( cls , args ): log . debug ( 'Updating LASTSLEWCAL time stamp to reset slew cal timer' ) ktl . write ( 'kpfconfig' , 'LASTSLEWCAL' , time . time (), binary = True ) @classmethod def post_condition ( cls , args ): pass","title":"ZeroOutSlewCalTime"}]}